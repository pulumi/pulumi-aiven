// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccountAuthenticationSamlFieldMapping {
    /**
     * Field name for user email
     */
    email?: string;
    /**
     * Field name for user's first name
     */
    firstName?: string;
    /**
     * Field name for user's identity. This field must always exist in responses, and must be immutable and unique. Contents of this field are used to identify the user. Using user ID (such as unix user id) is highly recommended, as email address may change, requiring relinking user to Aiven user.
     */
    identity?: string;
    /**
     * Field name for user's last name
     */
    lastName?: string;
    /**
     * Field name for user's full name. If specified, first*name and last*name mappings are ignored
     */
    realName?: string;
}

export interface CassandraCassandra {
}

export interface CassandraCassandraUserConfig {
    /**
     * Additional Cloud Regions for Backup Replication.
     */
    additionalBackupRegions?: string;
    /**
     * cassandra configuration values.
     */
    cassandra?: outputs.CassandraCassandraUserConfigCassandra;
    /**
     * Cassandra major version.
     */
    cassandraVersion?: string;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     */
    ipFilterObjects?: outputs.CassandraCassandraUserConfigIpFilterObject[];
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     */
    ipFilterStrings?: string[];
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     *
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    /**
     * Sets the service into migration mode enabling the sstableloader utility to be used to upload Cassandra data files. Available only on service create.
     */
    migrateSstableloader?: boolean;
    /**
     * Allow access to selected service ports from private networks.
     */
    privateAccess?: outputs.CassandraCassandraUserConfigPrivateAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet.
     */
    publicAccess?: outputs.CassandraCassandraUserConfigPublicAccess;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * When bootstrapping, instead of creating a new Cassandra cluster try to join an existing one from another service. Can only be set on service creation.
     */
    serviceToJoinWith?: string;
    /**
     * Use static public IP addresses.
     */
    staticIps?: boolean;
}

export interface CassandraCassandraUserConfigCassandra {
    batchSizeFailThresholdInKb?: number;
    batchSizeWarnThresholdInKb?: number;
    datacenter?: string;
}

export interface CassandraCassandraUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface CassandraCassandraUserConfigPrivateAccess {
    prometheus?: boolean;
}

export interface CassandraCassandraUserConfigPublicAccess {
    prometheus?: boolean;
}

export interface CassandraComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface CassandraServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface CassandraTag {
    /**
     * Service tag key
     */
    key: string;
    /**
     * Service tag value
     */
    value: string;
}

export interface ClickhouseClickhouse {
}

export interface ClickhouseClickhouseUserConfig {
    /**
     * Additional Cloud Regions for Backup Replication.
     */
    additionalBackupRegions?: string;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     */
    ipFilterObjects?: outputs.ClickhouseClickhouseUserConfigIpFilterObject[];
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     */
    ipFilterStrings?: string[];
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     *
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
}

export interface ClickhouseClickhouseUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface ClickhouseComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface ClickhouseGrantPrivilegeGrant {
    /**
     * The column that the grant refers to. This property cannot be changed, doing so forces recreation of the resource.
     */
    column?: string;
    /**
     * The database that the grant refers to. To set up proper dependencies please refer to this variable as a reference. This property cannot be changed, doing so forces recreation of the resource.
     */
    database: string;
    /**
     * The privilege to grant, i.e. 'INSERT', 'SELECT', etc. This property cannot be changed, doing so forces recreation of the resource.
     */
    privilege?: string;
    /**
     * The table that the grant refers to. This property cannot be changed, doing so forces recreation of the resource.
     */
    table?: string;
    /**
     * If true then the grantee gets the ability to grant the privileges he received too. This property cannot be changed, doing so forces recreation of the resource.
     */
    withGrant?: boolean;
}

export interface ClickhouseGrantRoleGrant {
    /**
     * The role that is to be granted. To set up proper dependencies please refer to this variable as a reference. This property cannot be changed, doing so forces recreation of the resource.
     */
    role?: string;
}

export interface ClickhouseServiceIntegration {
    /**
     * Type of the service integration. The only supported values at the moment are `clickhouseKafka` and `clickhousePostgresql`.
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface ClickhouseTag {
    /**
     * Service tag key
     */
    key: string;
    /**
     * Service tag value
     */
    value: string;
}

export interface FlinkApplicationVersionSink {
    /**
     * The CREATE TABLE statement
     */
    createTable: string;
    /**
     * The integration ID
     */
    integrationId?: string;
}

export interface FlinkApplicationVersionSource {
    /**
     * The CREATE TABLE statement
     */
    createTable: string;
    /**
     * The integration ID
     */
    integrationId?: string;
}

export interface FlinkComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface FlinkFlink {
    /**
     * Host and Port of a Flink server
     */
    hostPorts: string[];
}

export interface FlinkFlinkUserConfig {
    /**
     * Flink major version.
     */
    flinkVersion?: string;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     */
    ipFilterObjects?: outputs.FlinkFlinkUserConfigIpFilterObject[];
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     */
    ipFilterStrings?: string[];
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     *
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    /**
     * Task slots per node. For a 3 node plan, total number of task slots is 3x this value.
     */
    numberOfTaskSlots?: number;
    /**
     * Allow access to selected service components through Privatelink.
     */
    privatelinkAccess?: outputs.FlinkFlinkUserConfigPrivatelinkAccess;
}

export interface FlinkFlinkUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface FlinkFlinkUserConfigPrivatelinkAccess {
    /**
     * Flink server provided values
     */
    flink?: boolean;
    prometheus?: boolean;
}

export interface FlinkServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface FlinkTag {
    /**
     * Service tag key
     */
    key: string;
    /**
     * Service tag value
     */
    value: string;
}

export interface GetAccountAuthenticationSamlFieldMapping {
    email?: string;
    firstName?: string;
    identity?: string;
    lastName?: string;
    realName?: string;
}

export interface GetCassandaCassandra {
}

export interface GetCassandaCassandraUserConfig {
    additionalBackupRegions?: string;
    /**
     * Cassandra server provided values
     */
    cassandra?: outputs.GetCassandaCassandraUserConfigCassandra;
    cassandraVersion?: string;
    ipFilterObjects?: outputs.GetCassandaCassandraUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    migrateSstableloader?: boolean;
    privateAccess?: outputs.GetCassandaCassandraUserConfigPrivateAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetCassandaCassandraUserConfigPublicAccess;
    serviceToForkFrom?: string;
    serviceToJoinWith?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: boolean;
}

export interface GetCassandaCassandraUserConfigCassandra {
    batchSizeFailThresholdInKb?: number;
    batchSizeWarnThresholdInKb?: number;
    datacenter?: string;
}

export interface GetCassandaCassandraUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface GetCassandaCassandraUserConfigPrivateAccess {
    prometheus?: boolean;
}

export interface GetCassandaCassandraUserConfigPublicAccess {
    prometheus?: boolean;
}

export interface GetCassandaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetCassandaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetCassandaTag {
    key: string;
    value: string;
}

export interface GetCassandraCassandra {
}

export interface GetCassandraCassandraUserConfig {
    additionalBackupRegions?: string;
    /**
     * Cassandra server provided values
     */
    cassandra?: outputs.GetCassandraCassandraUserConfigCassandra;
    cassandraVersion?: string;
    ipFilterObjects?: outputs.GetCassandraCassandraUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    migrateSstableloader?: boolean;
    privateAccess?: outputs.GetCassandraCassandraUserConfigPrivateAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetCassandraCassandraUserConfigPublicAccess;
    serviceToForkFrom?: string;
    serviceToJoinWith?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: boolean;
}

export interface GetCassandraCassandraUserConfigCassandra {
    batchSizeFailThresholdInKb?: number;
    batchSizeWarnThresholdInKb?: number;
    datacenter?: string;
}

export interface GetCassandraCassandraUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface GetCassandraCassandraUserConfigPrivateAccess {
    prometheus?: boolean;
}

export interface GetCassandraCassandraUserConfigPublicAccess {
    prometheus?: boolean;
}

export interface GetCassandraComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetCassandraServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetCassandraTag {
    key: string;
    value: string;
}

export interface GetClickhouseClickhouse {
}

export interface GetClickhouseClickhouseUserConfig {
    additionalBackupRegions?: string;
    ipFilterObjects?: outputs.GetClickhouseClickhouseUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    projectToForkFrom?: string;
    serviceToForkFrom?: string;
}

export interface GetClickhouseClickhouseUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface GetClickhouseComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetClickhouseServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetClickhouseTag {
    key: string;
    value: string;
}

export interface GetFlinkApplicationVersionSink {
    createTable: string;
    integrationId?: string;
}

export interface GetFlinkApplicationVersionSource {
    createTable: string;
    integrationId?: string;
}

export interface GetFlinkComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetFlinkFlink {
    hostPorts: string[];
}

export interface GetFlinkFlinkUserConfig {
    flinkVersion?: string;
    ipFilterObjects?: outputs.GetFlinkFlinkUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    numberOfTaskSlots?: number;
    privatelinkAccess?: outputs.GetFlinkFlinkUserConfigPrivatelinkAccess;
}

export interface GetFlinkFlinkUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface GetFlinkFlinkUserConfigPrivatelinkAccess {
    /**
     * Flink server provided values
     */
    flink?: boolean;
    prometheus?: boolean;
}

export interface GetFlinkServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetFlinkTag {
    key: string;
    value: string;
}

export interface GetGrafanaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetGrafanaGrafana {
}

export interface GetGrafanaGrafanaUserConfig {
    additionalBackupRegions?: string;
    alertingEnabled?: boolean;
    alertingErrorOrTimeout?: string;
    alertingMaxAnnotationsToKeep?: number;
    alertingNodataOrNullvalues?: string;
    allowEmbedding?: boolean;
    authAzuread?: outputs.GetGrafanaGrafanaUserConfigAuthAzuread;
    authBasicEnabled?: boolean;
    authGenericOauth?: outputs.GetGrafanaGrafanaUserConfigAuthGenericOauth;
    authGithub?: outputs.GetGrafanaGrafanaUserConfigAuthGithub;
    authGitlab?: outputs.GetGrafanaGrafanaUserConfigAuthGitlab;
    authGoogle?: outputs.GetGrafanaGrafanaUserConfigAuthGoogle;
    cookieSamesite?: string;
    customDomain?: string;
    dashboardPreviewsEnabled?: boolean;
    dashboardsMinRefreshInterval?: string;
    dashboardsVersionsToKeep?: number;
    dataproxySendUserHeader?: boolean;
    dataproxyTimeout?: number;
    dateFormats?: outputs.GetGrafanaGrafanaUserConfigDateFormats;
    disableGravatar?: boolean;
    editorsCanAdmin?: boolean;
    externalImageStorage?: outputs.GetGrafanaGrafanaUserConfigExternalImageStorage;
    googleAnalyticsUaId?: string;
    ipFilterObjects?: outputs.GetGrafanaGrafanaUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    metricsEnabled?: boolean;
    privateAccess?: outputs.GetGrafanaGrafanaUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetGrafanaGrafanaUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetGrafanaGrafanaUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    smtpServer?: outputs.GetGrafanaGrafanaUserConfigSmtpServer;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: boolean;
    userAutoAssignOrg?: boolean;
    userAutoAssignOrgRole?: string;
    viewersCanEdit?: boolean;
}

export interface GetGrafanaGrafanaUserConfigAuthAzuread {
    allowSignUp?: boolean;
    allowedDomains?: string[];
    allowedGroups?: string[];
    authUrl: string;
    clientId: string;
    clientSecret: string;
    tokenUrl: string;
}

export interface GetGrafanaGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: boolean;
    allowedDomains?: string[];
    allowedOrganizations?: string[];
    apiUrl: string;
    authUrl: string;
    clientId: string;
    clientSecret: string;
    name?: string;
    scopes?: string[];
    tokenUrl: string;
}

export interface GetGrafanaGrafanaUserConfigAuthGithub {
    allowSignUp?: boolean;
    allowedOrganizations?: string[];
    clientId: string;
    clientSecret: string;
    teamIds?: number[];
}

export interface GetGrafanaGrafanaUserConfigAuthGitlab {
    allowSignUp?: boolean;
    allowedGroups?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId: string;
    clientSecret: string;
    tokenUrl?: string;
}

export interface GetGrafanaGrafanaUserConfigAuthGoogle {
    allowSignUp?: boolean;
    allowedDomains?: string[];
    clientId: string;
    clientSecret: string;
}

export interface GetGrafanaGrafanaUserConfigDateFormats {
    defaultTimezone?: string;
    fullDate?: string;
    intervalDay?: string;
    intervalHour?: string;
    intervalMinute?: string;
    intervalMonth?: string;
    intervalSecond?: string;
    intervalYear?: string;
}

export interface GetGrafanaGrafanaUserConfigExternalImageStorage {
    accessKey: string;
    bucketUrl: string;
    provider: string;
    secretKey: string;
}

export interface GetGrafanaGrafanaUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface GetGrafanaGrafanaUserConfigPrivateAccess {
    /**
     * Grafana server provided values
     */
    grafana?: boolean;
}

export interface GetGrafanaGrafanaUserConfigPrivatelinkAccess {
    /**
     * Grafana server provided values
     */
    grafana?: boolean;
}

export interface GetGrafanaGrafanaUserConfigPublicAccess {
    /**
     * Grafana server provided values
     */
    grafana?: boolean;
}

export interface GetGrafanaGrafanaUserConfigSmtpServer {
    fromAddress: string;
    fromName?: string;
    host: string;
    password?: string;
    port: number;
    skipVerify?: boolean;
    starttlsPolicy?: string;
    username?: string;
}

export interface GetGrafanaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetGrafanaTag {
    key: string;
    value: string;
}

export interface GetInfluxDbComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetInfluxDbInfluxdb {
    databaseName: string;
}

export interface GetInfluxDbInfluxdbUserConfig {
    additionalBackupRegions?: string;
    customDomain?: string;
    /**
     * InfluxDB server provided values
     */
    influxdb?: outputs.GetInfluxDbInfluxdbUserConfigInfluxdb;
    ipFilterObjects?: outputs.GetInfluxDbInfluxdbUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    privateAccess?: outputs.GetInfluxDbInfluxdbUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetInfluxDbInfluxdbUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetInfluxDbInfluxdbUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: boolean;
}

export interface GetInfluxDbInfluxdbUserConfigInfluxdb {
    logQueriesAfter?: number;
    maxConnectionLimit?: number;
    maxRowLimit?: number;
    maxSelectBuckets?: number;
    maxSelectPoint?: number;
    queryTimeout?: number;
}

export interface GetInfluxDbInfluxdbUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface GetInfluxDbInfluxdbUserConfigPrivateAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: boolean;
}

export interface GetInfluxDbInfluxdbUserConfigPrivatelinkAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: boolean;
}

export interface GetInfluxDbInfluxdbUserConfigPublicAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: boolean;
}

export interface GetInfluxDbServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetInfluxDbTag {
    key: string;
    value: string;
}

export interface GetKafkaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetKafkaConnectComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetKafkaConnectKafkaConnect {
}

export interface GetKafkaConnectKafkaConnectUserConfig {
    additionalBackupRegions?: string;
    ipFilterObjects?: outputs.GetKafkaConnectKafkaConnectUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    /**
     * Kafka Connect server provided values
     */
    kafkaConnect?: outputs.GetKafkaConnectKafkaConnectUserConfigKafkaConnect;
    privateAccess?: outputs.GetKafkaConnectKafkaConnectUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetKafkaConnectKafkaConnectUserConfigPrivatelinkAccess;
    publicAccess?: outputs.GetKafkaConnectKafkaConnectUserConfigPublicAccess;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: boolean;
}

export interface GetKafkaConnectKafkaConnectUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface GetKafkaConnectKafkaConnectUserConfigKafkaConnect {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerFetchMaxBytes?: number;
    consumerIsolationLevel?: string;
    consumerMaxPartitionFetchBytes?: number;
    consumerMaxPollIntervalMs?: number;
    consumerMaxPollRecords?: number;
    offsetFlushIntervalMs?: number;
    offsetFlushTimeoutMs?: number;
    producerBatchSize?: number;
    producerBufferMemory?: number;
    producerCompressionType?: string;
    producerLingerMs?: number;
    producerMaxRequestSize?: number;
    sessionTimeoutMs?: number;
}

export interface GetKafkaConnectKafkaConnectUserConfigPrivateAccess {
    /**
     * Kafka Connect server provided values
     */
    kafkaConnect?: boolean;
    prometheus?: boolean;
}

export interface GetKafkaConnectKafkaConnectUserConfigPrivatelinkAccess {
    jolokia?: boolean;
    /**
     * Kafka Connect server provided values
     */
    kafkaConnect?: boolean;
    prometheus?: boolean;
}

export interface GetKafkaConnectKafkaConnectUserConfigPublicAccess {
    /**
     * Kafka Connect server provided values
     */
    kafkaConnect?: boolean;
    prometheus?: boolean;
}

export interface GetKafkaConnectServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetKafkaConnectTag {
    key: string;
    value: string;
}

export interface GetKafkaConnectorTask {
    connector: string;
    /**
     * List of tasks of a connector.
     */
    task: number;
}

export interface GetKafkaKafka {
    accessCert: string;
    accessKey: string;
    connectUri: string;
    restUri: string;
    schemaRegistryUri: string;
}

export interface GetKafkaKafkaUserConfig {
    additionalBackupRegions?: string;
    customDomain?: string;
    ipFilterObjects?: outputs.GetKafkaKafkaUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    /**
     * Kafka server provided values
     */
    kafka?: outputs.GetKafkaKafkaUserConfigKafka;
    kafkaAuthenticationMethods?: outputs.GetKafkaKafkaUserConfigKafkaAuthenticationMethods;
    kafkaConnect?: boolean;
    kafkaConnectConfig?: outputs.GetKafkaKafkaUserConfigKafkaConnectConfig;
    kafkaRest?: boolean;
    kafkaRestAuthorization?: boolean;
    kafkaRestConfig?: outputs.GetKafkaKafkaUserConfigKafkaRestConfig;
    kafkaVersion?: string;
    privateAccess?: outputs.GetKafkaKafkaUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetKafkaKafkaUserConfigPrivatelinkAccess;
    publicAccess?: outputs.GetKafkaKafkaUserConfigPublicAccess;
    schemaRegistry?: boolean;
    schemaRegistryConfig?: outputs.GetKafkaKafkaUserConfigSchemaRegistryConfig;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: boolean;
}

export interface GetKafkaKafkaUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface GetKafkaKafkaUserConfigKafka {
    autoCreateTopicsEnable?: boolean;
    compressionType?: string;
    connectionsMaxIdleMs?: number;
    defaultReplicationFactor?: number;
    groupInitialRebalanceDelayMs?: number;
    groupMaxSessionTimeoutMs?: number;
    groupMinSessionTimeoutMs?: number;
    logCleanerDeleteRetentionMs?: number;
    logCleanerMaxCompactionLagMs?: number;
    logCleanerMinCleanableRatio?: number;
    logCleanerMinCompactionLagMs?: number;
    logCleanupPolicy?: string;
    logFlushIntervalMessages?: number;
    logFlushIntervalMs?: number;
    logIndexIntervalBytes?: number;
    logIndexSizeMaxBytes?: number;
    logMessageDownconversionEnable?: boolean;
    logMessageTimestampDifferenceMaxMs?: number;
    logMessageTimestampType?: string;
    logPreallocate?: boolean;
    logRetentionBytes?: number;
    logRetentionHours?: number;
    logRetentionMs?: number;
    logRollJitterMs?: number;
    logRollMs?: number;
    logSegmentBytes?: number;
    logSegmentDeleteDelayMs?: number;
    maxConnectionsPerIp?: number;
    maxIncrementalFetchSessionCacheSlots?: number;
    messageMaxBytes?: number;
    minInsyncReplicas?: number;
    numPartitions?: number;
    offsetsRetentionMinutes?: number;
    producerPurgatoryPurgeIntervalRequests?: number;
    replicaFetchMaxBytes?: number;
    replicaFetchResponseMaxBytes?: number;
    socketRequestMaxBytes?: number;
    transactionRemoveExpiredTransactionCleanupIntervalMs?: number;
    transactionStateLogSegmentBytes?: number;
}

export interface GetKafkaKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: boolean;
    sasl?: boolean;
}

export interface GetKafkaKafkaUserConfigKafkaConnectConfig {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerFetchMaxBytes?: number;
    consumerIsolationLevel?: string;
    consumerMaxPartitionFetchBytes?: number;
    consumerMaxPollIntervalMs?: number;
    consumerMaxPollRecords?: number;
    offsetFlushIntervalMs?: number;
    offsetFlushTimeoutMs?: number;
    producerBatchSize?: number;
    producerBufferMemory?: number;
    producerCompressionType?: string;
    producerLingerMs?: number;
    producerMaxRequestSize?: number;
    sessionTimeoutMs?: number;
}

export interface GetKafkaKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: boolean;
    consumerRequestMaxBytes?: number;
    consumerRequestTimeoutMs?: number;
    producerAcks?: string;
    producerCompressionType?: string;
    producerLingerMs?: number;
    simpleconsumerPoolSizeMax?: number;
}

export interface GetKafkaKafkaUserConfigPrivateAccess {
    /**
     * Kafka server provided values
     */
    kafka?: boolean;
    kafkaConnect?: boolean;
    kafkaRest?: boolean;
    prometheus?: boolean;
    schemaRegistry?: boolean;
}

export interface GetKafkaKafkaUserConfigPrivatelinkAccess {
    jolokia?: boolean;
    /**
     * Kafka server provided values
     */
    kafka?: boolean;
    kafkaConnect?: boolean;
    kafkaRest?: boolean;
    prometheus?: boolean;
    schemaRegistry?: boolean;
}

export interface GetKafkaKafkaUserConfigPublicAccess {
    /**
     * Kafka server provided values
     */
    kafka?: boolean;
    kafkaConnect?: boolean;
    kafkaRest?: boolean;
    prometheus?: boolean;
    schemaRegistry?: boolean;
}

export interface GetKafkaKafkaUserConfigSchemaRegistryConfig {
    leaderEligibility?: boolean;
    topicName?: string;
}

export interface GetKafkaMirrorMakerComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetKafkaMirrorMakerKafkaMirrormaker {
}

export interface GetKafkaMirrorMakerKafkaMirrormakerUserConfig {
    additionalBackupRegions?: string;
    ipFilterObjects?: outputs.GetKafkaMirrorMakerKafkaMirrormakerUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    /**
     * Kafka MirrorMaker 2 server provided values
     */
    kafkaMirrormaker?: outputs.GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: boolean;
}

export interface GetKafkaMirrorMakerKafkaMirrormakerUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker {
    emitCheckpointsEnabled?: boolean;
    emitCheckpointsIntervalSeconds?: number;
    refreshGroupsEnabled?: boolean;
    refreshGroupsIntervalSeconds?: number;
    refreshTopicsEnabled?: boolean;
    refreshTopicsIntervalSeconds?: number;
    syncGroupOffsetsEnabled?: boolean;
    syncGroupOffsetsIntervalSeconds?: number;
    syncTopicConfigsEnabled?: boolean;
    tasksMaxPerCpu?: number;
}

export interface GetKafkaMirrorMakerServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetKafkaMirrorMakerTag {
    key: string;
    value: string;
}

export interface GetKafkaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetKafkaTag {
    key: string;
    value: string;
}

export interface GetKafkaTopicConfig {
    cleanupPolicy?: string;
    compressionType?: string;
    deleteRetentionMs?: string;
    fileDeleteDelayMs?: string;
    flushMessages?: string;
    flushMs?: string;
    indexIntervalBytes?: string;
    maxCompactionLagMs?: string;
    maxMessageBytes?: string;
    messageDownconversionEnable?: boolean;
    messageFormatVersion?: string;
    messageTimestampDifferenceMaxMs?: string;
    messageTimestampType?: string;
    minCleanableDirtyRatio?: number;
    minCompactionLagMs?: string;
    minInsyncReplicas?: string;
    preallocate?: boolean;
    retentionBytes?: string;
    retentionMs?: string;
    segmentBytes?: string;
    segmentIndexBytes?: string;
    segmentJitterMs?: string;
    segmentMs?: string;
    uncleanLeaderElectionEnable?: boolean;
}

export interface GetKafkaTopicTag {
    key: string;
    value?: string;
}

export interface GetM3AggregatorComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetM3AggregatorM3aggregator {
}

export interface GetM3AggregatorM3aggregatorUserConfig {
    customDomain?: string;
    ipFilterObjects?: outputs.GetM3AggregatorM3aggregatorUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    /**
     * @deprecated Usage of this field is discouraged.
     */
    m3Version?: string;
    m3aggregatorVersion?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: boolean;
}

export interface GetM3AggregatorM3aggregatorUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface GetM3AggregatorServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetM3AggregatorTag {
    key: string;
    value: string;
}

export interface GetM3DbComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetM3DbM3db {
}

export interface GetM3DbM3dbUserConfig {
    additionalBackupRegions?: string;
    customDomain?: string;
    ipFilterObjects?: outputs.GetM3DbM3dbUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    limits?: outputs.GetM3DbM3dbUserConfigLimits;
    m3?: outputs.GetM3DbM3dbUserConfigM3;
    /**
     * @deprecated Usage of this field is discouraged.
     */
    m3Version?: string;
    m3coordinatorEnableGraphiteCarbonIngest?: boolean;
    m3dbVersion?: string;
    namespaces?: outputs.GetM3DbM3dbUserConfigNamespace[];
    privateAccess?: outputs.GetM3DbM3dbUserConfigPrivateAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetM3DbM3dbUserConfigPublicAccess;
    rules?: outputs.GetM3DbM3dbUserConfigRules;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: boolean;
}

export interface GetM3DbM3dbUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface GetM3DbM3dbUserConfigLimits {
    maxRecentlyQueriedSeriesBlocks?: number;
    maxRecentlyQueriedSeriesDiskBytesRead?: number;
    maxRecentlyQueriedSeriesLookback?: string;
    queryDocs?: number;
    queryRequireExhaustive?: boolean;
    querySeries?: number;
}

export interface GetM3DbM3dbUserConfigM3 {
    tagOptions?: outputs.GetM3DbM3dbUserConfigM3TagOptions;
}

export interface GetM3DbM3dbUserConfigM3TagOptions {
    allowTagNameDuplicates?: boolean;
    allowTagValueEmpty?: boolean;
}

export interface GetM3DbM3dbUserConfigNamespace {
    name: string;
    options?: outputs.GetM3DbM3dbUserConfigNamespaceOptions;
    resolution?: string;
    type: string;
}

export interface GetM3DbM3dbUserConfigNamespaceOptions {
    retentionOptions?: outputs.GetM3DbM3dbUserConfigNamespaceOptionsRetentionOptions;
    snapshotEnabled?: boolean;
    writesToCommitlog?: boolean;
}

export interface GetM3DbM3dbUserConfigNamespaceOptionsRetentionOptions {
    blockDataExpiryDuration?: string;
    blocksizeDuration?: string;
    bufferFutureDuration?: string;
    bufferPastDuration?: string;
    retentionPeriodDuration?: string;
}

export interface GetM3DbM3dbUserConfigPrivateAccess {
    m3coordinator?: boolean;
}

export interface GetM3DbM3dbUserConfigPublicAccess {
    m3coordinator?: boolean;
}

export interface GetM3DbM3dbUserConfigRules {
    mappings?: outputs.GetM3DbM3dbUserConfigRulesMapping[];
}

export interface GetM3DbM3dbUserConfigRulesMapping {
    aggregations?: string[];
    drop?: boolean;
    filter: string;
    name?: string;
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with namespaces_string instead. When switching to namespaces_string, please apply the changes twice due to technical limitations.
     */
    namespaces?: string[];
    namespacesObjects?: outputs.GetM3DbM3dbUserConfigRulesMappingNamespacesObject[];
    namespacesStrings?: string[];
    tags?: outputs.GetM3DbM3dbUserConfigRulesMappingTag[];
}

export interface GetM3DbM3dbUserConfigRulesMappingNamespacesObject {
    resolution?: string;
    retention?: string;
}

export interface GetM3DbM3dbUserConfigRulesMappingTag {
    name: string;
    value: string;
}

export interface GetM3DbServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetM3DbTag {
    key: string;
    value: string;
}

export interface GetMySqlComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetMySqlMysql {
}

export interface GetMySqlMysqlUserConfig {
    additionalBackupRegions?: string;
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: number;
    backupMinute?: number;
    binlogRetentionPeriod?: number;
    ipFilterObjects?: outputs.GetMySqlMysqlUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    migration?: outputs.GetMySqlMysqlUserConfigMigration;
    /**
     * MySQL specific server provided values
     */
    mysql?: outputs.GetMySqlMysqlUserConfigMysql;
    mysqlVersion?: string;
    privateAccess?: outputs.GetMySqlMysqlUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetMySqlMysqlUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetMySqlMysqlUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: boolean;
}

export interface GetMySqlMysqlUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface GetMySqlMysqlUserConfigMigration {
    dbname?: string;
    host: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port: number;
    ssl?: boolean;
    username?: string;
}

export interface GetMySqlMysqlUserConfigMysql {
    connectTimeout?: number;
    defaultTimeZone?: string;
    groupConcatMaxLen?: number;
    informationSchemaStatsExpiry?: number;
    innodbChangeBufferMaxSize?: number;
    innodbFlushNeighbors?: number;
    innodbFtMinTokenSize?: number;
    innodbFtServerStopwordTable?: string;
    innodbLockWaitTimeout?: number;
    innodbLogBufferSize?: number;
    innodbOnlineAlterLogMaxSize?: number;
    innodbPrintAllDeadlocks?: boolean;
    innodbReadIoThreads?: number;
    innodbRollbackOnTimeout?: boolean;
    innodbThreadConcurrency?: number;
    innodbWriteIoThreads?: number;
    interactiveTimeout?: number;
    internalTmpMemStorageEngine?: string;
    longQueryTime?: number;
    maxAllowedPacket?: number;
    maxHeapTableSize?: number;
    netBufferLength?: number;
    netReadTimeout?: number;
    netWriteTimeout?: number;
    slowQueryLog?: boolean;
    sortBufferSize?: number;
    sqlMode?: string;
    sqlRequirePrimaryKey?: boolean;
    tmpTableSize?: number;
    waitTimeout?: number;
}

export interface GetMySqlMysqlUserConfigPrivateAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: boolean;
    mysqlx?: boolean;
    prometheus?: boolean;
}

export interface GetMySqlMysqlUserConfigPrivatelinkAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: boolean;
    mysqlx?: boolean;
    prometheus?: boolean;
}

export interface GetMySqlMysqlUserConfigPublicAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: boolean;
    mysqlx?: boolean;
    prometheus?: boolean;
}

export interface GetMySqlServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetMySqlTag {
    key: string;
    value: string;
}

export interface GetOpenSearchComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetOpenSearchOpensearch {
    opensearchDashboardsUri: string;
}

export interface GetOpenSearchOpensearchUserConfig {
    additionalBackupRegions?: string;
    customDomain?: string;
    /**
     * @deprecated Usage of this field is discouraged.
     */
    disableReplicationFactorAdjustment?: boolean;
    indexPatterns?: outputs.GetOpenSearchOpensearchUserConfigIndexPattern[];
    indexTemplate?: outputs.GetOpenSearchOpensearchUserConfigIndexTemplate;
    ipFilterObjects?: outputs.GetOpenSearchOpensearchUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    keepIndexRefreshInterval?: boolean;
    /**
     * @deprecated Usage of this field is discouraged.
     */
    maxIndexCount?: number;
    /**
     * Opensearch server provided values
     */
    opensearch?: outputs.GetOpenSearchOpensearchUserConfigOpensearch;
    opensearchDashboards?: outputs.GetOpenSearchOpensearchUserConfigOpensearchDashboards;
    opensearchVersion?: string;
    privateAccess?: outputs.GetOpenSearchOpensearchUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetOpenSearchOpensearchUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetOpenSearchOpensearchUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: boolean;
}

export interface GetOpenSearchOpensearchUserConfigIndexPattern {
    maxIndexCount: number;
    pattern: string;
    sortingAlgorithm?: string;
}

export interface GetOpenSearchOpensearchUserConfigIndexTemplate {
    mappingNestedObjectsLimit?: number;
    numberOfReplicas?: number;
    numberOfShards?: number;
}

export interface GetOpenSearchOpensearchUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface GetOpenSearchOpensearchUserConfigOpensearch {
    actionAutoCreateIndexEnabled?: boolean;
    actionDestructiveRequiresName?: boolean;
    clusterMaxShardsPerNode?: number;
    clusterRoutingAllocationNodeConcurrentRecoveries?: number;
    emailSenderName?: string;
    emailSenderPassword?: string;
    emailSenderUsername?: string;
    httpMaxContentLength?: number;
    httpMaxHeaderSize?: number;
    httpMaxInitialLineLength?: number;
    indicesFielddataCacheSize?: number;
    indicesMemoryIndexBufferSize?: number;
    indicesQueriesCacheSize?: number;
    indicesQueryBoolMaxClauseCount?: number;
    indicesRecoveryMaxBytesPerSec?: number;
    indicesRecoveryMaxConcurrentFileChunks?: number;
    overrideMainResponseVersion?: boolean;
    reindexRemoteWhitelists?: string[];
    scriptMaxCompilationsRate?: string;
    searchMaxBuckets?: number;
    threadPoolAnalyzeQueueSize?: number;
    threadPoolAnalyzeSize?: number;
    threadPoolForceMergeSize?: number;
    threadPoolGetQueueSize?: number;
    threadPoolGetSize?: number;
    threadPoolSearchQueueSize?: number;
    threadPoolSearchSize?: number;
    threadPoolSearchThrottledQueueSize?: number;
    threadPoolSearchThrottledSize?: number;
    threadPoolWriteQueueSize?: number;
    threadPoolWriteSize?: number;
}

export interface GetOpenSearchOpensearchUserConfigOpensearchDashboards {
    enabled?: boolean;
    maxOldSpaceSize?: number;
    opensearchRequestTimeout?: number;
}

export interface GetOpenSearchOpensearchUserConfigPrivateAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: boolean;
    opensearchDashboards?: boolean;
    prometheus?: boolean;
}

export interface GetOpenSearchOpensearchUserConfigPrivatelinkAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: boolean;
    opensearchDashboards?: boolean;
    prometheus?: boolean;
}

export interface GetOpenSearchOpensearchUserConfigPublicAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: boolean;
    opensearchDashboards?: boolean;
    prometheus?: boolean;
}

export interface GetOpenSearchServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetOpenSearchTag {
    key: string;
    value: string;
}

export interface GetPgComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetPgPg {
    dbname: string;
    host: string;
    maxConnections: number;
    password: string;
    port: number;
    replicaUri: string;
    sslmode: string;
    uri: string;
    user: string;
}

export interface GetPgPgUserConfig {
    additionalBackupRegions?: string;
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: number;
    backupMinute?: number;
    enableIpv6?: boolean;
    ipFilterObjects?: outputs.GetPgPgUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    migration?: outputs.GetPgPgUserConfigMigration;
    /**
     * PostgreSQL specific server provided values
     */
    pg?: outputs.GetPgPgUserConfigPg;
    /**
     * @deprecated Usage of this field is discouraged.
     */
    pgReadReplica?: boolean;
    /**
     * @deprecated Usage of this field is discouraged.
     */
    pgServiceToForkFrom?: string;
    pgStatMonitorEnable?: boolean;
    pgVersion?: string;
    pgbouncer?: outputs.GetPgPgUserConfigPgbouncer;
    pglookout?: outputs.GetPgPgUserConfigPglookout;
    privateAccess?: outputs.GetPgPgUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetPgPgUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetPgPgUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    sharedBuffersPercentage?: number;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: boolean;
    synchronousReplication?: string;
    timescaledb?: outputs.GetPgPgUserConfigTimescaledb;
    variant?: string;
    workMem?: number;
}

export interface GetPgPgUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface GetPgPgUserConfigMigration {
    dbname?: string;
    host: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port: number;
    ssl?: boolean;
    username?: string;
}

export interface GetPgPgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: number;
    autovacuumAnalyzeThreshold?: number;
    autovacuumFreezeMaxAge?: number;
    autovacuumMaxWorkers?: number;
    autovacuumNaptime?: number;
    autovacuumVacuumCostDelay?: number;
    autovacuumVacuumCostLimit?: number;
    autovacuumVacuumScaleFactor?: number;
    autovacuumVacuumThreshold?: number;
    bgwriterDelay?: number;
    bgwriterFlushAfter?: number;
    bgwriterLruMaxpages?: number;
    bgwriterLruMultiplier?: number;
    deadlockTimeout?: number;
    defaultToastCompression?: string;
    idleInTransactionSessionTimeout?: number;
    jit?: boolean;
    logAutovacuumMinDuration?: number;
    logErrorVerbosity?: string;
    logLinePrefix?: string;
    logMinDurationStatement?: number;
    logTempFiles?: number;
    maxFilesPerProcess?: number;
    maxLocksPerTransaction?: number;
    maxLogicalReplicationWorkers?: number;
    maxParallelWorkers?: number;
    maxParallelWorkersPerGather?: number;
    maxPredLocksPerTransaction?: number;
    maxPreparedTransactions?: number;
    maxReplicationSlots?: number;
    maxSlotWalKeepSize?: number;
    maxStackDepth?: number;
    maxStandbyArchiveDelay?: number;
    maxStandbyStreamingDelay?: number;
    maxWalSenders?: number;
    maxWorkerProcesses?: number;
    pgPartmanBgwDotInterval?: number;
    pgPartmanBgwDotRole?: string;
    pgStatMonitorDotPgsmEnableQueryPlan?: boolean;
    pgStatMonitorDotPgsmMaxBuckets?: number;
    pgStatStatementsDotTrack?: string;
    tempFileLimit?: number;
    timezone?: string;
    trackActivityQuerySize?: number;
    trackCommitTimestamp?: string;
    trackFunctions?: string;
    trackIoTiming?: string;
    walSenderTimeout?: number;
    walWriterDelay?: number;
}

export interface GetPgPgUserConfigPgbouncer {
    autodbIdleTimeout?: number;
    autodbMaxDbConnections?: number;
    autodbPoolMode?: string;
    autodbPoolSize?: number;
    ignoreStartupParameters?: string[];
    minPoolSize?: number;
    serverIdleTimeout?: number;
    serverLifetime?: number;
    serverResetQueryAlways?: boolean;
}

export interface GetPgPgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: number;
}

export interface GetPgPgUserConfigPrivateAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: boolean;
    pgbouncer?: boolean;
    prometheus?: boolean;
}

export interface GetPgPgUserConfigPrivatelinkAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: boolean;
    pgbouncer?: boolean;
    prometheus?: boolean;
}

export interface GetPgPgUserConfigPublicAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: boolean;
    pgbouncer?: boolean;
    prometheus?: boolean;
}

export interface GetPgPgUserConfigTimescaledb {
    maxBackgroundWorkers?: number;
}

export interface GetPgServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetPgTag {
    key: string;
    value: string;
}

export interface GetProjectTag {
    key: string;
    value: string;
}

export interface GetRedisComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetRedisRedi {
}

export interface GetRedisRedisUserConfig {
    additionalBackupRegions?: string;
    ipFilterObjects?: outputs.GetRedisRedisUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    migration?: outputs.GetRedisRedisUserConfigMigration;
    privateAccess?: outputs.GetRedisRedisUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetRedisRedisUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetRedisRedisUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    redisAclChannelsDefault?: string;
    redisIoThreads?: number;
    redisLfuDecayTime?: number;
    redisLfuLogFactor?: number;
    redisMaxmemoryPolicy?: string;
    redisNotifyKeyspaceEvents?: string;
    redisNumberOfDatabases?: number;
    redisPersistence?: string;
    redisPubsubClientOutputBufferLimit?: number;
    redisSsl?: boolean;
    redisTimeout?: number;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: boolean;
}

export interface GetRedisRedisUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface GetRedisRedisUserConfigMigration {
    dbname?: string;
    host: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port: number;
    ssl?: boolean;
    username?: string;
}

export interface GetRedisRedisUserConfigPrivateAccess {
    prometheus?: boolean;
    /**
     * Redis server provided values
     */
    redis?: boolean;
}

export interface GetRedisRedisUserConfigPrivatelinkAccess {
    prometheus?: boolean;
    /**
     * Redis server provided values
     */
    redis?: boolean;
}

export interface GetRedisRedisUserConfigPublicAccess {
    prometheus?: boolean;
    /**
     * Redis server provided values
     */
    redis?: boolean;
}

export interface GetRedisServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetRedisTag {
    key: string;
    value: string;
}

export interface GetServiceIntegrationClickhouseKafkaUserConfig {
    tables?: outputs.GetServiceIntegrationClickhouseKafkaUserConfigTable[];
}

export interface GetServiceIntegrationClickhouseKafkaUserConfigTable {
    columns?: outputs.GetServiceIntegrationClickhouseKafkaUserConfigTableColumn[];
    dataFormat: string;
    groupName: string;
    name: string;
    topics?: outputs.GetServiceIntegrationClickhouseKafkaUserConfigTableTopic[];
}

export interface GetServiceIntegrationClickhouseKafkaUserConfigTableColumn {
    name: string;
    type: string;
}

export interface GetServiceIntegrationClickhouseKafkaUserConfigTableTopic {
    name: string;
}

export interface GetServiceIntegrationClickhousePostgresqlUserConfig {
    databases?: outputs.GetServiceIntegrationClickhousePostgresqlUserConfigDatabase[];
}

export interface GetServiceIntegrationClickhousePostgresqlUserConfigDatabase {
    database?: string;
    schema?: string;
}

export interface GetServiceIntegrationDatadogUserConfig {
    datadogDbmEnabled?: boolean;
    datadogTags?: outputs.GetServiceIntegrationDatadogUserConfigDatadogTag[];
    excludeConsumerGroups?: string[];
    excludeTopics?: string[];
    includeConsumerGroups?: string[];
    includeTopics?: string[];
    kafkaCustomMetrics?: string[];
    maxJmxMetrics?: number;
    opensearch?: outputs.GetServiceIntegrationDatadogUserConfigOpensearch;
}

export interface GetServiceIntegrationDatadogUserConfigDatadogTag {
    comment?: string;
    tag: string;
}

export interface GetServiceIntegrationDatadogUserConfigOpensearch {
    indexStatsEnabled?: boolean;
    pendingTaskStatsEnabled?: boolean;
    pshardStatsEnabled?: boolean;
}

export interface GetServiceIntegrationEndpointDatadogUserConfig {
    datadogApiKey?: string;
    datadogTags?: outputs.GetServiceIntegrationEndpointDatadogUserConfigDatadogTag[];
    disableConsumerStats?: boolean;
    kafkaConsumerCheckInstances?: number;
    kafkaConsumerStatsTimeout?: number;
    maxPartitionContexts?: number;
    site?: string;
}

export interface GetServiceIntegrationEndpointDatadogUserConfigDatadogTag {
    comment?: string;
    tag: string;
}

export interface GetServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig {
    accessKey?: string;
    logGroupName?: string;
    region?: string;
    secretKey?: string;
}

export interface GetServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig {
    accessKey?: string;
    namespace?: string;
    region?: string;
    secretKey?: string;
}

export interface GetServiceIntegrationEndpointExternalElasticsearchLogsUserConfig {
    ca?: string;
    indexDaysMax?: number;
    indexPrefix?: string;
    timeout?: number;
    url?: string;
}

export interface GetServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig {
    logId?: string;
    projectId?: string;
    serviceAccountCredentials?: string;
}

export interface GetServiceIntegrationEndpointExternalKafkaUserConfig {
    bootstrapServers?: string;
    saslMechanism?: string;
    saslPlainPassword?: string;
    saslPlainUsername?: string;
    securityProtocol?: string;
    sslCaCert?: string;
    sslClientCert?: string;
    sslClientKey?: string;
    sslEndpointIdentificationAlgorithm?: string;
}

export interface GetServiceIntegrationEndpointExternalOpensearchLogsUserConfig {
    ca?: string;
    indexDaysMax?: number;
    indexPrefix?: string;
    timeout?: number;
    url?: string;
}

export interface GetServiceIntegrationEndpointExternalSchemaRegistryUserConfig {
    authentication?: string;
    basicAuthPassword?: string;
    basicAuthUsername?: string;
    url?: string;
}

export interface GetServiceIntegrationEndpointJolokiaUserConfig {
    basicAuthPassword?: string;
    basicAuthUsername?: string;
}

export interface GetServiceIntegrationEndpointPrometheusUserConfig {
    basicAuthPassword?: string;
    basicAuthUsername?: string;
}

export interface GetServiceIntegrationEndpointRsyslogUserConfig {
    ca?: string;
    cert?: string;
    format?: string;
    key?: string;
    logline?: string;
    port?: number;
    sd?: string;
    server?: string;
    tls?: boolean;
}

export interface GetServiceIntegrationEndpointSignalfxUserConfig {
    enabledMetrics?: string[];
    signalfxApiKey?: string;
    signalfxRealm?: string;
}

export interface GetServiceIntegrationExternalAwsCloudwatchMetricsUserConfig {
    droppedMetrics?: outputs.GetServiceIntegrationExternalAwsCloudwatchMetricsUserConfigDroppedMetric[];
    extraMetrics?: outputs.GetServiceIntegrationExternalAwsCloudwatchMetricsUserConfigExtraMetric[];
}

export interface GetServiceIntegrationExternalAwsCloudwatchMetricsUserConfigDroppedMetric {
    field: string;
    metric: string;
}

export interface GetServiceIntegrationExternalAwsCloudwatchMetricsUserConfigExtraMetric {
    field: string;
    metric: string;
}

export interface GetServiceIntegrationKafkaConnectUserConfig {
    kafkaConnect?: outputs.GetServiceIntegrationKafkaConnectUserConfigKafkaConnect;
}

export interface GetServiceIntegrationKafkaConnectUserConfigKafkaConnect {
    configStorageTopic?: string;
    groupId?: string;
    offsetStorageTopic?: string;
    statusStorageTopic?: string;
}

export interface GetServiceIntegrationKafkaLogsUserConfig {
    kafkaTopic?: string;
}

export interface GetServiceIntegrationKafkaMirrormakerUserConfig {
    clusterAlias?: string;
    kafkaMirrormaker?: outputs.GetServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker;
}

export interface GetServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker {
    consumerFetchMinBytes?: number;
    producerBatchSize?: number;
    producerBufferMemory?: number;
    producerLingerMs?: number;
    producerMaxRequestSize?: number;
}

export interface GetServiceIntegrationLogsUserConfig {
    elasticsearchIndexDaysMax?: number;
    elasticsearchIndexPrefix?: string;
}

export interface GetServiceIntegrationMetricsUserConfig {
    database?: string;
    retentionDays?: number;
    roUsername?: string;
    sourceMysql?: outputs.GetServiceIntegrationMetricsUserConfigSourceMysql;
    username?: string;
}

export interface GetServiceIntegrationMetricsUserConfigSourceMysql {
    telegraf?: outputs.GetServiceIntegrationMetricsUserConfigSourceMysqlTelegraf;
}

export interface GetServiceIntegrationMetricsUserConfigSourceMysqlTelegraf {
    gatherEventWaits?: boolean;
    gatherFileEventsStats?: boolean;
    gatherIndexIoWaits?: boolean;
    gatherInfoSchemaAutoInc?: boolean;
    gatherInnodbMetrics?: boolean;
    gatherPerfEventsStatements?: boolean;
    gatherProcessList?: boolean;
    gatherSlaveStatus?: boolean;
    gatherTableIoWaits?: boolean;
    gatherTableLockWaits?: boolean;
    gatherTableSchema?: boolean;
    perfEventsStatementsDigestTextLimit?: number;
    perfEventsStatementsLimit?: number;
    perfEventsStatementsTimeLimit?: number;
}

export interface GrafanaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GrafanaGrafana {
}

export interface GrafanaGrafanaUserConfig {
    additionalBackupRegions?: string;
    alertingEnabled?: boolean;
    alertingErrorOrTimeout?: string;
    alertingMaxAnnotationsToKeep?: number;
    alertingNodataOrNullvalues?: string;
    allowEmbedding?: boolean;
    authAzuread?: outputs.GrafanaGrafanaUserConfigAuthAzuread;
    authBasicEnabled?: boolean;
    authGenericOauth?: outputs.GrafanaGrafanaUserConfigAuthGenericOauth;
    authGithub?: outputs.GrafanaGrafanaUserConfigAuthGithub;
    authGitlab?: outputs.GrafanaGrafanaUserConfigAuthGitlab;
    authGoogle?: outputs.GrafanaGrafanaUserConfigAuthGoogle;
    cookieSamesite?: string;
    customDomain?: string;
    dashboardPreviewsEnabled?: boolean;
    dashboardsMinRefreshInterval?: string;
    dashboardsVersionsToKeep?: number;
    dataproxySendUserHeader?: boolean;
    dataproxyTimeout?: number;
    dateFormats?: outputs.GrafanaGrafanaUserConfigDateFormats;
    disableGravatar?: boolean;
    editorsCanAdmin?: boolean;
    externalImageStorage?: outputs.GrafanaGrafanaUserConfigExternalImageStorage;
    googleAnalyticsUaId?: string;
    ipFilterObjects?: outputs.GrafanaGrafanaUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    metricsEnabled?: boolean;
    privateAccess?: outputs.GrafanaGrafanaUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GrafanaGrafanaUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GrafanaGrafanaUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    smtpServer?: outputs.GrafanaGrafanaUserConfigSmtpServer;
    staticIps?: boolean;
    userAutoAssignOrg?: boolean;
    userAutoAssignOrgRole?: string;
    viewersCanEdit?: boolean;
}

export interface GrafanaGrafanaUserConfigAuthAzuread {
    allowSignUp?: boolean;
    allowedDomains?: string[];
    allowedGroups?: string[];
    authUrl: string;
    clientId: string;
    clientSecret: string;
    tokenUrl: string;
}

export interface GrafanaGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: boolean;
    allowedDomains?: string[];
    allowedOrganizations?: string[];
    apiUrl: string;
    authUrl: string;
    clientId: string;
    clientSecret: string;
    name?: string;
    scopes?: string[];
    tokenUrl: string;
}

export interface GrafanaGrafanaUserConfigAuthGithub {
    allowSignUp?: boolean;
    allowedOrganizations?: string[];
    clientId: string;
    clientSecret: string;
    teamIds?: number[];
}

export interface GrafanaGrafanaUserConfigAuthGitlab {
    allowSignUp?: boolean;
    allowedGroups?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId: string;
    clientSecret: string;
    tokenUrl?: string;
}

export interface GrafanaGrafanaUserConfigAuthGoogle {
    allowSignUp?: boolean;
    allowedDomains?: string[];
    clientId: string;
    clientSecret: string;
}

export interface GrafanaGrafanaUserConfigDateFormats {
    defaultTimezone?: string;
    fullDate?: string;
    intervalDay?: string;
    intervalHour?: string;
    intervalMinute?: string;
    intervalMonth?: string;
    intervalSecond?: string;
    intervalYear?: string;
}

export interface GrafanaGrafanaUserConfigExternalImageStorage {
    accessKey: string;
    bucketUrl: string;
    provider: string;
    secretKey: string;
}

export interface GrafanaGrafanaUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface GrafanaGrafanaUserConfigPrivateAccess {
    grafana?: boolean;
}

export interface GrafanaGrafanaUserConfigPrivatelinkAccess {
    grafana?: boolean;
}

export interface GrafanaGrafanaUserConfigPublicAccess {
    grafana?: boolean;
}

export interface GrafanaGrafanaUserConfigSmtpServer {
    fromAddress: string;
    fromName?: string;
    host: string;
    password?: string;
    port: number;
    skipVerify?: boolean;
    starttlsPolicy?: string;
    username?: string;
}

export interface GrafanaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GrafanaTag {
    key: string;
    value: string;
}

export interface InfluxDbComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface InfluxDbInfluxdb {
    databaseName: string;
}

export interface InfluxDbInfluxdbUserConfig {
    /**
     * Additional Cloud Regions for Backup Replication.
     */
    additionalBackupRegions?: string;
    /**
     * Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.
     */
    customDomain?: string;
    /**
     * influxdb.conf configuration values.
     */
    influxdb?: outputs.InfluxDbInfluxdbUserConfigInfluxdb;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     */
    ipFilterObjects?: outputs.InfluxDbInfluxdbUserConfigIpFilterObject[];
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     */
    ipFilterStrings?: string[];
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     *
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    /**
     * Allow access to selected service ports from private networks.
     */
    privateAccess?: outputs.InfluxDbInfluxdbUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink.
     */
    privatelinkAccess?: outputs.InfluxDbInfluxdbUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet.
     */
    publicAccess?: outputs.InfluxDbInfluxdbUserConfigPublicAccess;
    /**
     * Name of the basebackup to restore in forked service.
     */
    recoveryBasebackupName?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * Use static public IP addresses.
     */
    staticIps?: boolean;
}

export interface InfluxDbInfluxdbUserConfigInfluxdb {
    logQueriesAfter?: number;
    maxConnectionLimit?: number;
    maxRowLimit?: number;
    maxSelectBuckets?: number;
    maxSelectPoint?: number;
    queryTimeout?: number;
}

export interface InfluxDbInfluxdbUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface InfluxDbInfluxdbUserConfigPrivateAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: boolean;
}

export interface InfluxDbInfluxdbUserConfigPrivatelinkAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: boolean;
}

export interface InfluxDbInfluxdbUserConfigPublicAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: boolean;
}

export interface InfluxDbServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface InfluxDbTag {
    /**
     * Service tag key
     */
    key: string;
    /**
     * Service tag value
     */
    value: string;
}

export interface KafkaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface KafkaConnectComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface KafkaConnectKafkaConnect {
}

export interface KafkaConnectKafkaConnectUserConfig {
    additionalBackupRegions?: string;
    ipFilterObjects?: outputs.KafkaConnectKafkaConnectUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    kafkaConnect?: outputs.KafkaConnectKafkaConnectUserConfigKafkaConnect;
    privateAccess?: outputs.KafkaConnectKafkaConnectUserConfigPrivateAccess;
    privatelinkAccess?: outputs.KafkaConnectKafkaConnectUserConfigPrivatelinkAccess;
    publicAccess?: outputs.KafkaConnectKafkaConnectUserConfigPublicAccess;
    staticIps?: boolean;
}

export interface KafkaConnectKafkaConnectUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface KafkaConnectKafkaConnectUserConfigKafkaConnect {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerFetchMaxBytes?: number;
    consumerIsolationLevel?: string;
    consumerMaxPartitionFetchBytes?: number;
    consumerMaxPollIntervalMs?: number;
    consumerMaxPollRecords?: number;
    offsetFlushIntervalMs?: number;
    offsetFlushTimeoutMs?: number;
    producerBatchSize?: number;
    producerBufferMemory?: number;
    producerCompressionType?: string;
    producerLingerMs?: number;
    producerMaxRequestSize?: number;
    sessionTimeoutMs?: number;
}

export interface KafkaConnectKafkaConnectUserConfigPrivateAccess {
    kafkaConnect?: boolean;
    prometheus?: boolean;
}

export interface KafkaConnectKafkaConnectUserConfigPrivatelinkAccess {
    jolokia?: boolean;
    kafkaConnect?: boolean;
    prometheus?: boolean;
}

export interface KafkaConnectKafkaConnectUserConfigPublicAccess {
    kafkaConnect?: boolean;
    prometheus?: boolean;
}

export interface KafkaConnectServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface KafkaConnectTag {
    key: string;
    value: string;
}

export interface KafkaConnectorTask {
    connector: string;
    /**
     * List of tasks of a connector.
     */
    task: number;
}

export interface KafkaKafka {
    /**
     * The Kafka client certificate
     */
    accessCert: string;
    /**
     * The Kafka client certificate key
     */
    accessKey: string;
    /**
     * The Kafka Connect URI, if any
     */
    connectUri: string;
    /**
     * The Kafka REST URI, if any
     */
    restUri: string;
    /**
     * The Schema Registry URI, if any
     */
    schemaRegistryUri: string;
}

export interface KafkaKafkaUserConfig {
    /**
     * Additional Cloud Regions for Backup Replication.
     */
    additionalBackupRegions?: string;
    /**
     * Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.
     */
    customDomain?: string;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     */
    ipFilterObjects?: outputs.KafkaKafkaUserConfigIpFilterObject[];
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     */
    ipFilterStrings?: string[];
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     *
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    /**
     * Kafka broker configuration values.
     */
    kafka?: outputs.KafkaKafkaUserConfigKafka;
    /**
     * Kafka authentication methods.
     */
    kafkaAuthenticationMethods?: outputs.KafkaKafkaUserConfigKafkaAuthenticationMethods;
    /**
     * Enable Kafka Connect service. The default value is `false`.
     */
    kafkaConnect?: boolean;
    /**
     * Kafka Connect configuration values.
     */
    kafkaConnectConfig?: outputs.KafkaKafkaUserConfigKafkaConnectConfig;
    /**
     * Enable Kafka-REST service. The default value is `false`.
     */
    kafkaRest?: boolean;
    /**
     * Enable authorization in Kafka-REST service.
     */
    kafkaRestAuthorization?: boolean;
    /**
     * Kafka REST configuration.
     */
    kafkaRestConfig?: outputs.KafkaKafkaUserConfigKafkaRestConfig;
    /**
     * Kafka major version.
     */
    kafkaVersion?: string;
    /**
     * Allow access to selected service ports from private networks.
     */
    privateAccess?: outputs.KafkaKafkaUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink.
     */
    privatelinkAccess?: outputs.KafkaKafkaUserConfigPrivatelinkAccess;
    /**
     * Allow access to selected service ports from the public Internet.
     */
    publicAccess?: outputs.KafkaKafkaUserConfigPublicAccess;
    /**
     * Enable Schema-Registry service. The default value is `false`.
     */
    schemaRegistry?: boolean;
    /**
     * Schema Registry configuration.
     */
    schemaRegistryConfig?: outputs.KafkaKafkaUserConfigSchemaRegistryConfig;
    /**
     * Use static public IP addresses.
     */
    staticIps?: boolean;
}

export interface KafkaKafkaUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface KafkaKafkaUserConfigKafka {
    autoCreateTopicsEnable?: boolean;
    compressionType?: string;
    connectionsMaxIdleMs?: number;
    defaultReplicationFactor?: number;
    groupInitialRebalanceDelayMs?: number;
    groupMaxSessionTimeoutMs?: number;
    groupMinSessionTimeoutMs?: number;
    logCleanerDeleteRetentionMs?: number;
    logCleanerMaxCompactionLagMs?: number;
    logCleanerMinCleanableRatio?: number;
    logCleanerMinCompactionLagMs?: number;
    logCleanupPolicy?: string;
    logFlushIntervalMessages?: number;
    logFlushIntervalMs?: number;
    logIndexIntervalBytes?: number;
    logIndexSizeMaxBytes?: number;
    logMessageDownconversionEnable?: boolean;
    logMessageTimestampDifferenceMaxMs?: number;
    logMessageTimestampType?: string;
    logPreallocate?: boolean;
    logRetentionBytes?: number;
    logRetentionHours?: number;
    logRetentionMs?: number;
    logRollJitterMs?: number;
    logRollMs?: number;
    logSegmentBytes?: number;
    logSegmentDeleteDelayMs?: number;
    maxConnectionsPerIp?: number;
    maxIncrementalFetchSessionCacheSlots?: number;
    messageMaxBytes?: number;
    minInsyncReplicas?: number;
    numPartitions?: number;
    offsetsRetentionMinutes?: number;
    producerPurgatoryPurgeIntervalRequests?: number;
    replicaFetchMaxBytes?: number;
    replicaFetchResponseMaxBytes?: number;
    socketRequestMaxBytes?: number;
    transactionRemoveExpiredTransactionCleanupIntervalMs?: number;
    transactionStateLogSegmentBytes?: number;
}

export interface KafkaKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: boolean;
    sasl?: boolean;
}

export interface KafkaKafkaUserConfigKafkaConnectConfig {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerFetchMaxBytes?: number;
    consumerIsolationLevel?: string;
    consumerMaxPartitionFetchBytes?: number;
    consumerMaxPollIntervalMs?: number;
    consumerMaxPollRecords?: number;
    offsetFlushIntervalMs?: number;
    offsetFlushTimeoutMs?: number;
    producerBatchSize?: number;
    producerBufferMemory?: number;
    producerCompressionType?: string;
    producerLingerMs?: number;
    producerMaxRequestSize?: number;
    sessionTimeoutMs?: number;
}

export interface KafkaKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: boolean;
    consumerRequestMaxBytes?: number;
    consumerRequestTimeoutMs?: number;
    producerAcks?: string;
    producerCompressionType?: string;
    producerLingerMs?: number;
    simpleconsumerPoolSizeMax?: number;
}

export interface KafkaKafkaUserConfigPrivateAccess {
    /**
     * Kafka server provided values
     */
    kafka?: boolean;
    kafkaConnect?: boolean;
    kafkaRest?: boolean;
    prometheus?: boolean;
    schemaRegistry?: boolean;
}

export interface KafkaKafkaUserConfigPrivatelinkAccess {
    jolokia?: boolean;
    /**
     * Kafka server provided values
     */
    kafka?: boolean;
    kafkaConnect?: boolean;
    kafkaRest?: boolean;
    prometheus?: boolean;
    schemaRegistry?: boolean;
}

export interface KafkaKafkaUserConfigPublicAccess {
    /**
     * Kafka server provided values
     */
    kafka?: boolean;
    kafkaConnect?: boolean;
    kafkaRest?: boolean;
    prometheus?: boolean;
    schemaRegistry?: boolean;
}

export interface KafkaKafkaUserConfigSchemaRegistryConfig {
    leaderEligibility?: boolean;
    topicName?: string;
}

export interface KafkaMirrorMakerComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface KafkaMirrorMakerKafkaMirrormaker {
}

export interface KafkaMirrorMakerKafkaMirrormakerUserConfig {
    additionalBackupRegions?: string;
    ipFilterObjects?: outputs.KafkaMirrorMakerKafkaMirrormakerUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    kafkaMirrormaker?: outputs.KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker;
    staticIps?: boolean;
}

export interface KafkaMirrorMakerKafkaMirrormakerUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker {
    emitCheckpointsEnabled?: boolean;
    emitCheckpointsIntervalSeconds?: number;
    refreshGroupsEnabled?: boolean;
    refreshGroupsIntervalSeconds?: number;
    refreshTopicsEnabled?: boolean;
    refreshTopicsIntervalSeconds?: number;
    syncGroupOffsetsEnabled?: boolean;
    syncGroupOffsetsIntervalSeconds?: number;
    syncTopicConfigsEnabled?: boolean;
    tasksMaxPerCpu?: number;
}

export interface KafkaMirrorMakerServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface KafkaMirrorMakerTag {
    key: string;
    value: string;
}

export interface KafkaServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface KafkaTag {
    /**
     * Service tag key
     */
    key: string;
    /**
     * Service tag value
     */
    value: string;
}

export interface KafkaTopicConfig {
    /**
     * cleanup.policy value
     */
    cleanupPolicy?: string;
    /**
     * compression.type value
     */
    compressionType?: string;
    /**
     * delete.retention.ms value
     */
    deleteRetentionMs?: string;
    /**
     * file.delete.delay.ms value
     */
    fileDeleteDelayMs?: string;
    /**
     * flush.messages value
     */
    flushMessages?: string;
    /**
     * flush.ms value
     */
    flushMs?: string;
    /**
     * index.interval.bytes value
     */
    indexIntervalBytes?: string;
    /**
     * max.compaction.lag.ms value
     */
    maxCompactionLagMs?: string;
    /**
     * max.message.bytes value
     */
    maxMessageBytes?: string;
    /**
     * message.downconversion.enable value
     */
    messageDownconversionEnable?: boolean;
    /**
     * message.format.version value
     */
    messageFormatVersion?: string;
    /**
     * message.timestamp.difference.max.ms value
     */
    messageTimestampDifferenceMaxMs?: string;
    /**
     * message.timestamp.type value
     */
    messageTimestampType?: string;
    /**
     * min.cleanable.dirty.ratio value
     */
    minCleanableDirtyRatio?: number;
    /**
     * min.compaction.lag.ms value
     */
    minCompactionLagMs?: string;
    /**
     * min.insync.replicas value
     */
    minInsyncReplicas?: string;
    /**
     * preallocate value
     */
    preallocate?: boolean;
    /**
     * retention.bytes value
     */
    retentionBytes?: string;
    /**
     * retention.ms value
     */
    retentionMs?: string;
    /**
     * segment.bytes value
     */
    segmentBytes?: string;
    /**
     * segment.index.bytes value
     */
    segmentIndexBytes?: string;
    /**
     * segment.jitter.ms value
     */
    segmentJitterMs?: string;
    /**
     * segment.ms value
     */
    segmentMs?: string;
    /**
     * unclean.leader.election.enable value
     */
    uncleanLeaderElectionEnable?: boolean;
}

export interface KafkaTopicTag {
    /**
     * Topic tag key. Maximum length: `64`.
     */
    key: string;
    /**
     * Topic tag value. Maximum length: `256`.
     */
    value?: string;
}

export interface M3AggregatorComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface M3AggregatorM3aggregator {
}

export interface M3AggregatorM3aggregatorUserConfig {
    customDomain?: string;
    ipFilterObjects?: outputs.M3AggregatorM3aggregatorUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    /**
     * @deprecated Usage of this field is discouraged.
     */
    m3Version?: string;
    m3aggregatorVersion?: string;
    staticIps?: boolean;
}

export interface M3AggregatorM3aggregatorUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface M3AggregatorServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface M3AggregatorTag {
    key: string;
    value: string;
}

export interface M3DbComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface M3DbM3db {
}

export interface M3DbM3dbUserConfig {
    additionalBackupRegions?: string;
    customDomain?: string;
    ipFilterObjects?: outputs.M3DbM3dbUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    limits?: outputs.M3DbM3dbUserConfigLimits;
    m3?: outputs.M3DbM3dbUserConfigM3;
    /**
     * @deprecated Usage of this field is discouraged.
     */
    m3Version?: string;
    m3coordinatorEnableGraphiteCarbonIngest?: boolean;
    m3dbVersion?: string;
    namespaces?: outputs.M3DbM3dbUserConfigNamespace[];
    privateAccess?: outputs.M3DbM3dbUserConfigPrivateAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.M3DbM3dbUserConfigPublicAccess;
    rules?: outputs.M3DbM3dbUserConfigRules;
    serviceToForkFrom?: string;
    staticIps?: boolean;
}

export interface M3DbM3dbUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface M3DbM3dbUserConfigLimits {
    maxRecentlyQueriedSeriesBlocks?: number;
    maxRecentlyQueriedSeriesDiskBytesRead?: number;
    maxRecentlyQueriedSeriesLookback?: string;
    queryDocs?: number;
    queryRequireExhaustive?: boolean;
    querySeries?: number;
}

export interface M3DbM3dbUserConfigM3 {
    tagOptions?: outputs.M3DbM3dbUserConfigM3TagOptions;
}

export interface M3DbM3dbUserConfigM3TagOptions {
    allowTagNameDuplicates?: boolean;
    allowTagValueEmpty?: boolean;
}

export interface M3DbM3dbUserConfigNamespace {
    name: string;
    options?: outputs.M3DbM3dbUserConfigNamespaceOptions;
    resolution?: string;
    type: string;
}

export interface M3DbM3dbUserConfigNamespaceOptions {
    retentionOptions?: outputs.M3DbM3dbUserConfigNamespaceOptionsRetentionOptions;
    snapshotEnabled?: boolean;
    writesToCommitlog?: boolean;
}

export interface M3DbM3dbUserConfigNamespaceOptionsRetentionOptions {
    blockDataExpiryDuration?: string;
    blocksizeDuration?: string;
    bufferFutureDuration?: string;
    bufferPastDuration?: string;
    retentionPeriodDuration?: string;
}

export interface M3DbM3dbUserConfigPrivateAccess {
    m3coordinator?: boolean;
}

export interface M3DbM3dbUserConfigPublicAccess {
    m3coordinator?: boolean;
}

export interface M3DbM3dbUserConfigRules {
    mappings?: outputs.M3DbM3dbUserConfigRulesMapping[];
}

export interface M3DbM3dbUserConfigRulesMapping {
    aggregations?: string[];
    drop?: boolean;
    filter: string;
    name?: string;
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with namespaces_string instead. When switching to namespaces_string, please apply the changes twice due to technical limitations.
     */
    namespaces?: string[];
    namespacesObjects?: outputs.M3DbM3dbUserConfigRulesMappingNamespacesObject[];
    namespacesStrings?: string[];
    tags?: outputs.M3DbM3dbUserConfigRulesMappingTag[];
}

export interface M3DbM3dbUserConfigRulesMappingNamespacesObject {
    resolution?: string;
    retention?: string;
}

export interface M3DbM3dbUserConfigRulesMappingTag {
    name: string;
    value: string;
}

export interface M3DbServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface M3DbTag {
    key: string;
    value: string;
}

export interface MySqlComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface MySqlMysql {
}

export interface MySqlMysqlUserConfig {
    additionalBackupRegions?: string;
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: number;
    backupMinute?: number;
    binlogRetentionPeriod?: number;
    ipFilterObjects?: outputs.MySqlMysqlUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    migration?: outputs.MySqlMysqlUserConfigMigration;
    mysql?: outputs.MySqlMysqlUserConfigMysql;
    mysqlVersion?: string;
    privateAccess?: outputs.MySqlMysqlUserConfigPrivateAccess;
    privatelinkAccess?: outputs.MySqlMysqlUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.MySqlMysqlUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    staticIps?: boolean;
}

export interface MySqlMysqlUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface MySqlMysqlUserConfigMigration {
    dbname?: string;
    host: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port: number;
    ssl?: boolean;
    username?: string;
}

export interface MySqlMysqlUserConfigMysql {
    connectTimeout?: number;
    defaultTimeZone?: string;
    groupConcatMaxLen?: number;
    informationSchemaStatsExpiry?: number;
    innodbChangeBufferMaxSize?: number;
    innodbFlushNeighbors?: number;
    innodbFtMinTokenSize?: number;
    innodbFtServerStopwordTable?: string;
    innodbLockWaitTimeout?: number;
    innodbLogBufferSize?: number;
    innodbOnlineAlterLogMaxSize?: number;
    innodbPrintAllDeadlocks?: boolean;
    innodbReadIoThreads?: number;
    innodbRollbackOnTimeout?: boolean;
    innodbThreadConcurrency?: number;
    innodbWriteIoThreads?: number;
    interactiveTimeout?: number;
    internalTmpMemStorageEngine?: string;
    longQueryTime?: number;
    maxAllowedPacket?: number;
    maxHeapTableSize?: number;
    netBufferLength?: number;
    netReadTimeout?: number;
    netWriteTimeout?: number;
    slowQueryLog?: boolean;
    sortBufferSize?: number;
    sqlMode?: string;
    sqlRequirePrimaryKey?: boolean;
    tmpTableSize?: number;
    waitTimeout?: number;
}

export interface MySqlMysqlUserConfigPrivateAccess {
    mysql?: boolean;
    mysqlx?: boolean;
    prometheus?: boolean;
}

export interface MySqlMysqlUserConfigPrivatelinkAccess {
    mysql?: boolean;
    mysqlx?: boolean;
    prometheus?: boolean;
}

export interface MySqlMysqlUserConfigPublicAccess {
    mysql?: boolean;
    mysqlx?: boolean;
    prometheus?: boolean;
}

export interface MySqlServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface MySqlTag {
    key: string;
    value: string;
}

export interface OpenSearchComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface OpenSearchOpensearch {
    opensearchDashboardsUri: string;
}

export interface OpenSearchOpensearchUserConfig {
    /**
     * Additional Cloud Regions for Backup Replication.
     */
    additionalBackupRegions?: string;
    /**
     * Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.
     */
    customDomain?: string;
    /**
     * Disable automatic replication factor adjustment for multi-node services. By default, Aiven ensures all indexes are replicated at least to two nodes. Note: Due to potential data loss in case of losing a service node, this setting can no longer be activated.
     *
     * @deprecated Usage of this field is discouraged.
     */
    disableReplicationFactorAdjustment?: boolean;
    /**
     * Index patterns.
     */
    indexPatterns?: outputs.OpenSearchOpensearchUserConfigIndexPattern[];
    /**
     * Template settings for all new indexes.
     */
    indexTemplate?: outputs.OpenSearchOpensearchUserConfigIndexTemplate;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     */
    ipFilterObjects?: outputs.OpenSearchOpensearchUserConfigIpFilterObject[];
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     */
    ipFilterStrings?: string[];
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     *
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    /**
     * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
     */
    keepIndexRefreshInterval?: boolean;
    /**
     * Use indexPatterns instead. The default value is `0`.
     *
     * @deprecated Usage of this field is discouraged.
     */
    maxIndexCount?: number;
    /**
     * OpenSearch settings.
     */
    opensearch?: outputs.OpenSearchOpensearchUserConfigOpensearch;
    /**
     * OpenSearch Dashboards settings.
     */
    opensearchDashboards?: outputs.OpenSearchOpensearchUserConfigOpensearchDashboards;
    /**
     * OpenSearch major version.
     */
    opensearchVersion?: string;
    /**
     * Allow access to selected service ports from private networks.
     */
    privateAccess?: outputs.OpenSearchOpensearchUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink.
     */
    privatelinkAccess?: outputs.OpenSearchOpensearchUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet.
     */
    publicAccess?: outputs.OpenSearchOpensearchUserConfigPublicAccess;
    /**
     * Name of the basebackup to restore in forked service.
     */
    recoveryBasebackupName?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * Use static public IP addresses.
     */
    staticIps?: boolean;
}

export interface OpenSearchOpensearchUserConfigIndexPattern {
    maxIndexCount: number;
    pattern: string;
    sortingAlgorithm?: string;
}

export interface OpenSearchOpensearchUserConfigIndexTemplate {
    mappingNestedObjectsLimit?: number;
    numberOfReplicas?: number;
    numberOfShards?: number;
}

export interface OpenSearchOpensearchUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface OpenSearchOpensearchUserConfigOpensearch {
    actionAutoCreateIndexEnabled?: boolean;
    actionDestructiveRequiresName?: boolean;
    clusterMaxShardsPerNode?: number;
    clusterRoutingAllocationNodeConcurrentRecoveries?: number;
    emailSenderName?: string;
    emailSenderPassword?: string;
    emailSenderUsername?: string;
    httpMaxContentLength?: number;
    httpMaxHeaderSize?: number;
    httpMaxInitialLineLength?: number;
    indicesFielddataCacheSize?: number;
    indicesMemoryIndexBufferSize?: number;
    indicesQueriesCacheSize?: number;
    indicesQueryBoolMaxClauseCount?: number;
    indicesRecoveryMaxBytesPerSec?: number;
    indicesRecoveryMaxConcurrentFileChunks?: number;
    overrideMainResponseVersion?: boolean;
    reindexRemoteWhitelists?: string[];
    scriptMaxCompilationsRate?: string;
    searchMaxBuckets?: number;
    threadPoolAnalyzeQueueSize?: number;
    threadPoolAnalyzeSize?: number;
    threadPoolForceMergeSize?: number;
    threadPoolGetQueueSize?: number;
    threadPoolGetSize?: number;
    threadPoolSearchQueueSize?: number;
    threadPoolSearchSize?: number;
    threadPoolSearchThrottledQueueSize?: number;
    threadPoolSearchThrottledSize?: number;
    threadPoolWriteQueueSize?: number;
    threadPoolWriteSize?: number;
}

export interface OpenSearchOpensearchUserConfigOpensearchDashboards {
    enabled?: boolean;
    maxOldSpaceSize?: number;
    opensearchRequestTimeout?: number;
}

export interface OpenSearchOpensearchUserConfigPrivateAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: boolean;
    opensearchDashboards?: boolean;
    prometheus?: boolean;
}

export interface OpenSearchOpensearchUserConfigPrivatelinkAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: boolean;
    opensearchDashboards?: boolean;
    prometheus?: boolean;
}

export interface OpenSearchOpensearchUserConfigPublicAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: boolean;
    opensearchDashboards?: boolean;
    prometheus?: boolean;
}

export interface OpenSearchServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface OpenSearchTag {
    /**
     * Service tag key
     */
    key: string;
    /**
     * Service tag value
     */
    value: string;
}

export interface PgComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface PgPg {
    /**
     * Primary PostgreSQL database name
     */
    dbname: string;
    /**
     * PostgreSQL master node host IP or name
     */
    host: string;
    /**
     * Connection limit
     */
    maxConnections: number;
    /**
     * PostgreSQL admin user password
     */
    password: string;
    /**
     * PostgreSQL port
     */
    port: number;
    /**
     * PostgreSQL replica URI for services with a replica
     */
    replicaUri: string;
    /**
     * PostgreSQL sslmode setting (currently always "require")
     */
    sslmode: string;
    /**
     * PostgreSQL master connection URI
     */
    uri: string;
    /**
     * PostgreSQL admin user name
     */
    user: string;
}

export interface PgPgUserConfig {
    /**
     * Additional Cloud Regions for Backup Replication.
     */
    additionalBackupRegions?: string;
    /**
     * Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
     */
    adminPassword?: string;
    /**
     * Custom username for admin user. This must be set only when a new service is being created.
     */
    adminUsername?: string;
    /**
     * The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
     */
    backupHour?: number;
    /**
     * The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
     */
    backupMinute?: number;
    /**
     * Register AAAA DNS records for the service, and allow IPv6 packets to service ports.
     */
    enableIpv6?: boolean;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     */
    ipFilterObjects?: outputs.PgPgUserConfigIpFilterObject[];
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     */
    ipFilterStrings?: string[];
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
     *
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    /**
     * Migrate data from existing server.
     */
    migration?: outputs.PgPgUserConfigMigration;
    /**
     * postgresql.conf configuration values.
     */
    pg?: outputs.PgPgUserConfigPg;
    /**
     * Use readReplica service integration instead.
     *
     * @deprecated Usage of this field is discouraged.
     */
    pgReadReplica?: boolean;
    /**
     * Name of the PG Service from which to fork (deprecated, use service*to*fork_from). This has effect only when a new service is being created.
     *
     * @deprecated Usage of this field is discouraged.
     */
    pgServiceToForkFrom?: string;
    /**
     * Enable the pg*stat*monitor extension. Enabling this extension will cause the cluster to be restarted.When this extension is enabled, pg*stat*statements results for utility commands are unreliable. The default value is `false`.
     */
    pgStatMonitorEnable?: boolean;
    /**
     * PostgreSQL major version.
     */
    pgVersion?: string;
    /**
     * PGBouncer connection pooling settings.
     */
    pgbouncer?: outputs.PgPgUserConfigPgbouncer;
    /**
     * PGLookout settings.
     */
    pglookout?: outputs.PgPgUserConfigPglookout;
    /**
     * Allow access to selected service ports from private networks.
     */
    privateAccess?: outputs.PgPgUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink.
     */
    privatelinkAccess?: outputs.PgPgUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet.
     */
    publicAccess?: outputs.PgPgUserConfigPublicAccess;
    /**
     * Recovery target time when forking a service. This has effect only when a new service is being created.
     */
    recoveryTargetTime?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * Percentage of total RAM that the database server uses for shared memory buffers. Valid range is 20-60 (float), which corresponds to 20% - 60%. This setting adjusts the sharedBuffers configuration value.
     */
    sharedBuffersPercentage?: number;
    /**
     * Use static public IP addresses.
     */
    staticIps?: boolean;
    /**
     * Synchronous replication type. Note that the service plan also needs to support synchronous replication.
     */
    synchronousReplication?: string;
    /**
     * TimescaleDB extension configuration values.
     */
    timescaledb?: outputs.PgPgUserConfigTimescaledb;
    /**
     * Variant of the PostgreSQL service, may affect the features that are exposed by default.
     */
    variant?: string;
    /**
     * Sets the maximum amount of memory to be used by a query operation (such as a sort or hash table) before writing to temporary disk files, in MB. Default is 1MB + 0.075% of total RAM (up to 32MB).
     */
    workMem?: number;
}

export interface PgPgUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface PgPgUserConfigMigration {
    dbname?: string;
    host: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port: number;
    ssl?: boolean;
    username?: string;
}

export interface PgPgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: number;
    autovacuumAnalyzeThreshold?: number;
    autovacuumFreezeMaxAge?: number;
    autovacuumMaxWorkers?: number;
    autovacuumNaptime?: number;
    autovacuumVacuumCostDelay?: number;
    autovacuumVacuumCostLimit?: number;
    autovacuumVacuumScaleFactor?: number;
    autovacuumVacuumThreshold?: number;
    bgwriterDelay?: number;
    bgwriterFlushAfter?: number;
    bgwriterLruMaxpages?: number;
    bgwriterLruMultiplier?: number;
    deadlockTimeout?: number;
    defaultToastCompression?: string;
    idleInTransactionSessionTimeout?: number;
    jit?: boolean;
    logAutovacuumMinDuration?: number;
    logErrorVerbosity?: string;
    logLinePrefix?: string;
    logMinDurationStatement?: number;
    logTempFiles?: number;
    maxFilesPerProcess?: number;
    maxLocksPerTransaction?: number;
    maxLogicalReplicationWorkers?: number;
    maxParallelWorkers?: number;
    maxParallelWorkersPerGather?: number;
    maxPredLocksPerTransaction?: number;
    maxPreparedTransactions?: number;
    maxReplicationSlots?: number;
    maxSlotWalKeepSize?: number;
    maxStackDepth?: number;
    maxStandbyArchiveDelay?: number;
    maxStandbyStreamingDelay?: number;
    maxWalSenders?: number;
    maxWorkerProcesses?: number;
    pgPartmanBgwDotInterval?: number;
    pgPartmanBgwDotRole?: string;
    pgStatMonitorDotPgsmEnableQueryPlan?: boolean;
    pgStatMonitorDotPgsmMaxBuckets?: number;
    pgStatStatementsDotTrack?: string;
    tempFileLimit?: number;
    timezone?: string;
    trackActivityQuerySize?: number;
    trackCommitTimestamp?: string;
    trackFunctions?: string;
    trackIoTiming?: string;
    walSenderTimeout?: number;
    walWriterDelay?: number;
}

export interface PgPgUserConfigPgbouncer {
    autodbIdleTimeout?: number;
    autodbMaxDbConnections?: number;
    autodbPoolMode?: string;
    autodbPoolSize?: number;
    ignoreStartupParameters?: string[];
    minPoolSize?: number;
    serverIdleTimeout?: number;
    serverLifetime?: number;
    serverResetQueryAlways?: boolean;
}

export interface PgPgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: number;
}

export interface PgPgUserConfigPrivateAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: boolean;
    pgbouncer?: boolean;
    prometheus?: boolean;
}

export interface PgPgUserConfigPrivatelinkAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: boolean;
    pgbouncer?: boolean;
    prometheus?: boolean;
}

export interface PgPgUserConfigPublicAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: boolean;
    pgbouncer?: boolean;
    prometheus?: boolean;
}

export interface PgPgUserConfigTimescaledb {
    maxBackgroundWorkers?: number;
}

export interface PgServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface PgTag {
    /**
     * Service tag key
     */
    key: string;
    /**
     * Service tag value
     */
    value: string;
}

export interface ProjectTag {
    /**
     * Project tag key
     */
    key: string;
    /**
     * Project tag value
     */
    value: string;
}

export interface RedisComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface RedisRedi {
}

export interface RedisRedisUserConfig {
    additionalBackupRegions?: string;
    ipFilterObjects?: outputs.RedisRedisUserConfigIpFilterObject[];
    ipFilterStrings?: string[];
    /**
     * @deprecated This will be removed in v5.0.0 and replaced with ip_filter_string instead. When switching to ip_filter_string, please apply the changes twice due to technical limitations.
     */
    ipFilters?: string[];
    migration?: outputs.RedisRedisUserConfigMigration;
    privateAccess?: outputs.RedisRedisUserConfigPrivateAccess;
    privatelinkAccess?: outputs.RedisRedisUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.RedisRedisUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    redisAclChannelsDefault?: string;
    redisIoThreads?: number;
    redisLfuDecayTime?: number;
    redisLfuLogFactor?: number;
    redisMaxmemoryPolicy?: string;
    redisNotifyKeyspaceEvents?: string;
    redisNumberOfDatabases?: number;
    redisPersistence?: string;
    redisPubsubClientOutputBufferLimit?: number;
    redisSsl?: boolean;
    redisTimeout?: number;
    serviceToForkFrom?: string;
    staticIps?: boolean;
}

export interface RedisRedisUserConfigIpFilterObject {
    description?: string;
    network: string;
}

export interface RedisRedisUserConfigMigration {
    dbname?: string;
    host: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port: number;
    ssl?: boolean;
    username?: string;
}

export interface RedisRedisUserConfigPrivateAccess {
    prometheus?: boolean;
    redis?: boolean;
}

export interface RedisRedisUserConfigPrivatelinkAccess {
    prometheus?: boolean;
    redis?: boolean;
}

export interface RedisRedisUserConfigPublicAccess {
    prometheus?: boolean;
    redis?: boolean;
}

export interface RedisServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface RedisTag {
    key: string;
    value: string;
}

export interface ServiceIntegrationClickhouseKafkaUserConfig {
    /**
     * Tables to create.
     */
    tables?: outputs.ServiceIntegrationClickhouseKafkaUserConfigTable[];
}

export interface ServiceIntegrationClickhouseKafkaUserConfigTable {
    columns?: outputs.ServiceIntegrationClickhouseKafkaUserConfigTableColumn[];
    dataFormat: string;
    groupName: string;
    name: string;
    topics?: outputs.ServiceIntegrationClickhouseKafkaUserConfigTableTopic[];
}

export interface ServiceIntegrationClickhouseKafkaUserConfigTableColumn {
    name: string;
    type: string;
}

export interface ServiceIntegrationClickhouseKafkaUserConfigTableTopic {
    name: string;
}

export interface ServiceIntegrationClickhousePostgresqlUserConfig {
    /**
     * Databases to expose.
     */
    databases?: outputs.ServiceIntegrationClickhousePostgresqlUserConfigDatabase[];
}

export interface ServiceIntegrationClickhousePostgresqlUserConfigDatabase {
    database?: string;
    schema?: string;
}

export interface ServiceIntegrationDatadogUserConfig {
    /**
     * Enable Datadog Database Monitoring.
     */
    datadogDbmEnabled?: boolean;
    /**
     * Custom tags provided by user.
     */
    datadogTags?: outputs.ServiceIntegrationDatadogUserConfigDatadogTag[];
    /**
     * List of custom metrics.
     */
    excludeConsumerGroups?: string[];
    /**
     * List of topics to exclude.
     */
    excludeTopics?: string[];
    /**
     * List of custom metrics.
     */
    includeConsumerGroups?: string[];
    /**
     * List of topics to include.
     */
    includeTopics?: string[];
    /**
     * List of custom metrics.
     */
    kafkaCustomMetrics?: string[];
    /**
     * Maximum number of JMX metrics to send.
     */
    maxJmxMetrics?: number;
    /**
     * Datadog Opensearch Options.
     */
    opensearch?: outputs.ServiceIntegrationDatadogUserConfigOpensearch;
}

export interface ServiceIntegrationDatadogUserConfigDatadogTag {
    comment?: string;
    tag: string;
}

export interface ServiceIntegrationDatadogUserConfigOpensearch {
    indexStatsEnabled?: boolean;
    pendingTaskStatsEnabled?: boolean;
    pshardStatsEnabled?: boolean;
}

export interface ServiceIntegrationEndpointDatadogUserConfig {
    /**
     * Datadog API key.
     */
    datadogApiKey?: string;
    /**
     * Custom tags provided by user.
     */
    datadogTags?: outputs.ServiceIntegrationEndpointDatadogUserConfigDatadogTag[];
    /**
     * Disable consumer group metrics.
     */
    disableConsumerStats?: boolean;
    /**
     * Number of separate instances to fetch kafka consumer statistics with.
     */
    kafkaConsumerCheckInstances?: number;
    /**
     * Number of seconds that datadog will wait to get consumer statistics from brokers.
     */
    kafkaConsumerStatsTimeout?: number;
    /**
     * Maximum number of partition contexts to send.
     */
    maxPartitionContexts?: number;
    /**
     * Datadog intake site. Defaults to datadoghq.com.
     */
    site?: string;
}

export interface ServiceIntegrationEndpointDatadogUserConfigDatadogTag {
    comment?: string;
    tag: string;
}

export interface ServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig {
    /**
     * AWS access key. Required permissions are logs:CreateLogGroup, logs:CreateLogStream, logs:PutLogEvents and logs:DescribeLogStreams.
     */
    accessKey?: string;
    /**
     * AWS CloudWatch log group name.
     */
    logGroupName?: string;
    /**
     * AWS region.
     */
    region?: string;
    /**
     * AWS secret key.
     */
    secretKey?: string;
}

export interface ServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig {
    /**
     * AWS access key. Required permissions are cloudwatch:PutMetricData.
     */
    accessKey?: string;
    /**
     * AWS CloudWatch Metrics Namespace.
     */
    namespace?: string;
    /**
     * AWS region.
     */
    region?: string;
    /**
     * AWS secret key.
     */
    secretKey?: string;
}

export interface ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig {
    /**
     * PEM encoded CA certificate.
     */
    ca?: string;
    /**
     * Maximum number of days of logs to keep. The default value is `3`.
     */
    indexDaysMax?: number;
    /**
     * Elasticsearch index prefix. The default value is `logs`.
     */
    indexPrefix?: string;
    /**
     * Elasticsearch request timeout limit. The default value is `10.0`.
     */
    timeout?: number;
    /**
     * Elasticsearch connection URL.
     */
    url?: string;
}

export interface ServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig {
    /**
     * Google Cloud Logging log id.
     */
    logId?: string;
    /**
     * GCP project id.
     */
    projectId?: string;
    /**
     * This is a JSON object with the fields documented in https://cloud.google.com/iam/docs/creating-managing-service-account-keys .
     */
    serviceAccountCredentials?: string;
}

export interface ServiceIntegrationEndpointExternalKafkaUserConfig {
    /**
     * Bootstrap servers.
     */
    bootstrapServers?: string;
    /**
     * The list of SASL mechanisms enabled in the Kafka server.
     */
    saslMechanism?: string;
    /**
     * Password for SASL PLAIN mechanism in the Kafka server.
     */
    saslPlainPassword?: string;
    /**
     * Username for SASL PLAIN mechanism in the Kafka server.
     */
    saslPlainUsername?: string;
    /**
     * Security protocol.
     */
    securityProtocol?: string;
    /**
     * PEM-encoded CA certificate.
     */
    sslCaCert?: string;
    /**
     * PEM-encoded client certificate.
     */
    sslClientCert?: string;
    /**
     * PEM-encoded client key.
     */
    sslClientKey?: string;
    /**
     * The endpoint identification algorithm to validate server hostname using server certificate.
     */
    sslEndpointIdentificationAlgorithm?: string;
}

export interface ServiceIntegrationEndpointExternalOpensearchLogsUserConfig {
    /**
     * PEM encoded CA certificate.
     */
    ca?: string;
    /**
     * Maximum number of days of logs to keep. The default value is `3`.
     */
    indexDaysMax?: number;
    /**
     * OpenSearch index prefix. The default value is `logs`.
     */
    indexPrefix?: string;
    /**
     * OpenSearch request timeout limit. The default value is `10.0`.
     */
    timeout?: number;
    /**
     * OpenSearch connection URL.
     */
    url?: string;
}

export interface ServiceIntegrationEndpointExternalSchemaRegistryUserConfig {
    /**
     * Authentication method.
     */
    authentication?: string;
    /**
     * Basic authentication password.
     */
    basicAuthPassword?: string;
    /**
     * Basic authentication user name.
     */
    basicAuthUsername?: string;
    /**
     * Schema Registry URL.
     */
    url?: string;
}

export interface ServiceIntegrationEndpointJolokiaUserConfig {
    /**
     * Jolokia basic authentication password.
     */
    basicAuthPassword?: string;
    /**
     * Jolokia basic authentication username.
     */
    basicAuthUsername?: string;
}

export interface ServiceIntegrationEndpointPrometheusUserConfig {
    /**
     * Prometheus basic authentication password.
     */
    basicAuthPassword?: string;
    /**
     * Prometheus basic authentication username.
     */
    basicAuthUsername?: string;
}

export interface ServiceIntegrationEndpointRsyslogUserConfig {
    /**
     * PEM encoded CA certificate.
     */
    ca?: string;
    /**
     * PEM encoded client certificate.
     */
    cert?: string;
    /**
     * message format. The default value is `rfc5424`.
     */
    format?: string;
    /**
     * PEM encoded client key.
     */
    key?: string;
    /**
     * custom syslog message format.
     */
    logline?: string;
    /**
     * rsyslog server port. The default value is `514`.
     */
    port?: number;
    /**
     * Structured data block for log message.
     */
    sd?: string;
    /**
     * rsyslog server IP address or hostname.
     */
    server?: string;
    /**
     * Require TLS. The default value is `true`.
     */
    tls?: boolean;
}

export interface ServiceIntegrationEndpointSignalfxUserConfig {
    /**
     * list of metrics to send.
     */
    enabledMetrics?: string[];
    /**
     * SignalFX API key.
     */
    signalfxApiKey?: string;
    /**
     * SignalFX realm. The default value is `us0`.
     */
    signalfxRealm?: string;
}

export interface ServiceIntegrationExternalAwsCloudwatchMetricsUserConfig {
    /**
     * Metrics to not send to AWS CloudWatch (takes precedence over extra*metrics).
     */
    droppedMetrics?: outputs.ServiceIntegrationExternalAwsCloudwatchMetricsUserConfigDroppedMetric[];
    /**
     * Metrics to allow through to AWS CloudWatch (in addition to default metrics).
     */
    extraMetrics?: outputs.ServiceIntegrationExternalAwsCloudwatchMetricsUserConfigExtraMetric[];
}

export interface ServiceIntegrationExternalAwsCloudwatchMetricsUserConfigDroppedMetric {
    field: string;
    metric: string;
}

export interface ServiceIntegrationExternalAwsCloudwatchMetricsUserConfigExtraMetric {
    field: string;
    metric: string;
}

export interface ServiceIntegrationKafkaConnectUserConfig {
    /**
     * Kafka Connect service configuration values.
     */
    kafkaConnect?: outputs.ServiceIntegrationKafkaConnectUserConfigKafkaConnect;
}

export interface ServiceIntegrationKafkaConnectUserConfigKafkaConnect {
    configStorageTopic?: string;
    groupId?: string;
    offsetStorageTopic?: string;
    statusStorageTopic?: string;
}

export interface ServiceIntegrationKafkaLogsUserConfig {
    /**
     * Topic name.
     */
    kafkaTopic?: string;
}

export interface ServiceIntegrationKafkaMirrormakerUserConfig {
    /**
     * The alias under which the Kafka cluster is known to MirrorMaker. Can contain the following symbols: ASCII alphanumerics, '.', '_', and '-'.
     */
    clusterAlias?: string;
    /**
     * Kafka MirrorMaker configuration values.
     */
    kafkaMirrormaker?: outputs.ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker;
}

export interface ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker {
    consumerFetchMinBytes?: number;
    producerBatchSize?: number;
    producerBufferMemory?: number;
    producerLingerMs?: number;
    producerMaxRequestSize?: number;
}

export interface ServiceIntegrationLogsUserConfig {
    /**
     * Elasticsearch index retention limit. The default value is `3`.
     */
    elasticsearchIndexDaysMax?: number;
    /**
     * Elasticsearch index prefix. The default value is `logs`.
     */
    elasticsearchIndexPrefix?: string;
}

export interface ServiceIntegrationMetricsUserConfig {
    /**
     * Name of the database where to store metric datapoints. Only affects PostgreSQL destinations. Defaults to 'metrics'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
     */
    database?: string;
    /**
     * Number of days to keep old metrics. Only affects PostgreSQL destinations. Set to 0 for no automatic cleanup. Defaults to 30 days.
     */
    retentionDays?: number;
    /**
     * Name of a user that can be used to read metrics. This will be used for Grafana integration (if enabled) to prevent Grafana users from making undesired changes. Only affects PostgreSQL destinations. Defaults to 'metrics_reader'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
     */
    roUsername?: string;
    /**
     * Configuration options for metrics where source service is MySQL.
     */
    sourceMysql?: outputs.ServiceIntegrationMetricsUserConfigSourceMysql;
    /**
     * Name of the user used to write metrics. Only affects PostgreSQL destinations. Defaults to 'metrics_writer'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
     */
    username?: string;
}

export interface ServiceIntegrationMetricsUserConfigSourceMysql {
    telegraf?: outputs.ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf;
}

export interface ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf {
    gatherEventWaits?: boolean;
    gatherFileEventsStats?: boolean;
    gatherIndexIoWaits?: boolean;
    gatherInfoSchemaAutoInc?: boolean;
    gatherInnodbMetrics?: boolean;
    gatherPerfEventsStatements?: boolean;
    gatherProcessList?: boolean;
    gatherSlaveStatus?: boolean;
    gatherTableIoWaits?: boolean;
    gatherTableLockWaits?: boolean;
    gatherTableSchema?: boolean;
    perfEventsStatementsDigestTextLimit?: number;
    perfEventsStatementsLimit?: number;
    perfEventsStatementsTimeLimit?: number;
}

