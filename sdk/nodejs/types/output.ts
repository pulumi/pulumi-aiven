// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface AccountAuthenticationSamlFieldMapping {
    email?: string;
    firstName?: string;
    identity?: string;
    lastName?: string;
    realName?: string;
}

export interface CassandraCassandra {
}

export interface CassandraCassandraUserConfig {
    cassandra?: outputs.CassandraCassandraUserConfigCassandra;
    cassandraVersion?: string;
    ipFilters?: string[];
    migrateSstableloader?: string;
    privateAccess?: outputs.CassandraCassandraUserConfigPrivateAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.CassandraCassandraUserConfigPublicAccess;
    serviceToForkFrom?: string;
    staticIps?: string;
}

export interface CassandraCassandraUserConfigCassandra {
    batchSizeFailThresholdInKb?: string;
    batchSizeWarnThresholdInKb?: string;
}

export interface CassandraCassandraUserConfigPrivateAccess {
    prometheus?: string;
}

export interface CassandraCassandraUserConfigPublicAccess {
    prometheus?: string;
}

export interface CassandraComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface CassandraServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface CassandraTag {
    key: string;
    value: string;
}

export interface ClickhouseClickhouse {
}

export interface ClickhouseClickhouseUserConfig {
    ipFilters?: string[];
    projectToForkFrom?: string;
    serviceToForkFrom?: string;
}

export interface ClickhouseComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface ClickhouseGrantPrivilegeGrant {
    column?: string;
    database: string;
    privilege?: string;
    table?: string;
    withGrant?: boolean;
}

export interface ClickhouseGrantRoleGrant {
    role?: string;
}

export interface ClickhouseServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface ClickhouseTag {
    key: string;
    value: string;
}

export interface FlinkComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface FlinkFlink {
    hostPorts: string[];
}

export interface FlinkFlinkUserConfig {
    executionCheckpointingIntervalMs?: string;
    executionCheckpointingTimeoutMs?: string;
    flinkVersion?: string;
    ipFilters?: string[];
    numberOfTaskSlots?: string;
    parallelismDefault?: string;
    privatelinkAccess?: outputs.FlinkFlinkUserConfigPrivatelinkAccess;
    restartStrategy?: string;
    restartStrategyDelaySec?: string;
    restartStrategyFailureRateIntervalMin?: string;
    restartStrategyMaxFailures?: string;
}

export interface FlinkFlinkUserConfigPrivatelinkAccess {
    flink?: string;
    prometheus?: string;
}

export interface FlinkJobTableUpsertKafka {
    keyFields?: string[];
    keyFormat?: string;
    scanStartupMode?: string;
    topic?: string;
    valueFieldsInclude?: string;
    valueFormat?: string;
}

export interface FlinkServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface FlinkTag {
    key: string;
    value: string;
}

export interface GetAccountAuthenticationSamlFieldMapping {
    email?: string;
    firstName?: string;
    identity?: string;
    lastName?: string;
    realName?: string;
}

export interface GetCassandaCassandra {
}

export interface GetCassandaCassandraUserConfig {
    cassandra?: outputs.GetCassandaCassandraUserConfigCassandra;
    cassandraVersion?: string;
    ipFilters?: string[];
    migrateSstableloader?: string;
    privateAccess?: outputs.GetCassandaCassandraUserConfigPrivateAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetCassandaCassandraUserConfigPublicAccess;
    serviceToForkFrom?: string;
    staticIps?: string;
}

export interface GetCassandaCassandraUserConfigCassandra {
    batchSizeFailThresholdInKb?: string;
    batchSizeWarnThresholdInKb?: string;
}

export interface GetCassandaCassandraUserConfigPrivateAccess {
    prometheus?: string;
}

export interface GetCassandaCassandraUserConfigPublicAccess {
    prometheus?: string;
}

export interface GetCassandaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetCassandaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetCassandaTag {
    key: string;
    value: string;
}

export interface GetCassandraCassandra {
}

export interface GetCassandraCassandraUserConfig {
    cassandra?: outputs.GetCassandraCassandraUserConfigCassandra;
    cassandraVersion?: string;
    ipFilters?: string[];
    migrateSstableloader?: string;
    privateAccess?: outputs.GetCassandraCassandraUserConfigPrivateAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetCassandraCassandraUserConfigPublicAccess;
    serviceToForkFrom?: string;
    staticIps?: string;
}

export interface GetCassandraCassandraUserConfigCassandra {
    batchSizeFailThresholdInKb?: string;
    batchSizeWarnThresholdInKb?: string;
}

export interface GetCassandraCassandraUserConfigPrivateAccess {
    prometheus?: string;
}

export interface GetCassandraCassandraUserConfigPublicAccess {
    prometheus?: string;
}

export interface GetCassandraComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetCassandraServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetCassandraTag {
    key: string;
    value: string;
}

export interface GetClickhouseClickhouse {
}

export interface GetClickhouseClickhouseUserConfig {
    ipFilters?: string[];
    projectToForkFrom?: string;
    serviceToForkFrom?: string;
}

export interface GetClickhouseComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetClickhouseServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetClickhouseTag {
    key: string;
    value: string;
}

export interface GetFlinkComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetFlinkFlink {
    hostPorts: string[];
}

export interface GetFlinkFlinkUserConfig {
    executionCheckpointingIntervalMs?: string;
    executionCheckpointingTimeoutMs?: string;
    flinkVersion?: string;
    ipFilters?: string[];
    numberOfTaskSlots?: string;
    parallelismDefault?: string;
    privatelinkAccess?: outputs.GetFlinkFlinkUserConfigPrivatelinkAccess;
    restartStrategy?: string;
    restartStrategyDelaySec?: string;
    restartStrategyFailureRateIntervalMin?: string;
    restartStrategyMaxFailures?: string;
}

export interface GetFlinkFlinkUserConfigPrivatelinkAccess {
    flink?: string;
    prometheus?: string;
}

export interface GetFlinkServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetFlinkTag {
    key: string;
    value: string;
}

export interface GetGrafanaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetGrafanaGrafana {
}

export interface GetGrafanaGrafanaUserConfig {
    alertingEnabled?: string;
    alertingErrorOrTimeout?: string;
    alertingMaxAnnotationsToKeep?: string;
    alertingNodataOrNullvalues?: string;
    allowEmbedding?: string;
    authAzuread?: outputs.GetGrafanaGrafanaUserConfigAuthAzuread;
    authBasicEnabled?: string;
    authGenericOauth?: outputs.GetGrafanaGrafanaUserConfigAuthGenericOauth;
    authGithub?: outputs.GetGrafanaGrafanaUserConfigAuthGithub;
    authGitlab?: outputs.GetGrafanaGrafanaUserConfigAuthGitlab;
    authGoogle?: outputs.GetGrafanaGrafanaUserConfigAuthGoogle;
    cookieSamesite?: string;
    customDomain?: string;
    dashboardsMinRefreshInterval?: string;
    dashboardsVersionsToKeep?: string;
    dataproxySendUserHeader?: string;
    dataproxyTimeout?: string;
    dateFormats?: outputs.GetGrafanaGrafanaUserConfigDateFormats;
    disableGravatar?: string;
    editorsCanAdmin?: string;
    externalImageStorage?: outputs.GetGrafanaGrafanaUserConfigExternalImageStorage;
    googleAnalyticsUaId?: string;
    ipFilters?: string[];
    metricsEnabled?: string;
    privateAccess?: outputs.GetGrafanaGrafanaUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetGrafanaGrafanaUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetGrafanaGrafanaUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    smtpServer?: outputs.GetGrafanaGrafanaUserConfigSmtpServer;
    staticIps?: string;
    userAutoAssignOrg?: string;
    userAutoAssignOrgRole?: string;
    viewersCanEdit?: string;
}

export interface GetGrafanaGrafanaUserConfigAuthAzuread {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedGroups?: string[];
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface GetGrafanaGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedOrganizations?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    name?: string;
    scopes?: string[];
    tokenUrl?: string;
}

export interface GetGrafanaGrafanaUserConfigAuthGithub {
    allowSignUp?: string;
    allowedOrganizations?: string[];
    clientId?: string;
    clientSecret?: string;
    teamIds?: string[];
}

export interface GetGrafanaGrafanaUserConfigAuthGitlab {
    allowSignUp?: string;
    allowedGroups?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface GetGrafanaGrafanaUserConfigAuthGoogle {
    allowSignUp?: string;
    allowedDomains?: string[];
    clientId?: string;
    clientSecret?: string;
}

export interface GetGrafanaGrafanaUserConfigDateFormats {
    defaultTimezone?: string;
    fullDate?: string;
    intervalDay?: string;
    intervalHour?: string;
    intervalMinute?: string;
    intervalMonth?: string;
    intervalSecond?: string;
    intervalYear?: string;
}

export interface GetGrafanaGrafanaUserConfigExternalImageStorage {
    accessKey?: string;
    bucketUrl?: string;
    provider?: string;
    secretKey?: string;
}

export interface GetGrafanaGrafanaUserConfigPrivateAccess {
    grafana?: string;
}

export interface GetGrafanaGrafanaUserConfigPrivatelinkAccess {
    grafana?: string;
}

export interface GetGrafanaGrafanaUserConfigPublicAccess {
    grafana?: string;
}

export interface GetGrafanaGrafanaUserConfigSmtpServer {
    fromAddress?: string;
    fromName?: string;
    host?: string;
    password?: string;
    port?: string;
    skipVerify?: string;
    starttlsPolicy?: string;
    username?: string;
}

export interface GetGrafanaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetGrafanaTag {
    key: string;
    value: string;
}

export interface GetInfluxDbComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetInfluxDbInfluxdb {
    databaseName: string;
}

export interface GetInfluxDbInfluxdbUserConfig {
    customDomain?: string;
    influxdb?: outputs.GetInfluxDbInfluxdbUserConfigInfluxdb;
    ipFilters?: string[];
    privateAccess?: outputs.GetInfluxDbInfluxdbUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetInfluxDbInfluxdbUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetInfluxDbInfluxdbUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    staticIps?: string;
}

export interface GetInfluxDbInfluxdbUserConfigInfluxdb {
    logQueriesAfter?: string;
    maxConnectionLimit?: string;
    maxRowLimit?: string;
    maxSelectBuckets?: string;
    maxSelectPoint?: string;
    queryTimeout?: string;
}

export interface GetInfluxDbInfluxdbUserConfigPrivateAccess {
    influxdb?: string;
}

export interface GetInfluxDbInfluxdbUserConfigPrivatelinkAccess {
    influxdb?: string;
}

export interface GetInfluxDbInfluxdbUserConfigPublicAccess {
    influxdb?: string;
}

export interface GetInfluxDbServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetInfluxDbTag {
    key: string;
    value: string;
}

export interface GetKafkaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetKafkaConnectComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetKafkaConnectKafkaConnect {
}

export interface GetKafkaConnectKafkaConnectUserConfig {
    ipFilters?: string[];
    kafkaConnect?: outputs.GetKafkaConnectKafkaConnectUserConfigKafkaConnect;
    privateAccess?: outputs.GetKafkaConnectKafkaConnectUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetKafkaConnectKafkaConnectUserConfigPrivatelinkAccess;
    publicAccess?: outputs.GetKafkaConnectKafkaConnectUserConfigPublicAccess;
    staticIps?: string;
}

export interface GetKafkaConnectKafkaConnectUserConfigKafkaConnect {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerFetchMaxBytes?: string;
    consumerIsolationLevel?: string;
    consumerMaxPartitionFetchBytes?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    producerCompressionType?: string;
    producerMaxRequestSize?: string;
    sessionTimeoutMs?: string;
}

export interface GetKafkaConnectKafkaConnectUserConfigPrivateAccess {
    kafkaConnect?: string;
    prometheus?: string;
}

export interface GetKafkaConnectKafkaConnectUserConfigPrivatelinkAccess {
    jolokia?: string;
    kafkaConnect?: string;
    prometheus?: string;
}

export interface GetKafkaConnectKafkaConnectUserConfigPublicAccess {
    kafkaConnect?: string;
    prometheus?: string;
}

export interface GetKafkaConnectServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetKafkaConnectTag {
    key: string;
    value: string;
}

export interface GetKafkaConnectorTask {
    connector: string;
    task: number;
}

export interface GetKafkaKafka {
    accessCert: string;
    accessKey: string;
    connectUri: string;
    restUri: string;
    schemaRegistryUri: string;
}

export interface GetKafkaKafkaUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    kafka?: outputs.GetKafkaKafkaUserConfigKafka;
    kafkaAuthenticationMethods?: outputs.GetKafkaKafkaUserConfigKafkaAuthenticationMethods;
    kafkaConnect?: string;
    kafkaConnectConfig?: outputs.GetKafkaKafkaUserConfigKafkaConnectConfig;
    kafkaRest?: string;
    kafkaRestConfig?: outputs.GetKafkaKafkaUserConfigKafkaRestConfig;
    kafkaVersion?: string;
    privateAccess?: outputs.GetKafkaKafkaUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetKafkaKafkaUserConfigPrivatelinkAccess;
    publicAccess?: outputs.GetKafkaKafkaUserConfigPublicAccess;
    schemaRegistry?: string;
    schemaRegistryConfig?: outputs.GetKafkaKafkaUserConfigSchemaRegistryConfig;
    staticIps?: string;
}

export interface GetKafkaKafkaUserConfigKafka {
    autoCreateTopicsEnable?: string;
    compressionType?: string;
    connectionsMaxIdleMs?: string;
    defaultReplicationFactor?: string;
    groupInitialRebalanceDelayMs?: string;
    groupMaxSessionTimeoutMs?: string;
    groupMinSessionTimeoutMs?: string;
    logCleanerDeleteRetentionMs?: string;
    logCleanerMaxCompactionLagMs?: string;
    logCleanerMinCleanableRatio?: string;
    logCleanerMinCompactionLagMs?: string;
    logCleanupPolicy?: string;
    logFlushIntervalMessages?: string;
    logFlushIntervalMs?: string;
    logIndexIntervalBytes?: string;
    logIndexSizeMaxBytes?: string;
    logMessageDownconversionEnable?: string;
    logMessageTimestampDifferenceMaxMs?: string;
    logMessageTimestampType?: string;
    logPreallocate?: string;
    logRetentionBytes?: string;
    logRetentionHours?: string;
    logRetentionMs?: string;
    logRollJitterMs?: string;
    logRollMs?: string;
    logSegmentBytes?: string;
    logSegmentDeleteDelayMs?: string;
    maxConnectionsPerIp?: string;
    maxIncrementalFetchSessionCacheSlots?: string;
    messageMaxBytes?: string;
    minInsyncReplicas?: string;
    numPartitions?: string;
    offsetsRetentionMinutes?: string;
    producerPurgatoryPurgeIntervalRequests?: string;
    replicaFetchMaxBytes?: string;
    replicaFetchResponseMaxBytes?: string;
    socketRequestMaxBytes?: string;
    transactionRemoveExpiredTransactionCleanupIntervalMs?: string;
    transactionStateLogSegmentBytes?: string;
}

export interface GetKafkaKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: string;
    sasl?: string;
}

export interface GetKafkaKafkaUserConfigKafkaConnectConfig {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerFetchMaxBytes?: string;
    consumerIsolationLevel?: string;
    consumerMaxPartitionFetchBytes?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    producerCompressionType?: string;
    producerMaxRequestSize?: string;
    sessionTimeoutMs?: string;
}

export interface GetKafkaKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: string;
    consumerRequestMaxBytes?: string;
    consumerRequestTimeoutMs?: string;
    producerAcks?: string;
    producerLingerMs?: string;
    simpleconsumerPoolSizeMax?: string;
}

export interface GetKafkaKafkaUserConfigPrivateAccess {
    prometheus?: string;
}

export interface GetKafkaKafkaUserConfigPrivatelinkAccess {
    jolokia?: string;
    kafka?: string;
    kafkaConnect?: string;
    kafkaRest?: string;
    prometheus?: string;
    schemaRegistry?: string;
}

export interface GetKafkaKafkaUserConfigPublicAccess {
    kafka?: string;
    kafkaConnect?: string;
    kafkaRest?: string;
    prometheus?: string;
    schemaRegistry?: string;
}

export interface GetKafkaKafkaUserConfigSchemaRegistryConfig {
    leaderEligibility?: string;
    topicName?: string;
}

export interface GetKafkaMirrorMakerComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetKafkaMirrorMakerKafkaMirrormaker {
}

export interface GetKafkaMirrorMakerKafkaMirrormakerUserConfig {
    ipFilters?: string[];
    kafkaMirrormaker?: outputs.GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker;
    staticIps?: string;
}

export interface GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker {
    emitCheckpointsEnabled?: string;
    emitCheckpointsIntervalSeconds?: string;
    refreshGroupsEnabled?: string;
    refreshGroupsIntervalSeconds?: string;
    refreshTopicsEnabled?: string;
    refreshTopicsIntervalSeconds?: string;
    syncGroupOffsetsEnabled?: string;
    syncGroupOffsetsIntervalSeconds?: string;
    syncTopicConfigsEnabled?: string;
    tasksMaxPerCpu?: string;
}

export interface GetKafkaMirrorMakerServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetKafkaMirrorMakerTag {
    key: string;
    value: string;
}

export interface GetKafkaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetKafkaTag {
    key: string;
    value: string;
}

export interface GetKafkaTopicConfig {
    cleanupPolicy?: string;
    compressionType?: string;
    deleteRetentionMs?: string;
    fileDeleteDelayMs?: string;
    flushMessages?: string;
    flushMs?: string;
    indexIntervalBytes?: string;
    maxCompactionLagMs?: string;
    maxMessageBytes?: string;
    messageDownconversionEnable?: string;
    messageFormatVersion?: string;
    messageTimestampDifferenceMaxMs?: string;
    messageTimestampType?: string;
    minCleanableDirtyRatio?: string;
    minCompactionLagMs?: string;
    minInsyncReplicas?: string;
    preallocate?: string;
    retentionBytes?: string;
    retentionMs?: string;
    segmentBytes?: string;
    segmentIndexBytes?: string;
    segmentJitterMs?: string;
    segmentMs?: string;
    uncleanLeaderElectionEnable?: string;
}

export interface GetKafkaTopicTag {
    key: string;
    value?: string;
}

export interface GetM3AggregatorComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetM3AggregatorM3aggregator {
}

export interface GetM3AggregatorM3aggregatorUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    m3Version?: string;
    m3aggregatorVersion?: string;
    staticIps?: string;
}

export interface GetM3AggregatorServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetM3AggregatorTag {
    key: string;
    value: string;
}

export interface GetM3DbComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetM3DbM3db {
}

export interface GetM3DbM3dbUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    limits?: outputs.GetM3DbM3dbUserConfigLimits;
    m3Version?: string;
    m3coordinatorEnableGraphiteCarbonIngest?: string;
    m3dbVersion?: string;
    namespaces?: outputs.GetM3DbM3dbUserConfigNamespace[];
    privateAccess?: outputs.GetM3DbM3dbUserConfigPrivateAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetM3DbM3dbUserConfigPublicAccess;
    rules?: outputs.GetM3DbM3dbUserConfigRules;
    serviceToForkFrom?: string;
    staticIps?: string;
}

export interface GetM3DbM3dbUserConfigLimits {
    queryRequireExhaustive?: string;
    querySeries?: string;
}

export interface GetM3DbM3dbUserConfigNamespace {
    name?: string;
    options?: outputs.GetM3DbM3dbUserConfigNamespaceOptions;
    resolution?: string;
    type?: string;
}

export interface GetM3DbM3dbUserConfigNamespaceOptions {
    retentionOptions?: outputs.GetM3DbM3dbUserConfigNamespaceOptionsRetentionOptions;
    snapshotEnabled?: string;
    writesToCommitlog?: string;
}

export interface GetM3DbM3dbUserConfigNamespaceOptionsRetentionOptions {
    blockDataExpiryDuration?: string;
    blocksizeDuration?: string;
    bufferFutureDuration?: string;
    bufferPastDuration?: string;
    retentionPeriodDuration?: string;
}

export interface GetM3DbM3dbUserConfigPrivateAccess {
    m3coordinator?: string;
}

export interface GetM3DbM3dbUserConfigPublicAccess {
    m3coordinator?: string;
}

export interface GetM3DbM3dbUserConfigRules {
    mappings?: outputs.GetM3DbM3dbUserConfigRulesMapping[];
}

export interface GetM3DbM3dbUserConfigRulesMapping {
    aggregations?: string[];
    drop?: string;
    filter?: string;
    name?: string;
    namespaces?: string[];
    tags?: outputs.GetM3DbM3dbUserConfigRulesMappingTag[];
}

export interface GetM3DbM3dbUserConfigRulesMappingTag {
    name?: string;
    value?: string;
}

export interface GetM3DbServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetM3DbTag {
    key: string;
    value: string;
}

export interface GetMySqlComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetMySqlMysql {
}

export interface GetMySqlMysqlUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    binlogRetentionPeriod?: string;
    ipFilters?: string[];
    migration?: outputs.GetMySqlMysqlUserConfigMigration;
    mysql?: outputs.GetMySqlMysqlUserConfigMysql;
    mysqlVersion?: string;
    privateAccess?: outputs.GetMySqlMysqlUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetMySqlMysqlUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetMySqlMysqlUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    staticIps?: string;
}

export interface GetMySqlMysqlUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface GetMySqlMysqlUserConfigMysql {
    connectTimeout?: string;
    defaultTimeZone?: string;
    groupConcatMaxLen?: string;
    informationSchemaStatsExpiry?: string;
    innodbFtMinTokenSize?: string;
    innodbFtServerStopwordTable?: string;
    innodbLockWaitTimeout?: string;
    innodbLogBufferSize?: string;
    innodbOnlineAlterLogMaxSize?: string;
    innodbPrintAllDeadlocks?: string;
    innodbRollbackOnTimeout?: string;
    interactiveTimeout?: string;
    internalTmpMemStorageEngine?: string;
    longQueryTime?: string;
    maxAllowedPacket?: string;
    maxHeapTableSize?: string;
    netReadTimeout?: string;
    netWriteTimeout?: string;
    slowQueryLog?: string;
    sortBufferSize?: string;
    sqlMode?: string;
    sqlRequirePrimaryKey?: string;
    tmpTableSize?: string;
    waitTimeout?: string;
}

export interface GetMySqlMysqlUserConfigPrivateAccess {
    mysql?: string;
    mysqlx?: string;
    prometheus?: string;
}

export interface GetMySqlMysqlUserConfigPrivatelinkAccess {
    mysql?: string;
    mysqlx?: string;
    prometheus?: string;
}

export interface GetMySqlMysqlUserConfigPublicAccess {
    mysql?: string;
    mysqlx?: string;
    prometheus?: string;
}

export interface GetMySqlServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetMySqlTag {
    key: string;
    value: string;
}

export interface GetOpenSearchComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetOpenSearchOpensearch {
    opensearchDashboardsUri: string;
}

export interface GetOpenSearchOpensearchUserConfig {
    customDomain?: string;
    disableReplicationFactorAdjustment?: string;
    indexPatterns?: outputs.GetOpenSearchOpensearchUserConfigIndexPattern[];
    indexTemplate?: outputs.GetOpenSearchOpensearchUserConfigIndexTemplate;
    ipFilters?: string[];
    keepIndexRefreshInterval?: string;
    maxIndexCount?: string;
    opensearch?: outputs.GetOpenSearchOpensearchUserConfigOpensearch;
    opensearchDashboards?: outputs.GetOpenSearchOpensearchUserConfigOpensearchDashboards;
    opensearchVersion?: string;
    privateAccess?: outputs.GetOpenSearchOpensearchUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetOpenSearchOpensearchUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetOpenSearchOpensearchUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    staticIps?: string;
}

export interface GetOpenSearchOpensearchUserConfigIndexPattern {
    maxIndexCount?: string;
    pattern?: string;
    sortingAlgorithm?: string;
}

export interface GetOpenSearchOpensearchUserConfigIndexTemplate {
    mappingNestedObjectsLimit?: string;
    numberOfReplicas?: string;
    numberOfShards?: string;
}

export interface GetOpenSearchOpensearchUserConfigOpensearch {
    actionAutoCreateIndexEnabled?: string;
    actionDestructiveRequiresName?: string;
    clusterMaxShardsPerNode?: string;
    clusterRoutingAllocationNodeConcurrentRecoveries?: string;
    httpMaxContentLength?: string;
    httpMaxHeaderSize?: string;
    httpMaxInitialLineLength?: string;
    indicesFielddataCacheSize?: string;
    indicesMemoryIndexBufferSize?: string;
    indicesQueriesCacheSize?: string;
    indicesQueryBoolMaxClauseCount?: string;
    indicesRecoveryMaxBytesPerSec?: string;
    indicesRecoveryMaxConcurrentFileChunks?: string;
    overrideMainResponseVersion?: string;
    reindexRemoteWhitelists?: string[];
    scriptMaxCompilationsRate?: string;
    searchMaxBuckets?: string;
    threadPoolAnalyzeQueueSize?: string;
    threadPoolAnalyzeSize?: string;
    threadPoolForceMergeSize?: string;
    threadPoolGetQueueSize?: string;
    threadPoolGetSize?: string;
    threadPoolSearchQueueSize?: string;
    threadPoolSearchSize?: string;
    threadPoolSearchThrottledQueueSize?: string;
    threadPoolSearchThrottledSize?: string;
    threadPoolWriteQueueSize?: string;
    threadPoolWriteSize?: string;
}

export interface GetOpenSearchOpensearchUserConfigOpensearchDashboards {
    enabled?: string;
    maxOldSpaceSize?: string;
    opensearchRequestTimeout?: string;
}

export interface GetOpenSearchOpensearchUserConfigPrivateAccess {
    opensearch?: string;
    opensearchDashboards?: string;
    prometheus?: string;
}

export interface GetOpenSearchOpensearchUserConfigPrivatelinkAccess {
    opensearch?: string;
    opensearchDashboards?: string;
    prometheus?: string;
}

export interface GetOpenSearchOpensearchUserConfigPublicAccess {
    opensearch?: string;
    opensearchDashboards?: string;
    prometheus?: string;
}

export interface GetOpenSearchServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetOpenSearchTag {
    key: string;
    value: string;
}

export interface GetPgComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetPgPg {
    dbname: string;
    host: string;
    password: string;
    port: number;
    replicaUri: string;
    sslmode: string;
    uri: string;
    user: string;
}

export interface GetPgPgUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    enableIpv6?: string;
    ipFilters?: string[];
    migration?: outputs.GetPgPgUserConfigMigration;
    pg?: outputs.GetPgPgUserConfigPg;
    pgReadReplica?: string;
    pgServiceToForkFrom?: string;
    pgVersion?: string;
    pgbouncer?: outputs.GetPgPgUserConfigPgbouncer;
    pglookout?: outputs.GetPgPgUserConfigPglookout;
    privateAccess?: outputs.GetPgPgUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetPgPgUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetPgPgUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    sharedBuffersPercentage?: string;
    staticIps?: string;
    synchronousReplication?: string;
    timescaledb?: outputs.GetPgPgUserConfigTimescaledb;
    variant?: string;
    workMem?: string;
}

export interface GetPgPgUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface GetPgPgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: string;
    autovacuumAnalyzeThreshold?: string;
    autovacuumFreezeMaxAge?: string;
    autovacuumMaxWorkers?: string;
    autovacuumNaptime?: string;
    autovacuumVacuumCostDelay?: string;
    autovacuumVacuumCostLimit?: string;
    autovacuumVacuumScaleFactor?: string;
    autovacuumVacuumThreshold?: string;
    bgwriterDelay?: string;
    bgwriterFlushAfter?: string;
    bgwriterLruMaxpages?: string;
    bgwriterLruMultiplier?: string;
    deadlockTimeout?: string;
    defaultToastCompression?: string;
    idleInTransactionSessionTimeout?: string;
    jit?: string;
    logAutovacuumMinDuration?: string;
    logErrorVerbosity?: string;
    logLinePrefix?: string;
    logMinDurationStatement?: string;
    maxFilesPerProcess?: string;
    maxLocksPerTransaction?: string;
    maxLogicalReplicationWorkers?: string;
    maxParallelWorkers?: string;
    maxParallelWorkersPerGather?: string;
    maxPredLocksPerTransaction?: string;
    maxPreparedTransactions?: string;
    maxReplicationSlots?: string;
    maxSlotWalKeepSize?: string;
    maxStackDepth?: string;
    maxStandbyArchiveDelay?: string;
    maxStandbyStreamingDelay?: string;
    maxWalSenders?: string;
    maxWorkerProcesses?: string;
    pgPartmanBgwDotInterval?: string;
    pgPartmanBgwDotRole?: string;
    pgStatStatementsDotTrack?: string;
    tempFileLimit?: string;
    timezone?: string;
    trackActivityQuerySize?: string;
    trackCommitTimestamp?: string;
    trackFunctions?: string;
    trackIoTiming?: string;
    walSenderTimeout?: string;
    walWriterDelay?: string;
}

export interface GetPgPgUserConfigPgbouncer {
    autodbIdleTimeout?: string;
    autodbMaxDbConnections?: string;
    autodbPoolMode?: string;
    autodbPoolSize?: string;
    ignoreStartupParameters?: string[];
    minPoolSize?: string;
    serverIdleTimeout?: string;
    serverLifetime?: string;
    serverResetQueryAlways?: string;
}

export interface GetPgPgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: string;
}

export interface GetPgPgUserConfigPrivateAccess {
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface GetPgPgUserConfigPrivatelinkAccess {
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface GetPgPgUserConfigPublicAccess {
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface GetPgPgUserConfigTimescaledb {
    maxBackgroundWorkers?: string;
}

export interface GetPgServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetPgTag {
    key: string;
    value: string;
}

export interface GetProjectTag {
    key: string;
    value: string;
}

export interface GetRedisComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetRedisRedi {
}

export interface GetRedisRedisUserConfig {
    ipFilters?: string[];
    migration?: outputs.GetRedisRedisUserConfigMigration;
    privateAccess?: outputs.GetRedisRedisUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetRedisRedisUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetRedisRedisUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    redisAclChannelsDefault?: string;
    redisIoThreads?: string;
    redisLfuDecayTime?: string;
    redisLfuLogFactor?: string;
    redisMaxmemoryPolicy?: string;
    redisNotifyKeyspaceEvents?: string;
    redisNumberOfDatabases?: string;
    redisPersistence?: string;
    redisPubsubClientOutputBufferLimit?: string;
    redisSsl?: string;
    redisTimeout?: string;
    serviceToForkFrom?: string;
    staticIps?: string;
}

export interface GetRedisRedisUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface GetRedisRedisUserConfigPrivateAccess {
    prometheus?: string;
    redis?: string;
}

export interface GetRedisRedisUserConfigPrivatelinkAccess {
    prometheus?: string;
    redis?: string;
}

export interface GetRedisRedisUserConfigPublicAccess {
    prometheus?: string;
    redis?: string;
}

export interface GetRedisServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetRedisTag {
    key: string;
    value: string;
}

export interface GetServiceIntegrationEndpointDatadogUserConfig {
    datadogApiKey?: string;
    datadogTags?: outputs.GetServiceIntegrationEndpointDatadogUserConfigDatadogTag[];
    disableConsumerStats?: string;
    kafkaConsumerCheckInstances?: string;
    kafkaConsumerStatsTimeout?: string;
    maxPartitionContexts?: string;
    site?: string;
}

export interface GetServiceIntegrationEndpointDatadogUserConfigDatadogTag {
    comment?: string;
    tag?: string;
}

export interface GetServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig {
    accessKey?: string;
    logGroupName?: string;
    region?: string;
    secretKey?: string;
}

export interface GetServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig {
    accessKey?: string;
    namespace?: string;
    region?: string;
    secretKey?: string;
}

export interface GetServiceIntegrationEndpointExternalElasticsearchLogsUserConfig {
    ca?: string;
    indexDaysMax?: string;
    indexPrefix?: string;
    timeout?: string;
    url?: string;
}

export interface GetServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig {
    logId?: string;
    projectId?: string;
    serviceAccountCredentials?: string;
}

export interface GetServiceIntegrationEndpointExternalKafkaUserConfig {
    bootstrapServers?: string;
    saslMechanism?: string;
    saslPlainPassword?: string;
    saslPlainUsername?: string;
    securityProtocol?: string;
    sslCaCert?: string;
    sslClientCert?: string;
    sslClientKey?: string;
    sslEndpointIdentificationAlgorithm?: string;
}

export interface GetServiceIntegrationEndpointExternalSchemaRegistryUserConfig {
    authentication?: string;
    basicAuthPassword?: string;
    basicAuthUsername?: string;
    url?: string;
}

export interface GetServiceIntegrationEndpointJolokiaUserConfig {
    basicAuthPassword?: string;
    basicAuthUsername?: string;
}

export interface GetServiceIntegrationEndpointPrometheusUserConfig {
    basicAuthPassword?: string;
    basicAuthUsername?: string;
}

export interface GetServiceIntegrationEndpointRsyslogUserConfig {
    ca?: string;
    cert?: string;
    format?: string;
    key?: string;
    logline?: string;
    port?: string;
    sd?: string;
    server?: string;
    tls?: string;
}

export interface GetServiceIntegrationEndpointSignalfxUserConfig {
    enabledMetrics?: string[];
    signalfxApiKey?: string;
    signalfxRealm?: string;
}

export interface GetServiceIntegrationKafkaConnectUserConfig {
    kafkaConnect?: outputs.GetServiceIntegrationKafkaConnectUserConfigKafkaConnect;
}

export interface GetServiceIntegrationKafkaConnectUserConfigKafkaConnect {
    configStorageTopic?: string;
    groupId?: string;
    offsetStorageTopic?: string;
    statusStorageTopic?: string;
}

export interface GetServiceIntegrationKafkaLogsUserConfig {
    kafkaTopic?: string;
}

export interface GetServiceIntegrationKafkaMirrormakerUserConfig {
    clusterAlias?: string;
    kafkaMirrormaker?: outputs.GetServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker;
}

export interface GetServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker {
    consumerFetchMinBytes?: string;
    producerBatchSize?: string;
    producerBufferMemory?: string;
    producerLingerMs?: string;
    producerMaxRequestSize?: string;
}

export interface GetServiceIntegrationLogsUserConfig {
    elasticsearchIndexDaysMax?: string;
    elasticsearchIndexPrefix?: string;
}

export interface GetServiceIntegrationMetricsUserConfig {
    database?: string;
    retentionDays?: string;
    roUsername?: string;
    sourceMysql?: outputs.GetServiceIntegrationMetricsUserConfigSourceMysql;
    username?: string;
}

export interface GetServiceIntegrationMetricsUserConfigSourceMysql {
    telegraf?: outputs.GetServiceIntegrationMetricsUserConfigSourceMysqlTelegraf;
}

export interface GetServiceIntegrationMetricsUserConfigSourceMysqlTelegraf {
    gatherEventWaits?: string;
    gatherFileEventsStats?: string;
    gatherIndexIoWaits?: string;
    gatherInfoSchemaAutoInc?: string;
    gatherInnodbMetrics?: string;
    gatherPerfEventsStatements?: string;
    gatherProcessList?: string;
    gatherSlaveStatus?: string;
    gatherTableIoWaits?: string;
    gatherTableLockWaits?: string;
    gatherTableSchema?: string;
    perfEventsStatementsDigestTextLimit?: string;
    perfEventsStatementsLimit?: string;
    perfEventsStatementsTimeLimit?: string;
}

export interface GetServiceIntegrationMirrormakerUserConfig {
    mirrormakerWhitelist?: string;
}

export interface GrafanaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GrafanaGrafana {
}

export interface GrafanaGrafanaUserConfig {
    alertingEnabled?: string;
    alertingErrorOrTimeout?: string;
    alertingMaxAnnotationsToKeep?: string;
    alertingNodataOrNullvalues?: string;
    allowEmbedding?: string;
    authAzuread?: outputs.GrafanaGrafanaUserConfigAuthAzuread;
    authBasicEnabled?: string;
    authGenericOauth?: outputs.GrafanaGrafanaUserConfigAuthGenericOauth;
    authGithub?: outputs.GrafanaGrafanaUserConfigAuthGithub;
    authGitlab?: outputs.GrafanaGrafanaUserConfigAuthGitlab;
    authGoogle?: outputs.GrafanaGrafanaUserConfigAuthGoogle;
    cookieSamesite?: string;
    customDomain?: string;
    dashboardsMinRefreshInterval?: string;
    dashboardsVersionsToKeep?: string;
    dataproxySendUserHeader?: string;
    dataproxyTimeout?: string;
    dateFormats?: outputs.GrafanaGrafanaUserConfigDateFormats;
    disableGravatar?: string;
    editorsCanAdmin?: string;
    externalImageStorage?: outputs.GrafanaGrafanaUserConfigExternalImageStorage;
    googleAnalyticsUaId?: string;
    ipFilters?: string[];
    metricsEnabled?: string;
    privateAccess?: outputs.GrafanaGrafanaUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GrafanaGrafanaUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GrafanaGrafanaUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    smtpServer?: outputs.GrafanaGrafanaUserConfigSmtpServer;
    staticIps?: string;
    userAutoAssignOrg?: string;
    userAutoAssignOrgRole?: string;
    viewersCanEdit?: string;
}

export interface GrafanaGrafanaUserConfigAuthAzuread {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedGroups?: string[];
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface GrafanaGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedOrganizations?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    name?: string;
    scopes?: string[];
    tokenUrl?: string;
}

export interface GrafanaGrafanaUserConfigAuthGithub {
    allowSignUp?: string;
    allowedOrganizations?: string[];
    clientId?: string;
    clientSecret?: string;
    teamIds?: string[];
}

export interface GrafanaGrafanaUserConfigAuthGitlab {
    allowSignUp?: string;
    allowedGroups?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface GrafanaGrafanaUserConfigAuthGoogle {
    allowSignUp?: string;
    allowedDomains?: string[];
    clientId?: string;
    clientSecret?: string;
}

export interface GrafanaGrafanaUserConfigDateFormats {
    defaultTimezone?: string;
    fullDate?: string;
    intervalDay?: string;
    intervalHour?: string;
    intervalMinute?: string;
    intervalMonth?: string;
    intervalSecond?: string;
    intervalYear?: string;
}

export interface GrafanaGrafanaUserConfigExternalImageStorage {
    accessKey?: string;
    bucketUrl?: string;
    provider?: string;
    secretKey?: string;
}

export interface GrafanaGrafanaUserConfigPrivateAccess {
    grafana?: string;
}

export interface GrafanaGrafanaUserConfigPrivatelinkAccess {
    grafana?: string;
}

export interface GrafanaGrafanaUserConfigPublicAccess {
    grafana?: string;
}

export interface GrafanaGrafanaUserConfigSmtpServer {
    fromAddress?: string;
    fromName?: string;
    host?: string;
    password?: string;
    port?: string;
    skipVerify?: string;
    starttlsPolicy?: string;
    username?: string;
}

export interface GrafanaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GrafanaTag {
    key: string;
    value: string;
}

export interface InfluxDbComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface InfluxDbInfluxdb {
    databaseName: string;
}

export interface InfluxDbInfluxdbUserConfig {
    customDomain?: string;
    influxdb?: outputs.InfluxDbInfluxdbUserConfigInfluxdb;
    ipFilters?: string[];
    privateAccess?: outputs.InfluxDbInfluxdbUserConfigPrivateAccess;
    privatelinkAccess?: outputs.InfluxDbInfluxdbUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.InfluxDbInfluxdbUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    staticIps?: string;
}

export interface InfluxDbInfluxdbUserConfigInfluxdb {
    logQueriesAfter?: string;
    maxConnectionLimit?: string;
    maxRowLimit?: string;
    maxSelectBuckets?: string;
    maxSelectPoint?: string;
    queryTimeout?: string;
}

export interface InfluxDbInfluxdbUserConfigPrivateAccess {
    influxdb?: string;
}

export interface InfluxDbInfluxdbUserConfigPrivatelinkAccess {
    influxdb?: string;
}

export interface InfluxDbInfluxdbUserConfigPublicAccess {
    influxdb?: string;
}

export interface InfluxDbServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface InfluxDbTag {
    key: string;
    value: string;
}

export interface KafkaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface KafkaConnectComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface KafkaConnectKafkaConnect {
}

export interface KafkaConnectKafkaConnectUserConfig {
    ipFilters?: string[];
    kafkaConnect?: outputs.KafkaConnectKafkaConnectUserConfigKafkaConnect;
    privateAccess?: outputs.KafkaConnectKafkaConnectUserConfigPrivateAccess;
    privatelinkAccess?: outputs.KafkaConnectKafkaConnectUserConfigPrivatelinkAccess;
    publicAccess?: outputs.KafkaConnectKafkaConnectUserConfigPublicAccess;
    staticIps?: string;
}

export interface KafkaConnectKafkaConnectUserConfigKafkaConnect {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerFetchMaxBytes?: string;
    consumerIsolationLevel?: string;
    consumerMaxPartitionFetchBytes?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    producerCompressionType?: string;
    producerMaxRequestSize?: string;
    sessionTimeoutMs?: string;
}

export interface KafkaConnectKafkaConnectUserConfigPrivateAccess {
    kafkaConnect?: string;
    prometheus?: string;
}

export interface KafkaConnectKafkaConnectUserConfigPrivatelinkAccess {
    jolokia?: string;
    kafkaConnect?: string;
    prometheus?: string;
}

export interface KafkaConnectKafkaConnectUserConfigPublicAccess {
    kafkaConnect?: string;
    prometheus?: string;
}

export interface KafkaConnectServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface KafkaConnectTag {
    key: string;
    value: string;
}

export interface KafkaConnectorTask {
    connector: string;
    task: number;
}

export interface KafkaKafka {
    accessCert: string;
    accessKey: string;
    connectUri: string;
    restUri: string;
    schemaRegistryUri: string;
}

export interface KafkaKafkaUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    kafka?: outputs.KafkaKafkaUserConfigKafka;
    kafkaAuthenticationMethods?: outputs.KafkaKafkaUserConfigKafkaAuthenticationMethods;
    kafkaConnect?: string;
    kafkaConnectConfig?: outputs.KafkaKafkaUserConfigKafkaConnectConfig;
    kafkaRest?: string;
    kafkaRestConfig?: outputs.KafkaKafkaUserConfigKafkaRestConfig;
    kafkaVersion?: string;
    privateAccess?: outputs.KafkaKafkaUserConfigPrivateAccess;
    privatelinkAccess?: outputs.KafkaKafkaUserConfigPrivatelinkAccess;
    publicAccess?: outputs.KafkaKafkaUserConfigPublicAccess;
    schemaRegistry?: string;
    schemaRegistryConfig?: outputs.KafkaKafkaUserConfigSchemaRegistryConfig;
    staticIps?: string;
}

export interface KafkaKafkaUserConfigKafka {
    autoCreateTopicsEnable?: string;
    compressionType?: string;
    connectionsMaxIdleMs?: string;
    defaultReplicationFactor?: string;
    groupInitialRebalanceDelayMs?: string;
    groupMaxSessionTimeoutMs?: string;
    groupMinSessionTimeoutMs?: string;
    logCleanerDeleteRetentionMs?: string;
    logCleanerMaxCompactionLagMs?: string;
    logCleanerMinCleanableRatio?: string;
    logCleanerMinCompactionLagMs?: string;
    logCleanupPolicy?: string;
    logFlushIntervalMessages?: string;
    logFlushIntervalMs?: string;
    logIndexIntervalBytes?: string;
    logIndexSizeMaxBytes?: string;
    logMessageDownconversionEnable?: string;
    logMessageTimestampDifferenceMaxMs?: string;
    logMessageTimestampType?: string;
    logPreallocate?: string;
    logRetentionBytes?: string;
    logRetentionHours?: string;
    logRetentionMs?: string;
    logRollJitterMs?: string;
    logRollMs?: string;
    logSegmentBytes?: string;
    logSegmentDeleteDelayMs?: string;
    maxConnectionsPerIp?: string;
    maxIncrementalFetchSessionCacheSlots?: string;
    messageMaxBytes?: string;
    minInsyncReplicas?: string;
    numPartitions?: string;
    offsetsRetentionMinutes?: string;
    producerPurgatoryPurgeIntervalRequests?: string;
    replicaFetchMaxBytes?: string;
    replicaFetchResponseMaxBytes?: string;
    socketRequestMaxBytes?: string;
    transactionRemoveExpiredTransactionCleanupIntervalMs?: string;
    transactionStateLogSegmentBytes?: string;
}

export interface KafkaKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: string;
    sasl?: string;
}

export interface KafkaKafkaUserConfigKafkaConnectConfig {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerFetchMaxBytes?: string;
    consumerIsolationLevel?: string;
    consumerMaxPartitionFetchBytes?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    producerCompressionType?: string;
    producerMaxRequestSize?: string;
    sessionTimeoutMs?: string;
}

export interface KafkaKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: string;
    consumerRequestMaxBytes?: string;
    consumerRequestTimeoutMs?: string;
    producerAcks?: string;
    producerLingerMs?: string;
    simpleconsumerPoolSizeMax?: string;
}

export interface KafkaKafkaUserConfigPrivateAccess {
    prometheus?: string;
}

export interface KafkaKafkaUserConfigPrivatelinkAccess {
    jolokia?: string;
    kafka?: string;
    kafkaConnect?: string;
    kafkaRest?: string;
    prometheus?: string;
    schemaRegistry?: string;
}

export interface KafkaKafkaUserConfigPublicAccess {
    kafka?: string;
    kafkaConnect?: string;
    kafkaRest?: string;
    prometheus?: string;
    schemaRegistry?: string;
}

export interface KafkaKafkaUserConfigSchemaRegistryConfig {
    leaderEligibility?: string;
    topicName?: string;
}

export interface KafkaMirrorMakerComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface KafkaMirrorMakerKafkaMirrormaker {
}

export interface KafkaMirrorMakerKafkaMirrormakerUserConfig {
    ipFilters?: string[];
    kafkaMirrormaker?: outputs.KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker;
    staticIps?: string;
}

export interface KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker {
    emitCheckpointsEnabled?: string;
    emitCheckpointsIntervalSeconds?: string;
    refreshGroupsEnabled?: string;
    refreshGroupsIntervalSeconds?: string;
    refreshTopicsEnabled?: string;
    refreshTopicsIntervalSeconds?: string;
    syncGroupOffsetsEnabled?: string;
    syncGroupOffsetsIntervalSeconds?: string;
    syncTopicConfigsEnabled?: string;
    tasksMaxPerCpu?: string;
}

export interface KafkaMirrorMakerServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface KafkaMirrorMakerTag {
    key: string;
    value: string;
}

export interface KafkaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface KafkaTag {
    key: string;
    value: string;
}

export interface KafkaTopicConfig {
    cleanupPolicy?: string;
    compressionType?: string;
    deleteRetentionMs?: string;
    fileDeleteDelayMs?: string;
    flushMessages?: string;
    flushMs?: string;
    indexIntervalBytes?: string;
    maxCompactionLagMs?: string;
    maxMessageBytes?: string;
    messageDownconversionEnable?: string;
    messageFormatVersion?: string;
    messageTimestampDifferenceMaxMs?: string;
    messageTimestampType?: string;
    minCleanableDirtyRatio?: string;
    minCompactionLagMs?: string;
    minInsyncReplicas?: string;
    preallocate?: string;
    retentionBytes?: string;
    retentionMs?: string;
    segmentBytes?: string;
    segmentIndexBytes?: string;
    segmentJitterMs?: string;
    segmentMs?: string;
    uncleanLeaderElectionEnable?: string;
}

export interface KafkaTopicTag {
    key: string;
    value?: string;
}

export interface M3AggregatorComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface M3AggregatorM3aggregator {
}

export interface M3AggregatorM3aggregatorUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    m3Version?: string;
    m3aggregatorVersion?: string;
    staticIps?: string;
}

export interface M3AggregatorServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface M3AggregatorTag {
    key: string;
    value: string;
}

export interface M3DbComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface M3DbM3db {
}

export interface M3DbM3dbUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    limits?: outputs.M3DbM3dbUserConfigLimits;
    m3Version?: string;
    m3coordinatorEnableGraphiteCarbonIngest?: string;
    m3dbVersion?: string;
    namespaces?: outputs.M3DbM3dbUserConfigNamespace[];
    privateAccess?: outputs.M3DbM3dbUserConfigPrivateAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.M3DbM3dbUserConfigPublicAccess;
    rules?: outputs.M3DbM3dbUserConfigRules;
    serviceToForkFrom?: string;
    staticIps?: string;
}

export interface M3DbM3dbUserConfigLimits {
    queryRequireExhaustive?: string;
    querySeries?: string;
}

export interface M3DbM3dbUserConfigNamespace {
    name?: string;
    options?: outputs.M3DbM3dbUserConfigNamespaceOptions;
    resolution?: string;
    type?: string;
}

export interface M3DbM3dbUserConfigNamespaceOptions {
    retentionOptions?: outputs.M3DbM3dbUserConfigNamespaceOptionsRetentionOptions;
    snapshotEnabled?: string;
    writesToCommitlog?: string;
}

export interface M3DbM3dbUserConfigNamespaceOptionsRetentionOptions {
    blockDataExpiryDuration?: string;
    blocksizeDuration?: string;
    bufferFutureDuration?: string;
    bufferPastDuration?: string;
    retentionPeriodDuration?: string;
}

export interface M3DbM3dbUserConfigPrivateAccess {
    m3coordinator?: string;
}

export interface M3DbM3dbUserConfigPublicAccess {
    m3coordinator?: string;
}

export interface M3DbM3dbUserConfigRules {
    mappings?: outputs.M3DbM3dbUserConfigRulesMapping[];
}

export interface M3DbM3dbUserConfigRulesMapping {
    aggregations?: string[];
    drop?: string;
    filter?: string;
    name?: string;
    namespaces?: string[];
    tags?: outputs.M3DbM3dbUserConfigRulesMappingTag[];
}

export interface M3DbM3dbUserConfigRulesMappingTag {
    name?: string;
    value?: string;
}

export interface M3DbServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface M3DbTag {
    key: string;
    value: string;
}

export interface MySqlComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface MySqlMysql {
}

export interface MySqlMysqlUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    binlogRetentionPeriod?: string;
    ipFilters?: string[];
    migration?: outputs.MySqlMysqlUserConfigMigration;
    mysql?: outputs.MySqlMysqlUserConfigMysql;
    mysqlVersion?: string;
    privateAccess?: outputs.MySqlMysqlUserConfigPrivateAccess;
    privatelinkAccess?: outputs.MySqlMysqlUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.MySqlMysqlUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    staticIps?: string;
}

export interface MySqlMysqlUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface MySqlMysqlUserConfigMysql {
    connectTimeout?: string;
    defaultTimeZone?: string;
    groupConcatMaxLen?: string;
    informationSchemaStatsExpiry?: string;
    innodbFtMinTokenSize?: string;
    innodbFtServerStopwordTable?: string;
    innodbLockWaitTimeout?: string;
    innodbLogBufferSize?: string;
    innodbOnlineAlterLogMaxSize?: string;
    innodbPrintAllDeadlocks?: string;
    innodbRollbackOnTimeout?: string;
    interactiveTimeout?: string;
    internalTmpMemStorageEngine?: string;
    longQueryTime?: string;
    maxAllowedPacket?: string;
    maxHeapTableSize?: string;
    netReadTimeout?: string;
    netWriteTimeout?: string;
    slowQueryLog?: string;
    sortBufferSize?: string;
    sqlMode?: string;
    sqlRequirePrimaryKey?: string;
    tmpTableSize?: string;
    waitTimeout?: string;
}

export interface MySqlMysqlUserConfigPrivateAccess {
    mysql?: string;
    mysqlx?: string;
    prometheus?: string;
}

export interface MySqlMysqlUserConfigPrivatelinkAccess {
    mysql?: string;
    mysqlx?: string;
    prometheus?: string;
}

export interface MySqlMysqlUserConfigPublicAccess {
    mysql?: string;
    mysqlx?: string;
    prometheus?: string;
}

export interface MySqlServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface MySqlTag {
    key: string;
    value: string;
}

export interface OpenSearchComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface OpenSearchOpensearch {
    opensearchDashboardsUri: string;
}

export interface OpenSearchOpensearchUserConfig {
    customDomain?: string;
    disableReplicationFactorAdjustment?: string;
    indexPatterns?: outputs.OpenSearchOpensearchUserConfigIndexPattern[];
    indexTemplate?: outputs.OpenSearchOpensearchUserConfigIndexTemplate;
    ipFilters?: string[];
    keepIndexRefreshInterval?: string;
    maxIndexCount?: string;
    opensearch?: outputs.OpenSearchOpensearchUserConfigOpensearch;
    opensearchDashboards?: outputs.OpenSearchOpensearchUserConfigOpensearchDashboards;
    opensearchVersion?: string;
    privateAccess?: outputs.OpenSearchOpensearchUserConfigPrivateAccess;
    privatelinkAccess?: outputs.OpenSearchOpensearchUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.OpenSearchOpensearchUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    staticIps?: string;
}

export interface OpenSearchOpensearchUserConfigIndexPattern {
    maxIndexCount?: string;
    pattern?: string;
    sortingAlgorithm?: string;
}

export interface OpenSearchOpensearchUserConfigIndexTemplate {
    mappingNestedObjectsLimit?: string;
    numberOfReplicas?: string;
    numberOfShards?: string;
}

export interface OpenSearchOpensearchUserConfigOpensearch {
    actionAutoCreateIndexEnabled?: string;
    actionDestructiveRequiresName?: string;
    clusterMaxShardsPerNode?: string;
    clusterRoutingAllocationNodeConcurrentRecoveries?: string;
    httpMaxContentLength?: string;
    httpMaxHeaderSize?: string;
    httpMaxInitialLineLength?: string;
    indicesFielddataCacheSize?: string;
    indicesMemoryIndexBufferSize?: string;
    indicesQueriesCacheSize?: string;
    indicesQueryBoolMaxClauseCount?: string;
    indicesRecoveryMaxBytesPerSec?: string;
    indicesRecoveryMaxConcurrentFileChunks?: string;
    overrideMainResponseVersion?: string;
    reindexRemoteWhitelists?: string[];
    scriptMaxCompilationsRate?: string;
    searchMaxBuckets?: string;
    threadPoolAnalyzeQueueSize?: string;
    threadPoolAnalyzeSize?: string;
    threadPoolForceMergeSize?: string;
    threadPoolGetQueueSize?: string;
    threadPoolGetSize?: string;
    threadPoolSearchQueueSize?: string;
    threadPoolSearchSize?: string;
    threadPoolSearchThrottledQueueSize?: string;
    threadPoolSearchThrottledSize?: string;
    threadPoolWriteQueueSize?: string;
    threadPoolWriteSize?: string;
}

export interface OpenSearchOpensearchUserConfigOpensearchDashboards {
    enabled?: string;
    maxOldSpaceSize?: string;
    opensearchRequestTimeout?: string;
}

export interface OpenSearchOpensearchUserConfigPrivateAccess {
    opensearch?: string;
    opensearchDashboards?: string;
    prometheus?: string;
}

export interface OpenSearchOpensearchUserConfigPrivatelinkAccess {
    opensearch?: string;
    opensearchDashboards?: string;
    prometheus?: string;
}

export interface OpenSearchOpensearchUserConfigPublicAccess {
    opensearch?: string;
    opensearchDashboards?: string;
    prometheus?: string;
}

export interface OpenSearchServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface OpenSearchTag {
    key: string;
    value: string;
}

export interface PgComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface PgPg {
    dbname: string;
    host: string;
    password: string;
    port: number;
    replicaUri: string;
    sslmode: string;
    uri: string;
    user: string;
}

export interface PgPgUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    enableIpv6?: string;
    ipFilters?: string[];
    migration?: outputs.PgPgUserConfigMigration;
    pg?: outputs.PgPgUserConfigPg;
    pgReadReplica?: string;
    pgServiceToForkFrom?: string;
    pgVersion?: string;
    pgbouncer?: outputs.PgPgUserConfigPgbouncer;
    pglookout?: outputs.PgPgUserConfigPglookout;
    privateAccess?: outputs.PgPgUserConfigPrivateAccess;
    privatelinkAccess?: outputs.PgPgUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.PgPgUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    sharedBuffersPercentage?: string;
    staticIps?: string;
    synchronousReplication?: string;
    timescaledb?: outputs.PgPgUserConfigTimescaledb;
    variant?: string;
    workMem?: string;
}

export interface PgPgUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface PgPgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: string;
    autovacuumAnalyzeThreshold?: string;
    autovacuumFreezeMaxAge?: string;
    autovacuumMaxWorkers?: string;
    autovacuumNaptime?: string;
    autovacuumVacuumCostDelay?: string;
    autovacuumVacuumCostLimit?: string;
    autovacuumVacuumScaleFactor?: string;
    autovacuumVacuumThreshold?: string;
    bgwriterDelay?: string;
    bgwriterFlushAfter?: string;
    bgwriterLruMaxpages?: string;
    bgwriterLruMultiplier?: string;
    deadlockTimeout?: string;
    defaultToastCompression?: string;
    idleInTransactionSessionTimeout?: string;
    jit?: string;
    logAutovacuumMinDuration?: string;
    logErrorVerbosity?: string;
    logLinePrefix?: string;
    logMinDurationStatement?: string;
    maxFilesPerProcess?: string;
    maxLocksPerTransaction?: string;
    maxLogicalReplicationWorkers?: string;
    maxParallelWorkers?: string;
    maxParallelWorkersPerGather?: string;
    maxPredLocksPerTransaction?: string;
    maxPreparedTransactions?: string;
    maxReplicationSlots?: string;
    maxSlotWalKeepSize?: string;
    maxStackDepth?: string;
    maxStandbyArchiveDelay?: string;
    maxStandbyStreamingDelay?: string;
    maxWalSenders?: string;
    maxWorkerProcesses?: string;
    pgPartmanBgwDotInterval?: string;
    pgPartmanBgwDotRole?: string;
    pgStatStatementsDotTrack?: string;
    tempFileLimit?: string;
    timezone?: string;
    trackActivityQuerySize?: string;
    trackCommitTimestamp?: string;
    trackFunctions?: string;
    trackIoTiming?: string;
    walSenderTimeout?: string;
    walWriterDelay?: string;
}

export interface PgPgUserConfigPgbouncer {
    autodbIdleTimeout?: string;
    autodbMaxDbConnections?: string;
    autodbPoolMode?: string;
    autodbPoolSize?: string;
    ignoreStartupParameters?: string[];
    minPoolSize?: string;
    serverIdleTimeout?: string;
    serverLifetime?: string;
    serverResetQueryAlways?: string;
}

export interface PgPgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: string;
}

export interface PgPgUserConfigPrivateAccess {
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface PgPgUserConfigPrivatelinkAccess {
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface PgPgUserConfigPublicAccess {
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface PgPgUserConfigTimescaledb {
    maxBackgroundWorkers?: string;
}

export interface PgServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface PgTag {
    key: string;
    value: string;
}

export interface ProjectTag {
    key: string;
    value: string;
}

export interface RedisComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface RedisRedi {
}

export interface RedisRedisUserConfig {
    ipFilters?: string[];
    migration?: outputs.RedisRedisUserConfigMigration;
    privateAccess?: outputs.RedisRedisUserConfigPrivateAccess;
    privatelinkAccess?: outputs.RedisRedisUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.RedisRedisUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    redisAclChannelsDefault?: string;
    redisIoThreads?: string;
    redisLfuDecayTime?: string;
    redisLfuLogFactor?: string;
    redisMaxmemoryPolicy?: string;
    redisNotifyKeyspaceEvents?: string;
    redisNumberOfDatabases?: string;
    redisPersistence?: string;
    redisPubsubClientOutputBufferLimit?: string;
    redisSsl?: string;
    redisTimeout?: string;
    serviceToForkFrom?: string;
    staticIps?: string;
}

export interface RedisRedisUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface RedisRedisUserConfigPrivateAccess {
    prometheus?: string;
    redis?: string;
}

export interface RedisRedisUserConfigPrivatelinkAccess {
    prometheus?: string;
    redis?: string;
}

export interface RedisRedisUserConfigPublicAccess {
    prometheus?: string;
    redis?: string;
}

export interface RedisServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface RedisTag {
    key: string;
    value: string;
}

export interface ServiceIntegrationEndpointDatadogUserConfig {
    datadogApiKey?: string;
    datadogTags?: outputs.ServiceIntegrationEndpointDatadogUserConfigDatadogTag[];
    disableConsumerStats?: string;
    kafkaConsumerCheckInstances?: string;
    kafkaConsumerStatsTimeout?: string;
    maxPartitionContexts?: string;
    site?: string;
}

export interface ServiceIntegrationEndpointDatadogUserConfigDatadogTag {
    comment?: string;
    tag?: string;
}

export interface ServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig {
    accessKey?: string;
    logGroupName?: string;
    region?: string;
    secretKey?: string;
}

export interface ServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig {
    accessKey?: string;
    namespace?: string;
    region?: string;
    secretKey?: string;
}

export interface ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig {
    ca?: string;
    indexDaysMax?: string;
    indexPrefix?: string;
    timeout?: string;
    url?: string;
}

export interface ServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig {
    logId?: string;
    projectId?: string;
    serviceAccountCredentials?: string;
}

export interface ServiceIntegrationEndpointExternalKafkaUserConfig {
    bootstrapServers?: string;
    saslMechanism?: string;
    saslPlainPassword?: string;
    saslPlainUsername?: string;
    securityProtocol?: string;
    sslCaCert?: string;
    sslClientCert?: string;
    sslClientKey?: string;
    sslEndpointIdentificationAlgorithm?: string;
}

export interface ServiceIntegrationEndpointExternalSchemaRegistryUserConfig {
    authentication?: string;
    basicAuthPassword?: string;
    basicAuthUsername?: string;
    url?: string;
}

export interface ServiceIntegrationEndpointJolokiaUserConfig {
    basicAuthPassword?: string;
    basicAuthUsername?: string;
}

export interface ServiceIntegrationEndpointPrometheusUserConfig {
    basicAuthPassword?: string;
    basicAuthUsername?: string;
}

export interface ServiceIntegrationEndpointRsyslogUserConfig {
    ca?: string;
    cert?: string;
    format?: string;
    key?: string;
    logline?: string;
    port?: string;
    sd?: string;
    server?: string;
    tls?: string;
}

export interface ServiceIntegrationEndpointSignalfxUserConfig {
    enabledMetrics?: string[];
    signalfxApiKey?: string;
    signalfxRealm?: string;
}

export interface ServiceIntegrationKafkaConnectUserConfig {
    kafkaConnect?: outputs.ServiceIntegrationKafkaConnectUserConfigKafkaConnect;
}

export interface ServiceIntegrationKafkaConnectUserConfigKafkaConnect {
    configStorageTopic?: string;
    groupId?: string;
    offsetStorageTopic?: string;
    statusStorageTopic?: string;
}

export interface ServiceIntegrationKafkaLogsUserConfig {
    kafkaTopic?: string;
}

export interface ServiceIntegrationKafkaMirrormakerUserConfig {
    clusterAlias?: string;
    kafkaMirrormaker?: outputs.ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker;
}

export interface ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker {
    consumerFetchMinBytes?: string;
    producerBatchSize?: string;
    producerBufferMemory?: string;
    producerLingerMs?: string;
    producerMaxRequestSize?: string;
}

export interface ServiceIntegrationLogsUserConfig {
    elasticsearchIndexDaysMax?: string;
    elasticsearchIndexPrefix?: string;
}

export interface ServiceIntegrationMetricsUserConfig {
    database?: string;
    retentionDays?: string;
    roUsername?: string;
    sourceMysql?: outputs.ServiceIntegrationMetricsUserConfigSourceMysql;
    username?: string;
}

export interface ServiceIntegrationMetricsUserConfigSourceMysql {
    telegraf?: outputs.ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf;
}

export interface ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf {
    gatherEventWaits?: string;
    gatherFileEventsStats?: string;
    gatherIndexIoWaits?: string;
    gatherInfoSchemaAutoInc?: string;
    gatherInnodbMetrics?: string;
    gatherPerfEventsStatements?: string;
    gatherProcessList?: string;
    gatherSlaveStatus?: string;
    gatherTableIoWaits?: string;
    gatherTableLockWaits?: string;
    gatherTableSchema?: string;
    perfEventsStatementsDigestTextLimit?: string;
    perfEventsStatementsLimit?: string;
    perfEventsStatementsTimeLimit?: string;
}

export interface ServiceIntegrationMirrormakerUserConfig {
    mirrormakerWhitelist?: string;
}

