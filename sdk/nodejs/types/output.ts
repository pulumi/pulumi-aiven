// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface CassandraCassandra {
}

export interface CassandraCassandraUserConfig {
    /**
     * cassandra configuration values
     */
    cassandra?: outputs.CassandraCassandraUserConfigCassandra;
    /**
     * Cassandra major version
     */
    cassandraVersion?: string;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Migration mode for the sstableloader utility
     */
    migrateSstableloader?: string;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.CassandraCassandraUserConfigPrivateAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.CassandraCassandraUserConfigPublicAccess;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface CassandraCassandraUserConfigCassandra {
    batchSizeFailThresholdInKb?: string;
    batchSizeWarnThresholdInKb?: string;
}

export interface CassandraCassandraUserConfigPrivateAccess {
    prometheus?: string;
}

export interface CassandraCassandraUserConfigPublicAccess {
    prometheus?: string;
}

export interface CassandraComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface CassandraServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface ClickhouseClickhouse {
}

export interface ClickhouseClickhouseUserConfig {
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
}

export interface ClickhouseComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface ClickhouseGrantPrivilegeGrant {
    /**
     * The column that the grant refers to. This property cannot be changed, doing so forces recreation of the resource.
     */
    column?: string;
    /**
     * The database that the grant refers to. To set up proper dependencies please refer to this variable as a reference. This property cannot be changed, doing so forces recreation of the resource.
     */
    database: string;
    /**
     * The privilege to grant, i.e. 'INSERT', 'SELECT', etc. This property cannot be changed, doing so forces recreation of the resource.
     */
    privilege?: string;
    /**
     * The table that the grant refers to. This property cannot be changed, doing so forces recreation of the resource.
     */
    table?: string;
    /**
     * If true then the grantee gets the ability to grant the privileges he received too This property cannot be changed, doing so forces recreation of the resource.
     */
    withGrant?: boolean;
}

export interface ClickhouseGrantRoleGrant {
    /**
     * The role that is to be granted. To set up proper dependencies please refer to this variable as a reference. This property cannot be changed, doing so forces recreation of the resource.
     */
    role?: string;
}

export interface ClickhouseServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface ElasticSearchAclAcl {
    /**
     * Elasticsearch rules.
     */
    rules: outputs.ElasticSearchAclAclRule[];
    /**
     * Username for the ACL entry. Maximum Length: `40`.
     */
    username: string;
}

export interface ElasticSearchAclAclRule {
    index: string;
    permission: string;
}

export interface ElasticSearchComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface ElasticSearchElasticsearch {
    kibanaUri: string;
}

export interface ElasticSearchElasticsearchUserConfig {
    /**
     * Custom domain
     */
    customDomain?: string;
    /**
     * Disable replication factor adjustment
     */
    disableReplicationFactorAdjustment?: string;
    /**
     * Elasticsearch settings
     */
    elasticsearch?: outputs.ElasticSearchElasticsearchUserConfigElasticsearch;
    /**
     * Elasticsearch major version
     */
    elasticsearchVersion?: string;
    /**
     * Index patterns
     */
    indexPatterns?: outputs.ElasticSearchElasticsearchUserConfigIndexPattern[];
    /**
     * Template settings for all new indexes
     */
    indexTemplate?: outputs.ElasticSearchElasticsearchUserConfigIndexTemplate;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Don't reset index.refresh_interval to the default value
     */
    keepIndexRefreshInterval?: string;
    /**
     * Kibana settings
     */
    kibana?: outputs.ElasticSearchElasticsearchUserConfigKibana;
    /**
     * Maximum index count
     */
    maxIndexCount?: string;
    /**
     * OpenSearch major version
     */
    opensearchVersion?: string;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.ElasticSearchElasticsearchUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.ElasticSearchElasticsearchUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.ElasticSearchElasticsearchUserConfigPublicAccess;
    /**
     * Name of the basebackup to restore in forked service
     */
    recoveryBasebackupName?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface ElasticSearchElasticsearchUserConfigElasticsearch {
    actionAutoCreateIndexEnabled?: string;
    actionDestructiveRequiresName?: string;
    clusterMaxShardsPerNode?: string;
    httpMaxContentLength?: string;
    httpMaxHeaderSize?: string;
    httpMaxInitialLineLength?: string;
    indicesFielddataCacheSize?: string;
    indicesMemoryIndexBufferSize?: string;
    indicesQueriesCacheSize?: string;
    indicesQueryBoolMaxClauseCount?: string;
    overrideMainResponseVersion?: string;
    reindexRemoteWhitelists?: string[];
    searchMaxBuckets?: string;
    threadPoolAnalyzeQueueSize?: string;
    threadPoolAnalyzeSize?: string;
    threadPoolForceMergeSize?: string;
    threadPoolGetQueueSize?: string;
    threadPoolGetSize?: string;
    threadPoolIndexQueueSize?: string;
    threadPoolIndexSize?: string;
    threadPoolSearchQueueSize?: string;
    threadPoolSearchSize?: string;
    threadPoolSearchThrottledQueueSize?: string;
    threadPoolSearchThrottledSize?: string;
    threadPoolWriteQueueSize?: string;
    threadPoolWriteSize?: string;
}

export interface ElasticSearchElasticsearchUserConfigIndexPattern {
    maxIndexCount?: string;
    pattern?: string;
    sortingAlgorithm?: string;
}

export interface ElasticSearchElasticsearchUserConfigIndexTemplate {
    mappingNestedObjectsLimit?: string;
    numberOfReplicas?: string;
    numberOfShards?: string;
}

export interface ElasticSearchElasticsearchUserConfigKibana {
    elasticsearchRequestTimeout?: string;
    enabled?: string;
    maxOldSpaceSize?: string;
}

export interface ElasticSearchElasticsearchUserConfigPrivateAccess {
    /**
     * Elasticsearch server provided values
     */
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface ElasticSearchElasticsearchUserConfigPrivatelinkAccess {
    /**
     * Elasticsearch server provided values
     */
    elasticsearch?: string;
    kibana?: string;
}

export interface ElasticSearchElasticsearchUserConfigPublicAccess {
    /**
     * Elasticsearch server provided values
     */
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface ElasticSearchServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface FlinkComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface FlinkFlink {
    /**
     * Host and Port of a Flink server
     */
    hostPorts: string[];
}

export interface FlinkFlinkUserConfig {
    /**
     * Flink execution.checkpointing.interval in milliseconds
     */
    executionCheckpointingIntervalMs?: string;
    /**
     * Flink execution.checkpointing.timeout in milliseconds
     */
    executionCheckpointingTimeoutMs?: string;
    /**
     * Flink major version
     */
    flinkVersion?: string;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Flink taskmanager.numberOfTaskSlots
     */
    numberOfTaskSlots?: string;
    /**
     * Flink parallelism.default
     */
    parallelismDefault?: string;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.FlinkFlinkUserConfigPrivatelinkAccess;
    /**
     * Flink restart-strategy
     */
    restartStrategy?: string;
    /**
     * Flink restart-strategy.failure-rate.delay in seconds
     */
    restartStrategyDelaySec?: string;
    /**
     * Flink restart-strategy.failure-rate.failure-rate-interval in minutes
     */
    restartStrategyFailureRateIntervalMin?: string;
    /**
     * Flink restart-strategy.failure-rate.max-failures-per-interval
     */
    restartStrategyMaxFailures?: string;
}

export interface FlinkFlinkUserConfigPrivatelinkAccess {
    /**
     * Flink server provided values
     */
    flink?: string;
}

export interface FlinkServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface GetCassandaCassandra {
}

export interface GetCassandaCassandraUserConfig {
    /**
     * Cassandra server provided values
     */
    cassandra?: outputs.GetCassandaCassandraUserConfigCassandra;
    cassandraVersion?: string;
    ipFilters?: string[];
    migrateSstableloader?: string;
    privateAccess?: outputs.GetCassandaCassandraUserConfigPrivateAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetCassandaCassandraUserConfigPublicAccess;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetCassandaCassandraUserConfigCassandra {
    batchSizeFailThresholdInKb?: string;
    batchSizeWarnThresholdInKb?: string;
}

export interface GetCassandaCassandraUserConfigPrivateAccess {
    prometheus?: string;
}

export interface GetCassandaCassandraUserConfigPublicAccess {
    prometheus?: string;
}

export interface GetCassandaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetCassandaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetCassandraCassandra {
}

export interface GetCassandraCassandraUserConfig {
    /**
     * Cassandra server provided values
     */
    cassandra?: outputs.GetCassandraCassandraUserConfigCassandra;
    cassandraVersion?: string;
    ipFilters?: string[];
    migrateSstableloader?: string;
    privateAccess?: outputs.GetCassandraCassandraUserConfigPrivateAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetCassandraCassandraUserConfigPublicAccess;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetCassandraCassandraUserConfigCassandra {
    batchSizeFailThresholdInKb?: string;
    batchSizeWarnThresholdInKb?: string;
}

export interface GetCassandraCassandraUserConfigPrivateAccess {
    prometheus?: string;
}

export interface GetCassandraCassandraUserConfigPublicAccess {
    prometheus?: string;
}

export interface GetCassandraComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetCassandraServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetClickhouseClickhouse {
}

export interface GetClickhouseClickhouseUserConfig {
    ipFilters?: string[];
    projectToForkFrom?: string;
    serviceToForkFrom?: string;
}

export interface GetClickhouseComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetClickhouseServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetElasticSearchAclAcl {
    rules: outputs.GetElasticSearchAclAclRule[];
    username: string;
}

export interface GetElasticSearchAclAclRule {
    index: string;
    permission: string;
}

export interface GetElasticSearchComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetElasticSearchElasticsearch {
    kibanaUri: string;
}

export interface GetElasticSearchElasticsearchUserConfig {
    customDomain?: string;
    disableReplicationFactorAdjustment?: string;
    /**
     * Elasticsearch server provided values
     */
    elasticsearch?: outputs.GetElasticSearchElasticsearchUserConfigElasticsearch;
    elasticsearchVersion?: string;
    indexPatterns?: outputs.GetElasticSearchElasticsearchUserConfigIndexPattern[];
    indexTemplate?: outputs.GetElasticSearchElasticsearchUserConfigIndexTemplate;
    ipFilters?: string[];
    keepIndexRefreshInterval?: string;
    kibana?: outputs.GetElasticSearchElasticsearchUserConfigKibana;
    maxIndexCount?: string;
    opensearchVersion?: string;
    privateAccess?: outputs.GetElasticSearchElasticsearchUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetElasticSearchElasticsearchUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetElasticSearchElasticsearchUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetElasticSearchElasticsearchUserConfigElasticsearch {
    actionAutoCreateIndexEnabled?: string;
    actionDestructiveRequiresName?: string;
    clusterMaxShardsPerNode?: string;
    httpMaxContentLength?: string;
    httpMaxHeaderSize?: string;
    httpMaxInitialLineLength?: string;
    indicesFielddataCacheSize?: string;
    indicesMemoryIndexBufferSize?: string;
    indicesQueriesCacheSize?: string;
    indicesQueryBoolMaxClauseCount?: string;
    overrideMainResponseVersion?: string;
    reindexRemoteWhitelists?: string[];
    searchMaxBuckets?: string;
    threadPoolAnalyzeQueueSize?: string;
    threadPoolAnalyzeSize?: string;
    threadPoolForceMergeSize?: string;
    threadPoolGetQueueSize?: string;
    threadPoolGetSize?: string;
    threadPoolIndexQueueSize?: string;
    threadPoolIndexSize?: string;
    threadPoolSearchQueueSize?: string;
    threadPoolSearchSize?: string;
    threadPoolSearchThrottledQueueSize?: string;
    threadPoolSearchThrottledSize?: string;
    threadPoolWriteQueueSize?: string;
    threadPoolWriteSize?: string;
}

export interface GetElasticSearchElasticsearchUserConfigIndexPattern {
    maxIndexCount?: string;
    pattern?: string;
    sortingAlgorithm?: string;
}

export interface GetElasticSearchElasticsearchUserConfigIndexTemplate {
    mappingNestedObjectsLimit?: string;
    numberOfReplicas?: string;
    numberOfShards?: string;
}

export interface GetElasticSearchElasticsearchUserConfigKibana {
    elasticsearchRequestTimeout?: string;
    enabled?: string;
    maxOldSpaceSize?: string;
}

export interface GetElasticSearchElasticsearchUserConfigPrivateAccess {
    /**
     * Elasticsearch server provided values
     */
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface GetElasticSearchElasticsearchUserConfigPrivatelinkAccess {
    /**
     * Elasticsearch server provided values
     */
    elasticsearch?: string;
    kibana?: string;
}

export interface GetElasticSearchElasticsearchUserConfigPublicAccess {
    /**
     * Elasticsearch server provided values
     */
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface GetElasticSearchServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetFlinkComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetFlinkFlink {
    hostPorts: string[];
}

export interface GetFlinkFlinkUserConfig {
    executionCheckpointingIntervalMs?: string;
    executionCheckpointingTimeoutMs?: string;
    flinkVersion?: string;
    ipFilters?: string[];
    numberOfTaskSlots?: string;
    parallelismDefault?: string;
    privatelinkAccess?: outputs.GetFlinkFlinkUserConfigPrivatelinkAccess;
    restartStrategy?: string;
    restartStrategyDelaySec?: string;
    restartStrategyFailureRateIntervalMin?: string;
    restartStrategyMaxFailures?: string;
}

export interface GetFlinkFlinkUserConfigPrivatelinkAccess {
    /**
     * Flink server provided values
     */
    flink?: string;
}

export interface GetFlinkServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetGrafanaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetGrafanaGrafana {
}

export interface GetGrafanaGrafanaUserConfig {
    alertingEnabled?: string;
    alertingErrorOrTimeout?: string;
    alertingMaxAnnotationsToKeep?: string;
    alertingNodataOrNullvalues?: string;
    allowEmbedding?: string;
    authAzuread?: outputs.GetGrafanaGrafanaUserConfigAuthAzuread;
    authBasicEnabled?: string;
    authGenericOauth?: outputs.GetGrafanaGrafanaUserConfigAuthGenericOauth;
    authGithub?: outputs.GetGrafanaGrafanaUserConfigAuthGithub;
    authGitlab?: outputs.GetGrafanaGrafanaUserConfigAuthGitlab;
    authGoogle?: outputs.GetGrafanaGrafanaUserConfigAuthGoogle;
    cookieSamesite?: string;
    customDomain?: string;
    dashboardsMinRefreshInterval?: string;
    dashboardsVersionsToKeep?: string;
    dataproxySendUserHeader?: string;
    dataproxyTimeout?: string;
    dateFormats?: outputs.GetGrafanaGrafanaUserConfigDateFormats;
    disableGravatar?: string;
    editorsCanAdmin?: string;
    externalImageStorage?: outputs.GetGrafanaGrafanaUserConfigExternalImageStorage;
    googleAnalyticsUaId?: string;
    ipFilters?: string[];
    metricsEnabled?: string;
    privateAccess?: outputs.GetGrafanaGrafanaUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetGrafanaGrafanaUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetGrafanaGrafanaUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    smtpServer?: outputs.GetGrafanaGrafanaUserConfigSmtpServer;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
    userAutoAssignOrg?: string;
    userAutoAssignOrgRole?: string;
    viewersCanEdit?: string;
}

export interface GetGrafanaGrafanaUserConfigAuthAzuread {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedGroups?: string[];
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface GetGrafanaGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedOrganizations?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    name?: string;
    scopes?: string[];
    tokenUrl?: string;
}

export interface GetGrafanaGrafanaUserConfigAuthGithub {
    allowSignUp?: string;
    allowedOrganizations?: string[];
    clientId?: string;
    clientSecret?: string;
    teamIds?: string[];
}

export interface GetGrafanaGrafanaUserConfigAuthGitlab {
    allowSignUp?: string;
    allowedGroups?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface GetGrafanaGrafanaUserConfigAuthGoogle {
    allowSignUp?: string;
    allowedDomains?: string[];
    clientId?: string;
    clientSecret?: string;
}

export interface GetGrafanaGrafanaUserConfigDateFormats {
    defaultTimezone?: string;
    fullDate?: string;
    intervalDay?: string;
    intervalHour?: string;
    intervalMinute?: string;
    intervalMonth?: string;
    intervalSecond?: string;
    intervalYear?: string;
}

export interface GetGrafanaGrafanaUserConfigExternalImageStorage {
    accessKey?: string;
    bucketUrl?: string;
    provider?: string;
    secretKey?: string;
}

export interface GetGrafanaGrafanaUserConfigPrivateAccess {
    /**
     * Grafana server provided values
     */
    grafana?: string;
}

export interface GetGrafanaGrafanaUserConfigPrivatelinkAccess {
    /**
     * Grafana server provided values
     */
    grafana?: string;
}

export interface GetGrafanaGrafanaUserConfigPublicAccess {
    /**
     * Grafana server provided values
     */
    grafana?: string;
}

export interface GetGrafanaGrafanaUserConfigSmtpServer {
    fromAddress?: string;
    fromName?: string;
    host?: string;
    password?: string;
    port?: string;
    skipVerify?: string;
    starttlsPolicy?: string;
    username?: string;
}

export interface GetGrafanaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetInfluxDbComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetInfluxDbInfluxdb {
    databaseName: string;
}

export interface GetInfluxDbInfluxdbUserConfig {
    customDomain?: string;
    /**
     * InfluxDB server provided values
     */
    influxdb?: outputs.GetInfluxDbInfluxdbUserConfigInfluxdb;
    ipFilters?: string[];
    privateAccess?: outputs.GetInfluxDbInfluxdbUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetInfluxDbInfluxdbUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetInfluxDbInfluxdbUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetInfluxDbInfluxdbUserConfigInfluxdb {
    logQueriesAfter?: string;
    maxConnectionLimit?: string;
    maxRowLimit?: string;
    maxSelectBuckets?: string;
    maxSelectPoint?: string;
    queryTimeout?: string;
}

export interface GetInfluxDbInfluxdbUserConfigPrivateAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: string;
}

export interface GetInfluxDbInfluxdbUserConfigPrivatelinkAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: string;
}

export interface GetInfluxDbInfluxdbUserConfigPublicAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: string;
}

export interface GetInfluxDbServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetKafkaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetKafkaConnectComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetKafkaConnectKafkaConnect {
}

export interface GetKafkaConnectKafkaConnectUserConfig {
    ipFilters?: string[];
    /**
     * Kafka Connect server provided values
     */
    kafkaConnect?: outputs.GetKafkaConnectKafkaConnectUserConfigKafkaConnect;
    privateAccess?: outputs.GetKafkaConnectKafkaConnectUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetKafkaConnectKafkaConnectUserConfigPrivatelinkAccess;
    publicAccess?: outputs.GetKafkaConnectKafkaConnectUserConfigPublicAccess;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetKafkaConnectKafkaConnectUserConfigKafkaConnect {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerFetchMaxBytes?: string;
    consumerIsolationLevel?: string;
    consumerMaxPartitionFetchBytes?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    producerMaxRequestSize?: string;
    sessionTimeoutMs?: string;
}

export interface GetKafkaConnectKafkaConnectUserConfigPrivateAccess {
    /**
     * Kafka Connect server provided values
     */
    kafkaConnect?: string;
    prometheus?: string;
}

export interface GetKafkaConnectKafkaConnectUserConfigPrivatelinkAccess {
    /**
     * Kafka Connect server provided values
     */
    kafkaConnect?: string;
}

export interface GetKafkaConnectKafkaConnectUserConfigPublicAccess {
    /**
     * Kafka Connect server provided values
     */
    kafkaConnect?: string;
    prometheus?: string;
}

export interface GetKafkaConnectServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetKafkaConnectorTask {
    connector: string;
    /**
     * List of tasks of a connector.
     */
    task: number;
}

export interface GetKafkaKafka {
    accessCert: string;
    accessKey: string;
    connectUri: string;
    restUri: string;
    schemaRegistryUri: string;
}

export interface GetKafkaKafkaUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    /**
     * Kafka server provided values
     */
    kafka?: outputs.GetKafkaKafkaUserConfigKafka;
    kafkaAuthenticationMethods?: outputs.GetKafkaKafkaUserConfigKafkaAuthenticationMethods;
    kafkaConnect?: string;
    kafkaConnectConfig?: outputs.GetKafkaKafkaUserConfigKafkaConnectConfig;
    kafkaRest?: string;
    kafkaRestConfig?: outputs.GetKafkaKafkaUserConfigKafkaRestConfig;
    kafkaVersion?: string;
    privateAccess?: outputs.GetKafkaKafkaUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetKafkaKafkaUserConfigPrivatelinkAccess;
    publicAccess?: outputs.GetKafkaKafkaUserConfigPublicAccess;
    schemaRegistry?: string;
    schemaRegistryConfig?: outputs.GetKafkaKafkaUserConfigSchemaRegistryConfig;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetKafkaKafkaUserConfigKafka {
    autoCreateTopicsEnable?: string;
    compressionType?: string;
    connectionsMaxIdleMs?: string;
    defaultReplicationFactor?: string;
    groupInitialRebalanceDelayMs?: string;
    groupMaxSessionTimeoutMs?: string;
    groupMinSessionTimeoutMs?: string;
    logCleanerDeleteRetentionMs?: string;
    logCleanerMaxCompactionLagMs?: string;
    logCleanerMinCleanableRatio?: string;
    logCleanerMinCompactionLagMs?: string;
    logCleanupPolicy?: string;
    logFlushIntervalMessages?: string;
    logFlushIntervalMs?: string;
    logIndexIntervalBytes?: string;
    logIndexSizeMaxBytes?: string;
    logMessageDownconversionEnable?: string;
    logMessageTimestampDifferenceMaxMs?: string;
    logMessageTimestampType?: string;
    logPreallocate?: string;
    logRetentionBytes?: string;
    logRetentionHours?: string;
    logRetentionMs?: string;
    logRollJitterMs?: string;
    logRollMs?: string;
    logSegmentBytes?: string;
    logSegmentDeleteDelayMs?: string;
    maxConnectionsPerIp?: string;
    maxIncrementalFetchSessionCacheSlots?: string;
    messageMaxBytes?: string;
    minInsyncReplicas?: string;
    numPartitions?: string;
    offsetsRetentionMinutes?: string;
    producerPurgatoryPurgeIntervalRequests?: string;
    replicaFetchMaxBytes?: string;
    replicaFetchResponseMaxBytes?: string;
    socketRequestMaxBytes?: string;
    transactionRemoveExpiredTransactionCleanupIntervalMs?: string;
    transactionStateLogSegmentBytes?: string;
}

export interface GetKafkaKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: string;
    sasl?: string;
}

export interface GetKafkaKafkaUserConfigKafkaConnectConfig {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerFetchMaxBytes?: string;
    consumerIsolationLevel?: string;
    consumerMaxPartitionFetchBytes?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    producerMaxRequestSize?: string;
    sessionTimeoutMs?: string;
}

export interface GetKafkaKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: string;
    consumerRequestMaxBytes?: string;
    consumerRequestTimeoutMs?: string;
    producerAcks?: string;
    producerLingerMs?: string;
    simpleconsumerPoolSizeMax?: string;
}

export interface GetKafkaKafkaUserConfigPrivateAccess {
    prometheus?: string;
}

export interface GetKafkaKafkaUserConfigPrivatelinkAccess {
    /**
     * Kafka server provided values
     */
    kafka?: string;
    kafkaConnect?: string;
    kafkaRest?: string;
    schemaRegistry?: string;
}

export interface GetKafkaKafkaUserConfigPublicAccess {
    /**
     * Kafka server provided values
     */
    kafka?: string;
    kafkaConnect?: string;
    kafkaRest?: string;
    prometheus?: string;
    schemaRegistry?: string;
}

export interface GetKafkaKafkaUserConfigSchemaRegistryConfig {
    leaderEligibility?: string;
    topicName?: string;
}

export interface GetKafkaMirrorMakerComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetKafkaMirrorMakerKafkaMirrormaker {
}

export interface GetKafkaMirrorMakerKafkaMirrormakerUserConfig {
    ipFilters?: string[];
    /**
     * Kafka MirrorMaker 2 server provided values
     */
    kafkaMirrormaker?: outputs.GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker {
    emitCheckpointsEnabled?: string;
    emitCheckpointsIntervalSeconds?: string;
    refreshGroupsEnabled?: string;
    refreshGroupsIntervalSeconds?: string;
    refreshTopicsEnabled?: string;
    refreshTopicsIntervalSeconds?: string;
    syncGroupOffsetsEnabled?: string;
    syncGroupOffsetsIntervalSeconds?: string;
    syncTopicConfigsEnabled?: string;
    tasksMaxPerCpu?: string;
}

export interface GetKafkaMirrorMakerServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetKafkaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetKafkaTopicConfig {
    /**
     * **DEPRECATED use config.cleanup_policy instead** Topic cleanup policy. The possible values are `delete` and `compact`.
     */
    cleanupPolicy?: string;
    compressionType?: string;
    deleteRetentionMs?: string;
    fileDeleteDelayMs?: string;
    flushMessages?: string;
    flushMs?: string;
    indexIntervalBytes?: string;
    maxCompactionLagMs?: string;
    maxMessageBytes?: string;
    messageDownconversionEnable?: string;
    messageFormatVersion?: string;
    messageTimestampDifferenceMaxMs?: string;
    messageTimestampType?: string;
    minCleanableDirtyRatio?: string;
    minCompactionLagMs?: string;
    minInsyncReplicas?: string;
    preallocate?: string;
    /**
     * **DEPRECATED use config.retention_bytes instead** Retention bytes.
     */
    retentionBytes?: string;
    retentionMs?: string;
    segmentBytes?: string;
    segmentIndexBytes?: string;
    segmentJitterMs?: string;
    segmentMs?: string;
    uncleanLeaderElectionEnable?: string;
}

export interface GetKafkaTopicTag {
    key: string;
    value?: string;
}

export interface GetM3AggregatorComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetM3AggregatorM3aggregator {
}

export interface GetM3AggregatorM3aggregatorUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    m3Version?: string;
    m3aggregatorVersion?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetM3AggregatorServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetM3DbComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetM3DbM3db {
}

export interface GetM3DbM3dbUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    limits?: outputs.GetM3DbM3dbUserConfigLimits;
    m3Version?: string;
    m3coordinatorEnableGraphiteCarbonIngest?: string;
    m3dbVersion?: string;
    namespaces?: outputs.GetM3DbM3dbUserConfigNamespace[];
    privateAccess?: outputs.GetM3DbM3dbUserConfigPrivateAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetM3DbM3dbUserConfigPublicAccess;
    rules?: outputs.GetM3DbM3dbUserConfigRules;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetM3DbM3dbUserConfigLimits {
    queryRequireExhaustive?: string;
    querySeries?: string;
}

export interface GetM3DbM3dbUserConfigNamespace {
    name?: string;
    options?: outputs.GetM3DbM3dbUserConfigNamespaceOptions;
    resolution?: string;
    type?: string;
}

export interface GetM3DbM3dbUserConfigNamespaceOptions {
    retentionOptions?: outputs.GetM3DbM3dbUserConfigNamespaceOptionsRetentionOptions;
    snapshotEnabled?: string;
    writesToCommitlog?: string;
}

export interface GetM3DbM3dbUserConfigNamespaceOptionsRetentionOptions {
    blockDataExpiryDuration?: string;
    blocksizeDuration?: string;
    bufferFutureDuration?: string;
    bufferPastDuration?: string;
    retentionPeriodDuration?: string;
}

export interface GetM3DbM3dbUserConfigPrivateAccess {
    m3coordinator?: string;
}

export interface GetM3DbM3dbUserConfigPublicAccess {
    m3coordinator?: string;
}

export interface GetM3DbM3dbUserConfigRules {
    mappings?: outputs.GetM3DbM3dbUserConfigRulesMapping[];
}

export interface GetM3DbM3dbUserConfigRulesMapping {
    aggregations?: string[];
    drop?: string;
    filter?: string;
    name?: string;
    namespaces?: string[];
    tags?: outputs.GetM3DbM3dbUserConfigRulesMappingTag[];
}

export interface GetM3DbM3dbUserConfigRulesMappingTag {
    name?: string;
    value?: string;
}

export interface GetM3DbServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetMySqlComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetMySqlMysql {
}

export interface GetMySqlMysqlUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    binlogRetentionPeriod?: string;
    ipFilters?: string[];
    migration?: outputs.GetMySqlMysqlUserConfigMigration;
    /**
     * MySQL specific server provided values
     */
    mysql?: outputs.GetMySqlMysqlUserConfigMysql;
    mysqlVersion?: string;
    privateAccess?: outputs.GetMySqlMysqlUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetMySqlMysqlUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetMySqlMysqlUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetMySqlMysqlUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface GetMySqlMysqlUserConfigMysql {
    connectTimeout?: string;
    defaultTimeZone?: string;
    groupConcatMaxLen?: string;
    informationSchemaStatsExpiry?: string;
    innodbFtMinTokenSize?: string;
    innodbFtServerStopwordTable?: string;
    innodbLockWaitTimeout?: string;
    innodbLogBufferSize?: string;
    innodbOnlineAlterLogMaxSize?: string;
    innodbPrintAllDeadlocks?: string;
    innodbRollbackOnTimeout?: string;
    interactiveTimeout?: string;
    internalTmpMemStorageEngine?: string;
    longQueryTime?: string;
    maxAllowedPacket?: string;
    maxHeapTableSize?: string;
    netReadTimeout?: string;
    netWriteTimeout?: string;
    slowQueryLog?: string;
    sortBufferSize?: string;
    sqlMode?: string;
    sqlRequirePrimaryKey?: string;
    tmpTableSize?: string;
    waitTimeout?: string;
}

export interface GetMySqlMysqlUserConfigPrivateAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: string;
    mysqlx?: string;
    prometheus?: string;
}

export interface GetMySqlMysqlUserConfigPrivatelinkAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: string;
    mysqlx?: string;
}

export interface GetMySqlMysqlUserConfigPublicAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: string;
    mysqlx?: string;
    prometheus?: string;
}

export interface GetMySqlServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetOpenSearchComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetOpenSearchOpensearch {
    opensearchDashboardsUri: string;
}

export interface GetOpenSearchOpensearchUserConfig {
    customDomain?: string;
    disableReplicationFactorAdjustment?: string;
    indexPatterns?: outputs.GetOpenSearchOpensearchUserConfigIndexPattern[];
    indexTemplate?: outputs.GetOpenSearchOpensearchUserConfigIndexTemplate;
    ipFilters?: string[];
    keepIndexRefreshInterval?: string;
    maxIndexCount?: string;
    /**
     * Opensearch server provided values
     */
    opensearch?: outputs.GetOpenSearchOpensearchUserConfigOpensearch;
    opensearchDashboards?: outputs.GetOpenSearchOpensearchUserConfigOpensearchDashboards;
    opensearchVersion?: string;
    privateAccess?: outputs.GetOpenSearchOpensearchUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetOpenSearchOpensearchUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetOpenSearchOpensearchUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetOpenSearchOpensearchUserConfigIndexPattern {
    maxIndexCount?: string;
    pattern?: string;
    sortingAlgorithm?: string;
}

export interface GetOpenSearchOpensearchUserConfigIndexTemplate {
    mappingNestedObjectsLimit?: string;
    numberOfReplicas?: string;
    numberOfShards?: string;
}

export interface GetOpenSearchOpensearchUserConfigOpensearch {
    actionAutoCreateIndexEnabled?: string;
    actionDestructiveRequiresName?: string;
    clusterMaxShardsPerNode?: string;
    httpMaxContentLength?: string;
    httpMaxHeaderSize?: string;
    httpMaxInitialLineLength?: string;
    indicesFielddataCacheSize?: string;
    indicesMemoryIndexBufferSize?: string;
    indicesQueriesCacheSize?: string;
    indicesQueryBoolMaxClauseCount?: string;
    overrideMainResponseVersion?: string;
    reindexRemoteWhitelists?: string[];
    searchMaxBuckets?: string;
    threadPoolAnalyzeQueueSize?: string;
    threadPoolAnalyzeSize?: string;
    threadPoolForceMergeSize?: string;
    threadPoolGetQueueSize?: string;
    threadPoolGetSize?: string;
    threadPoolIndexSize?: string;
    threadPoolSearchQueueSize?: string;
    threadPoolSearchSize?: string;
    threadPoolSearchThrottledQueueSize?: string;
    threadPoolSearchThrottledSize?: string;
    threadPoolWriteQueueSize?: string;
    threadPoolWriteSize?: string;
}

export interface GetOpenSearchOpensearchUserConfigOpensearchDashboards {
    enabled?: string;
    maxOldSpaceSize?: string;
    opensearchRequestTimeout?: string;
}

export interface GetOpenSearchOpensearchUserConfigPrivateAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: string;
    opensearchDashboards?: string;
    prometheus?: string;
}

export interface GetOpenSearchOpensearchUserConfigPrivatelinkAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: string;
    opensearchDashboards?: string;
}

export interface GetOpenSearchOpensearchUserConfigPublicAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: string;
    opensearchDashboards?: string;
    prometheus?: string;
}

export interface GetOpenSearchServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetPgComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetPgPg {
    dbname: string;
    host: string;
    password: string;
    port: number;
    replicaUri: string;
    sslmode: string;
    uri: string;
    user: string;
}

export interface GetPgPgUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    ipFilters?: string[];
    migration?: outputs.GetPgPgUserConfigMigration;
    /**
     * PostgreSQL specific server provided values
     */
    pg?: outputs.GetPgPgUserConfigPg;
    pgReadReplica?: string;
    pgServiceToForkFrom?: string;
    pgVersion?: string;
    pgbouncer?: outputs.GetPgPgUserConfigPgbouncer;
    pglookout?: outputs.GetPgPgUserConfigPglookout;
    privateAccess?: outputs.GetPgPgUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetPgPgUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetPgPgUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    sharedBuffersPercentage?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
    synchronousReplication?: string;
    timescaledb?: outputs.GetPgPgUserConfigTimescaledb;
    variant?: string;
    workMem?: string;
}

export interface GetPgPgUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface GetPgPgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: string;
    autovacuumAnalyzeThreshold?: string;
    autovacuumFreezeMaxAge?: string;
    autovacuumMaxWorkers?: string;
    autovacuumNaptime?: string;
    autovacuumVacuumCostDelay?: string;
    autovacuumVacuumCostLimit?: string;
    autovacuumVacuumScaleFactor?: string;
    autovacuumVacuumThreshold?: string;
    bgwriterDelay?: string;
    bgwriterFlushAfter?: string;
    bgwriterLruMaxpages?: string;
    bgwriterLruMultiplier?: string;
    deadlockTimeout?: string;
    defaultToastCompression?: string;
    idleInTransactionSessionTimeout?: string;
    jit?: string;
    logAutovacuumMinDuration?: string;
    logErrorVerbosity?: string;
    logLinePrefix?: string;
    logMinDurationStatement?: string;
    maxFilesPerProcess?: string;
    maxLocksPerTransaction?: string;
    maxLogicalReplicationWorkers?: string;
    maxParallelWorkers?: string;
    maxParallelWorkersPerGather?: string;
    maxPredLocksPerTransaction?: string;
    maxPreparedTransactions?: string;
    maxReplicationSlots?: string;
    maxSlotWalKeepSize?: string;
    maxStackDepth?: string;
    maxStandbyArchiveDelay?: string;
    maxStandbyStreamingDelay?: string;
    maxWalSenders?: string;
    maxWorkerProcesses?: string;
    pgPartmanBgwDotInterval?: string;
    pgPartmanBgwDotRole?: string;
    pgStatStatementsDotTrack?: string;
    tempFileLimit?: string;
    timezone?: string;
    trackActivityQuerySize?: string;
    trackCommitTimestamp?: string;
    trackFunctions?: string;
    trackIoTiming?: string;
    walSenderTimeout?: string;
    walWriterDelay?: string;
}

export interface GetPgPgUserConfigPgbouncer {
    autodbIdleTimeout?: string;
    autodbMaxDbConnections?: string;
    autodbPoolMode?: string;
    autodbPoolSize?: string;
    ignoreStartupParameters?: string[];
    minPoolSize?: string;
    serverIdleTimeout?: string;
    serverLifetime?: string;
    serverResetQueryAlways?: string;
}

export interface GetPgPgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: string;
}

export interface GetPgPgUserConfigPrivateAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface GetPgPgUserConfigPrivatelinkAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: string;
    pgbouncer?: string;
}

export interface GetPgPgUserConfigPublicAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface GetPgPgUserConfigTimescaledb {
    maxBackgroundWorkers?: string;
}

export interface GetPgServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetRedisComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetRedisRedi {
}

export interface GetRedisRedisUserConfig {
    ipFilters?: string[];
    migration?: outputs.GetRedisRedisUserConfigMigration;
    privateAccess?: outputs.GetRedisRedisUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetRedisRedisUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetRedisRedisUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    redisAclChannelsDefault?: string;
    redisIoThreads?: string;
    redisLfuDecayTime?: string;
    redisLfuLogFactor?: string;
    redisMaxmemoryPolicy?: string;
    redisNotifyKeyspaceEvents?: string;
    redisNumberOfDatabases?: string;
    redisPersistence?: string;
    redisPubsubClientOutputBufferLimit?: string;
    redisSsl?: string;
    redisTimeout?: string;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetRedisRedisUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface GetRedisRedisUserConfigPrivateAccess {
    prometheus?: string;
    /**
     * Redis server provided values
     */
    redis?: string;
}

export interface GetRedisRedisUserConfigPrivatelinkAccess {
    /**
     * Redis server provided values
     */
    redis?: string;
}

export interface GetRedisRedisUserConfigPublicAccess {
    prometheus?: string;
    /**
     * Redis server provided values
     */
    redis?: string;
}

export interface GetRedisServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetServiceCassandra {
}

export interface GetServiceCassandraUserConfig {
    /**
     * Cassandra specific server provided values
     */
    cassandra?: outputs.GetServiceCassandraUserConfigCassandra;
    cassandraVersion?: string;
    ipFilters?: string[];
    migrateSstableloader?: string;
    privateAccess?: outputs.GetServiceCassandraUserConfigPrivateAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetServiceCassandraUserConfigPublicAccess;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetServiceCassandraUserConfigCassandra {
    batchSizeFailThresholdInKb?: string;
    batchSizeWarnThresholdInKb?: string;
}

export interface GetServiceCassandraUserConfigPrivateAccess {
    prometheus?: string;
}

export interface GetServiceCassandraUserConfigPublicAccess {
    prometheus?: string;
}

export interface GetServiceClickhouse {
}

export interface GetServiceClickhouseUserConfig {
    ipFilters?: string[];
    projectToForkFrom?: string;
    serviceToForkFrom?: string;
}

export interface GetServiceComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetServiceElasticsearch {
    kibanaUri: string;
}

export interface GetServiceElasticsearchUserConfig {
    customDomain?: string;
    disableReplicationFactorAdjustment?: string;
    /**
     * Elasticsearch specific server provided values
     */
    elasticsearch?: outputs.GetServiceElasticsearchUserConfigElasticsearch;
    elasticsearchVersion?: string;
    indexPatterns?: outputs.GetServiceElasticsearchUserConfigIndexPattern[];
    indexTemplate?: outputs.GetServiceElasticsearchUserConfigIndexTemplate;
    ipFilters?: string[];
    keepIndexRefreshInterval?: string;
    kibana?: outputs.GetServiceElasticsearchUserConfigKibana;
    maxIndexCount?: string;
    opensearchVersion?: string;
    privateAccess?: outputs.GetServiceElasticsearchUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetServiceElasticsearchUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetServiceElasticsearchUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetServiceElasticsearchUserConfigElasticsearch {
    actionAutoCreateIndexEnabled?: string;
    actionDestructiveRequiresName?: string;
    clusterMaxShardsPerNode?: string;
    httpMaxContentLength?: string;
    httpMaxHeaderSize?: string;
    httpMaxInitialLineLength?: string;
    indicesFielddataCacheSize?: string;
    indicesMemoryIndexBufferSize?: string;
    indicesQueriesCacheSize?: string;
    indicesQueryBoolMaxClauseCount?: string;
    overrideMainResponseVersion?: string;
    reindexRemoteWhitelists?: string[];
    searchMaxBuckets?: string;
    threadPoolAnalyzeQueueSize?: string;
    threadPoolAnalyzeSize?: string;
    threadPoolForceMergeSize?: string;
    threadPoolGetQueueSize?: string;
    threadPoolGetSize?: string;
    threadPoolIndexQueueSize?: string;
    threadPoolIndexSize?: string;
    threadPoolSearchQueueSize?: string;
    threadPoolSearchSize?: string;
    threadPoolSearchThrottledQueueSize?: string;
    threadPoolSearchThrottledSize?: string;
    threadPoolWriteQueueSize?: string;
    threadPoolWriteSize?: string;
}

export interface GetServiceElasticsearchUserConfigIndexPattern {
    maxIndexCount?: string;
    pattern?: string;
    sortingAlgorithm?: string;
}

export interface GetServiceElasticsearchUserConfigIndexTemplate {
    mappingNestedObjectsLimit?: string;
    numberOfReplicas?: string;
    numberOfShards?: string;
}

export interface GetServiceElasticsearchUserConfigKibana {
    elasticsearchRequestTimeout?: string;
    enabled?: string;
    maxOldSpaceSize?: string;
}

export interface GetServiceElasticsearchUserConfigPrivateAccess {
    /**
     * Elasticsearch specific server provided values
     */
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface GetServiceElasticsearchUserConfigPrivatelinkAccess {
    /**
     * Elasticsearch specific server provided values
     */
    elasticsearch?: string;
    kibana?: string;
}

export interface GetServiceElasticsearchUserConfigPublicAccess {
    /**
     * Elasticsearch specific server provided values
     */
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface GetServiceFlink {
    hostPorts: string[];
}

export interface GetServiceFlinkUserConfig {
    executionCheckpointingIntervalMs?: string;
    executionCheckpointingTimeoutMs?: string;
    flinkVersion?: string;
    ipFilters?: string[];
    numberOfTaskSlots?: string;
    parallelismDefault?: string;
    privatelinkAccess?: outputs.GetServiceFlinkUserConfigPrivatelinkAccess;
    restartStrategy?: string;
    restartStrategyDelaySec?: string;
    restartStrategyFailureRateIntervalMin?: string;
    restartStrategyMaxFailures?: string;
}

export interface GetServiceFlinkUserConfigPrivatelinkAccess {
    /**
     * Flink specific server provided values
     */
    flink?: string;
}

export interface GetServiceGrafana {
}

export interface GetServiceGrafanaUserConfig {
    alertingEnabled?: string;
    alertingErrorOrTimeout?: string;
    alertingMaxAnnotationsToKeep?: string;
    alertingNodataOrNullvalues?: string;
    allowEmbedding?: string;
    authAzuread?: outputs.GetServiceGrafanaUserConfigAuthAzuread;
    authBasicEnabled?: string;
    authGenericOauth?: outputs.GetServiceGrafanaUserConfigAuthGenericOauth;
    authGithub?: outputs.GetServiceGrafanaUserConfigAuthGithub;
    authGitlab?: outputs.GetServiceGrafanaUserConfigAuthGitlab;
    authGoogle?: outputs.GetServiceGrafanaUserConfigAuthGoogle;
    cookieSamesite?: string;
    customDomain?: string;
    dashboardsMinRefreshInterval?: string;
    dashboardsVersionsToKeep?: string;
    dataproxySendUserHeader?: string;
    dataproxyTimeout?: string;
    dateFormats?: outputs.GetServiceGrafanaUserConfigDateFormats;
    disableGravatar?: string;
    editorsCanAdmin?: string;
    externalImageStorage?: outputs.GetServiceGrafanaUserConfigExternalImageStorage;
    googleAnalyticsUaId?: string;
    ipFilters?: string[];
    metricsEnabled?: string;
    privateAccess?: outputs.GetServiceGrafanaUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetServiceGrafanaUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetServiceGrafanaUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    smtpServer?: outputs.GetServiceGrafanaUserConfigSmtpServer;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
    userAutoAssignOrg?: string;
    userAutoAssignOrgRole?: string;
    viewersCanEdit?: string;
}

export interface GetServiceGrafanaUserConfigAuthAzuread {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedGroups?: string[];
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface GetServiceGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedOrganizations?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    name?: string;
    scopes?: string[];
    tokenUrl?: string;
}

export interface GetServiceGrafanaUserConfigAuthGithub {
    allowSignUp?: string;
    allowedOrganizations?: string[];
    clientId?: string;
    clientSecret?: string;
    teamIds?: string[];
}

export interface GetServiceGrafanaUserConfigAuthGitlab {
    allowSignUp?: string;
    allowedGroups?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface GetServiceGrafanaUserConfigAuthGoogle {
    allowSignUp?: string;
    allowedDomains?: string[];
    clientId?: string;
    clientSecret?: string;
}

export interface GetServiceGrafanaUserConfigDateFormats {
    defaultTimezone?: string;
    fullDate?: string;
    intervalDay?: string;
    intervalHour?: string;
    intervalMinute?: string;
    intervalMonth?: string;
    intervalSecond?: string;
    intervalYear?: string;
}

export interface GetServiceGrafanaUserConfigExternalImageStorage {
    accessKey?: string;
    bucketUrl?: string;
    provider?: string;
    secretKey?: string;
}

export interface GetServiceGrafanaUserConfigPrivateAccess {
    /**
     * Grafana specific server provided values
     */
    grafana?: string;
}

export interface GetServiceGrafanaUserConfigPrivatelinkAccess {
    /**
     * Grafana specific server provided values
     */
    grafana?: string;
}

export interface GetServiceGrafanaUserConfigPublicAccess {
    /**
     * Grafana specific server provided values
     */
    grafana?: string;
}

export interface GetServiceGrafanaUserConfigSmtpServer {
    fromAddress?: string;
    fromName?: string;
    host?: string;
    password?: string;
    port?: string;
    skipVerify?: string;
    starttlsPolicy?: string;
    username?: string;
}

export interface GetServiceInfluxdb {
    databaseName: string;
}

export interface GetServiceInfluxdbUserConfig {
    customDomain?: string;
    /**
     * InfluxDB specific server provided values
     */
    influxdb?: outputs.GetServiceInfluxdbUserConfigInfluxdb;
    ipFilters?: string[];
    privateAccess?: outputs.GetServiceInfluxdbUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetServiceInfluxdbUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetServiceInfluxdbUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetServiceInfluxdbUserConfigInfluxdb {
    logQueriesAfter?: string;
    maxConnectionLimit?: string;
    maxRowLimit?: string;
    maxSelectBuckets?: string;
    maxSelectPoint?: string;
    queryTimeout?: string;
}

export interface GetServiceInfluxdbUserConfigPrivateAccess {
    /**
     * InfluxDB specific server provided values
     */
    influxdb?: string;
}

export interface GetServiceInfluxdbUserConfigPrivatelinkAccess {
    /**
     * InfluxDB specific server provided values
     */
    influxdb?: string;
}

export interface GetServiceInfluxdbUserConfigPublicAccess {
    /**
     * InfluxDB specific server provided values
     */
    influxdb?: string;
}

export interface GetServiceIntegrationDatadogUserConfig {
    datadogTags?: outputs.GetServiceIntegrationDatadogUserConfigDatadogTag[];
    excludeConsumerGroups?: string[];
    excludeTopics?: string[];
    includeConsumerGroups?: string[];
    includeTopics?: string[];
    kafkaCustomMetrics?: string[];
    maxJmxMetrics?: string;
}

export interface GetServiceIntegrationDatadogUserConfigDatadogTag {
    comment?: string;
    tag?: string;
}

export interface GetServiceIntegrationEndpointDatadogUserConfig {
    datadogApiKey?: string;
    datadogTags?: outputs.GetServiceIntegrationEndpointDatadogUserConfigDatadogTag[];
    disableConsumerStats?: string;
    kafkaConsumerCheckInstances?: string;
    kafkaConsumerStatsTimeout?: string;
    maxPartitionContexts?: string;
    site?: string;
}

export interface GetServiceIntegrationEndpointDatadogUserConfigDatadogTag {
    comment?: string;
    tag?: string;
}

export interface GetServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig {
    accessKey?: string;
    logGroupName?: string;
    region?: string;
    secretKey?: string;
}

export interface GetServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig {
    accessKey?: string;
    namespace?: string;
    region?: string;
    secretKey?: string;
}

export interface GetServiceIntegrationEndpointExternalElasticsearchLogsUserConfig {
    ca?: string;
    indexDaysMax?: string;
    indexPrefix?: string;
    timeout?: string;
    url?: string;
}

export interface GetServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig {
    logId?: string;
    projectId?: string;
    serviceAccountCredentials?: string;
}

export interface GetServiceIntegrationEndpointExternalKafkaUserConfig {
    bootstrapServers?: string;
    saslMechanism?: string;
    saslPlainPassword?: string;
    saslPlainUsername?: string;
    securityProtocol?: string;
    sslCaCert?: string;
    sslClientCert?: string;
    sslClientKey?: string;
    sslEndpointIdentificationAlgorithm?: string;
}

export interface GetServiceIntegrationEndpointExternalSchemaRegistryUserConfig {
    authentication?: string;
    basicAuthPassword?: string;
    basicAuthUsername?: string;
    url?: string;
}

export interface GetServiceIntegrationEndpointJolokiaUserConfig {
    basicAuthPassword?: string;
    basicAuthUsername?: string;
}

export interface GetServiceIntegrationEndpointPrometheusUserConfig {
    basicAuthPassword?: string;
    basicAuthUsername?: string;
}

export interface GetServiceIntegrationEndpointRsyslogUserConfig {
    ca?: string;
    cert?: string;
    format?: string;
    key?: string;
    logline?: string;
    port?: string;
    sd?: string;
    server?: string;
    tls?: string;
}

export interface GetServiceIntegrationEndpointSignalfxUserConfig {
    enabledMetrics?: string[];
    signalfxApiKey?: string;
    signalfxRealm?: string;
}

export interface GetServiceIntegrationKafkaConnectUserConfig {
    kafkaConnect?: outputs.GetServiceIntegrationKafkaConnectUserConfigKafkaConnect;
}

export interface GetServiceIntegrationKafkaConnectUserConfigKafkaConnect {
    configStorageTopic?: string;
    groupId?: string;
    offsetStorageTopic?: string;
    statusStorageTopic?: string;
}

export interface GetServiceIntegrationKafkaLogsUserConfig {
    kafkaTopic?: string;
}

export interface GetServiceIntegrationKafkaMirrormakerUserConfig {
    clusterAlias?: string;
    kafkaMirrormaker?: outputs.GetServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker;
}

export interface GetServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker {
    consumerFetchMinBytes?: string;
    producerBatchSize?: string;
    producerBufferMemory?: string;
    producerLingerMs?: string;
    producerMaxRequestSize?: string;
}

export interface GetServiceIntegrationLogsUserConfig {
    elasticsearchIndexDaysMax?: string;
    elasticsearchIndexPrefix?: string;
}

export interface GetServiceIntegrationMetricsUserConfig {
    database?: string;
    retentionDays?: string;
    roUsername?: string;
    sourceMysql?: outputs.GetServiceIntegrationMetricsUserConfigSourceMysql;
    username?: string;
}

export interface GetServiceIntegrationMetricsUserConfigSourceMysql {
    telegraf?: outputs.GetServiceIntegrationMetricsUserConfigSourceMysqlTelegraf;
}

export interface GetServiceIntegrationMetricsUserConfigSourceMysqlTelegraf {
    gatherEventWaits?: string;
    gatherFileEventsStats?: string;
    gatherIndexIoWaits?: string;
    gatherInfoSchemaAutoInc?: string;
    gatherInnodbMetrics?: string;
    gatherPerfEventsStatements?: string;
    gatherProcessList?: string;
    gatherSlaveStatus?: string;
    gatherTableIoWaits?: string;
    gatherTableLockWaits?: string;
    gatherTableSchema?: string;
    perfEventsStatementsDigestTextLimit?: string;
    perfEventsStatementsLimit?: string;
    perfEventsStatementsTimeLimit?: string;
}

export interface GetServiceIntegrationMirrormakerUserConfig {
    mirrormakerWhitelist?: string;
}

export interface GetServiceIntegrationPrometheusUserConfig {
    sourceMysql?: outputs.GetServiceIntegrationPrometheusUserConfigSourceMysql;
}

export interface GetServiceIntegrationPrometheusUserConfigSourceMysql {
    telegraf?: outputs.GetServiceIntegrationPrometheusUserConfigSourceMysqlTelegraf;
}

export interface GetServiceIntegrationPrometheusUserConfigSourceMysqlTelegraf {
    gatherEventWaits?: string;
    gatherFileEventsStats?: string;
    gatherIndexIoWaits?: string;
    gatherInfoSchemaAutoInc?: string;
    gatherInnodbMetrics?: string;
    gatherPerfEventsStatements?: string;
    gatherProcessList?: string;
    gatherSlaveStatus?: string;
    gatherTableIoWaits?: string;
    gatherTableLockWaits?: string;
    gatherTableSchema?: string;
    perfEventsStatementsDigestTextLimit?: string;
    perfEventsStatementsLimit?: string;
    perfEventsStatementsTimeLimit?: string;
}

export interface GetServiceKafka {
    accessCert: string;
    accessKey: string;
    connectUri: string;
    restUri: string;
    schemaRegistryUri: string;
}

export interface GetServiceKafkaConnect {
}

export interface GetServiceKafkaConnectUserConfig {
    ipFilters?: string[];
    /**
     * Kafka Connect specific server provided values
     */
    kafkaConnect?: outputs.GetServiceKafkaConnectUserConfigKafkaConnect;
    privateAccess?: outputs.GetServiceKafkaConnectUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetServiceKafkaConnectUserConfigPrivatelinkAccess;
    publicAccess?: outputs.GetServiceKafkaConnectUserConfigPublicAccess;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetServiceKafkaConnectUserConfigKafkaConnect {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerFetchMaxBytes?: string;
    consumerIsolationLevel?: string;
    consumerMaxPartitionFetchBytes?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    producerMaxRequestSize?: string;
    sessionTimeoutMs?: string;
}

export interface GetServiceKafkaConnectUserConfigPrivateAccess {
    /**
     * Kafka Connect specific server provided values
     */
    kafkaConnect?: string;
    prometheus?: string;
}

export interface GetServiceKafkaConnectUserConfigPrivatelinkAccess {
    /**
     * Kafka Connect specific server provided values
     */
    kafkaConnect?: string;
}

export interface GetServiceKafkaConnectUserConfigPublicAccess {
    /**
     * Kafka Connect specific server provided values
     */
    kafkaConnect?: string;
    prometheus?: string;
}

export interface GetServiceKafkaMirrormaker {
}

export interface GetServiceKafkaMirrormakerUserConfig {
    ipFilters?: string[];
    /**
     * Kafka MirrorMaker 2 specific server provided values
     */
    kafkaMirrormaker?: outputs.GetServiceKafkaMirrormakerUserConfigKafkaMirrormaker;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetServiceKafkaMirrormakerUserConfigKafkaMirrormaker {
    emitCheckpointsEnabled?: string;
    emitCheckpointsIntervalSeconds?: string;
    refreshGroupsEnabled?: string;
    refreshGroupsIntervalSeconds?: string;
    refreshTopicsEnabled?: string;
    refreshTopicsIntervalSeconds?: string;
    syncGroupOffsetsEnabled?: string;
    syncGroupOffsetsIntervalSeconds?: string;
    syncTopicConfigsEnabled?: string;
    tasksMaxPerCpu?: string;
}

export interface GetServiceKafkaUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    /**
     * Kafka specific server provided values
     */
    kafka?: outputs.GetServiceKafkaUserConfigKafka;
    kafkaAuthenticationMethods?: outputs.GetServiceKafkaUserConfigKafkaAuthenticationMethods;
    /**
     * Kafka Connect specific server provided values
     */
    kafkaConnect?: string;
    kafkaConnectConfig?: outputs.GetServiceKafkaUserConfigKafkaConnectConfig;
    kafkaRest?: string;
    kafkaRestConfig?: outputs.GetServiceKafkaUserConfigKafkaRestConfig;
    kafkaVersion?: string;
    privateAccess?: outputs.GetServiceKafkaUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetServiceKafkaUserConfigPrivatelinkAccess;
    publicAccess?: outputs.GetServiceKafkaUserConfigPublicAccess;
    schemaRegistry?: string;
    schemaRegistryConfig?: outputs.GetServiceKafkaUserConfigSchemaRegistryConfig;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetServiceKafkaUserConfigKafka {
    autoCreateTopicsEnable?: string;
    compressionType?: string;
    connectionsMaxIdleMs?: string;
    defaultReplicationFactor?: string;
    groupInitialRebalanceDelayMs?: string;
    groupMaxSessionTimeoutMs?: string;
    groupMinSessionTimeoutMs?: string;
    logCleanerDeleteRetentionMs?: string;
    logCleanerMaxCompactionLagMs?: string;
    logCleanerMinCleanableRatio?: string;
    logCleanerMinCompactionLagMs?: string;
    logCleanupPolicy?: string;
    logFlushIntervalMessages?: string;
    logFlushIntervalMs?: string;
    logIndexIntervalBytes?: string;
    logIndexSizeMaxBytes?: string;
    logMessageDownconversionEnable?: string;
    logMessageTimestampDifferenceMaxMs?: string;
    logMessageTimestampType?: string;
    logPreallocate?: string;
    logRetentionBytes?: string;
    logRetentionHours?: string;
    logRetentionMs?: string;
    logRollJitterMs?: string;
    logRollMs?: string;
    logSegmentBytes?: string;
    logSegmentDeleteDelayMs?: string;
    maxConnectionsPerIp?: string;
    maxIncrementalFetchSessionCacheSlots?: string;
    messageMaxBytes?: string;
    minInsyncReplicas?: string;
    numPartitions?: string;
    offsetsRetentionMinutes?: string;
    producerPurgatoryPurgeIntervalRequests?: string;
    replicaFetchMaxBytes?: string;
    replicaFetchResponseMaxBytes?: string;
    socketRequestMaxBytes?: string;
    transactionRemoveExpiredTransactionCleanupIntervalMs?: string;
    transactionStateLogSegmentBytes?: string;
}

export interface GetServiceKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: string;
    sasl?: string;
}

export interface GetServiceKafkaUserConfigKafkaConnectConfig {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerFetchMaxBytes?: string;
    consumerIsolationLevel?: string;
    consumerMaxPartitionFetchBytes?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    producerMaxRequestSize?: string;
    sessionTimeoutMs?: string;
}

export interface GetServiceKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: string;
    consumerRequestMaxBytes?: string;
    consumerRequestTimeoutMs?: string;
    producerAcks?: string;
    producerLingerMs?: string;
    simpleconsumerPoolSizeMax?: string;
}

export interface GetServiceKafkaUserConfigPrivateAccess {
    prometheus?: string;
}

export interface GetServiceKafkaUserConfigPrivatelinkAccess {
    /**
     * Kafka specific server provided values
     */
    kafka?: string;
    /**
     * Kafka Connect specific server provided values
     */
    kafkaConnect?: string;
    kafkaRest?: string;
    schemaRegistry?: string;
}

export interface GetServiceKafkaUserConfigPublicAccess {
    /**
     * Kafka specific server provided values
     */
    kafka?: string;
    /**
     * Kafka Connect specific server provided values
     */
    kafkaConnect?: string;
    kafkaRest?: string;
    prometheus?: string;
    schemaRegistry?: string;
}

export interface GetServiceKafkaUserConfigSchemaRegistryConfig {
    leaderEligibility?: string;
    topicName?: string;
}

export interface GetServiceMysql {
}

export interface GetServiceMysqlUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    binlogRetentionPeriod?: string;
    ipFilters?: string[];
    migration?: outputs.GetServiceMysqlUserConfigMigration;
    /**
     * MySQL specific server provided values
     */
    mysql?: outputs.GetServiceMysqlUserConfigMysql;
    mysqlVersion?: string;
    privateAccess?: outputs.GetServiceMysqlUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetServiceMysqlUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetServiceMysqlUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetServiceMysqlUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface GetServiceMysqlUserConfigMysql {
    connectTimeout?: string;
    defaultTimeZone?: string;
    groupConcatMaxLen?: string;
    informationSchemaStatsExpiry?: string;
    innodbFtMinTokenSize?: string;
    innodbFtServerStopwordTable?: string;
    innodbLockWaitTimeout?: string;
    innodbLogBufferSize?: string;
    innodbOnlineAlterLogMaxSize?: string;
    innodbPrintAllDeadlocks?: string;
    innodbRollbackOnTimeout?: string;
    interactiveTimeout?: string;
    internalTmpMemStorageEngine?: string;
    longQueryTime?: string;
    maxAllowedPacket?: string;
    maxHeapTableSize?: string;
    netReadTimeout?: string;
    netWriteTimeout?: string;
    slowQueryLog?: string;
    sortBufferSize?: string;
    sqlMode?: string;
    sqlRequirePrimaryKey?: string;
    tmpTableSize?: string;
    waitTimeout?: string;
}

export interface GetServiceMysqlUserConfigPrivateAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: string;
    mysqlx?: string;
    prometheus?: string;
}

export interface GetServiceMysqlUserConfigPrivatelinkAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: string;
    mysqlx?: string;
}

export interface GetServiceMysqlUserConfigPublicAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: string;
    mysqlx?: string;
    prometheus?: string;
}

export interface GetServiceOpensearch {
    opensearchDashboardsUri: string;
}

export interface GetServiceOpensearchUserConfig {
    customDomain?: string;
    disableReplicationFactorAdjustment?: string;
    indexPatterns?: outputs.GetServiceOpensearchUserConfigIndexPattern[];
    indexTemplate?: outputs.GetServiceOpensearchUserConfigIndexTemplate;
    ipFilters?: string[];
    keepIndexRefreshInterval?: string;
    maxIndexCount?: string;
    /**
     * Opensearch specific server provided values
     */
    opensearch?: outputs.GetServiceOpensearchUserConfigOpensearch;
    opensearchDashboards?: outputs.GetServiceOpensearchUserConfigOpensearchDashboards;
    opensearchVersion?: string;
    privateAccess?: outputs.GetServiceOpensearchUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetServiceOpensearchUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetServiceOpensearchUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetServiceOpensearchUserConfigIndexPattern {
    maxIndexCount?: string;
    pattern?: string;
    sortingAlgorithm?: string;
}

export interface GetServiceOpensearchUserConfigIndexTemplate {
    mappingNestedObjectsLimit?: string;
    numberOfReplicas?: string;
    numberOfShards?: string;
}

export interface GetServiceOpensearchUserConfigOpensearch {
    actionAutoCreateIndexEnabled?: string;
    actionDestructiveRequiresName?: string;
    clusterMaxShardsPerNode?: string;
    httpMaxContentLength?: string;
    httpMaxHeaderSize?: string;
    httpMaxInitialLineLength?: string;
    indicesFielddataCacheSize?: string;
    indicesMemoryIndexBufferSize?: string;
    indicesQueriesCacheSize?: string;
    indicesQueryBoolMaxClauseCount?: string;
    overrideMainResponseVersion?: string;
    reindexRemoteWhitelists?: string[];
    searchMaxBuckets?: string;
    threadPoolAnalyzeQueueSize?: string;
    threadPoolAnalyzeSize?: string;
    threadPoolForceMergeSize?: string;
    threadPoolGetQueueSize?: string;
    threadPoolGetSize?: string;
    threadPoolIndexSize?: string;
    threadPoolSearchQueueSize?: string;
    threadPoolSearchSize?: string;
    threadPoolSearchThrottledQueueSize?: string;
    threadPoolSearchThrottledSize?: string;
    threadPoolWriteQueueSize?: string;
    threadPoolWriteSize?: string;
}

export interface GetServiceOpensearchUserConfigOpensearchDashboards {
    enabled?: string;
    maxOldSpaceSize?: string;
    opensearchRequestTimeout?: string;
}

export interface GetServiceOpensearchUserConfigPrivateAccess {
    /**
     * Opensearch specific server provided values
     */
    opensearch?: string;
    opensearchDashboards?: string;
    prometheus?: string;
}

export interface GetServiceOpensearchUserConfigPrivatelinkAccess {
    /**
     * Opensearch specific server provided values
     */
    opensearch?: string;
    opensearchDashboards?: string;
}

export interface GetServiceOpensearchUserConfigPublicAccess {
    /**
     * Opensearch specific server provided values
     */
    opensearch?: string;
    opensearchDashboards?: string;
    prometheus?: string;
}

export interface GetServicePg {
    dbname: string;
    host: string;
    password: string;
    port: number;
    replicaUri: string;
    sslmode: string;
    uri: string;
    user: string;
}

export interface GetServicePgUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    ipFilters?: string[];
    migration?: outputs.GetServicePgUserConfigMigration;
    /**
     * PostgreSQL specific server provided values
     */
    pg?: outputs.GetServicePgUserConfigPg;
    pgReadReplica?: string;
    pgServiceToForkFrom?: string;
    pgVersion?: string;
    pgbouncer?: outputs.GetServicePgUserConfigPgbouncer;
    pglookout?: outputs.GetServicePgUserConfigPglookout;
    privateAccess?: outputs.GetServicePgUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetServicePgUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetServicePgUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    sharedBuffersPercentage?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
    synchronousReplication?: string;
    timescaledb?: outputs.GetServicePgUserConfigTimescaledb;
    variant?: string;
    workMem?: string;
}

export interface GetServicePgUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface GetServicePgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: string;
    autovacuumAnalyzeThreshold?: string;
    autovacuumFreezeMaxAge?: string;
    autovacuumMaxWorkers?: string;
    autovacuumNaptime?: string;
    autovacuumVacuumCostDelay?: string;
    autovacuumVacuumCostLimit?: string;
    autovacuumVacuumScaleFactor?: string;
    autovacuumVacuumThreshold?: string;
    bgwriterDelay?: string;
    bgwriterFlushAfter?: string;
    bgwriterLruMaxpages?: string;
    bgwriterLruMultiplier?: string;
    deadlockTimeout?: string;
    defaultToastCompression?: string;
    idleInTransactionSessionTimeout?: string;
    jit?: string;
    logAutovacuumMinDuration?: string;
    logErrorVerbosity?: string;
    logLinePrefix?: string;
    logMinDurationStatement?: string;
    maxFilesPerProcess?: string;
    maxLocksPerTransaction?: string;
    maxLogicalReplicationWorkers?: string;
    maxParallelWorkers?: string;
    maxParallelWorkersPerGather?: string;
    maxPredLocksPerTransaction?: string;
    maxPreparedTransactions?: string;
    maxReplicationSlots?: string;
    maxSlotWalKeepSize?: string;
    maxStackDepth?: string;
    maxStandbyArchiveDelay?: string;
    maxStandbyStreamingDelay?: string;
    maxWalSenders?: string;
    maxWorkerProcesses?: string;
    pgPartmanBgwInterval?: string;
    pgPartmanBgwRole?: string;
    pgStatStatementsTrack?: string;
    tempFileLimit?: string;
    timezone?: string;
    trackActivityQuerySize?: string;
    trackCommitTimestamp?: string;
    trackFunctions?: string;
    trackIoTiming?: string;
    walSenderTimeout?: string;
    walWriterDelay?: string;
}

export interface GetServicePgUserConfigPgbouncer {
    autodbIdleTimeout?: string;
    autodbMaxDbConnections?: string;
    autodbPoolMode?: string;
    autodbPoolSize?: string;
    ignoreStartupParameters?: string[];
    minPoolSize?: string;
    serverIdleTimeout?: string;
    serverLifetime?: string;
    serverResetQueryAlways?: string;
}

export interface GetServicePgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: string;
}

export interface GetServicePgUserConfigPrivateAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface GetServicePgUserConfigPrivatelinkAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: string;
    pgbouncer?: string;
}

export interface GetServicePgUserConfigPublicAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface GetServicePgUserConfigTimescaledb {
    maxBackgroundWorkers?: string;
}

export interface GetServiceRedi {
}

export interface GetServiceRedisUserConfig {
    ipFilters?: string[];
    migration?: outputs.GetServiceRedisUserConfigMigration;
    privateAccess?: outputs.GetServiceRedisUserConfigPrivateAccess;
    privatelinkAccess?: outputs.GetServiceRedisUserConfigPrivatelinkAccess;
    projectToForkFrom?: string;
    publicAccess?: outputs.GetServiceRedisUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    redisAclChannelsDefault?: string;
    redisIoThreads?: string;
    redisLfuDecayTime?: string;
    redisLfuLogFactor?: string;
    redisMaxmemoryPolicy?: string;
    redisNotifyKeyspaceEvents?: string;
    redisNumberOfDatabases?: string;
    redisPersistence?: string;
    redisPubsubClientOutputBufferLimit?: string;
    redisSsl?: string;
    redisTimeout?: string;
    serviceToForkFrom?: string;
    /**
     * Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
     */
    staticIps?: string;
}

export interface GetServiceRedisUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface GetServiceRedisUserConfigPrivateAccess {
    prometheus?: string;
    /**
     * Redis specific server provided values
     */
    redis?: string;
}

export interface GetServiceRedisUserConfigPrivatelinkAccess {
    /**
     * Redis specific server provided values
     */
    redis?: string;
}

export interface GetServiceRedisUserConfigPublicAccess {
    prometheus?: string;
    /**
     * Redis specific server provided values
     */
    redis?: string;
}

export interface GetServiceServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GrafanaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GrafanaGrafana {
}

export interface GrafanaGrafanaUserConfig {
    /**
     * Enable or disable Grafana alerting functionality
     */
    alertingEnabled?: string;
    /**
     * Default error or timeout setting for new alerting rules
     */
    alertingErrorOrTimeout?: string;
    /**
     * Max number of alert annotations that Grafana stores. 0 (default) keeps all alert annotations.
     */
    alertingMaxAnnotationsToKeep?: string;
    /**
     * Default value for 'no data or null values' for new alerting rules
     */
    alertingNodataOrNullvalues?: string;
    /**
     * Allow embedding Grafana dashboards with iframe/frame/object/embed tags. Disabled by default to limit impact of clickjacking
     */
    allowEmbedding?: string;
    /**
     * Azure AD OAuth integration
     */
    authAzuread?: outputs.GrafanaGrafanaUserConfigAuthAzuread;
    /**
     * Enable or disable basic authentication form, used by Grafana built-in login
     */
    authBasicEnabled?: string;
    /**
     * Generic OAuth integration
     */
    authGenericOauth?: outputs.GrafanaGrafanaUserConfigAuthGenericOauth;
    /**
     * Github Auth integration
     */
    authGithub?: outputs.GrafanaGrafanaUserConfigAuthGithub;
    /**
     * GitLab Auth integration
     */
    authGitlab?: outputs.GrafanaGrafanaUserConfigAuthGitlab;
    /**
     * Google Auth integration
     */
    authGoogle?: outputs.GrafanaGrafanaUserConfigAuthGoogle;
    /**
     * Cookie SameSite attribute: 'strict' prevents sending cookie for cross-site requests, effectively disabling direct linking from other sites to Grafana. 'lax' is the default value.
     */
    cookieSamesite?: string;
    /**
     * Custom domain
     */
    customDomain?: string;
    /**
     * Minimum refresh interval
     */
    dashboardsMinRefreshInterval?: string;
    /**
     * Dashboard versions to keep per dashboard
     */
    dashboardsVersionsToKeep?: string;
    /**
     * Send 'X-Grafana-User' header to data source
     */
    dataproxySendUserHeader?: string;
    /**
     * Timeout for data proxy requests in seconds
     */
    dataproxyTimeout?: string;
    /**
     * Grafana date format specifications
     */
    dateFormats?: outputs.GrafanaGrafanaUserConfigDateFormats;
    /**
     * Set to true to disable gravatar. Defaults to false (gravatar is enabled)
     */
    disableGravatar?: string;
    /**
     * Editors can manage folders, teams and dashboards created by them
     */
    editorsCanAdmin?: string;
    /**
     * External image store settings
     */
    externalImageStorage?: outputs.GrafanaGrafanaUserConfigExternalImageStorage;
    /**
     * Google Analytics ID
     */
    googleAnalyticsUaId?: string;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Enable Grafana /metrics endpoint
     */
    metricsEnabled?: string;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.GrafanaGrafanaUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.GrafanaGrafanaUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.GrafanaGrafanaUserConfigPublicAccess;
    /**
     * Name of the basebackup to restore in forked service
     */
    recoveryBasebackupName?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * SMTP server settings
     */
    smtpServer?: outputs.GrafanaGrafanaUserConfigSmtpServer;
    /**
     * Static IP addresses
     */
    staticIps?: string;
    /**
     * Auto-assign new users on signup to main organization. Defaults to false
     */
    userAutoAssignOrg?: string;
    /**
     * Set role for new signups. Defaults to Viewer
     */
    userAutoAssignOrgRole?: string;
    /**
     * Users with view-only permission can edit but not save dashboards
     */
    viewersCanEdit?: string;
}

export interface GrafanaGrafanaUserConfigAuthAzuread {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedGroups?: string[];
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface GrafanaGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedOrganizations?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    name?: string;
    scopes?: string[];
    tokenUrl?: string;
}

export interface GrafanaGrafanaUserConfigAuthGithub {
    allowSignUp?: string;
    allowedOrganizations?: string[];
    clientId?: string;
    clientSecret?: string;
    teamIds?: string[];
}

export interface GrafanaGrafanaUserConfigAuthGitlab {
    allowSignUp?: string;
    allowedGroups?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface GrafanaGrafanaUserConfigAuthGoogle {
    allowSignUp?: string;
    allowedDomains?: string[];
    clientId?: string;
    clientSecret?: string;
}

export interface GrafanaGrafanaUserConfigDateFormats {
    defaultTimezone?: string;
    fullDate?: string;
    intervalDay?: string;
    intervalHour?: string;
    intervalMinute?: string;
    intervalMonth?: string;
    intervalSecond?: string;
    intervalYear?: string;
}

export interface GrafanaGrafanaUserConfigExternalImageStorage {
    accessKey?: string;
    bucketUrl?: string;
    provider?: string;
    secretKey?: string;
}

export interface GrafanaGrafanaUserConfigPrivateAccess {
    /**
     * Grafana server provided values
     */
    grafana?: string;
}

export interface GrafanaGrafanaUserConfigPrivatelinkAccess {
    /**
     * Grafana server provided values
     */
    grafana?: string;
}

export interface GrafanaGrafanaUserConfigPublicAccess {
    /**
     * Grafana server provided values
     */
    grafana?: string;
}

export interface GrafanaGrafanaUserConfigSmtpServer {
    fromAddress?: string;
    fromName?: string;
    host?: string;
    password?: string;
    port?: string;
    skipVerify?: string;
    starttlsPolicy?: string;
    username?: string;
}

export interface GrafanaServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface InfluxDbComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface InfluxDbInfluxdb {
    databaseName: string;
}

export interface InfluxDbInfluxdbUserConfig {
    /**
     * Custom domain
     */
    customDomain?: string;
    /**
     * influxdb.conf configuration values
     */
    influxdb?: outputs.InfluxDbInfluxdbUserConfigInfluxdb;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.InfluxDbInfluxdbUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.InfluxDbInfluxdbUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.InfluxDbInfluxdbUserConfigPublicAccess;
    /**
     * Name of the basebackup to restore in forked service
     */
    recoveryBasebackupName?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface InfluxDbInfluxdbUserConfigInfluxdb {
    logQueriesAfter?: string;
    maxConnectionLimit?: string;
    maxRowLimit?: string;
    maxSelectBuckets?: string;
    maxSelectPoint?: string;
    queryTimeout?: string;
}

export interface InfluxDbInfluxdbUserConfigPrivateAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: string;
}

export interface InfluxDbInfluxdbUserConfigPrivatelinkAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: string;
}

export interface InfluxDbInfluxdbUserConfigPublicAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: string;
}

export interface InfluxDbServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface KafkaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface KafkaConnectComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface KafkaConnectKafkaConnect {
}

export interface KafkaConnectKafkaConnectUserConfig {
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Kafka Connect configuration values
     */
    kafkaConnect?: outputs.KafkaConnectKafkaConnectUserConfigKafkaConnect;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.KafkaConnectKafkaConnectUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.KafkaConnectKafkaConnectUserConfigPrivatelinkAccess;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.KafkaConnectKafkaConnectUserConfigPublicAccess;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface KafkaConnectKafkaConnectUserConfigKafkaConnect {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerFetchMaxBytes?: string;
    consumerIsolationLevel?: string;
    consumerMaxPartitionFetchBytes?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    producerMaxRequestSize?: string;
    sessionTimeoutMs?: string;
}

export interface KafkaConnectKafkaConnectUserConfigPrivateAccess {
    /**
     * Kafka Connect server provided values
     */
    kafkaConnect?: string;
    prometheus?: string;
}

export interface KafkaConnectKafkaConnectUserConfigPrivatelinkAccess {
    /**
     * Kafka Connect server provided values
     */
    kafkaConnect?: string;
}

export interface KafkaConnectKafkaConnectUserConfigPublicAccess {
    /**
     * Kafka Connect server provided values
     */
    kafkaConnect?: string;
    prometheus?: string;
}

export interface KafkaConnectServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface KafkaConnectorTask {
    connector: string;
    /**
     * List of tasks of a connector.
     */
    task: number;
}

export interface KafkaKafka {
    /**
     * The Kafka client certificate
     */
    accessCert: string;
    /**
     * The Kafka client certificate key
     */
    accessKey: string;
    /**
     * The Kafka Connect URI, if any
     */
    connectUri: string;
    /**
     * The Kafka REST URI, if any
     */
    restUri: string;
    /**
     * The Schema Registry URI, if any
     */
    schemaRegistryUri: string;
}

export interface KafkaKafkaUserConfig {
    /**
     * Custom domain
     */
    customDomain?: string;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Kafka broker configuration values
     */
    kafka?: outputs.KafkaKafkaUserConfigKafka;
    /**
     * Kafka authentication methods
     */
    kafkaAuthenticationMethods?: outputs.KafkaKafkaUserConfigKafkaAuthenticationMethods;
    /**
     * Enable Kafka Connect service
     */
    kafkaConnect?: string;
    /**
     * Kafka Connect configuration values
     */
    kafkaConnectConfig?: outputs.KafkaKafkaUserConfigKafkaConnectConfig;
    /**
     * Enable Kafka-REST service
     */
    kafkaRest?: string;
    /**
     * Kafka REST configuration
     */
    kafkaRestConfig?: outputs.KafkaKafkaUserConfigKafkaRestConfig;
    /**
     * Kafka major version
     */
    kafkaVersion?: string;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.KafkaKafkaUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.KafkaKafkaUserConfigPrivatelinkAccess;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.KafkaKafkaUserConfigPublicAccess;
    /**
     * Enable Schema-Registry service
     */
    schemaRegistry?: string;
    /**
     * Schema Registry configuration
     */
    schemaRegistryConfig?: outputs.KafkaKafkaUserConfigSchemaRegistryConfig;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface KafkaKafkaUserConfigKafka {
    autoCreateTopicsEnable?: string;
    compressionType?: string;
    connectionsMaxIdleMs?: string;
    defaultReplicationFactor?: string;
    groupInitialRebalanceDelayMs?: string;
    groupMaxSessionTimeoutMs?: string;
    groupMinSessionTimeoutMs?: string;
    logCleanerDeleteRetentionMs?: string;
    logCleanerMaxCompactionLagMs?: string;
    logCleanerMinCleanableRatio?: string;
    logCleanerMinCompactionLagMs?: string;
    logCleanupPolicy?: string;
    logFlushIntervalMessages?: string;
    logFlushIntervalMs?: string;
    logIndexIntervalBytes?: string;
    logIndexSizeMaxBytes?: string;
    logMessageDownconversionEnable?: string;
    logMessageTimestampDifferenceMaxMs?: string;
    logMessageTimestampType?: string;
    logPreallocate?: string;
    logRetentionBytes?: string;
    logRetentionHours?: string;
    logRetentionMs?: string;
    logRollJitterMs?: string;
    logRollMs?: string;
    logSegmentBytes?: string;
    logSegmentDeleteDelayMs?: string;
    maxConnectionsPerIp?: string;
    maxIncrementalFetchSessionCacheSlots?: string;
    messageMaxBytes?: string;
    minInsyncReplicas?: string;
    numPartitions?: string;
    offsetsRetentionMinutes?: string;
    producerPurgatoryPurgeIntervalRequests?: string;
    replicaFetchMaxBytes?: string;
    replicaFetchResponseMaxBytes?: string;
    socketRequestMaxBytes?: string;
    transactionRemoveExpiredTransactionCleanupIntervalMs?: string;
    transactionStateLogSegmentBytes?: string;
}

export interface KafkaKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: string;
    sasl?: string;
}

export interface KafkaKafkaUserConfigKafkaConnectConfig {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerFetchMaxBytes?: string;
    consumerIsolationLevel?: string;
    consumerMaxPartitionFetchBytes?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    producerMaxRequestSize?: string;
    sessionTimeoutMs?: string;
}

export interface KafkaKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: string;
    consumerRequestMaxBytes?: string;
    consumerRequestTimeoutMs?: string;
    producerAcks?: string;
    producerLingerMs?: string;
    simpleconsumerPoolSizeMax?: string;
}

export interface KafkaKafkaUserConfigPrivateAccess {
    prometheus?: string;
}

export interface KafkaKafkaUserConfigPrivatelinkAccess {
    /**
     * Kafka server provided values
     */
    kafka?: string;
    kafkaConnect?: string;
    kafkaRest?: string;
    schemaRegistry?: string;
}

export interface KafkaKafkaUserConfigPublicAccess {
    /**
     * Kafka server provided values
     */
    kafka?: string;
    kafkaConnect?: string;
    kafkaRest?: string;
    prometheus?: string;
    schemaRegistry?: string;
}

export interface KafkaKafkaUserConfigSchemaRegistryConfig {
    leaderEligibility?: string;
    topicName?: string;
}

export interface KafkaMirrorMakerComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface KafkaMirrorMakerKafkaMirrormaker {
}

export interface KafkaMirrorMakerKafkaMirrormakerUserConfig {
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Kafka MirrorMaker configuration values
     */
    kafkaMirrormaker?: outputs.KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker {
    emitCheckpointsEnabled?: string;
    emitCheckpointsIntervalSeconds?: string;
    refreshGroupsEnabled?: string;
    refreshGroupsIntervalSeconds?: string;
    refreshTopicsEnabled?: string;
    refreshTopicsIntervalSeconds?: string;
    syncGroupOffsetsEnabled?: string;
    syncGroupOffsetsIntervalSeconds?: string;
    syncTopicConfigsEnabled?: string;
    tasksMaxPerCpu?: string;
}

export interface KafkaMirrorMakerServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface KafkaServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface KafkaTopicConfig {
    /**
     * cleanup.policy value
     */
    cleanupPolicy?: string;
    /**
     * compression.type value
     */
    compressionType?: string;
    /**
     * delete.retention.ms value
     */
    deleteRetentionMs?: string;
    /**
     * file.delete.delay.ms value
     */
    fileDeleteDelayMs?: string;
    /**
     * flush.messages value
     */
    flushMessages?: string;
    /**
     * flush.ms value
     */
    flushMs?: string;
    /**
     * index.interval.bytes value
     */
    indexIntervalBytes?: string;
    /**
     * max.compaction.lag.ms value
     */
    maxCompactionLagMs?: string;
    /**
     * max.message.bytes value
     */
    maxMessageBytes?: string;
    /**
     * message.downconversion.enable value
     */
    messageDownconversionEnable?: string;
    /**
     * message.format.version value
     */
    messageFormatVersion?: string;
    /**
     * message.timestamp.difference.max.ms value
     */
    messageTimestampDifferenceMaxMs?: string;
    /**
     * message.timestamp.type value
     */
    messageTimestampType?: string;
    /**
     * min.cleanable.dirty.ratio value
     */
    minCleanableDirtyRatio?: string;
    /**
     * min.compaction.lag.ms value
     */
    minCompactionLagMs?: string;
    /**
     * min.insync.replicas value
     */
    minInsyncReplicas?: string;
    /**
     * preallocate value
     */
    preallocate?: string;
    /**
     * retention.bytes value
     */
    retentionBytes?: string;
    /**
     * retention.ms value
     */
    retentionMs?: string;
    /**
     * segment.bytes value
     */
    segmentBytes?: string;
    /**
     * segment.index.bytes value
     */
    segmentIndexBytes?: string;
    /**
     * segment.jitter.ms value
     */
    segmentJitterMs?: string;
    /**
     * segment.ms value
     */
    segmentMs?: string;
    /**
     * unclean.leader.election.enable value
     */
    uncleanLeaderElectionEnable?: string;
}

export interface KafkaTopicTag {
    /**
     * Topic tag key. Maximum Length: `64`.
     */
    key: string;
    /**
     * Topic tag value. Maximum Length: `256`.
     */
    value?: string;
}

export interface M3AggregatorComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface M3AggregatorM3aggregator {
}

export interface M3AggregatorM3aggregatorUserConfig {
    /**
     * Custom domain
     */
    customDomain?: string;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * M3 major version (deprecated, use m3aggregator_version)
     */
    m3Version?: string;
    /**
     * M3 major version (the minimum compatible version)
     */
    m3aggregatorVersion?: string;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface M3AggregatorServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface M3DbComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface M3DbM3db {
}

export interface M3DbM3dbUserConfig {
    /**
     * Custom domain
     */
    customDomain?: string;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * M3 limits
     */
    limits?: outputs.M3DbM3dbUserConfigLimits;
    /**
     * M3 major version (deprecated, use m3db_version)
     */
    m3Version?: string;
    /**
     * Enable Graphite ingestion using Carbon plaintext protocol
     */
    m3coordinatorEnableGraphiteCarbonIngest?: string;
    /**
     * M3 major version (the minimum compatible version)
     */
    m3dbVersion?: string;
    /**
     * List of M3 namespaces
     */
    namespaces?: outputs.M3DbM3dbUserConfigNamespace[];
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.M3DbM3dbUserConfigPrivateAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.M3DbM3dbUserConfigPublicAccess;
    /**
     * M3 rules
     */
    rules?: outputs.M3DbM3dbUserConfigRules;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface M3DbM3dbUserConfigLimits {
    queryRequireExhaustive?: string;
    querySeries?: string;
}

export interface M3DbM3dbUserConfigNamespace {
    name?: string;
    options?: outputs.M3DbM3dbUserConfigNamespaceOptions;
    resolution?: string;
    type?: string;
}

export interface M3DbM3dbUserConfigNamespaceOptions {
    retentionOptions?: outputs.M3DbM3dbUserConfigNamespaceOptionsRetentionOptions;
    snapshotEnabled?: string;
    writesToCommitlog?: string;
}

export interface M3DbM3dbUserConfigNamespaceOptionsRetentionOptions {
    blockDataExpiryDuration?: string;
    blocksizeDuration?: string;
    bufferFutureDuration?: string;
    bufferPastDuration?: string;
    retentionPeriodDuration?: string;
}

export interface M3DbM3dbUserConfigPrivateAccess {
    m3coordinator?: string;
}

export interface M3DbM3dbUserConfigPublicAccess {
    m3coordinator?: string;
}

export interface M3DbM3dbUserConfigRules {
    mappings?: outputs.M3DbM3dbUserConfigRulesMapping[];
}

export interface M3DbM3dbUserConfigRulesMapping {
    aggregations?: string[];
    drop?: string;
    filter?: string;
    name?: string;
    namespaces?: string[];
    tags?: outputs.M3DbM3dbUserConfigRulesMappingTag[];
}

export interface M3DbM3dbUserConfigRulesMappingTag {
    name?: string;
    value?: string;
}

export interface M3DbServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface MySqlComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface MySqlMysql {
}

export interface MySqlMysqlUserConfig {
    /**
     * Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
     */
    adminPassword?: string;
    /**
     * Custom username for admin user. This must be set only when a new service is being created.
     */
    adminUsername?: string;
    /**
     * The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
     */
    backupHour?: string;
    /**
     * The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
     */
    backupMinute?: string;
    /**
     * The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
     */
    binlogRetentionPeriod?: string;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Migrate data from existing server
     */
    migration?: outputs.MySqlMysqlUserConfigMigration;
    /**
     * mysql.conf configuration values
     */
    mysql?: outputs.MySqlMysqlUserConfigMysql;
    /**
     * MySQL major version
     */
    mysqlVersion?: string;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.MySqlMysqlUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.MySqlMysqlUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.MySqlMysqlUserConfigPublicAccess;
    /**
     * Recovery target time when forking a service. This has effect only when a new service is being created.
     */
    recoveryTargetTime?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface MySqlMysqlUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface MySqlMysqlUserConfigMysql {
    connectTimeout?: string;
    defaultTimeZone?: string;
    groupConcatMaxLen?: string;
    informationSchemaStatsExpiry?: string;
    innodbFtMinTokenSize?: string;
    innodbFtServerStopwordTable?: string;
    innodbLockWaitTimeout?: string;
    innodbLogBufferSize?: string;
    innodbOnlineAlterLogMaxSize?: string;
    innodbPrintAllDeadlocks?: string;
    innodbRollbackOnTimeout?: string;
    interactiveTimeout?: string;
    internalTmpMemStorageEngine?: string;
    longQueryTime?: string;
    maxAllowedPacket?: string;
    maxHeapTableSize?: string;
    netReadTimeout?: string;
    netWriteTimeout?: string;
    slowQueryLog?: string;
    sortBufferSize?: string;
    sqlMode?: string;
    sqlRequirePrimaryKey?: string;
    tmpTableSize?: string;
    waitTimeout?: string;
}

export interface MySqlMysqlUserConfigPrivateAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: string;
    mysqlx?: string;
    prometheus?: string;
}

export interface MySqlMysqlUserConfigPrivatelinkAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: string;
    mysqlx?: string;
}

export interface MySqlMysqlUserConfigPublicAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: string;
    mysqlx?: string;
    prometheus?: string;
}

export interface MySqlServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface OpenSearchComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface OpenSearchOpensearch {
    opensearchDashboardsUri: string;
}

export interface OpenSearchOpensearchUserConfig {
    /**
     * Custom domain
     */
    customDomain?: string;
    /**
     * Disable replication factor adjustment
     */
    disableReplicationFactorAdjustment?: string;
    /**
     * Index patterns
     */
    indexPatterns?: outputs.OpenSearchOpensearchUserConfigIndexPattern[];
    /**
     * Template settings for all new indexes
     */
    indexTemplate?: outputs.OpenSearchOpensearchUserConfigIndexTemplate;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Don't reset index.refresh_interval to the default value
     */
    keepIndexRefreshInterval?: string;
    /**
     * Maximum index count
     */
    maxIndexCount?: string;
    /**
     * OpenSearch settings
     */
    opensearch?: outputs.OpenSearchOpensearchUserConfigOpensearch;
    /**
     * OpenSearch Dashboards settings
     */
    opensearchDashboards?: outputs.OpenSearchOpensearchUserConfigOpensearchDashboards;
    /**
     * OpenSearch major version
     */
    opensearchVersion?: string;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.OpenSearchOpensearchUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.OpenSearchOpensearchUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.OpenSearchOpensearchUserConfigPublicAccess;
    /**
     * Name of the basebackup to restore in forked service
     */
    recoveryBasebackupName?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface OpenSearchOpensearchUserConfigIndexPattern {
    maxIndexCount?: string;
    pattern?: string;
    sortingAlgorithm?: string;
}

export interface OpenSearchOpensearchUserConfigIndexTemplate {
    mappingNestedObjectsLimit?: string;
    numberOfReplicas?: string;
    numberOfShards?: string;
}

export interface OpenSearchOpensearchUserConfigOpensearch {
    actionAutoCreateIndexEnabled?: string;
    actionDestructiveRequiresName?: string;
    clusterMaxShardsPerNode?: string;
    httpMaxContentLength?: string;
    httpMaxHeaderSize?: string;
    httpMaxInitialLineLength?: string;
    indicesFielddataCacheSize?: string;
    indicesMemoryIndexBufferSize?: string;
    indicesQueriesCacheSize?: string;
    indicesQueryBoolMaxClauseCount?: string;
    overrideMainResponseVersion?: string;
    reindexRemoteWhitelists?: string[];
    searchMaxBuckets?: string;
    threadPoolAnalyzeQueueSize?: string;
    threadPoolAnalyzeSize?: string;
    threadPoolForceMergeSize?: string;
    threadPoolGetQueueSize?: string;
    threadPoolGetSize?: string;
    threadPoolIndexSize?: string;
    threadPoolSearchQueueSize?: string;
    threadPoolSearchSize?: string;
    threadPoolSearchThrottledQueueSize?: string;
    threadPoolSearchThrottledSize?: string;
    threadPoolWriteQueueSize?: string;
    threadPoolWriteSize?: string;
}

export interface OpenSearchOpensearchUserConfigOpensearchDashboards {
    enabled?: string;
    maxOldSpaceSize?: string;
    opensearchRequestTimeout?: string;
}

export interface OpenSearchOpensearchUserConfigPrivateAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: string;
    opensearchDashboards?: string;
    prometheus?: string;
}

export interface OpenSearchOpensearchUserConfigPrivatelinkAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: string;
    opensearchDashboards?: string;
}

export interface OpenSearchOpensearchUserConfigPublicAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: string;
    opensearchDashboards?: string;
    prometheus?: string;
}

export interface OpenSearchServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface PgComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface PgPg {
    /**
     * Primary PostgreSQL database name
     */
    dbname: string;
    /**
     * PostgreSQL master node host IP or name
     */
    host: string;
    /**
     * PostgreSQL admin user password
     */
    password: string;
    /**
     * PostgreSQL port
     */
    port: number;
    /**
     * PostgreSQL replica URI for services with a replica
     */
    replicaUri: string;
    /**
     * PostgreSQL sslmode setting (currently always "require")
     */
    sslmode: string;
    /**
     * PostgreSQL master connection URI
     */
    uri: string;
    /**
     * PostgreSQL admin user name
     */
    user: string;
}

export interface PgPgUserConfig {
    /**
     * Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
     */
    adminPassword?: string;
    /**
     * Custom username for admin user. This must be set only when a new service is being created.
     */
    adminUsername?: string;
    /**
     * The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
     */
    backupHour?: string;
    /**
     * The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
     */
    backupMinute?: string;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Migrate data from existing server
     */
    migration?: outputs.PgPgUserConfigMigration;
    /**
     * postgresql.conf configuration values
     */
    pg?: outputs.PgPgUserConfigPg;
    /**
     * Should the service which is being forked be a read replica (deprecated, use readReplica service integration instead).
     */
    pgReadReplica?: string;
    /**
     * Name of the PG Service from which to fork (deprecated, use service*to*fork_from). This has effect only when a new service is being created.
     */
    pgServiceToForkFrom?: string;
    /**
     * PostgreSQL major version
     */
    pgVersion?: string;
    /**
     * PGBouncer connection pooling settings
     */
    pgbouncer?: outputs.PgPgUserConfigPgbouncer;
    /**
     * PGLookout settings
     */
    pglookout?: outputs.PgPgUserConfigPglookout;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.PgPgUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.PgPgUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.PgPgUserConfigPublicAccess;
    /**
     * Recovery target time when forking a service. This has effect only when a new service is being created.
     */
    recoveryTargetTime?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * shared*buffers*percentage
     */
    sharedBuffersPercentage?: string;
    /**
     * Static IP addresses
     */
    staticIps?: string;
    /**
     * Synchronous replication type. Note that the service plan also needs to support synchronous replication.
     */
    synchronousReplication?: string;
    /**
     * TimescaleDB extension configuration values
     */
    timescaledb?: outputs.PgPgUserConfigTimescaledb;
    /**
     * Variant of the PostgreSQL service, may affect the features that are exposed by default
     */
    variant?: string;
    /**
     * work_mem
     */
    workMem?: string;
}

export interface PgPgUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface PgPgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: string;
    autovacuumAnalyzeThreshold?: string;
    autovacuumFreezeMaxAge?: string;
    autovacuumMaxWorkers?: string;
    autovacuumNaptime?: string;
    autovacuumVacuumCostDelay?: string;
    autovacuumVacuumCostLimit?: string;
    autovacuumVacuumScaleFactor?: string;
    autovacuumVacuumThreshold?: string;
    bgwriterDelay?: string;
    bgwriterFlushAfter?: string;
    bgwriterLruMaxpages?: string;
    bgwriterLruMultiplier?: string;
    deadlockTimeout?: string;
    defaultToastCompression?: string;
    idleInTransactionSessionTimeout?: string;
    jit?: string;
    logAutovacuumMinDuration?: string;
    logErrorVerbosity?: string;
    logLinePrefix?: string;
    logMinDurationStatement?: string;
    maxFilesPerProcess?: string;
    maxLocksPerTransaction?: string;
    maxLogicalReplicationWorkers?: string;
    maxParallelWorkers?: string;
    maxParallelWorkersPerGather?: string;
    maxPredLocksPerTransaction?: string;
    maxPreparedTransactions?: string;
    maxReplicationSlots?: string;
    maxSlotWalKeepSize?: string;
    maxStackDepth?: string;
    maxStandbyArchiveDelay?: string;
    maxStandbyStreamingDelay?: string;
    maxWalSenders?: string;
    maxWorkerProcesses?: string;
    pgPartmanBgwDotInterval?: string;
    pgPartmanBgwDotRole?: string;
    pgStatStatementsDotTrack?: string;
    tempFileLimit?: string;
    timezone?: string;
    trackActivityQuerySize?: string;
    trackCommitTimestamp?: string;
    trackFunctions?: string;
    trackIoTiming?: string;
    walSenderTimeout?: string;
    walWriterDelay?: string;
}

export interface PgPgUserConfigPgbouncer {
    autodbIdleTimeout?: string;
    autodbMaxDbConnections?: string;
    autodbPoolMode?: string;
    autodbPoolSize?: string;
    ignoreStartupParameters?: string[];
    minPoolSize?: string;
    serverIdleTimeout?: string;
    serverLifetime?: string;
    serverResetQueryAlways?: string;
}

export interface PgPgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: string;
}

export interface PgPgUserConfigPrivateAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface PgPgUserConfigPrivatelinkAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: string;
    pgbouncer?: string;
}

export interface PgPgUserConfigPublicAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface PgPgUserConfigTimescaledb {
    maxBackgroundWorkers?: string;
}

export interface PgServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface RedisComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface RedisRedi {
}

export interface RedisRedisUserConfig {
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Migrate data from existing server
     */
    migration?: outputs.RedisRedisUserConfigMigration;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.RedisRedisUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.RedisRedisUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.RedisRedisUserConfigPublicAccess;
    /**
     * Name of the basebackup to restore in forked service
     */
    recoveryBasebackupName?: string;
    /**
     * Default ACL for pub/sub channels used when Redis user is created
     */
    redisAclChannelsDefault?: string;
    /**
     * Redis IO thread count
     */
    redisIoThreads?: string;
    /**
     * LFU maxmemory-policy counter decay time in minutes
     */
    redisLfuDecayTime?: string;
    /**
     * Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies
     */
    redisLfuLogFactor?: string;
    /**
     * Redis maxmemory-policy
     */
    redisMaxmemoryPolicy?: string;
    /**
     * Set notify-keyspace-events option
     */
    redisNotifyKeyspaceEvents?: string;
    /**
     * Number of redis databases
     */
    redisNumberOfDatabases?: string;
    /**
     * Redis persistence
     */
    redisPersistence?: string;
    /**
     * Pub/sub client output buffer hard limit in MB
     */
    redisPubsubClientOutputBufferLimit?: string;
    /**
     * Require SSL to access Redis
     */
    redisSsl?: string;
    /**
     * Redis idle connection timeout
     */
    redisTimeout?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface RedisRedisUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface RedisRedisUserConfigPrivateAccess {
    prometheus?: string;
    /**
     * Redis server provided values
     */
    redis?: string;
}

export interface RedisRedisUserConfigPrivatelinkAccess {
    /**
     * Redis server provided values
     */
    redis?: string;
}

export interface RedisRedisUserConfigPublicAccess {
    prometheus?: string;
    /**
     * Redis server provided values
     */
    redis?: string;
}

export interface RedisServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}

export interface ServiceCassandra {
}

export interface ServiceCassandraUserConfig {
    /**
     * cassandra configuration values
     */
    cassandra?: outputs.ServiceCassandraUserConfigCassandra;
    /**
     * Cassandra major version
     */
    cassandraVersion?: string;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Migration mode for the sstableloader utility
     */
    migrateSstableloader?: string;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.ServiceCassandraUserConfigPrivateAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.ServiceCassandraUserConfigPublicAccess;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface ServiceCassandraUserConfigCassandra {
    batchSizeFailThresholdInKb?: string;
    batchSizeWarnThresholdInKb?: string;
}

export interface ServiceCassandraUserConfigPrivateAccess {
    prometheus?: string;
}

export interface ServiceCassandraUserConfigPublicAccess {
    prometheus?: string;
}

export interface ServiceClickhouse {
}

export interface ServiceClickhouseUserConfig {
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
}

export interface ServiceComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface ServiceElasticsearch {
    kibanaUri: string;
}

export interface ServiceElasticsearchUserConfig {
    /**
     * Custom domain
     */
    customDomain?: string;
    /**
     * Disable replication factor adjustment
     */
    disableReplicationFactorAdjustment?: string;
    /**
     * Elasticsearch settings
     */
    elasticsearch?: outputs.ServiceElasticsearchUserConfigElasticsearch;
    /**
     * Elasticsearch major version
     */
    elasticsearchVersion?: string;
    /**
     * Index patterns
     */
    indexPatterns?: outputs.ServiceElasticsearchUserConfigIndexPattern[];
    /**
     * Template settings for all new indexes
     */
    indexTemplate?: outputs.ServiceElasticsearchUserConfigIndexTemplate;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Don't reset index.refresh_interval to the default value
     */
    keepIndexRefreshInterval?: string;
    /**
     * Kibana settings
     */
    kibana?: outputs.ServiceElasticsearchUserConfigKibana;
    /**
     * Maximum index count
     */
    maxIndexCount?: string;
    /**
     * OpenSearch major version
     */
    opensearchVersion?: string;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.ServiceElasticsearchUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.ServiceElasticsearchUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.ServiceElasticsearchUserConfigPublicAccess;
    /**
     * Name of the basebackup to restore in forked service
     */
    recoveryBasebackupName?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface ServiceElasticsearchUserConfigElasticsearch {
    actionAutoCreateIndexEnabled?: string;
    actionDestructiveRequiresName?: string;
    clusterMaxShardsPerNode?: string;
    httpMaxContentLength?: string;
    httpMaxHeaderSize?: string;
    httpMaxInitialLineLength?: string;
    indicesFielddataCacheSize?: string;
    indicesMemoryIndexBufferSize?: string;
    indicesQueriesCacheSize?: string;
    indicesQueryBoolMaxClauseCount?: string;
    overrideMainResponseVersion?: string;
    reindexRemoteWhitelists?: string[];
    searchMaxBuckets?: string;
    threadPoolAnalyzeQueueSize?: string;
    threadPoolAnalyzeSize?: string;
    threadPoolForceMergeSize?: string;
    threadPoolGetQueueSize?: string;
    threadPoolGetSize?: string;
    threadPoolIndexQueueSize?: string;
    threadPoolIndexSize?: string;
    threadPoolSearchQueueSize?: string;
    threadPoolSearchSize?: string;
    threadPoolSearchThrottledQueueSize?: string;
    threadPoolSearchThrottledSize?: string;
    threadPoolWriteQueueSize?: string;
    threadPoolWriteSize?: string;
}

export interface ServiceElasticsearchUserConfigIndexPattern {
    maxIndexCount?: string;
    pattern?: string;
    sortingAlgorithm?: string;
}

export interface ServiceElasticsearchUserConfigIndexTemplate {
    mappingNestedObjectsLimit?: string;
    numberOfReplicas?: string;
    numberOfShards?: string;
}

export interface ServiceElasticsearchUserConfigKibana {
    elasticsearchRequestTimeout?: string;
    enabled?: string;
    maxOldSpaceSize?: string;
}

export interface ServiceElasticsearchUserConfigPrivateAccess {
    /**
     * Elasticsearch specific server provided values
     */
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface ServiceElasticsearchUserConfigPrivatelinkAccess {
    /**
     * Elasticsearch specific server provided values
     */
    elasticsearch?: string;
    kibana?: string;
}

export interface ServiceElasticsearchUserConfigPublicAccess {
    /**
     * Elasticsearch specific server provided values
     */
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface ServiceFlink {
    /**
     * Host and Port of a Flink server
     */
    hostPorts: string[];
}

export interface ServiceFlinkUserConfig {
    /**
     * Flink execution.checkpointing.interval in milliseconds
     */
    executionCheckpointingIntervalMs?: string;
    /**
     * Flink execution.checkpointing.timeout in milliseconds
     */
    executionCheckpointingTimeoutMs?: string;
    /**
     * Flink major version
     */
    flinkVersion?: string;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Flink taskmanager.numberOfTaskSlots
     */
    numberOfTaskSlots?: string;
    /**
     * Flink parallelism.default
     */
    parallelismDefault?: string;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.ServiceFlinkUserConfigPrivatelinkAccess;
    /**
     * Flink restart-strategy
     */
    restartStrategy?: string;
    /**
     * Flink restart-strategy.failure-rate.delay in seconds
     */
    restartStrategyDelaySec?: string;
    /**
     * Flink restart-strategy.failure-rate.failure-rate-interval in minutes
     */
    restartStrategyFailureRateIntervalMin?: string;
    /**
     * Flink restart-strategy.failure-rate.max-failures-per-interval
     */
    restartStrategyMaxFailures?: string;
}

export interface ServiceFlinkUserConfigPrivatelinkAccess {
    /**
     * Flink specific server provided values
     */
    flink?: string;
}

export interface ServiceGrafana {
}

export interface ServiceGrafanaUserConfig {
    /**
     * Enable or disable Grafana alerting functionality
     */
    alertingEnabled?: string;
    /**
     * Default error or timeout setting for new alerting rules
     */
    alertingErrorOrTimeout?: string;
    /**
     * Max number of alert annotations that Grafana stores. 0 (default) keeps all alert annotations.
     */
    alertingMaxAnnotationsToKeep?: string;
    /**
     * Default value for 'no data or null values' for new alerting rules
     */
    alertingNodataOrNullvalues?: string;
    /**
     * Allow embedding Grafana dashboards with iframe/frame/object/embed tags. Disabled by default to limit impact of clickjacking
     */
    allowEmbedding?: string;
    /**
     * Azure AD OAuth integration
     */
    authAzuread?: outputs.ServiceGrafanaUserConfigAuthAzuread;
    /**
     * Enable or disable basic authentication form, used by Grafana built-in login
     */
    authBasicEnabled?: string;
    /**
     * Generic OAuth integration
     */
    authGenericOauth?: outputs.ServiceGrafanaUserConfigAuthGenericOauth;
    /**
     * Github Auth integration
     */
    authGithub?: outputs.ServiceGrafanaUserConfigAuthGithub;
    /**
     * GitLab Auth integration
     */
    authGitlab?: outputs.ServiceGrafanaUserConfigAuthGitlab;
    /**
     * Google Auth integration
     */
    authGoogle?: outputs.ServiceGrafanaUserConfigAuthGoogle;
    /**
     * Cookie SameSite attribute: 'strict' prevents sending cookie for cross-site requests, effectively disabling direct linking from other sites to Grafana. 'lax' is the default value.
     */
    cookieSamesite?: string;
    /**
     * Custom domain
     */
    customDomain?: string;
    /**
     * Minimum refresh interval
     */
    dashboardsMinRefreshInterval?: string;
    /**
     * Dashboard versions to keep per dashboard
     */
    dashboardsVersionsToKeep?: string;
    /**
     * Send 'X-Grafana-User' header to data source
     */
    dataproxySendUserHeader?: string;
    /**
     * Timeout for data proxy requests in seconds
     */
    dataproxyTimeout?: string;
    /**
     * Grafana date format specifications
     */
    dateFormats?: outputs.ServiceGrafanaUserConfigDateFormats;
    /**
     * Set to true to disable gravatar. Defaults to false (gravatar is enabled)
     */
    disableGravatar?: string;
    /**
     * Editors can manage folders, teams and dashboards created by them
     */
    editorsCanAdmin?: string;
    /**
     * External image store settings
     */
    externalImageStorage?: outputs.ServiceGrafanaUserConfigExternalImageStorage;
    /**
     * Google Analytics ID
     */
    googleAnalyticsUaId?: string;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Enable Grafana /metrics endpoint
     */
    metricsEnabled?: string;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.ServiceGrafanaUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.ServiceGrafanaUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.ServiceGrafanaUserConfigPublicAccess;
    /**
     * Name of the basebackup to restore in forked service
     */
    recoveryBasebackupName?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * SMTP server settings
     */
    smtpServer?: outputs.ServiceGrafanaUserConfigSmtpServer;
    /**
     * Static IP addresses
     */
    staticIps?: string;
    /**
     * Auto-assign new users on signup to main organization. Defaults to false
     */
    userAutoAssignOrg?: string;
    /**
     * Set role for new signups. Defaults to Viewer
     */
    userAutoAssignOrgRole?: string;
    /**
     * Users with view-only permission can edit but not save dashboards
     */
    viewersCanEdit?: string;
}

export interface ServiceGrafanaUserConfigAuthAzuread {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedGroups?: string[];
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface ServiceGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedOrganizations?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    name?: string;
    scopes?: string[];
    tokenUrl?: string;
}

export interface ServiceGrafanaUserConfigAuthGithub {
    allowSignUp?: string;
    allowedOrganizations?: string[];
    clientId?: string;
    clientSecret?: string;
    teamIds?: string[];
}

export interface ServiceGrafanaUserConfigAuthGitlab {
    allowSignUp?: string;
    allowedGroups?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface ServiceGrafanaUserConfigAuthGoogle {
    allowSignUp?: string;
    allowedDomains?: string[];
    clientId?: string;
    clientSecret?: string;
}

export interface ServiceGrafanaUserConfigDateFormats {
    defaultTimezone?: string;
    fullDate?: string;
    intervalDay?: string;
    intervalHour?: string;
    intervalMinute?: string;
    intervalMonth?: string;
    intervalSecond?: string;
    intervalYear?: string;
}

export interface ServiceGrafanaUserConfigExternalImageStorage {
    accessKey?: string;
    bucketUrl?: string;
    provider?: string;
    secretKey?: string;
}

export interface ServiceGrafanaUserConfigPrivateAccess {
    /**
     * Grafana specific server provided values
     */
    grafana?: string;
}

export interface ServiceGrafanaUserConfigPrivatelinkAccess {
    /**
     * Grafana specific server provided values
     */
    grafana?: string;
}

export interface ServiceGrafanaUserConfigPublicAccess {
    /**
     * Grafana specific server provided values
     */
    grafana?: string;
}

export interface ServiceGrafanaUserConfigSmtpServer {
    fromAddress?: string;
    fromName?: string;
    host?: string;
    password?: string;
    port?: string;
    skipVerify?: string;
    starttlsPolicy?: string;
    username?: string;
}

export interface ServiceInfluxdb {
    databaseName: string;
}

export interface ServiceInfluxdbUserConfig {
    /**
     * Custom domain
     */
    customDomain?: string;
    /**
     * influxdb.conf configuration values
     */
    influxdb?: outputs.ServiceInfluxdbUserConfigInfluxdb;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.ServiceInfluxdbUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.ServiceInfluxdbUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.ServiceInfluxdbUserConfigPublicAccess;
    /**
     * Name of the basebackup to restore in forked service
     */
    recoveryBasebackupName?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface ServiceInfluxdbUserConfigInfluxdb {
    logQueriesAfter?: string;
    maxConnectionLimit?: string;
    maxRowLimit?: string;
    maxSelectBuckets?: string;
    maxSelectPoint?: string;
    queryTimeout?: string;
}

export interface ServiceInfluxdbUserConfigPrivateAccess {
    /**
     * InfluxDB specific server provided values
     */
    influxdb?: string;
}

export interface ServiceInfluxdbUserConfigPrivatelinkAccess {
    /**
     * InfluxDB specific server provided values
     */
    influxdb?: string;
}

export interface ServiceInfluxdbUserConfigPublicAccess {
    /**
     * InfluxDB specific server provided values
     */
    influxdb?: string;
}

export interface ServiceIntegrationDatadogUserConfig {
    /**
     * Custom tags provided by user
     */
    datadogTags?: outputs.ServiceIntegrationDatadogUserConfigDatadogTag[];
    /**
     * List of custom metrics
     */
    excludeConsumerGroups?: string[];
    /**
     * List of topics to exclude
     */
    excludeTopics?: string[];
    /**
     * List of custom metrics
     */
    includeConsumerGroups?: string[];
    /**
     * List of topics to include
     */
    includeTopics?: string[];
    /**
     * List of custom metrics
     */
    kafkaCustomMetrics?: string[];
    /**
     * Maximum number of JMX metrics to send
     */
    maxJmxMetrics?: string;
}

export interface ServiceIntegrationDatadogUserConfigDatadogTag {
    comment?: string;
    tag?: string;
}

export interface ServiceIntegrationEndpointDatadogUserConfig {
    /**
     * Datadog API key
     */
    datadogApiKey?: string;
    /**
     * Custom tags provided by user
     */
    datadogTags?: outputs.ServiceIntegrationEndpointDatadogUserConfigDatadogTag[];
    /**
     * Disable consumer group metrics
     */
    disableConsumerStats?: string;
    /**
     * Number of separate instances to fetch kafka consumer statistics with
     */
    kafkaConsumerCheckInstances?: string;
    /**
     * Number of seconds that datadog will wait to get consumer statistics from brokers
     */
    kafkaConsumerStatsTimeout?: string;
    /**
     * Maximum number of partition contexts to send
     */
    maxPartitionContexts?: string;
    /**
     * Datadog intake site. Defaults to datadoghq.com
     */
    site?: string;
}

export interface ServiceIntegrationEndpointDatadogUserConfigDatadogTag {
    comment?: string;
    tag?: string;
}

export interface ServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig {
    /**
     * AWS access key. Required permissions are logs:CreateLogGroup, logs:CreateLogStream, logs:PutLogEvents and logs:DescribeLogStreams
     */
    accessKey?: string;
    /**
     * AWS CloudWatch log group name
     */
    logGroupName?: string;
    /**
     * AWS region
     */
    region?: string;
    /**
     * AWS secret key
     */
    secretKey?: string;
}

export interface ServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig {
    /**
     * AWS access key. Required permissions are cloudwatch:PutMetricData
     */
    accessKey?: string;
    /**
     * AWS CloudWatch Metrics Namespace
     */
    namespace?: string;
    /**
     * AWS region
     */
    region?: string;
    /**
     * AWS secret key
     */
    secretKey?: string;
}

export interface ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig {
    /**
     * PEM encoded CA certificate
     */
    ca?: string;
    /**
     * Maximum number of days of logs to keep
     */
    indexDaysMax?: string;
    /**
     * Elasticsearch index prefix
     */
    indexPrefix?: string;
    /**
     * Elasticsearch request timeout limit
     */
    timeout?: string;
    /**
     * Elasticsearch connection URL
     */
    url?: string;
}

export interface ServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig {
    /**
     * Google Cloud Logging log id
     */
    logId?: string;
    /**
     * GCP project id.
     */
    projectId?: string;
    /**
     * Google Service Account Credentials
     */
    serviceAccountCredentials?: string;
}

export interface ServiceIntegrationEndpointExternalKafkaUserConfig {
    /**
     * Bootstrap servers
     */
    bootstrapServers?: string;
    /**
     * The list of SASL mechanisms enabled in the Kafka server.
     */
    saslMechanism?: string;
    /**
     * Password for SASL PLAIN mechanism in the Kafka server.
     */
    saslPlainPassword?: string;
    /**
     * Username for SASL PLAIN mechanism in the Kafka server.
     */
    saslPlainUsername?: string;
    /**
     * Security protocol
     */
    securityProtocol?: string;
    /**
     * PEM-encoded CA certificate
     */
    sslCaCert?: string;
    /**
     * PEM-encoded client certificate
     */
    sslClientCert?: string;
    /**
     * PEM-encoded client key
     */
    sslClientKey?: string;
    /**
     * The endpoint identification algorithm to validate server hostname using server certificate.
     */
    sslEndpointIdentificationAlgorithm?: string;
}

export interface ServiceIntegrationEndpointExternalSchemaRegistryUserConfig {
    /**
     * Authentication method
     */
    authentication?: string;
    /**
     * Basic authentication password
     */
    basicAuthPassword?: string;
    /**
     * Basic authentication user name
     */
    basicAuthUsername?: string;
    /**
     * Schema Registry URL
     */
    url?: string;
}

export interface ServiceIntegrationEndpointJolokiaUserConfig {
    /**
     * Jolokia basic authentication password
     */
    basicAuthPassword?: string;
    /**
     * Jolokia basic authentication username
     */
    basicAuthUsername?: string;
}

export interface ServiceIntegrationEndpointPrometheusUserConfig {
    /**
     * Prometheus basic authentication password
     */
    basicAuthPassword?: string;
    /**
     * Prometheus basic authentication username
     */
    basicAuthUsername?: string;
}

export interface ServiceIntegrationEndpointRsyslogUserConfig {
    /**
     * PEM encoded CA certificate
     */
    ca?: string;
    /**
     * PEM encoded client certificate
     */
    cert?: string;
    /**
     * message format
     */
    format?: string;
    /**
     * PEM encoded client key
     */
    key?: string;
    /**
     * custom syslog message format
     */
    logline?: string;
    /**
     * rsyslog server port
     */
    port?: string;
    /**
     * Structured data block for log message
     */
    sd?: string;
    /**
     * rsyslog server IP address or hostname
     */
    server?: string;
    /**
     * Require TLS
     */
    tls?: string;
}

export interface ServiceIntegrationEndpointSignalfxUserConfig {
    /**
     * list of metrics to send
     */
    enabledMetrics?: string[];
    /**
     * SignalFX API key
     */
    signalfxApiKey?: string;
    /**
     * SignalFX realm
     */
    signalfxRealm?: string;
}

export interface ServiceIntegrationKafkaConnectUserConfig {
    /**
     * Kafka Connect service configuration values
     */
    kafkaConnect?: outputs.ServiceIntegrationKafkaConnectUserConfigKafkaConnect;
}

export interface ServiceIntegrationKafkaConnectUserConfigKafkaConnect {
    configStorageTopic?: string;
    groupId?: string;
    offsetStorageTopic?: string;
    statusStorageTopic?: string;
}

export interface ServiceIntegrationKafkaLogsUserConfig {
    /**
     * Topic name
     */
    kafkaTopic?: string;
}

export interface ServiceIntegrationKafkaMirrormakerUserConfig {
    /**
     * Kafka cluster alias
     */
    clusterAlias?: string;
    /**
     * Kafka MirrorMaker configuration values
     */
    kafkaMirrormaker?: outputs.ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker;
}

export interface ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker {
    consumerFetchMinBytes?: string;
    producerBatchSize?: string;
    producerBufferMemory?: string;
    producerLingerMs?: string;
    producerMaxRequestSize?: string;
}

export interface ServiceIntegrationLogsUserConfig {
    /**
     * Elasticsearch index retention limit
     */
    elasticsearchIndexDaysMax?: string;
    /**
     * Elasticsearch index prefix
     */
    elasticsearchIndexPrefix?: string;
}

export interface ServiceIntegrationMetricsUserConfig {
    /**
     * Name of the database where to store metric datapoints. Only affects PostgreSQL destinations. Defaults to 'metrics'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
     */
    database?: string;
    /**
     * Number of days to keep old metrics. Only affects PostgreSQL destinations. Set to 0 for no automatic cleanup. Defaults to 30 days.
     */
    retentionDays?: string;
    /**
     * Name of a user that can be used to read metrics. This will be used for Grafana integration (if enabled) to prevent Grafana users from making undesired changes. Only affects PostgreSQL destinations. Defaults to 'metrics_reader'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
     */
    roUsername?: string;
    /**
     * Configuration options for metrics where source service is MySQL
     */
    sourceMysql?: outputs.ServiceIntegrationMetricsUserConfigSourceMysql;
    /**
     * Name of the user used to write metrics. Only affects PostgreSQL destinations. Defaults to 'metrics_writer'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
     */
    username?: string;
}

export interface ServiceIntegrationMetricsUserConfigSourceMysql {
    telegraf?: outputs.ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf;
}

export interface ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf {
    gatherEventWaits?: string;
    gatherFileEventsStats?: string;
    gatherIndexIoWaits?: string;
    gatherInfoSchemaAutoInc?: string;
    gatherInnodbMetrics?: string;
    gatherPerfEventsStatements?: string;
    gatherProcessList?: string;
    gatherSlaveStatus?: string;
    gatherTableIoWaits?: string;
    gatherTableLockWaits?: string;
    gatherTableSchema?: string;
    perfEventsStatementsDigestTextLimit?: string;
    perfEventsStatementsLimit?: string;
    perfEventsStatementsTimeLimit?: string;
}

export interface ServiceIntegrationMirrormakerUserConfig {
    /**
     * Mirrormaker topic whitelist
     */
    mirrormakerWhitelist?: string;
}

export interface ServiceIntegrationPrometheusUserConfig {
    /**
     * Configuration options for metrics where source service is MySQL
     */
    sourceMysql?: outputs.ServiceIntegrationPrometheusUserConfigSourceMysql;
}

export interface ServiceIntegrationPrometheusUserConfigSourceMysql {
    telegraf?: outputs.ServiceIntegrationPrometheusUserConfigSourceMysqlTelegraf;
}

export interface ServiceIntegrationPrometheusUserConfigSourceMysqlTelegraf {
    gatherEventWaits?: string;
    gatherFileEventsStats?: string;
    gatherIndexIoWaits?: string;
    gatherInfoSchemaAutoInc?: string;
    gatherInnodbMetrics?: string;
    gatherPerfEventsStatements?: string;
    gatherProcessList?: string;
    gatherSlaveStatus?: string;
    gatherTableIoWaits?: string;
    gatherTableLockWaits?: string;
    gatherTableSchema?: string;
    perfEventsStatementsDigestTextLimit?: string;
    perfEventsStatementsLimit?: string;
    perfEventsStatementsTimeLimit?: string;
}

export interface ServiceKafka {
    /**
     * The Kafka client certificate
     */
    accessCert: string;
    /**
     * The Kafka client certificate key
     */
    accessKey: string;
    /**
     * The Kafka Connect URI, if any
     */
    connectUri: string;
    /**
     * The Kafka REST URI, if any
     */
    restUri: string;
    /**
     * The Schema Registry URI, if any
     */
    schemaRegistryUri: string;
}

export interface ServiceKafkaConnect {
}

export interface ServiceKafkaConnectUserConfig {
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Kafka Connect configuration values
     */
    kafkaConnect?: outputs.ServiceKafkaConnectUserConfigKafkaConnect;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.ServiceKafkaConnectUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.ServiceKafkaConnectUserConfigPrivatelinkAccess;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.ServiceKafkaConnectUserConfigPublicAccess;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface ServiceKafkaConnectUserConfigKafkaConnect {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerFetchMaxBytes?: string;
    consumerIsolationLevel?: string;
    consumerMaxPartitionFetchBytes?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    producerMaxRequestSize?: string;
    sessionTimeoutMs?: string;
}

export interface ServiceKafkaConnectUserConfigPrivateAccess {
    /**
     * Kafka Connect specific server provided values
     */
    kafkaConnect?: string;
    prometheus?: string;
}

export interface ServiceKafkaConnectUserConfigPrivatelinkAccess {
    /**
     * Kafka Connect specific server provided values
     */
    kafkaConnect?: string;
}

export interface ServiceKafkaConnectUserConfigPublicAccess {
    /**
     * Kafka Connect specific server provided values
     */
    kafkaConnect?: string;
    prometheus?: string;
}

export interface ServiceKafkaMirrormaker {
}

export interface ServiceKafkaMirrormakerUserConfig {
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Kafka MirrorMaker configuration values
     */
    kafkaMirrormaker?: outputs.ServiceKafkaMirrormakerUserConfigKafkaMirrormaker;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface ServiceKafkaMirrormakerUserConfigKafkaMirrormaker {
    emitCheckpointsEnabled?: string;
    emitCheckpointsIntervalSeconds?: string;
    refreshGroupsEnabled?: string;
    refreshGroupsIntervalSeconds?: string;
    refreshTopicsEnabled?: string;
    refreshTopicsIntervalSeconds?: string;
    syncGroupOffsetsEnabled?: string;
    syncGroupOffsetsIntervalSeconds?: string;
    syncTopicConfigsEnabled?: string;
    tasksMaxPerCpu?: string;
}

export interface ServiceKafkaUserConfig {
    /**
     * Custom domain
     */
    customDomain?: string;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Kafka broker configuration values
     */
    kafka?: outputs.ServiceKafkaUserConfigKafka;
    /**
     * Kafka authentication methods
     */
    kafkaAuthenticationMethods?: outputs.ServiceKafkaUserConfigKafkaAuthenticationMethods;
    /**
     * Enable Kafka Connect service
     */
    kafkaConnect?: string;
    /**
     * Kafka Connect configuration values
     */
    kafkaConnectConfig?: outputs.ServiceKafkaUserConfigKafkaConnectConfig;
    /**
     * Enable Kafka-REST service
     */
    kafkaRest?: string;
    /**
     * Kafka REST configuration
     */
    kafkaRestConfig?: outputs.ServiceKafkaUserConfigKafkaRestConfig;
    /**
     * Kafka major version
     */
    kafkaVersion?: string;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.ServiceKafkaUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.ServiceKafkaUserConfigPrivatelinkAccess;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.ServiceKafkaUserConfigPublicAccess;
    /**
     * Enable Schema-Registry service
     */
    schemaRegistry?: string;
    /**
     * Schema Registry configuration
     */
    schemaRegistryConfig?: outputs.ServiceKafkaUserConfigSchemaRegistryConfig;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface ServiceKafkaUserConfigKafka {
    autoCreateTopicsEnable?: string;
    compressionType?: string;
    connectionsMaxIdleMs?: string;
    defaultReplicationFactor?: string;
    groupInitialRebalanceDelayMs?: string;
    groupMaxSessionTimeoutMs?: string;
    groupMinSessionTimeoutMs?: string;
    logCleanerDeleteRetentionMs?: string;
    logCleanerMaxCompactionLagMs?: string;
    logCleanerMinCleanableRatio?: string;
    logCleanerMinCompactionLagMs?: string;
    logCleanupPolicy?: string;
    logFlushIntervalMessages?: string;
    logFlushIntervalMs?: string;
    logIndexIntervalBytes?: string;
    logIndexSizeMaxBytes?: string;
    logMessageDownconversionEnable?: string;
    logMessageTimestampDifferenceMaxMs?: string;
    logMessageTimestampType?: string;
    logPreallocate?: string;
    logRetentionBytes?: string;
    logRetentionHours?: string;
    logRetentionMs?: string;
    logRollJitterMs?: string;
    logRollMs?: string;
    logSegmentBytes?: string;
    logSegmentDeleteDelayMs?: string;
    maxConnectionsPerIp?: string;
    maxIncrementalFetchSessionCacheSlots?: string;
    messageMaxBytes?: string;
    minInsyncReplicas?: string;
    numPartitions?: string;
    offsetsRetentionMinutes?: string;
    producerPurgatoryPurgeIntervalRequests?: string;
    replicaFetchMaxBytes?: string;
    replicaFetchResponseMaxBytes?: string;
    socketRequestMaxBytes?: string;
    transactionRemoveExpiredTransactionCleanupIntervalMs?: string;
    transactionStateLogSegmentBytes?: string;
}

export interface ServiceKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: string;
    sasl?: string;
}

export interface ServiceKafkaUserConfigKafkaConnectConfig {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerFetchMaxBytes?: string;
    consumerIsolationLevel?: string;
    consumerMaxPartitionFetchBytes?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    producerMaxRequestSize?: string;
    sessionTimeoutMs?: string;
}

export interface ServiceKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: string;
    consumerRequestMaxBytes?: string;
    consumerRequestTimeoutMs?: string;
    producerAcks?: string;
    producerLingerMs?: string;
    simpleconsumerPoolSizeMax?: string;
}

export interface ServiceKafkaUserConfigPrivateAccess {
    prometheus?: string;
}

export interface ServiceKafkaUserConfigPrivatelinkAccess {
    /**
     * Kafka specific server provided values
     */
    kafka?: string;
    /**
     * Kafka Connect specific server provided values
     */
    kafkaConnect?: string;
    kafkaRest?: string;
    schemaRegistry?: string;
}

export interface ServiceKafkaUserConfigPublicAccess {
    /**
     * Kafka specific server provided values
     */
    kafka?: string;
    /**
     * Kafka Connect specific server provided values
     */
    kafkaConnect?: string;
    kafkaRest?: string;
    prometheus?: string;
    schemaRegistry?: string;
}

export interface ServiceKafkaUserConfigSchemaRegistryConfig {
    leaderEligibility?: string;
    topicName?: string;
}

export interface ServiceMysql {
}

export interface ServiceMysqlUserConfig {
    /**
     * Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
     */
    adminPassword?: string;
    /**
     * Custom username for admin user. This must be set only when a new service is being created.
     */
    adminUsername?: string;
    /**
     * The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
     */
    backupHour?: string;
    /**
     * The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
     */
    backupMinute?: string;
    /**
     * The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
     */
    binlogRetentionPeriod?: string;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Migrate data from existing server
     */
    migration?: outputs.ServiceMysqlUserConfigMigration;
    /**
     * mysql.conf configuration values
     */
    mysql?: outputs.ServiceMysqlUserConfigMysql;
    /**
     * MySQL major version
     */
    mysqlVersion?: string;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.ServiceMysqlUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.ServiceMysqlUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.ServiceMysqlUserConfigPublicAccess;
    /**
     * Recovery target time when forking a service. This has effect only when a new service is being created.
     */
    recoveryTargetTime?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface ServiceMysqlUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface ServiceMysqlUserConfigMysql {
    connectTimeout?: string;
    defaultTimeZone?: string;
    groupConcatMaxLen?: string;
    informationSchemaStatsExpiry?: string;
    innodbFtMinTokenSize?: string;
    innodbFtServerStopwordTable?: string;
    innodbLockWaitTimeout?: string;
    innodbLogBufferSize?: string;
    innodbOnlineAlterLogMaxSize?: string;
    innodbPrintAllDeadlocks?: string;
    innodbRollbackOnTimeout?: string;
    interactiveTimeout?: string;
    internalTmpMemStorageEngine?: string;
    longQueryTime?: string;
    maxAllowedPacket?: string;
    maxHeapTableSize?: string;
    netReadTimeout?: string;
    netWriteTimeout?: string;
    slowQueryLog?: string;
    sortBufferSize?: string;
    sqlMode?: string;
    sqlRequirePrimaryKey?: string;
    tmpTableSize?: string;
    waitTimeout?: string;
}

export interface ServiceMysqlUserConfigPrivateAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: string;
    mysqlx?: string;
    prometheus?: string;
}

export interface ServiceMysqlUserConfigPrivatelinkAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: string;
    mysqlx?: string;
}

export interface ServiceMysqlUserConfigPublicAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: string;
    mysqlx?: string;
    prometheus?: string;
}

export interface ServiceOpensearch {
    opensearchDashboardsUri: string;
}

export interface ServiceOpensearchUserConfig {
    /**
     * Custom domain
     */
    customDomain?: string;
    /**
     * Disable replication factor adjustment
     */
    disableReplicationFactorAdjustment?: string;
    /**
     * Index patterns
     */
    indexPatterns?: outputs.ServiceOpensearchUserConfigIndexPattern[];
    /**
     * Template settings for all new indexes
     */
    indexTemplate?: outputs.ServiceOpensearchUserConfigIndexTemplate;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Don't reset index.refresh_interval to the default value
     */
    keepIndexRefreshInterval?: string;
    /**
     * Maximum index count
     */
    maxIndexCount?: string;
    /**
     * OpenSearch settings
     */
    opensearch?: outputs.ServiceOpensearchUserConfigOpensearch;
    /**
     * OpenSearch Dashboards settings
     */
    opensearchDashboards?: outputs.ServiceOpensearchUserConfigOpensearchDashboards;
    /**
     * OpenSearch major version
     */
    opensearchVersion?: string;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.ServiceOpensearchUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.ServiceOpensearchUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.ServiceOpensearchUserConfigPublicAccess;
    /**
     * Name of the basebackup to restore in forked service
     */
    recoveryBasebackupName?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface ServiceOpensearchUserConfigIndexPattern {
    maxIndexCount?: string;
    pattern?: string;
    sortingAlgorithm?: string;
}

export interface ServiceOpensearchUserConfigIndexTemplate {
    mappingNestedObjectsLimit?: string;
    numberOfReplicas?: string;
    numberOfShards?: string;
}

export interface ServiceOpensearchUserConfigOpensearch {
    actionAutoCreateIndexEnabled?: string;
    actionDestructiveRequiresName?: string;
    clusterMaxShardsPerNode?: string;
    httpMaxContentLength?: string;
    httpMaxHeaderSize?: string;
    httpMaxInitialLineLength?: string;
    indicesFielddataCacheSize?: string;
    indicesMemoryIndexBufferSize?: string;
    indicesQueriesCacheSize?: string;
    indicesQueryBoolMaxClauseCount?: string;
    overrideMainResponseVersion?: string;
    reindexRemoteWhitelists?: string[];
    searchMaxBuckets?: string;
    threadPoolAnalyzeQueueSize?: string;
    threadPoolAnalyzeSize?: string;
    threadPoolForceMergeSize?: string;
    threadPoolGetQueueSize?: string;
    threadPoolGetSize?: string;
    threadPoolIndexSize?: string;
    threadPoolSearchQueueSize?: string;
    threadPoolSearchSize?: string;
    threadPoolSearchThrottledQueueSize?: string;
    threadPoolSearchThrottledSize?: string;
    threadPoolWriteQueueSize?: string;
    threadPoolWriteSize?: string;
}

export interface ServiceOpensearchUserConfigOpensearchDashboards {
    enabled?: string;
    maxOldSpaceSize?: string;
    opensearchRequestTimeout?: string;
}

export interface ServiceOpensearchUserConfigPrivateAccess {
    /**
     * Opensearch specific server provided values
     */
    opensearch?: string;
    opensearchDashboards?: string;
    prometheus?: string;
}

export interface ServiceOpensearchUserConfigPrivatelinkAccess {
    /**
     * Opensearch specific server provided values
     */
    opensearch?: string;
    opensearchDashboards?: string;
}

export interface ServiceOpensearchUserConfigPublicAccess {
    /**
     * Opensearch specific server provided values
     */
    opensearch?: string;
    opensearchDashboards?: string;
    prometheus?: string;
}

export interface ServicePg {
    dbname: string;
    host: string;
    password: string;
    port: number;
    replicaUri: string;
    sslmode: string;
    uri: string;
    user: string;
}

export interface ServicePgUserConfig {
    /**
     * Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
     */
    adminPassword?: string;
    /**
     * Custom username for admin user. This must be set only when a new service is being created.
     */
    adminUsername?: string;
    /**
     * The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
     */
    backupHour?: string;
    /**
     * The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
     */
    backupMinute?: string;
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Migrate data from existing server
     */
    migration?: outputs.ServicePgUserConfigMigration;
    /**
     * postgresql.conf configuration values
     */
    pg?: outputs.ServicePgUserConfigPg;
    /**
     * Should the service which is being forked be a read replica (deprecated, use readReplica service integration instead).
     */
    pgReadReplica?: string;
    /**
     * Name of the PG Service from which to fork (deprecated, use service*to*fork_from). This has effect only when a new service is being created.
     */
    pgServiceToForkFrom?: string;
    /**
     * PostgreSQL major version
     */
    pgVersion?: string;
    /**
     * PGBouncer connection pooling settings
     */
    pgbouncer?: outputs.ServicePgUserConfigPgbouncer;
    /**
     * PGLookout settings
     */
    pglookout?: outputs.ServicePgUserConfigPglookout;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.ServicePgUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.ServicePgUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.ServicePgUserConfigPublicAccess;
    /**
     * Recovery target time when forking a service. This has effect only when a new service is being created.
     */
    recoveryTargetTime?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * shared*buffers*percentage
     */
    sharedBuffersPercentage?: string;
    /**
     * Static IP addresses
     */
    staticIps?: string;
    /**
     * Synchronous replication type. Note that the service plan also needs to support synchronous replication.
     */
    synchronousReplication?: string;
    /**
     * TimescaleDB extension configuration values
     */
    timescaledb?: outputs.ServicePgUserConfigTimescaledb;
    /**
     * Variant of the PostgreSQL service, may affect the features that are exposed by default
     */
    variant?: string;
    /**
     * work_mem
     */
    workMem?: string;
}

export interface ServicePgUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface ServicePgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: string;
    autovacuumAnalyzeThreshold?: string;
    autovacuumFreezeMaxAge?: string;
    autovacuumMaxWorkers?: string;
    autovacuumNaptime?: string;
    autovacuumVacuumCostDelay?: string;
    autovacuumVacuumCostLimit?: string;
    autovacuumVacuumScaleFactor?: string;
    autovacuumVacuumThreshold?: string;
    bgwriterDelay?: string;
    bgwriterFlushAfter?: string;
    bgwriterLruMaxpages?: string;
    bgwriterLruMultiplier?: string;
    deadlockTimeout?: string;
    defaultToastCompression?: string;
    idleInTransactionSessionTimeout?: string;
    jit?: string;
    logAutovacuumMinDuration?: string;
    logErrorVerbosity?: string;
    logLinePrefix?: string;
    logMinDurationStatement?: string;
    maxFilesPerProcess?: string;
    maxLocksPerTransaction?: string;
    maxLogicalReplicationWorkers?: string;
    maxParallelWorkers?: string;
    maxParallelWorkersPerGather?: string;
    maxPredLocksPerTransaction?: string;
    maxPreparedTransactions?: string;
    maxReplicationSlots?: string;
    maxSlotWalKeepSize?: string;
    maxStackDepth?: string;
    maxStandbyArchiveDelay?: string;
    maxStandbyStreamingDelay?: string;
    maxWalSenders?: string;
    maxWorkerProcesses?: string;
    pgPartmanBgwInterval?: string;
    pgPartmanBgwRole?: string;
    pgStatStatementsTrack?: string;
    tempFileLimit?: string;
    timezone?: string;
    trackActivityQuerySize?: string;
    trackCommitTimestamp?: string;
    trackFunctions?: string;
    trackIoTiming?: string;
    walSenderTimeout?: string;
    walWriterDelay?: string;
}

export interface ServicePgUserConfigPgbouncer {
    autodbIdleTimeout?: string;
    autodbMaxDbConnections?: string;
    autodbPoolMode?: string;
    autodbPoolSize?: string;
    ignoreStartupParameters?: string[];
    minPoolSize?: string;
    serverIdleTimeout?: string;
    serverLifetime?: string;
    serverResetQueryAlways?: string;
}

export interface ServicePgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: string;
}

export interface ServicePgUserConfigPrivateAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface ServicePgUserConfigPrivatelinkAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: string;
    pgbouncer?: string;
}

export interface ServicePgUserConfigPublicAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface ServicePgUserConfigTimescaledb {
    maxBackgroundWorkers?: string;
}

export interface ServiceRedi {
}

export interface ServiceRedisUserConfig {
    /**
     * IP filter
     */
    ipFilters?: string[];
    /**
     * Migrate data from existing server
     */
    migration?: outputs.ServiceRedisUserConfigMigration;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: outputs.ServiceRedisUserConfigPrivateAccess;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: outputs.ServiceRedisUserConfigPrivatelinkAccess;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: string;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: outputs.ServiceRedisUserConfigPublicAccess;
    /**
     * Name of the basebackup to restore in forked service
     */
    recoveryBasebackupName?: string;
    /**
     * Default ACL for pub/sub channels used when Redis user is created
     */
    redisAclChannelsDefault?: string;
    /**
     * Redis IO thread count
     */
    redisIoThreads?: string;
    /**
     * LFU maxmemory-policy counter decay time in minutes
     */
    redisLfuDecayTime?: string;
    /**
     * Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies
     */
    redisLfuLogFactor?: string;
    /**
     * Redis maxmemory-policy
     */
    redisMaxmemoryPolicy?: string;
    /**
     * Set notify-keyspace-events option
     */
    redisNotifyKeyspaceEvents?: string;
    /**
     * Number of redis databases
     */
    redisNumberOfDatabases?: string;
    /**
     * Redis persistence
     */
    redisPersistence?: string;
    /**
     * Pub/sub client output buffer hard limit in MB
     */
    redisPubsubClientOutputBufferLimit?: string;
    /**
     * Require SSL to access Redis
     */
    redisSsl?: string;
    /**
     * Redis idle connection timeout
     */
    redisTimeout?: string;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: string;
    /**
     * Static IP addresses
     */
    staticIps?: string;
}

export interface ServiceRedisUserConfigMigration {
    dbname?: string;
    host?: string;
    ignoreDbs?: string;
    method?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface ServiceRedisUserConfigPrivateAccess {
    prometheus?: string;
    /**
     * Redis specific server provided values
     */
    redis?: string;
}

export interface ServiceRedisUserConfigPrivatelinkAccess {
    /**
     * Redis specific server provided values
     */
    redis?: string;
}

export interface ServiceRedisUserConfigPublicAccess {
    prometheus?: string;
    /**
     * Redis specific server provided values
     */
    redis?: string;
}

export interface ServiceServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is 'read_replica'
     */
    integrationType: string;
    /**
     * Name of the source service
     */
    sourceServiceName: string;
}
