// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as outputs from "../types/output";

export interface ElasticSearchAclAcl {
    rules: outputs.ElasticSearchAclAclRule[];
    username: string;
}

export interface ElasticSearchAclAclRule {
    index: string;
    permission: string;
}

export interface GetElasticSearchAclAcl {
    rules: outputs.GetElasticSearchAclAclRule[];
    username: string;
}

export interface GetElasticSearchAclAclRule {
    index: string;
    permission: string;
}

export interface GetKafkaConnectorTask {
    connector: string;
    task: number;
}

export interface GetServiceCassandra {

}

export interface GetServiceCassandraUserConfig {
    ipFilters?: string[];
    migrateSstableloader?: boolean;
    privateAccess?: outputs.GetServiceCassandraUserConfigPrivateAccess;
    publicAccess?: outputs.GetServiceCassandraUserConfigPublicAccess;
    serviceToForkFrom?: string;
}

export interface GetServiceCassandraUserConfigPrivateAccess {
    prometheus?: boolean;
}

export interface GetServiceCassandraUserConfigPublicAccess {
    prometheus?: boolean;
}

export interface GetServiceComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetServiceElasticsearch {
    kibanaUri: string;
}

export interface GetServiceElasticsearchUserConfig {
    customDomain?: string;
    disableReplicationFactorAdjustment?: boolean;
    elasticsearch?: outputs.GetServiceElasticsearchUserConfigElasticsearch;
    elasticsearchVersion?: string;
    indexPatterns?: outputs.GetServiceElasticsearchUserConfigIndexPattern[];
    ipFilters?: string[];
    kibana?: outputs.GetServiceElasticsearchUserConfigKibana;
    maxIndexCount?: number;
    privateAccess?: outputs.GetServiceElasticsearchUserConfigPrivateAccess;
    publicAccess?: outputs.GetServiceElasticsearchUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
}

export interface GetServiceElasticsearchUserConfigElasticsearch {
    actionDestructiveRequiresName?: boolean;
    httpMaxContentLength?: number;
    indicesFielddataCacheSize?: number;
    indicesMemoryIndexBufferSize?: number;
    indicesQueriesCacheSize?: number;
    indicesQueryBoolMaxClauseCount?: number;
    reindexRemoteWhitelists?: string[];
    threadPoolAnalyzeQueueSize?: number;
    threadPoolAnalyzeSize?: number;
    threadPoolForceMergeSize?: number;
    threadPoolGetQueueSize?: number;
    threadPoolGetSize?: number;
    threadPoolIndexQueueSize?: number;
    threadPoolIndexSize?: number;
    threadPoolSearchQueueSize?: number;
    threadPoolSearchSize?: number;
    threadPoolSearchThrottledQueueSize?: number;
    threadPoolSearchThrottledSize?: number;
    threadPoolWriteQueueSize?: number;
    threadPoolWriteSize?: number;
}

export interface GetServiceElasticsearchUserConfigIndexPattern {
    maxIndexCount?: number;
    pattern?: string;
}

export interface GetServiceElasticsearchUserConfigKibana {
    elasticsearchRequestTimeout?: number;
    enabled?: boolean;
    maxOldSpaceSize?: number;
}

export interface GetServiceElasticsearchUserConfigPrivateAccess {
    elasticsearch?: boolean;
    kibana?: boolean;
    prometheus?: boolean;
}

export interface GetServiceElasticsearchUserConfigPublicAccess {
    elasticsearch?: boolean;
    kibana?: boolean;
    prometheus?: boolean;
}

export interface GetServiceGrafana {

}

export interface GetServiceGrafanaUserConfig {
    alertingEnabled?: boolean;
    alertingErrorOrTimeout?: string;
    alertingNodataOrNullvalues?: string;
    allowEmbedding?: boolean;
    authGithub?: outputs.GetServiceGrafanaUserConfigAuthGithub;
    authGitlab?: outputs.GetServiceGrafanaUserConfigAuthGitlab;
    authGoogle?: outputs.GetServiceGrafanaUserConfigAuthGoogle;
    cookieSamesite?: string;
    customDomain?: string;
    dashboardsVersionsToKeep?: number;
    dataproxySendUserHeader?: boolean;
    dataproxyTimeout?: number;
    disableGravatar?: boolean;
    editorsCanAdmin?: boolean;
    externalImageStorage?: outputs.GetServiceGrafanaUserConfigExternalImageStorage;
    googleAnalyticsUaId?: string;
    ipFilters?: string[];
    metricsEnabled?: boolean;
    privateAccess?: outputs.GetServiceGrafanaUserConfigPrivateAccess;
    publicAccess?: outputs.GetServiceGrafanaUserConfigPublicAccess;
    smtpServer?: outputs.GetServiceGrafanaUserConfigSmtpServer;
    userAutoAssignOrg?: boolean;
    userAutoAssignOrgRole?: string;
    viewersCanEdit?: boolean;
}

export interface GetServiceGrafanaUserConfigAuthGithub {
    allowSignUp?: boolean;
    allowedOrganizations?: string[];
    clientId?: string;
    clientSecret?: string;
    teamIds?: number[];
}

export interface GetServiceGrafanaUserConfigAuthGitlab {
    allowSignUp?: boolean;
    allowedGroups?: string[];
    clientId?: string;
    clientSecret?: string;
}

export interface GetServiceGrafanaUserConfigAuthGoogle {
    allowSignUp?: boolean;
    allowedDomains?: string[];
    clientId?: string;
    clientSecret?: string;
}

export interface GetServiceGrafanaUserConfigExternalImageStorage {
    accessKey?: string;
    bucketUrl?: string;
    provider?: string;
    secretKey?: string;
}

export interface GetServiceGrafanaUserConfigPrivateAccess {
    grafana?: boolean;
}

export interface GetServiceGrafanaUserConfigPublicAccess {
    grafana?: boolean;
}

export interface GetServiceGrafanaUserConfigSmtpServer {
    fromAddress?: string;
    fromName?: string;
    host?: string;
    password?: string;
    port?: number;
    skipVerify?: boolean;
    username?: string;
}

export interface GetServiceInfluxdb {
    databaseName: string;
}

export interface GetServiceInfluxdbUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    privateAccess?: outputs.GetServiceInfluxdbUserConfigPrivateAccess;
    publicAccess?: outputs.GetServiceInfluxdbUserConfigPublicAccess;
    serviceToForkFrom?: string;
}

export interface GetServiceInfluxdbUserConfigPrivateAccess {
    influxdb?: boolean;
}

export interface GetServiceInfluxdbUserConfigPublicAccess {
    influxdb?: boolean;
}

export interface GetServiceIntegrationEndpointDatadogUserConfig {
    datadogApiKey?: string;
    disableConsumerStats?: boolean;
    maxPartitionContexts?: number;
    site?: string;
}

export interface GetServiceIntegrationEndpointExternalElasticsearchLogsUserConfig {
    ca?: string;
    indexDaysMax?: number;
    indexPrefix?: string;
    timeout?: number;
    url?: string;
}

export interface GetServiceIntegrationEndpointPrometheusUserConfig {
    basicAuthPassword?: string;
    basicAuthUsername?: string;
}

export interface GetServiceIntegrationEndpointRsyslogUserConfig {
    ca?: string;
    cert?: string;
    format?: string;
    key?: string;
    logline?: string;
    port?: number;
    sd?: string;
    server?: string;
    tls?: boolean;
}

export interface GetServiceKafka {
    accessCert: string;
    accessKey: string;
    connectUri: string;
    restUri: string;
    schemaRegistryUri: string;
}

export interface GetServiceKafkaConnect {

}

export interface GetServiceKafkaConnectUserConfig {
    ipFilters?: string[];
    kafkaConnect?: outputs.GetServiceKafkaConnectUserConfigKafkaConnect;
    privateAccess?: outputs.GetServiceKafkaConnectUserConfigPrivateAccess;
    publicAccess?: outputs.GetServiceKafkaConnectUserConfigPublicAccess;
}

export interface GetServiceKafkaConnectUserConfigKafkaConnect {
    consumerIsolationLevel?: string;
    consumerMaxPollRecords?: number;
}

export interface GetServiceKafkaConnectUserConfigPrivateAccess {
    kafkaConnect?: boolean;
    prometheus?: boolean;
}

export interface GetServiceKafkaConnectUserConfigPublicAccess {
    kafkaConnect?: boolean;
    prometheus?: boolean;
}

export interface GetServiceKafkaUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    kafka?: outputs.GetServiceKafkaUserConfigKafka;
    kafkaAuthenticationMethods?: outputs.GetServiceKafkaUserConfigKafkaAuthenticationMethods;
    kafkaConnect?: boolean;
    kafkaConnectConfig?: outputs.GetServiceKafkaUserConfigKafkaConnectConfig;
    kafkaRest?: boolean;
    kafkaRestConfig?: outputs.GetServiceKafkaUserConfigKafkaRestConfig;
    kafkaVersion?: string;
    privateAccess?: outputs.GetServiceKafkaUserConfigPrivateAccess;
    publicAccess?: outputs.GetServiceKafkaUserConfigPublicAccess;
    schemaRegistry?: boolean;
}

export interface GetServiceKafkaUserConfigKafka {
    autoCreateTopicsEnable?: boolean;
    compressionType?: string;
    defaultReplicationFactor?: number;
    groupMaxSessionTimeoutMs?: number;
    groupMinSessionTimeoutMs?: number;
    logCleanerMaxCompactionLagMs?: number;
    logCleanerMinCleanableRatio?: number;
    logCleanerMinCompactionLagMs?: number;
    logMessageTimestampDifferenceMaxMs?: number;
    logMessageTimestampType?: string;
    logRetentionBytes?: number;
    logRetentionHours?: number;
    logSegmentBytes?: number;
    maxConnectionsPerIp?: number;
    messageMaxBytes?: number;
    numPartitions?: number;
    offsetsRetentionMinutes?: number;
    producerPurgatoryPurgeIntervalRequests?: number;
    replicaFetchMaxBytes?: number;
    replicaFetchResponseMaxBytes?: number;
    socketRequestMaxBytes?: number;
}

export interface GetServiceKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: boolean;
    sasl?: boolean;
}

export interface GetServiceKafkaUserConfigKafkaConnectConfig {
    consumerIsolationLevel?: string;
    consumerMaxPollRecords?: number;
}

export interface GetServiceKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: boolean;
    consumerRequestMaxBytes?: number;
    consumerRequestTimeoutMs?: number;
    producerAcks?: string;
    producerLingerMs?: number;
    simpleconsumerPoolSizeMax?: number;
}

export interface GetServiceKafkaUserConfigPrivateAccess {
    prometheus?: boolean;
}

export interface GetServiceKafkaUserConfigPublicAccess {
    kafka?: boolean;
    prometheus?: boolean;
}

export interface GetServiceMysql {

}

export interface GetServiceMysqlUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: number;
    backupMinute?: number;
    ipFilters?: string[];
    mysql?: outputs.GetServiceMysqlUserConfigMysql;
    mysqlVersion?: string;
    privateAccess?: outputs.GetServiceMysqlUserConfigPrivateAccess;
    publicAccess?: outputs.GetServiceMysqlUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
}

export interface GetServiceMysqlUserConfigMysql {
    defaultTimeZone?: string;
    groupConcatMaxLen?: number;
    innodbFtMinTokenSize?: number;
    sqlMode?: string;
}

export interface GetServiceMysqlUserConfigPrivateAccess {
    mysql?: boolean;
    prometheus?: boolean;
}

export interface GetServiceMysqlUserConfigPublicAccess {
    mysql?: boolean;
    prometheus?: boolean;
}

export interface GetServicePg {
    dbname: string;
    host: string;
    password: string;
    port: number;
    replicaUri: string;
    sslmode: string;
    uri: string;
    user: string;
}

export interface GetServicePgUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: number;
    backupMinute?: number;
    ipFilters?: string[];
    pg?: outputs.GetServicePgUserConfigPg;
    pgReadReplica?: boolean;
    pgServiceToForkFrom?: string;
    pgVersion?: string;
    pgbouncer?: outputs.GetServicePgUserConfigPgbouncer;
    pglookout?: outputs.GetServicePgUserConfigPglookout;
    privateAccess?: outputs.GetServicePgUserConfigPrivateAccess;
    publicAccess?: outputs.GetServicePgUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    variant?: string;
}

export interface GetServicePgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: number;
    autovacuumAnalyzeThreshold?: number;
    autovacuumMaxWorkers?: number;
    autovacuumNaptime?: number;
    autovacuumVacuumCostDelay?: number;
    autovacuumVacuumCostLimit?: number;
    autovacuumVacuumScaleFactor?: number;
    autovacuumVacuumThreshold?: number;
    idleInTransactionSessionTimeout?: number;
    jit?: boolean;
    logAutovacuumMinDuration?: number;
    logErrorVerbosity?: string;
    logMinDurationStatement?: number;
    maxLocksPerTransaction?: number;
    maxParallelWorkers?: number;
    maxParallelWorkersPerGather?: number;
    maxPredLocksPerTransaction?: number;
    maxPreparedTransactions?: number;
    maxStackDepth?: number;
    maxStandbyArchiveDelay?: number;
    maxStandbyStreamingDelay?: number;
    maxWorkerProcesses?: number;
    pgStatStatementsTrack?: string;
    tempFileLimit?: number;
    timezone?: string;
    trackActivityQuerySize?: number;
    trackFunctions?: string;
}

export interface GetServicePgUserConfigPgbouncer {
    serverResetQueryAlways?: boolean;
}

export interface GetServicePgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: number;
}

export interface GetServicePgUserConfigPrivateAccess {
    pg?: boolean;
    pgbouncer?: boolean;
    prometheus?: boolean;
}

export interface GetServicePgUserConfigPublicAccess {
    pg?: boolean;
    pgbouncer?: boolean;
    prometheus?: boolean;
}

export interface GetServiceRedis {

}

export interface GetServiceRedisUserConfig {
    ipFilters?: string[];
    privateAccess?: outputs.GetServiceRedisUserConfigPrivateAccess;
    publicAccess?: outputs.GetServiceRedisUserConfigPublicAccess;
    redisLfuDecayTime?: number;
    redisLfuLogFactor?: number;
    redisMaxmemoryPolicy?: string;
    redisNotifyKeyspaceEvents?: string;
    redisSsl?: boolean;
    redisTimeout?: number;
}

export interface GetServiceRedisUserConfigPrivateAccess {
    prometheus?: boolean;
    redis?: boolean;
}

export interface GetServiceRedisUserConfigPublicAccess {
    prometheus?: boolean;
    redis?: boolean;
}

export interface GetServiceServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface KafkaConnectorTask {
    connector: string;
    task: number;
}

export interface ServiceCassandra {

}

export interface ServiceCassandraUserConfig {
    ipFilters?: string[];
    migrateSstableloader?: boolean;
    privateAccess?: outputs.ServiceCassandraUserConfigPrivateAccess;
    publicAccess?: outputs.ServiceCassandraUserConfigPublicAccess;
    serviceToForkFrom?: string;
}

export interface ServiceCassandraUserConfigPrivateAccess {
    prometheus?: boolean;
}

export interface ServiceCassandraUserConfigPublicAccess {
    prometheus?: boolean;
}

export interface ServiceComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface ServiceElasticsearch {
    kibanaUri: string;
}

export interface ServiceElasticsearchUserConfig {
    customDomain?: string;
    disableReplicationFactorAdjustment?: boolean;
    elasticsearch?: outputs.ServiceElasticsearchUserConfigElasticsearch;
    elasticsearchVersion?: string;
    indexPatterns?: outputs.ServiceElasticsearchUserConfigIndexPattern[];
    ipFilters?: string[];
    kibana?: outputs.ServiceElasticsearchUserConfigKibana;
    maxIndexCount?: number;
    privateAccess?: outputs.ServiceElasticsearchUserConfigPrivateAccess;
    publicAccess?: outputs.ServiceElasticsearchUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
}

export interface ServiceElasticsearchUserConfigElasticsearch {
    actionDestructiveRequiresName?: boolean;
    httpMaxContentLength?: number;
    indicesFielddataCacheSize?: number;
    indicesMemoryIndexBufferSize?: number;
    indicesQueriesCacheSize?: number;
    indicesQueryBoolMaxClauseCount?: number;
    reindexRemoteWhitelists?: string[];
    threadPoolAnalyzeQueueSize?: number;
    threadPoolAnalyzeSize?: number;
    threadPoolForceMergeSize?: number;
    threadPoolGetQueueSize?: number;
    threadPoolGetSize?: number;
    threadPoolIndexQueueSize?: number;
    threadPoolIndexSize?: number;
    threadPoolSearchQueueSize?: number;
    threadPoolSearchSize?: number;
    threadPoolSearchThrottledQueueSize?: number;
    threadPoolSearchThrottledSize?: number;
    threadPoolWriteQueueSize?: number;
    threadPoolWriteSize?: number;
}

export interface ServiceElasticsearchUserConfigIndexPattern {
    maxIndexCount?: number;
    pattern?: string;
}

export interface ServiceElasticsearchUserConfigKibana {
    elasticsearchRequestTimeout?: number;
    enabled?: boolean;
    maxOldSpaceSize?: number;
}

export interface ServiceElasticsearchUserConfigPrivateAccess {
    elasticsearch?: boolean;
    kibana?: boolean;
    prometheus?: boolean;
}

export interface ServiceElasticsearchUserConfigPublicAccess {
    elasticsearch?: boolean;
    kibana?: boolean;
    prometheus?: boolean;
}

export interface ServiceGrafana {

}

export interface ServiceGrafanaUserConfig {
    alertingEnabled?: boolean;
    alertingErrorOrTimeout?: string;
    alertingNodataOrNullvalues?: string;
    allowEmbedding?: boolean;
    authGithub?: outputs.ServiceGrafanaUserConfigAuthGithub;
    authGitlab?: outputs.ServiceGrafanaUserConfigAuthGitlab;
    authGoogle?: outputs.ServiceGrafanaUserConfigAuthGoogle;
    cookieSamesite?: string;
    customDomain?: string;
    dashboardsVersionsToKeep?: number;
    dataproxySendUserHeader?: boolean;
    dataproxyTimeout?: number;
    disableGravatar?: boolean;
    editorsCanAdmin?: boolean;
    externalImageStorage?: outputs.ServiceGrafanaUserConfigExternalImageStorage;
    googleAnalyticsUaId?: string;
    ipFilters?: string[];
    metricsEnabled?: boolean;
    privateAccess?: outputs.ServiceGrafanaUserConfigPrivateAccess;
    publicAccess?: outputs.ServiceGrafanaUserConfigPublicAccess;
    smtpServer?: outputs.ServiceGrafanaUserConfigSmtpServer;
    userAutoAssignOrg?: boolean;
    userAutoAssignOrgRole?: string;
    viewersCanEdit?: boolean;
}

export interface ServiceGrafanaUserConfigAuthGithub {
    allowSignUp?: boolean;
    allowedOrganizations?: string[];
    clientId?: string;
    clientSecret?: string;
    teamIds?: number[];
}

export interface ServiceGrafanaUserConfigAuthGitlab {
    allowSignUp?: boolean;
    allowedGroups?: string[];
    clientId?: string;
    clientSecret?: string;
}

export interface ServiceGrafanaUserConfigAuthGoogle {
    allowSignUp?: boolean;
    allowedDomains?: string[];
    clientId?: string;
    clientSecret?: string;
}

export interface ServiceGrafanaUserConfigExternalImageStorage {
    accessKey?: string;
    bucketUrl?: string;
    provider?: string;
    secretKey?: string;
}

export interface ServiceGrafanaUserConfigPrivateAccess {
    grafana?: boolean;
}

export interface ServiceGrafanaUserConfigPublicAccess {
    grafana?: boolean;
}

export interface ServiceGrafanaUserConfigSmtpServer {
    fromAddress?: string;
    fromName?: string;
    host?: string;
    password?: string;
    port?: number;
    skipVerify?: boolean;
    username?: string;
}

export interface ServiceInfluxdb {
    databaseName: string;
}

export interface ServiceInfluxdbUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    privateAccess?: outputs.ServiceInfluxdbUserConfigPrivateAccess;
    publicAccess?: outputs.ServiceInfluxdbUserConfigPublicAccess;
    serviceToForkFrom?: string;
}

export interface ServiceInfluxdbUserConfigPrivateAccess {
    influxdb?: boolean;
}

export interface ServiceInfluxdbUserConfigPublicAccess {
    influxdb?: boolean;
}

export interface ServiceIntegrationEndpointDatadogUserConfig {
    datadogApiKey?: string;
    disableConsumerStats?: boolean;
    maxPartitionContexts?: number;
    site?: string;
}

export interface ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig {
    ca?: string;
    indexDaysMax?: number;
    indexPrefix?: string;
    timeout?: number;
    url?: string;
}

export interface ServiceIntegrationEndpointPrometheusUserConfig {
    basicAuthPassword?: string;
    basicAuthUsername?: string;
}

export interface ServiceIntegrationEndpointRsyslogUserConfig {
    ca?: string;
    cert?: string;
    format?: string;
    key?: string;
    logline?: string;
    port?: number;
    sd?: string;
    server?: string;
    tls?: boolean;
}

export interface ServiceIntegrationLogsUserConfig {
    elasticsearchIndexDaysMax?: number;
    elasticsearchIndexPrefix?: string;
}

export interface ServiceIntegrationMirrormakerUserConfig {
    mirrormakerWhitelist?: string;
}

export interface ServiceKafka {
    accessCert: string;
    accessKey: string;
    connectUri: string;
    restUri: string;
    schemaRegistryUri: string;
}

export interface ServiceKafkaConnect {

}

export interface ServiceKafkaConnectUserConfig {
    ipFilters?: string[];
    kafkaConnect?: outputs.ServiceKafkaConnectUserConfigKafkaConnect;
    privateAccess?: outputs.ServiceKafkaConnectUserConfigPrivateAccess;
    publicAccess?: outputs.ServiceKafkaConnectUserConfigPublicAccess;
}

export interface ServiceKafkaConnectUserConfigKafkaConnect {
    consumerIsolationLevel?: string;
    consumerMaxPollRecords?: number;
}

export interface ServiceKafkaConnectUserConfigPrivateAccess {
    kafkaConnect?: boolean;
    prometheus?: boolean;
}

export interface ServiceKafkaConnectUserConfigPublicAccess {
    kafkaConnect?: boolean;
    prometheus?: boolean;
}

export interface ServiceKafkaUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    kafka?: outputs.ServiceKafkaUserConfigKafka;
    kafkaAuthenticationMethods?: outputs.ServiceKafkaUserConfigKafkaAuthenticationMethods;
    kafkaConnect?: boolean;
    kafkaConnectConfig?: outputs.ServiceKafkaUserConfigKafkaConnectConfig;
    kafkaRest?: boolean;
    kafkaRestConfig?: outputs.ServiceKafkaUserConfigKafkaRestConfig;
    kafkaVersion?: string;
    privateAccess?: outputs.ServiceKafkaUserConfigPrivateAccess;
    publicAccess?: outputs.ServiceKafkaUserConfigPublicAccess;
    schemaRegistry?: boolean;
}

export interface ServiceKafkaUserConfigKafka {
    autoCreateTopicsEnable?: boolean;
    compressionType?: string;
    defaultReplicationFactor?: number;
    groupMaxSessionTimeoutMs?: number;
    groupMinSessionTimeoutMs?: number;
    logCleanerMaxCompactionLagMs?: number;
    logCleanerMinCleanableRatio?: number;
    logCleanerMinCompactionLagMs?: number;
    logMessageTimestampDifferenceMaxMs?: number;
    logMessageTimestampType?: string;
    logRetentionBytes?: number;
    logRetentionHours?: number;
    logSegmentBytes?: number;
    maxConnectionsPerIp?: number;
    messageMaxBytes?: number;
    numPartitions?: number;
    offsetsRetentionMinutes?: number;
    producerPurgatoryPurgeIntervalRequests?: number;
    replicaFetchMaxBytes?: number;
    replicaFetchResponseMaxBytes?: number;
    socketRequestMaxBytes?: number;
}

export interface ServiceKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: boolean;
    sasl?: boolean;
}

export interface ServiceKafkaUserConfigKafkaConnectConfig {
    consumerIsolationLevel?: string;
    consumerMaxPollRecords?: number;
}

export interface ServiceKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: boolean;
    consumerRequestMaxBytes?: number;
    consumerRequestTimeoutMs?: number;
    producerAcks?: string;
    producerLingerMs?: number;
    simpleconsumerPoolSizeMax?: number;
}

export interface ServiceKafkaUserConfigPrivateAccess {
    prometheus?: boolean;
}

export interface ServiceKafkaUserConfigPublicAccess {
    kafka?: boolean;
    prometheus?: boolean;
}

export interface ServiceMysql {

}

export interface ServiceMysqlUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: number;
    backupMinute?: number;
    ipFilters?: string[];
    mysql?: outputs.ServiceMysqlUserConfigMysql;
    mysqlVersion?: string;
    privateAccess?: outputs.ServiceMysqlUserConfigPrivateAccess;
    publicAccess?: outputs.ServiceMysqlUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
}

export interface ServiceMysqlUserConfigMysql {
    defaultTimeZone?: string;
    groupConcatMaxLen?: number;
    innodbFtMinTokenSize?: number;
    sqlMode?: string;
}

export interface ServiceMysqlUserConfigPrivateAccess {
    mysql?: boolean;
    prometheus?: boolean;
}

export interface ServiceMysqlUserConfigPublicAccess {
    mysql?: boolean;
    prometheus?: boolean;
}

export interface ServicePg {
    dbname: string;
    host: string;
    password: string;
    port: number;
    replicaUri: string;
    sslmode: string;
    uri: string;
    user: string;
}

export interface ServicePgUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: number;
    backupMinute?: number;
    ipFilters?: string[];
    pg?: outputs.ServicePgUserConfigPg;
    pgReadReplica?: boolean;
    pgServiceToForkFrom?: string;
    pgVersion?: string;
    pgbouncer?: outputs.ServicePgUserConfigPgbouncer;
    pglookout?: outputs.ServicePgUserConfigPglookout;
    privateAccess?: outputs.ServicePgUserConfigPrivateAccess;
    publicAccess?: outputs.ServicePgUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    variant?: string;
}

export interface ServicePgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: number;
    autovacuumAnalyzeThreshold?: number;
    autovacuumMaxWorkers?: number;
    autovacuumNaptime?: number;
    autovacuumVacuumCostDelay?: number;
    autovacuumVacuumCostLimit?: number;
    autovacuumVacuumScaleFactor?: number;
    autovacuumVacuumThreshold?: number;
    idleInTransactionSessionTimeout?: number;
    jit?: boolean;
    logAutovacuumMinDuration?: number;
    logErrorVerbosity?: string;
    logMinDurationStatement?: number;
    maxLocksPerTransaction?: number;
    maxParallelWorkers?: number;
    maxParallelWorkersPerGather?: number;
    maxPredLocksPerTransaction?: number;
    maxPreparedTransactions?: number;
    maxStackDepth?: number;
    maxStandbyArchiveDelay?: number;
    maxStandbyStreamingDelay?: number;
    maxWorkerProcesses?: number;
    pgStatStatementsTrack?: string;
    tempFileLimit?: number;
    timezone?: string;
    trackActivityQuerySize?: number;
    trackFunctions?: string;
}

export interface ServicePgUserConfigPgbouncer {
    serverResetQueryAlways?: boolean;
}

export interface ServicePgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: number;
}

export interface ServicePgUserConfigPrivateAccess {
    pg?: boolean;
    pgbouncer?: boolean;
    prometheus?: boolean;
}

export interface ServicePgUserConfigPublicAccess {
    pg?: boolean;
    pgbouncer?: boolean;
    prometheus?: boolean;
}

export interface ServiceRedis {

}

export interface ServiceRedisUserConfig {
    ipFilters?: string[];
    privateAccess?: outputs.ServiceRedisUserConfigPrivateAccess;
    publicAccess?: outputs.ServiceRedisUserConfigPublicAccess;
    redisLfuDecayTime?: number;
    redisLfuLogFactor?: number;
    redisMaxmemoryPolicy?: string;
    redisNotifyKeyspaceEvents?: string;
    redisSsl?: boolean;
    redisTimeout?: number;
}

export interface ServiceRedisUserConfigPrivateAccess {
    prometheus?: boolean;
    redis?: boolean;
}

export interface ServiceRedisUserConfigPublicAccess {
    prometheus?: boolean;
    redis?: boolean;
}

export interface ServiceServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}
