// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CassandraCassandra {
}

export interface CassandraCassandraUserConfig {
    ipFilters?: string[];
    migrateSstableloader?: string;
    privateAccess?: outputs.CassandraCassandraUserConfigPrivateAccess;
    publicAccess?: outputs.CassandraCassandraUserConfigPublicAccess;
    serviceToForkFrom?: string;
}

export interface CassandraCassandraUserConfigPrivateAccess {
    prometheus?: string;
}

export interface CassandraCassandraUserConfigPublicAccess {
    prometheus?: string;
}

export interface CassandraComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface CassandraServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface ElasticSearchAclAcl {
    rules: outputs.ElasticSearchAclAclRule[];
    username: string;
}

export interface ElasticSearchAclAclRule {
    index: string;
    permission: string;
}

export interface ElasticSearchComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface ElasticSearchElasticsearch {
    kibanaUri: string;
}

export interface ElasticSearchElasticsearchUserConfig {
    customDomain?: string;
    disableReplicationFactorAdjustment?: string;
    elasticsearch?: outputs.ElasticSearchElasticsearchUserConfigElasticsearch;
    elasticsearchVersion?: string;
    indexPatterns?: outputs.ElasticSearchElasticsearchUserConfigIndexPattern[];
    ipFilters?: string[];
    kibana?: outputs.ElasticSearchElasticsearchUserConfigKibana;
    maxIndexCount?: string;
    privateAccess?: outputs.ElasticSearchElasticsearchUserConfigPrivateAccess;
    publicAccess?: outputs.ElasticSearchElasticsearchUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
}

export interface ElasticSearchElasticsearchUserConfigElasticsearch {
    actionAutoCreateIndexEnabled?: string;
    actionDestructiveRequiresName?: string;
    httpMaxContentLength?: string;
    httpMaxHeaderSize?: string;
    httpMaxInitialLineLength?: string;
    indicesFielddataCacheSize?: string;
    indicesMemoryIndexBufferSize?: string;
    indicesQueriesCacheSize?: string;
    indicesQueryBoolMaxClauseCount?: string;
    reindexRemoteWhitelists?: string[];
    searchMaxBuckets?: string;
    threadPoolAnalyzeQueueSize?: string;
    threadPoolAnalyzeSize?: string;
    threadPoolForceMergeSize?: string;
    threadPoolGetQueueSize?: string;
    threadPoolGetSize?: string;
    threadPoolIndexQueueSize?: string;
    threadPoolIndexSize?: string;
    threadPoolSearchQueueSize?: string;
    threadPoolSearchSize?: string;
    threadPoolSearchThrottledQueueSize?: string;
    threadPoolSearchThrottledSize?: string;
    threadPoolWriteQueueSize?: string;
    threadPoolWriteSize?: string;
}

export interface ElasticSearchElasticsearchUserConfigIndexPattern {
    maxIndexCount?: string;
    pattern?: string;
}

export interface ElasticSearchElasticsearchUserConfigKibana {
    elasticsearchRequestTimeout?: string;
    enabled?: string;
    maxOldSpaceSize?: string;
}

export interface ElasticSearchElasticsearchUserConfigPrivateAccess {
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface ElasticSearchElasticsearchUserConfigPublicAccess {
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface ElasticSearchServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetCassandaCassandra {
}

export interface GetCassandaCassandraUserConfig {
    ipFilters?: string[];
    migrateSstableloader?: string;
    privateAccess?: outputs.GetCassandaCassandraUserConfigPrivateAccess;
    publicAccess?: outputs.GetCassandaCassandraUserConfigPublicAccess;
    serviceToForkFrom?: string;
}

export interface GetCassandaCassandraUserConfigPrivateAccess {
    prometheus?: string;
}

export interface GetCassandaCassandraUserConfigPublicAccess {
    prometheus?: string;
}

export interface GetCassandaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetCassandaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetElasticSearchAclAcl {
    rules: outputs.GetElasticSearchAclAclRule[];
    username: string;
}

export interface GetElasticSearchAclAclRule {
    index: string;
    permission: string;
}

export interface GetElasticSearchComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetElasticSearchElasticsearch {
    kibanaUri: string;
}

export interface GetElasticSearchElasticsearchUserConfig {
    customDomain?: string;
    disableReplicationFactorAdjustment?: string;
    elasticsearch?: outputs.GetElasticSearchElasticsearchUserConfigElasticsearch;
    elasticsearchVersion?: string;
    indexPatterns?: outputs.GetElasticSearchElasticsearchUserConfigIndexPattern[];
    ipFilters?: string[];
    kibana?: outputs.GetElasticSearchElasticsearchUserConfigKibana;
    maxIndexCount?: string;
    privateAccess?: outputs.GetElasticSearchElasticsearchUserConfigPrivateAccess;
    publicAccess?: outputs.GetElasticSearchElasticsearchUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
}

export interface GetElasticSearchElasticsearchUserConfigElasticsearch {
    actionAutoCreateIndexEnabled?: string;
    actionDestructiveRequiresName?: string;
    httpMaxContentLength?: string;
    httpMaxHeaderSize?: string;
    httpMaxInitialLineLength?: string;
    indicesFielddataCacheSize?: string;
    indicesMemoryIndexBufferSize?: string;
    indicesQueriesCacheSize?: string;
    indicesQueryBoolMaxClauseCount?: string;
    reindexRemoteWhitelists?: string[];
    searchMaxBuckets?: string;
    threadPoolAnalyzeQueueSize?: string;
    threadPoolAnalyzeSize?: string;
    threadPoolForceMergeSize?: string;
    threadPoolGetQueueSize?: string;
    threadPoolGetSize?: string;
    threadPoolIndexQueueSize?: string;
    threadPoolIndexSize?: string;
    threadPoolSearchQueueSize?: string;
    threadPoolSearchSize?: string;
    threadPoolSearchThrottledQueueSize?: string;
    threadPoolSearchThrottledSize?: string;
    threadPoolWriteQueueSize?: string;
    threadPoolWriteSize?: string;
}

export interface GetElasticSearchElasticsearchUserConfigIndexPattern {
    maxIndexCount?: string;
    pattern?: string;
}

export interface GetElasticSearchElasticsearchUserConfigKibana {
    elasticsearchRequestTimeout?: string;
    enabled?: string;
    maxOldSpaceSize?: string;
}

export interface GetElasticSearchElasticsearchUserConfigPrivateAccess {
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface GetElasticSearchElasticsearchUserConfigPublicAccess {
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface GetElasticSearchServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetGrafanaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetGrafanaGrafana {
}

export interface GetGrafanaGrafanaUserConfig {
    alertingEnabled?: string;
    alertingErrorOrTimeout?: string;
    alertingNodataOrNullvalues?: string;
    allowEmbedding?: string;
    authBasicEnabled?: string;
    authGenericOauth?: outputs.GetGrafanaGrafanaUserConfigAuthGenericOauth;
    authGithub?: outputs.GetGrafanaGrafanaUserConfigAuthGithub;
    authGitlab?: outputs.GetGrafanaGrafanaUserConfigAuthGitlab;
    authGoogle?: outputs.GetGrafanaGrafanaUserConfigAuthGoogle;
    cookieSamesite?: string;
    customDomain?: string;
    dashboardsVersionsToKeep?: string;
    dataproxySendUserHeader?: string;
    dataproxyTimeout?: string;
    disableGravatar?: string;
    editorsCanAdmin?: string;
    externalImageStorage?: outputs.GetGrafanaGrafanaUserConfigExternalImageStorage;
    googleAnalyticsUaId?: string;
    ipFilters?: string[];
    metricsEnabled?: string;
    privateAccess?: outputs.GetGrafanaGrafanaUserConfigPrivateAccess;
    publicAccess?: outputs.GetGrafanaGrafanaUserConfigPublicAccess;
    smtpServer?: outputs.GetGrafanaGrafanaUserConfigSmtpServer;
    userAutoAssignOrg?: string;
    userAutoAssignOrgRole?: string;
    viewersCanEdit?: string;
}

export interface GetGrafanaGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedOrganizations?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    name?: string;
    scopes?: string[];
    tokenUrl?: string;
}

export interface GetGrafanaGrafanaUserConfigAuthGithub {
    allowSignUp?: string;
    allowedOrganizations?: string[];
    clientId?: string;
    clientSecret?: string;
    teamIds?: string[];
}

export interface GetGrafanaGrafanaUserConfigAuthGitlab {
    allowSignUp?: string;
    allowedGroups?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface GetGrafanaGrafanaUserConfigAuthGoogle {
    allowSignUp?: string;
    allowedDomains?: string[];
    clientId?: string;
    clientSecret?: string;
}

export interface GetGrafanaGrafanaUserConfigExternalImageStorage {
    accessKey?: string;
    bucketUrl?: string;
    provider?: string;
    secretKey?: string;
}

export interface GetGrafanaGrafanaUserConfigPrivateAccess {
    grafana?: string;
}

export interface GetGrafanaGrafanaUserConfigPublicAccess {
    grafana?: string;
}

export interface GetGrafanaGrafanaUserConfigSmtpServer {
    fromAddress?: string;
    fromName?: string;
    host?: string;
    password?: string;
    port?: string;
    skipVerify?: string;
    username?: string;
}

export interface GetGrafanaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetInfluxDbComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetInfluxDbInfluxdb {
    databaseName: string;
}

export interface GetInfluxDbInfluxdbUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    privateAccess?: outputs.GetInfluxDbInfluxdbUserConfigPrivateAccess;
    publicAccess?: outputs.GetInfluxDbInfluxdbUserConfigPublicAccess;
    serviceToForkFrom?: string;
}

export interface GetInfluxDbInfluxdbUserConfigPrivateAccess {
    influxdb?: string;
}

export interface GetInfluxDbInfluxdbUserConfigPublicAccess {
    influxdb?: string;
}

export interface GetInfluxDbServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetKafkaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetKafkaConnectComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetKafkaConnectKafkaConnect {
}

export interface GetKafkaConnectKafkaConnectUserConfig {
    ipFilters?: string[];
    kafkaConnect?: outputs.GetKafkaConnectKafkaConnectUserConfigKafkaConnect;
    privateAccess?: outputs.GetKafkaConnectKafkaConnectUserConfigPrivateAccess;
    publicAccess?: outputs.GetKafkaConnectKafkaConnectUserConfigPublicAccess;
}

export interface GetKafkaConnectKafkaConnectUserConfigKafkaConnect {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerIsolationLevel?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    sessionTimeoutMs?: string;
}

export interface GetKafkaConnectKafkaConnectUserConfigPrivateAccess {
    kafkaConnect?: string;
    prometheus?: string;
}

export interface GetKafkaConnectKafkaConnectUserConfigPublicAccess {
    kafkaConnect?: string;
    prometheus?: string;
}

export interface GetKafkaConnectServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetKafkaConnectorTask {
    connector: string;
    task: number;
}

export interface GetKafkaKafka {
    accessCert: string;
    accessKey: string;
    connectUri: string;
    restUri: string;
    schemaRegistryUri: string;
}

export interface GetKafkaKafkaUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    kafka?: outputs.GetKafkaKafkaUserConfigKafka;
    kafkaAuthenticationMethods?: outputs.GetKafkaKafkaUserConfigKafkaAuthenticationMethods;
    kafkaConnect?: string;
    kafkaConnectConfig?: outputs.GetKafkaKafkaUserConfigKafkaConnectConfig;
    kafkaRest?: string;
    kafkaRestConfig?: outputs.GetKafkaKafkaUserConfigKafkaRestConfig;
    kafkaVersion?: string;
    privateAccess?: outputs.GetKafkaKafkaUserConfigPrivateAccess;
    publicAccess?: outputs.GetKafkaKafkaUserConfigPublicAccess;
    schemaRegistry?: string;
}

export interface GetKafkaKafkaUserConfigKafka {
    autoCreateTopicsEnable?: string;
    compressionType?: string;
    connectionsMaxIdleMs?: string;
    defaultReplicationFactor?: string;
    groupMaxSessionTimeoutMs?: string;
    groupMinSessionTimeoutMs?: string;
    logCleanerMaxCompactionLagMs?: string;
    logCleanerMinCleanableRatio?: string;
    logCleanerMinCompactionLagMs?: string;
    logCleanupPolicy?: string;
    logMessageTimestampDifferenceMaxMs?: string;
    logMessageTimestampType?: string;
    logRetentionBytes?: string;
    logRetentionHours?: string;
    logSegmentBytes?: string;
    maxConnectionsPerIp?: string;
    maxIncrementalFetchSessionCacheSlots?: string;
    messageMaxBytes?: string;
    numPartitions?: string;
    offsetsRetentionMinutes?: string;
    producerPurgatoryPurgeIntervalRequests?: string;
    replicaFetchMaxBytes?: string;
    replicaFetchResponseMaxBytes?: string;
    socketRequestMaxBytes?: string;
}

export interface GetKafkaKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: string;
    sasl?: string;
}

export interface GetKafkaKafkaUserConfigKafkaConnectConfig {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerIsolationLevel?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    sessionTimeoutMs?: string;
}

export interface GetKafkaKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: string;
    consumerRequestMaxBytes?: string;
    consumerRequestTimeoutMs?: string;
    producerAcks?: string;
    producerLingerMs?: string;
    simpleconsumerPoolSizeMax?: string;
}

export interface GetKafkaKafkaUserConfigPrivateAccess {
    prometheus?: string;
}

export interface GetKafkaKafkaUserConfigPublicAccess {
    kafka?: string;
    kafkaConnect?: string;
    kafkaRest?: string;
    prometheus?: string;
    schemaRegistry?: string;
}

export interface GetKafkaMirrorMakerComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetKafkaMirrorMakerKafkaMirrormaker {
}

export interface GetKafkaMirrorMakerKafkaMirrormakerUserConfig {
    ipFilters?: string[];
    kafkaMirrormaker?: outputs.GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker;
}

export interface GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker {
    refreshGroupsEnabled?: string;
    refreshGroupsIntervalSeconds?: string;
    refreshTopicsEnabled?: string;
    refreshTopicsIntervalSeconds?: string;
}

export interface GetKafkaMirrorMakerServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetKafkaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetMySqlComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetMySqlMysql {
}

export interface GetMySqlMysqlUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    ipFilters?: string[];
    mysql?: outputs.GetMySqlMysqlUserConfigMysql;
    mysqlVersion?: string;
    privateAccess?: outputs.GetMySqlMysqlUserConfigPrivateAccess;
    publicAccess?: outputs.GetMySqlMysqlUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
}

export interface GetMySqlMysqlUserConfigMysql {
    connectTimeout?: string;
    defaultTimeZone?: string;
    groupConcatMaxLen?: string;
    informationSchemaStatsExpiry?: string;
    innodbFtMinTokenSize?: string;
    innodbFtServerStopwordTable?: string;
    innodbLockWaitTimeout?: string;
    innodbLogBufferSize?: string;
    innodbOnlineAlterLogMaxSize?: string;
    innodbPrintAllDeadlocks?: string;
    innodbRollbackOnTimeout?: string;
    interactiveTimeout?: string;
    maxAllowedPacket?: string;
    maxHeapTableSize?: string;
    netReadTimeout?: string;
    netWriteTimeout?: string;
    sortBufferSize?: string;
    sqlMode?: string;
    sqlRequirePrimaryKey?: string;
    tmpTableSize?: string;
    waitTimeout?: string;
}

export interface GetMySqlMysqlUserConfigPrivateAccess {
    mysql?: string;
    prometheus?: string;
}

export interface GetMySqlMysqlUserConfigPublicAccess {
    mysql?: string;
    prometheus?: string;
}

export interface GetMySqlServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetPgComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetPgPg {
    dbname: string;
    host: string;
    password: string;
    port: number;
    replicaUri: string;
    sslmode: string;
    uri: string;
    user: string;
}

export interface GetPgPgUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    ipFilters?: string[];
    pg?: outputs.GetPgPgUserConfigPg;
    pgReadReplica?: string;
    pgServiceToForkFrom?: string;
    pgVersion?: string;
    pgbouncer?: outputs.GetPgPgUserConfigPgbouncer;
    pglookout?: outputs.GetPgPgUserConfigPglookout;
    privateAccess?: outputs.GetPgPgUserConfigPrivateAccess;
    publicAccess?: outputs.GetPgPgUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    sharedBuffersPercentage?: string;
    synchronousReplication?: string;
    timescaledb?: outputs.GetPgPgUserConfigTimescaledb;
    variant?: string;
    workMem?: string;
}

export interface GetPgPgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: string;
    autovacuumAnalyzeThreshold?: string;
    autovacuumFreezeMaxAge?: string;
    autovacuumMaxWorkers?: string;
    autovacuumNaptime?: string;
    autovacuumVacuumCostDelay?: string;
    autovacuumVacuumCostLimit?: string;
    autovacuumVacuumScaleFactor?: string;
    autovacuumVacuumThreshold?: string;
    deadlockTimeout?: string;
    idleInTransactionSessionTimeout?: string;
    jit?: string;
    logAutovacuumMinDuration?: string;
    logErrorVerbosity?: string;
    logMinDurationStatement?: string;
    maxLocksPerTransaction?: string;
    maxParallelWorkers?: string;
    maxParallelWorkersPerGather?: string;
    maxPredLocksPerTransaction?: string;
    maxPreparedTransactions?: string;
    maxStackDepth?: string;
    maxStandbyArchiveDelay?: string;
    maxStandbyStreamingDelay?: string;
    maxWorkerProcesses?: string;
    pgStatStatementsDotTrack?: string;
    tempFileLimit?: string;
    timezone?: string;
    trackActivityQuerySize?: string;
    trackCommitTimestamp?: string;
    trackFunctions?: string;
    walSenderTimeout?: string;
    walWriterDelay?: string;
}

export interface GetPgPgUserConfigPgbouncer {
    ignoreStartupParameters?: string[];
    serverResetQueryAlways?: string;
}

export interface GetPgPgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: string;
}

export interface GetPgPgUserConfigPrivateAccess {
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface GetPgPgUserConfigPublicAccess {
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface GetPgPgUserConfigTimescaledb {
    maxBackgroundWorkers?: string;
}

export interface GetPgServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetRedisComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetRedisRedis {
}

export interface GetRedisRedisUserConfig {
    ipFilters?: string[];
    migration?: outputs.GetRedisRedisUserConfigMigration;
    privateAccess?: outputs.GetRedisRedisUserConfigPrivateAccess;
    publicAccess?: outputs.GetRedisRedisUserConfigPublicAccess;
    redisLfuDecayTime?: string;
    redisLfuLogFactor?: string;
    redisMaxmemoryPolicy?: string;
    redisNotifyKeyspaceEvents?: string;
    redisSsl?: string;
    redisTimeout?: string;
}

export interface GetRedisRedisUserConfigMigration {
    host?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface GetRedisRedisUserConfigPrivateAccess {
    prometheus?: string;
    redis?: string;
}

export interface GetRedisRedisUserConfigPublicAccess {
    prometheus?: string;
    redis?: string;
}

export interface GetRedisServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetServiceCassandra {
}

export interface GetServiceCassandraUserConfig {
    ipFilters?: string[];
    migrateSstableloader?: string;
    privateAccess?: outputs.GetServiceCassandraUserConfigPrivateAccess;
    publicAccess?: outputs.GetServiceCassandraUserConfigPublicAccess;
    serviceToForkFrom?: string;
}

export interface GetServiceCassandraUserConfigPrivateAccess {
    prometheus?: string;
}

export interface GetServiceCassandraUserConfigPublicAccess {
    prometheus?: string;
}

export interface GetServiceComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GetServiceElasticsearch {
    kibanaUri: string;
}

export interface GetServiceElasticsearchUserConfig {
    customDomain?: string;
    disableReplicationFactorAdjustment?: string;
    elasticsearch?: outputs.GetServiceElasticsearchUserConfigElasticsearch;
    elasticsearchVersion?: string;
    indexPatterns?: outputs.GetServiceElasticsearchUserConfigIndexPattern[];
    ipFilters?: string[];
    kibana?: outputs.GetServiceElasticsearchUserConfigKibana;
    maxIndexCount?: string;
    privateAccess?: outputs.GetServiceElasticsearchUserConfigPrivateAccess;
    publicAccess?: outputs.GetServiceElasticsearchUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
}

export interface GetServiceElasticsearchUserConfigElasticsearch {
    actionAutoCreateIndexEnabled?: string;
    actionDestructiveRequiresName?: string;
    httpMaxContentLength?: string;
    httpMaxHeaderSize?: string;
    httpMaxInitialLineLength?: string;
    indicesFielddataCacheSize?: string;
    indicesMemoryIndexBufferSize?: string;
    indicesQueriesCacheSize?: string;
    indicesQueryBoolMaxClauseCount?: string;
    reindexRemoteWhitelists?: string[];
    searchMaxBuckets?: string;
    threadPoolAnalyzeQueueSize?: string;
    threadPoolAnalyzeSize?: string;
    threadPoolForceMergeSize?: string;
    threadPoolGetQueueSize?: string;
    threadPoolGetSize?: string;
    threadPoolIndexQueueSize?: string;
    threadPoolIndexSize?: string;
    threadPoolSearchQueueSize?: string;
    threadPoolSearchSize?: string;
    threadPoolSearchThrottledQueueSize?: string;
    threadPoolSearchThrottledSize?: string;
    threadPoolWriteQueueSize?: string;
    threadPoolWriteSize?: string;
}

export interface GetServiceElasticsearchUserConfigIndexPattern {
    maxIndexCount?: string;
    pattern?: string;
}

export interface GetServiceElasticsearchUserConfigKibana {
    elasticsearchRequestTimeout?: string;
    enabled?: string;
    maxOldSpaceSize?: string;
}

export interface GetServiceElasticsearchUserConfigPrivateAccess {
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface GetServiceElasticsearchUserConfigPublicAccess {
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface GetServiceGrafana {
}

export interface GetServiceGrafanaUserConfig {
    alertingEnabled?: string;
    alertingErrorOrTimeout?: string;
    alertingNodataOrNullvalues?: string;
    allowEmbedding?: string;
    authBasicEnabled?: string;
    authGenericOauth?: outputs.GetServiceGrafanaUserConfigAuthGenericOauth;
    authGithub?: outputs.GetServiceGrafanaUserConfigAuthGithub;
    authGitlab?: outputs.GetServiceGrafanaUserConfigAuthGitlab;
    authGoogle?: outputs.GetServiceGrafanaUserConfigAuthGoogle;
    cookieSamesite?: string;
    customDomain?: string;
    dashboardsVersionsToKeep?: string;
    dataproxySendUserHeader?: string;
    dataproxyTimeout?: string;
    disableGravatar?: string;
    editorsCanAdmin?: string;
    externalImageStorage?: outputs.GetServiceGrafanaUserConfigExternalImageStorage;
    googleAnalyticsUaId?: string;
    ipFilters?: string[];
    metricsEnabled?: string;
    privateAccess?: outputs.GetServiceGrafanaUserConfigPrivateAccess;
    publicAccess?: outputs.GetServiceGrafanaUserConfigPublicAccess;
    smtpServer?: outputs.GetServiceGrafanaUserConfigSmtpServer;
    userAutoAssignOrg?: string;
    userAutoAssignOrgRole?: string;
    viewersCanEdit?: string;
}

export interface GetServiceGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedOrganizations?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    name?: string;
    scopes?: string[];
    tokenUrl?: string;
}

export interface GetServiceGrafanaUserConfigAuthGithub {
    allowSignUp?: string;
    allowedOrganizations?: string[];
    clientId?: string;
    clientSecret?: string;
    teamIds?: string[];
}

export interface GetServiceGrafanaUserConfigAuthGitlab {
    allowSignUp?: string;
    allowedGroups?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface GetServiceGrafanaUserConfigAuthGoogle {
    allowSignUp?: string;
    allowedDomains?: string[];
    clientId?: string;
    clientSecret?: string;
}

export interface GetServiceGrafanaUserConfigExternalImageStorage {
    accessKey?: string;
    bucketUrl?: string;
    provider?: string;
    secretKey?: string;
}

export interface GetServiceGrafanaUserConfigPrivateAccess {
    grafana?: string;
}

export interface GetServiceGrafanaUserConfigPublicAccess {
    grafana?: string;
}

export interface GetServiceGrafanaUserConfigSmtpServer {
    fromAddress?: string;
    fromName?: string;
    host?: string;
    password?: string;
    port?: string;
    skipVerify?: string;
    username?: string;
}

export interface GetServiceInfluxdb {
    databaseName: string;
}

export interface GetServiceInfluxdbUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    privateAccess?: outputs.GetServiceInfluxdbUserConfigPrivateAccess;
    publicAccess?: outputs.GetServiceInfluxdbUserConfigPublicAccess;
    serviceToForkFrom?: string;
}

export interface GetServiceInfluxdbUserConfigPrivateAccess {
    influxdb?: string;
}

export interface GetServiceInfluxdbUserConfigPublicAccess {
    influxdb?: string;
}

export interface GetServiceIntegrationEndpointDatadogUserConfig {
    datadogApiKey?: string;
    disableConsumerStats?: string;
    maxPartitionContexts?: string;
    site?: string;
}

export interface GetServiceIntegrationEndpointExternalElasticsearchLogsUserConfig {
    ca?: string;
    indexDaysMax?: string;
    indexPrefix?: string;
    timeout?: string;
    url?: string;
}

export interface GetServiceIntegrationEndpointPrometheusUserConfig {
    basicAuthPassword?: string;
    basicAuthUsername?: string;
}

export interface GetServiceIntegrationEndpointRsyslogUserConfig {
    ca?: string;
    cert?: string;
    format?: string;
    key?: string;
    logline?: string;
    port?: string;
    sd?: string;
    server?: string;
    tls?: string;
}

export interface GetServiceIntegrationKafkaConnectUserConfig {
    kafkaConnect?: outputs.GetServiceIntegrationKafkaConnectUserConfigKafkaConnect;
}

export interface GetServiceIntegrationKafkaConnectUserConfigKafkaConnect {
    configStorageTopic?: string;
    groupId?: string;
    offsetStorageTopic?: string;
    statusStorageTopic?: string;
}

export interface GetServiceIntegrationKafkaMirrormakerUserConfig {
    clusterAlias?: string;
}

export interface GetServiceIntegrationLogsUserConfig {
    elasticsearchIndexDaysMax?: string;
    elasticsearchIndexPrefix?: string;
}

export interface GetServiceIntegrationMirrormakerUserConfig {
    mirrormakerWhitelist?: string;
}

export interface GetServiceKafka {
    accessCert: string;
    accessKey: string;
    connectUri: string;
    restUri: string;
    schemaRegistryUri: string;
}

export interface GetServiceKafkaConnect {
}

export interface GetServiceKafkaConnectUserConfig {
    ipFilters?: string[];
    kafkaConnect?: outputs.GetServiceKafkaConnectUserConfigKafkaConnect;
    privateAccess?: outputs.GetServiceKafkaConnectUserConfigPrivateAccess;
    publicAccess?: outputs.GetServiceKafkaConnectUserConfigPublicAccess;
}

export interface GetServiceKafkaConnectUserConfigKafkaConnect {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerIsolationLevel?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    sessionTimeoutMs?: string;
}

export interface GetServiceKafkaConnectUserConfigPrivateAccess {
    kafkaConnect?: string;
    prometheus?: string;
}

export interface GetServiceKafkaConnectUserConfigPublicAccess {
    kafkaConnect?: string;
    prometheus?: string;
}

export interface GetServiceKafkaMirrormaker {
}

export interface GetServiceKafkaMirrormakerUserConfig {
    ipFilters?: string[];
    kafkaMirrormaker?: outputs.GetServiceKafkaMirrormakerUserConfigKafkaMirrormaker;
}

export interface GetServiceKafkaMirrormakerUserConfigKafkaMirrormaker {
    refreshGroupsEnabled?: string;
    refreshGroupsIntervalSeconds?: string;
    refreshTopicsEnabled?: string;
    refreshTopicsIntervalSeconds?: string;
}

export interface GetServiceKafkaUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    kafka?: outputs.GetServiceKafkaUserConfigKafka;
    kafkaAuthenticationMethods?: outputs.GetServiceKafkaUserConfigKafkaAuthenticationMethods;
    kafkaConnect?: string;
    kafkaConnectConfig?: outputs.GetServiceKafkaUserConfigKafkaConnectConfig;
    kafkaRest?: string;
    kafkaRestConfig?: outputs.GetServiceKafkaUserConfigKafkaRestConfig;
    kafkaVersion?: string;
    privateAccess?: outputs.GetServiceKafkaUserConfigPrivateAccess;
    publicAccess?: outputs.GetServiceKafkaUserConfigPublicAccess;
    schemaRegistry?: string;
}

export interface GetServiceKafkaUserConfigKafka {
    autoCreateTopicsEnable?: string;
    compressionType?: string;
    connectionsMaxIdleMs?: string;
    defaultReplicationFactor?: string;
    groupMaxSessionTimeoutMs?: string;
    groupMinSessionTimeoutMs?: string;
    logCleanerMaxCompactionLagMs?: string;
    logCleanerMinCleanableRatio?: string;
    logCleanerMinCompactionLagMs?: string;
    logCleanupPolicy?: string;
    logMessageTimestampDifferenceMaxMs?: string;
    logMessageTimestampType?: string;
    logRetentionBytes?: string;
    logRetentionHours?: string;
    logSegmentBytes?: string;
    maxConnectionsPerIp?: string;
    maxIncrementalFetchSessionCacheSlots?: string;
    messageMaxBytes?: string;
    numPartitions?: string;
    offsetsRetentionMinutes?: string;
    producerPurgatoryPurgeIntervalRequests?: string;
    replicaFetchMaxBytes?: string;
    replicaFetchResponseMaxBytes?: string;
    socketRequestMaxBytes?: string;
}

export interface GetServiceKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: string;
    sasl?: string;
}

export interface GetServiceKafkaUserConfigKafkaConnectConfig {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerIsolationLevel?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    sessionTimeoutMs?: string;
}

export interface GetServiceKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: string;
    consumerRequestMaxBytes?: string;
    consumerRequestTimeoutMs?: string;
    producerAcks?: string;
    producerLingerMs?: string;
    simpleconsumerPoolSizeMax?: string;
}

export interface GetServiceKafkaUserConfigPrivateAccess {
    prometheus?: string;
}

export interface GetServiceKafkaUserConfigPublicAccess {
    kafka?: string;
    kafkaConnect?: string;
    kafkaRest?: string;
    prometheus?: string;
    schemaRegistry?: string;
}

export interface GetServiceMysql {
}

export interface GetServiceMysqlUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    ipFilters?: string[];
    mysql?: outputs.GetServiceMysqlUserConfigMysql;
    mysqlVersion?: string;
    privateAccess?: outputs.GetServiceMysqlUserConfigPrivateAccess;
    publicAccess?: outputs.GetServiceMysqlUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
}

export interface GetServiceMysqlUserConfigMysql {
    connectTimeout?: string;
    defaultTimeZone?: string;
    groupConcatMaxLen?: string;
    informationSchemaStatsExpiry?: string;
    innodbFtMinTokenSize?: string;
    innodbFtServerStopwordTable?: string;
    innodbLockWaitTimeout?: string;
    innodbLogBufferSize?: string;
    innodbOnlineAlterLogMaxSize?: string;
    innodbPrintAllDeadlocks?: string;
    innodbRollbackOnTimeout?: string;
    interactiveTimeout?: string;
    maxAllowedPacket?: string;
    maxHeapTableSize?: string;
    netReadTimeout?: string;
    netWriteTimeout?: string;
    sortBufferSize?: string;
    sqlMode?: string;
    sqlRequirePrimaryKey?: string;
    tmpTableSize?: string;
    waitTimeout?: string;
}

export interface GetServiceMysqlUserConfigPrivateAccess {
    mysql?: string;
    prometheus?: string;
}

export interface GetServiceMysqlUserConfigPublicAccess {
    mysql?: string;
    prometheus?: string;
}

export interface GetServicePg {
    dbname: string;
    host: string;
    password: string;
    port: number;
    replicaUri: string;
    sslmode: string;
    uri: string;
    user: string;
}

export interface GetServicePgUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    ipFilters?: string[];
    pg?: outputs.GetServicePgUserConfigPg;
    pgReadReplica?: string;
    pgServiceToForkFrom?: string;
    pgVersion?: string;
    pgbouncer?: outputs.GetServicePgUserConfigPgbouncer;
    pglookout?: outputs.GetServicePgUserConfigPglookout;
    privateAccess?: outputs.GetServicePgUserConfigPrivateAccess;
    publicAccess?: outputs.GetServicePgUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    sharedBuffersPercentage?: string;
    synchronousReplication?: string;
    timescaledb?: outputs.GetServicePgUserConfigTimescaledb;
    variant?: string;
    workMem?: string;
}

export interface GetServicePgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: string;
    autovacuumAnalyzeThreshold?: string;
    autovacuumFreezeMaxAge?: string;
    autovacuumMaxWorkers?: string;
    autovacuumNaptime?: string;
    autovacuumVacuumCostDelay?: string;
    autovacuumVacuumCostLimit?: string;
    autovacuumVacuumScaleFactor?: string;
    autovacuumVacuumThreshold?: string;
    deadlockTimeout?: string;
    idleInTransactionSessionTimeout?: string;
    jit?: string;
    logAutovacuumMinDuration?: string;
    logErrorVerbosity?: string;
    logMinDurationStatement?: string;
    maxLocksPerTransaction?: string;
    maxParallelWorkers?: string;
    maxParallelWorkersPerGather?: string;
    maxPredLocksPerTransaction?: string;
    maxPreparedTransactions?: string;
    maxStackDepth?: string;
    maxStandbyArchiveDelay?: string;
    maxStandbyStreamingDelay?: string;
    maxWorkerProcesses?: string;
    pgStatStatementsTrack?: string;
    tempFileLimit?: string;
    timezone?: string;
    trackActivityQuerySize?: string;
    trackCommitTimestamp?: string;
    trackFunctions?: string;
    walSenderTimeout?: string;
    walWriterDelay?: string;
}

export interface GetServicePgUserConfigPgbouncer {
    ignoreStartupParameters?: string[];
    serverResetQueryAlways?: string;
}

export interface GetServicePgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: string;
}

export interface GetServicePgUserConfigPrivateAccess {
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface GetServicePgUserConfigPublicAccess {
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface GetServicePgUserConfigTimescaledb {
    maxBackgroundWorkers?: string;
}

export interface GetServiceRedis {
}

export interface GetServiceRedisUserConfig {
    ipFilters?: string[];
    migration?: outputs.GetServiceRedisUserConfigMigration;
    privateAccess?: outputs.GetServiceRedisUserConfigPrivateAccess;
    publicAccess?: outputs.GetServiceRedisUserConfigPublicAccess;
    redisLfuDecayTime?: string;
    redisLfuLogFactor?: string;
    redisMaxmemoryPolicy?: string;
    redisNotifyKeyspaceEvents?: string;
    redisSsl?: string;
    redisTimeout?: string;
}

export interface GetServiceRedisUserConfigMigration {
    host?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface GetServiceRedisUserConfigPrivateAccess {
    prometheus?: string;
    redis?: string;
}

export interface GetServiceRedisUserConfigPublicAccess {
    prometheus?: string;
    redis?: string;
}

export interface GetServiceServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GrafanaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface GrafanaGrafana {
}

export interface GrafanaGrafanaUserConfig {
    alertingEnabled?: string;
    alertingErrorOrTimeout?: string;
    alertingNodataOrNullvalues?: string;
    allowEmbedding?: string;
    authBasicEnabled?: string;
    authGenericOauth?: outputs.GrafanaGrafanaUserConfigAuthGenericOauth;
    authGithub?: outputs.GrafanaGrafanaUserConfigAuthGithub;
    authGitlab?: outputs.GrafanaGrafanaUserConfigAuthGitlab;
    authGoogle?: outputs.GrafanaGrafanaUserConfigAuthGoogle;
    cookieSamesite?: string;
    customDomain?: string;
    dashboardsVersionsToKeep?: string;
    dataproxySendUserHeader?: string;
    dataproxyTimeout?: string;
    disableGravatar?: string;
    editorsCanAdmin?: string;
    externalImageStorage?: outputs.GrafanaGrafanaUserConfigExternalImageStorage;
    googleAnalyticsUaId?: string;
    ipFilters?: string[];
    metricsEnabled?: string;
    privateAccess?: outputs.GrafanaGrafanaUserConfigPrivateAccess;
    publicAccess?: outputs.GrafanaGrafanaUserConfigPublicAccess;
    smtpServer?: outputs.GrafanaGrafanaUserConfigSmtpServer;
    userAutoAssignOrg?: string;
    userAutoAssignOrgRole?: string;
    viewersCanEdit?: string;
}

export interface GrafanaGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedOrganizations?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    name?: string;
    scopes?: string[];
    tokenUrl?: string;
}

export interface GrafanaGrafanaUserConfigAuthGithub {
    allowSignUp?: string;
    allowedOrganizations?: string[];
    clientId?: string;
    clientSecret?: string;
    teamIds?: string[];
}

export interface GrafanaGrafanaUserConfigAuthGitlab {
    allowSignUp?: string;
    allowedGroups?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface GrafanaGrafanaUserConfigAuthGoogle {
    allowSignUp?: string;
    allowedDomains?: string[];
    clientId?: string;
    clientSecret?: string;
}

export interface GrafanaGrafanaUserConfigExternalImageStorage {
    accessKey?: string;
    bucketUrl?: string;
    provider?: string;
    secretKey?: string;
}

export interface GrafanaGrafanaUserConfigPrivateAccess {
    grafana?: string;
}

export interface GrafanaGrafanaUserConfigPublicAccess {
    grafana?: string;
}

export interface GrafanaGrafanaUserConfigSmtpServer {
    fromAddress?: string;
    fromName?: string;
    host?: string;
    password?: string;
    port?: string;
    skipVerify?: string;
    username?: string;
}

export interface GrafanaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface InfluxDbComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface InfluxDbInfluxdb {
    databaseName: string;
}

export interface InfluxDbInfluxdbUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    privateAccess?: outputs.InfluxDbInfluxdbUserConfigPrivateAccess;
    publicAccess?: outputs.InfluxDbInfluxdbUserConfigPublicAccess;
    serviceToForkFrom?: string;
}

export interface InfluxDbInfluxdbUserConfigPrivateAccess {
    influxdb?: string;
}

export interface InfluxDbInfluxdbUserConfigPublicAccess {
    influxdb?: string;
}

export interface InfluxDbServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface KafkaComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface KafkaConnectComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface KafkaConnectKafkaConnect {
}

export interface KafkaConnectKafkaConnectUserConfig {
    ipFilters?: string[];
    kafkaConnect?: outputs.KafkaConnectKafkaConnectUserConfigKafkaConnect;
    privateAccess?: outputs.KafkaConnectKafkaConnectUserConfigPrivateAccess;
    publicAccess?: outputs.KafkaConnectKafkaConnectUserConfigPublicAccess;
}

export interface KafkaConnectKafkaConnectUserConfigKafkaConnect {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerIsolationLevel?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    sessionTimeoutMs?: string;
}

export interface KafkaConnectKafkaConnectUserConfigPrivateAccess {
    kafkaConnect?: string;
    prometheus?: string;
}

export interface KafkaConnectKafkaConnectUserConfigPublicAccess {
    kafkaConnect?: string;
    prometheus?: string;
}

export interface KafkaConnectServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface KafkaConnectorTask {
    connector: string;
    task: number;
}

export interface KafkaKafka {
    accessCert: string;
    accessKey: string;
    connectUri: string;
    restUri: string;
    schemaRegistryUri: string;
}

export interface KafkaKafkaUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    kafka?: outputs.KafkaKafkaUserConfigKafka;
    kafkaAuthenticationMethods?: outputs.KafkaKafkaUserConfigKafkaAuthenticationMethods;
    kafkaConnect?: string;
    kafkaConnectConfig?: outputs.KafkaKafkaUserConfigKafkaConnectConfig;
    kafkaRest?: string;
    kafkaRestConfig?: outputs.KafkaKafkaUserConfigKafkaRestConfig;
    kafkaVersion?: string;
    privateAccess?: outputs.KafkaKafkaUserConfigPrivateAccess;
    publicAccess?: outputs.KafkaKafkaUserConfigPublicAccess;
    schemaRegistry?: string;
}

export interface KafkaKafkaUserConfigKafka {
    autoCreateTopicsEnable?: string;
    compressionType?: string;
    connectionsMaxIdleMs?: string;
    defaultReplicationFactor?: string;
    groupMaxSessionTimeoutMs?: string;
    groupMinSessionTimeoutMs?: string;
    logCleanerMaxCompactionLagMs?: string;
    logCleanerMinCleanableRatio?: string;
    logCleanerMinCompactionLagMs?: string;
    logCleanupPolicy?: string;
    logMessageTimestampDifferenceMaxMs?: string;
    logMessageTimestampType?: string;
    logRetentionBytes?: string;
    logRetentionHours?: string;
    logSegmentBytes?: string;
    maxConnectionsPerIp?: string;
    maxIncrementalFetchSessionCacheSlots?: string;
    messageMaxBytes?: string;
    numPartitions?: string;
    offsetsRetentionMinutes?: string;
    producerPurgatoryPurgeIntervalRequests?: string;
    replicaFetchMaxBytes?: string;
    replicaFetchResponseMaxBytes?: string;
    socketRequestMaxBytes?: string;
}

export interface KafkaKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: string;
    sasl?: string;
}

export interface KafkaKafkaUserConfigKafkaConnectConfig {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerIsolationLevel?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    sessionTimeoutMs?: string;
}

export interface KafkaKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: string;
    consumerRequestMaxBytes?: string;
    consumerRequestTimeoutMs?: string;
    producerAcks?: string;
    producerLingerMs?: string;
    simpleconsumerPoolSizeMax?: string;
}

export interface KafkaKafkaUserConfigPrivateAccess {
    prometheus?: string;
}

export interface KafkaKafkaUserConfigPublicAccess {
    kafka?: string;
    kafkaConnect?: string;
    kafkaRest?: string;
    prometheus?: string;
    schemaRegistry?: string;
}

export interface KafkaMirrorMakerComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface KafkaMirrorMakerKafkaMirrormaker {
}

export interface KafkaMirrorMakerKafkaMirrormakerUserConfig {
    ipFilters?: string[];
    kafkaMirrormaker?: outputs.KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker;
}

export interface KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker {
    refreshGroupsEnabled?: string;
    refreshGroupsIntervalSeconds?: string;
    refreshTopicsEnabled?: string;
    refreshTopicsIntervalSeconds?: string;
}

export interface KafkaMirrorMakerServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface KafkaServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface MySqlComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface MySqlMysql {
}

export interface MySqlMysqlUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    ipFilters?: string[];
    mysql?: outputs.MySqlMysqlUserConfigMysql;
    mysqlVersion?: string;
    privateAccess?: outputs.MySqlMysqlUserConfigPrivateAccess;
    publicAccess?: outputs.MySqlMysqlUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
}

export interface MySqlMysqlUserConfigMysql {
    connectTimeout?: string;
    defaultTimeZone?: string;
    groupConcatMaxLen?: string;
    informationSchemaStatsExpiry?: string;
    innodbFtMinTokenSize?: string;
    innodbFtServerStopwordTable?: string;
    innodbLockWaitTimeout?: string;
    innodbLogBufferSize?: string;
    innodbOnlineAlterLogMaxSize?: string;
    innodbPrintAllDeadlocks?: string;
    innodbRollbackOnTimeout?: string;
    interactiveTimeout?: string;
    maxAllowedPacket?: string;
    maxHeapTableSize?: string;
    netReadTimeout?: string;
    netWriteTimeout?: string;
    sortBufferSize?: string;
    sqlMode?: string;
    sqlRequirePrimaryKey?: string;
    tmpTableSize?: string;
    waitTimeout?: string;
}

export interface MySqlMysqlUserConfigPrivateAccess {
    mysql?: string;
    prometheus?: string;
}

export interface MySqlMysqlUserConfigPublicAccess {
    mysql?: string;
    prometheus?: string;
}

export interface MySqlServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface PgComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface PgPg {
    dbname: string;
    host: string;
    password: string;
    port: number;
    replicaUri: string;
    sslmode: string;
    uri: string;
    user: string;
}

export interface PgPgUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    ipFilters?: string[];
    pg?: outputs.PgPgUserConfigPg;
    pgReadReplica?: string;
    pgServiceToForkFrom?: string;
    pgVersion?: string;
    pgbouncer?: outputs.PgPgUserConfigPgbouncer;
    pglookout?: outputs.PgPgUserConfigPglookout;
    privateAccess?: outputs.PgPgUserConfigPrivateAccess;
    publicAccess?: outputs.PgPgUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    sharedBuffersPercentage?: string;
    synchronousReplication?: string;
    timescaledb?: outputs.PgPgUserConfigTimescaledb;
    variant?: string;
    workMem?: string;
}

export interface PgPgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: string;
    autovacuumAnalyzeThreshold?: string;
    autovacuumFreezeMaxAge?: string;
    autovacuumMaxWorkers?: string;
    autovacuumNaptime?: string;
    autovacuumVacuumCostDelay?: string;
    autovacuumVacuumCostLimit?: string;
    autovacuumVacuumScaleFactor?: string;
    autovacuumVacuumThreshold?: string;
    deadlockTimeout?: string;
    idleInTransactionSessionTimeout?: string;
    jit?: string;
    logAutovacuumMinDuration?: string;
    logErrorVerbosity?: string;
    logMinDurationStatement?: string;
    maxLocksPerTransaction?: string;
    maxParallelWorkers?: string;
    maxParallelWorkersPerGather?: string;
    maxPredLocksPerTransaction?: string;
    maxPreparedTransactions?: string;
    maxStackDepth?: string;
    maxStandbyArchiveDelay?: string;
    maxStandbyStreamingDelay?: string;
    maxWorkerProcesses?: string;
    pgStatStatementsDotTrack?: string;
    tempFileLimit?: string;
    timezone?: string;
    trackActivityQuerySize?: string;
    trackCommitTimestamp?: string;
    trackFunctions?: string;
    walSenderTimeout?: string;
    walWriterDelay?: string;
}

export interface PgPgUserConfigPgbouncer {
    ignoreStartupParameters?: string[];
    serverResetQueryAlways?: string;
}

export interface PgPgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: string;
}

export interface PgPgUserConfigPrivateAccess {
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface PgPgUserConfigPublicAccess {
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface PgPgUserConfigTimescaledb {
    maxBackgroundWorkers?: string;
}

export interface PgServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface RedisComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface RedisRedis {
}

export interface RedisRedisUserConfig {
    ipFilters?: string[];
    migration?: outputs.RedisRedisUserConfigMigration;
    privateAccess?: outputs.RedisRedisUserConfigPrivateAccess;
    publicAccess?: outputs.RedisRedisUserConfigPublicAccess;
    redisLfuDecayTime?: string;
    redisLfuLogFactor?: string;
    redisMaxmemoryPolicy?: string;
    redisNotifyKeyspaceEvents?: string;
    redisSsl?: string;
    redisTimeout?: string;
}

export interface RedisRedisUserConfigMigration {
    host?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface RedisRedisUserConfigPrivateAccess {
    prometheus?: string;
    redis?: string;
}

export interface RedisRedisUserConfigPublicAccess {
    prometheus?: string;
    redis?: string;
}

export interface RedisServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface ServiceCassandra {
}

export interface ServiceCassandraUserConfig {
    ipFilters?: string[];
    migrateSstableloader?: string;
    privateAccess?: outputs.ServiceCassandraUserConfigPrivateAccess;
    publicAccess?: outputs.ServiceCassandraUserConfigPublicAccess;
    serviceToForkFrom?: string;
}

export interface ServiceCassandraUserConfigPrivateAccess {
    prometheus?: string;
}

export interface ServiceCassandraUserConfigPublicAccess {
    prometheus?: string;
}

export interface ServiceComponent {
    component: string;
    host: string;
    kafkaAuthenticationMethod: string;
    port: number;
    route: string;
    ssl: boolean;
    usage: string;
}

export interface ServiceElasticsearch {
    kibanaUri: string;
}

export interface ServiceElasticsearchUserConfig {
    customDomain?: string;
    disableReplicationFactorAdjustment?: string;
    elasticsearch?: outputs.ServiceElasticsearchUserConfigElasticsearch;
    elasticsearchVersion?: string;
    indexPatterns?: outputs.ServiceElasticsearchUserConfigIndexPattern[];
    ipFilters?: string[];
    kibana?: outputs.ServiceElasticsearchUserConfigKibana;
    maxIndexCount?: string;
    privateAccess?: outputs.ServiceElasticsearchUserConfigPrivateAccess;
    publicAccess?: outputs.ServiceElasticsearchUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
}

export interface ServiceElasticsearchUserConfigElasticsearch {
    actionAutoCreateIndexEnabled?: string;
    actionDestructiveRequiresName?: string;
    httpMaxContentLength?: string;
    httpMaxHeaderSize?: string;
    httpMaxInitialLineLength?: string;
    indicesFielddataCacheSize?: string;
    indicesMemoryIndexBufferSize?: string;
    indicesQueriesCacheSize?: string;
    indicesQueryBoolMaxClauseCount?: string;
    reindexRemoteWhitelists?: string[];
    searchMaxBuckets?: string;
    threadPoolAnalyzeQueueSize?: string;
    threadPoolAnalyzeSize?: string;
    threadPoolForceMergeSize?: string;
    threadPoolGetQueueSize?: string;
    threadPoolGetSize?: string;
    threadPoolIndexQueueSize?: string;
    threadPoolIndexSize?: string;
    threadPoolSearchQueueSize?: string;
    threadPoolSearchSize?: string;
    threadPoolSearchThrottledQueueSize?: string;
    threadPoolSearchThrottledSize?: string;
    threadPoolWriteQueueSize?: string;
    threadPoolWriteSize?: string;
}

export interface ServiceElasticsearchUserConfigIndexPattern {
    maxIndexCount?: string;
    pattern?: string;
}

export interface ServiceElasticsearchUserConfigKibana {
    elasticsearchRequestTimeout?: string;
    enabled?: string;
    maxOldSpaceSize?: string;
}

export interface ServiceElasticsearchUserConfigPrivateAccess {
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface ServiceElasticsearchUserConfigPublicAccess {
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface ServiceGrafana {
}

export interface ServiceGrafanaUserConfig {
    alertingEnabled?: string;
    alertingErrorOrTimeout?: string;
    alertingNodataOrNullvalues?: string;
    allowEmbedding?: string;
    authBasicEnabled?: string;
    authGenericOauth?: outputs.ServiceGrafanaUserConfigAuthGenericOauth;
    authGithub?: outputs.ServiceGrafanaUserConfigAuthGithub;
    authGitlab?: outputs.ServiceGrafanaUserConfigAuthGitlab;
    authGoogle?: outputs.ServiceGrafanaUserConfigAuthGoogle;
    cookieSamesite?: string;
    customDomain?: string;
    dashboardsVersionsToKeep?: string;
    dataproxySendUserHeader?: string;
    dataproxyTimeout?: string;
    disableGravatar?: string;
    editorsCanAdmin?: string;
    externalImageStorage?: outputs.ServiceGrafanaUserConfigExternalImageStorage;
    googleAnalyticsUaId?: string;
    ipFilters?: string[];
    metricsEnabled?: string;
    privateAccess?: outputs.ServiceGrafanaUserConfigPrivateAccess;
    publicAccess?: outputs.ServiceGrafanaUserConfigPublicAccess;
    smtpServer?: outputs.ServiceGrafanaUserConfigSmtpServer;
    userAutoAssignOrg?: string;
    userAutoAssignOrgRole?: string;
    viewersCanEdit?: string;
}

export interface ServiceGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedOrganizations?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    name?: string;
    scopes?: string[];
    tokenUrl?: string;
}

export interface ServiceGrafanaUserConfigAuthGithub {
    allowSignUp?: string;
    allowedOrganizations?: string[];
    clientId?: string;
    clientSecret?: string;
    teamIds?: string[];
}

export interface ServiceGrafanaUserConfigAuthGitlab {
    allowSignUp?: string;
    allowedGroups?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface ServiceGrafanaUserConfigAuthGoogle {
    allowSignUp?: string;
    allowedDomains?: string[];
    clientId?: string;
    clientSecret?: string;
}

export interface ServiceGrafanaUserConfigExternalImageStorage {
    accessKey?: string;
    bucketUrl?: string;
    provider?: string;
    secretKey?: string;
}

export interface ServiceGrafanaUserConfigPrivateAccess {
    grafana?: string;
}

export interface ServiceGrafanaUserConfigPublicAccess {
    grafana?: string;
}

export interface ServiceGrafanaUserConfigSmtpServer {
    fromAddress?: string;
    fromName?: string;
    host?: string;
    password?: string;
    port?: string;
    skipVerify?: string;
    username?: string;
}

export interface ServiceInfluxdb {
    databaseName: string;
}

export interface ServiceInfluxdbUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    privateAccess?: outputs.ServiceInfluxdbUserConfigPrivateAccess;
    publicAccess?: outputs.ServiceInfluxdbUserConfigPublicAccess;
    serviceToForkFrom?: string;
}

export interface ServiceInfluxdbUserConfigPrivateAccess {
    influxdb?: string;
}

export interface ServiceInfluxdbUserConfigPublicAccess {
    influxdb?: string;
}

export interface ServiceIntegrationEndpointDatadogUserConfig {
    datadogApiKey?: string;
    disableConsumerStats?: string;
    maxPartitionContexts?: string;
    site?: string;
}

export interface ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig {
    ca?: string;
    indexDaysMax?: string;
    indexPrefix?: string;
    timeout?: string;
    url?: string;
}

export interface ServiceIntegrationEndpointPrometheusUserConfig {
    basicAuthPassword?: string;
    basicAuthUsername?: string;
}

export interface ServiceIntegrationEndpointRsyslogUserConfig {
    ca?: string;
    cert?: string;
    format?: string;
    key?: string;
    logline?: string;
    port?: string;
    sd?: string;
    server?: string;
    tls?: string;
}

export interface ServiceIntegrationKafkaConnectUserConfig {
    kafkaConnect?: outputs.ServiceIntegrationKafkaConnectUserConfigKafkaConnect;
}

export interface ServiceIntegrationKafkaConnectUserConfigKafkaConnect {
    configStorageTopic?: string;
    groupId?: string;
    offsetStorageTopic?: string;
    statusStorageTopic?: string;
}

export interface ServiceIntegrationKafkaMirrormakerUserConfig {
    clusterAlias?: string;
}

export interface ServiceIntegrationLogsUserConfig {
    elasticsearchIndexDaysMax?: string;
    elasticsearchIndexPrefix?: string;
}

export interface ServiceIntegrationMirrormakerUserConfig {
    mirrormakerWhitelist?: string;
}

export interface ServiceKafka {
    accessCert: string;
    accessKey: string;
    connectUri: string;
    restUri: string;
    schemaRegistryUri: string;
}

export interface ServiceKafkaConnect {
}

export interface ServiceKafkaConnectUserConfig {
    ipFilters?: string[];
    kafkaConnect?: outputs.ServiceKafkaConnectUserConfigKafkaConnect;
    privateAccess?: outputs.ServiceKafkaConnectUserConfigPrivateAccess;
    publicAccess?: outputs.ServiceKafkaConnectUserConfigPublicAccess;
}

export interface ServiceKafkaConnectUserConfigKafkaConnect {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerIsolationLevel?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    sessionTimeoutMs?: string;
}

export interface ServiceKafkaConnectUserConfigPrivateAccess {
    kafkaConnect?: string;
    prometheus?: string;
}

export interface ServiceKafkaConnectUserConfigPublicAccess {
    kafkaConnect?: string;
    prometheus?: string;
}

export interface ServiceKafkaMirrormaker {
}

export interface ServiceKafkaMirrormakerUserConfig {
    ipFilters?: string[];
    kafkaMirrormaker?: outputs.ServiceKafkaMirrormakerUserConfigKafkaMirrormaker;
}

export interface ServiceKafkaMirrormakerUserConfigKafkaMirrormaker {
    refreshGroupsEnabled?: string;
    refreshGroupsIntervalSeconds?: string;
    refreshTopicsEnabled?: string;
    refreshTopicsIntervalSeconds?: string;
}

export interface ServiceKafkaUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    kafka?: outputs.ServiceKafkaUserConfigKafka;
    kafkaAuthenticationMethods?: outputs.ServiceKafkaUserConfigKafkaAuthenticationMethods;
    kafkaConnect?: string;
    kafkaConnectConfig?: outputs.ServiceKafkaUserConfigKafkaConnectConfig;
    kafkaRest?: string;
    kafkaRestConfig?: outputs.ServiceKafkaUserConfigKafkaRestConfig;
    kafkaVersion?: string;
    privateAccess?: outputs.ServiceKafkaUserConfigPrivateAccess;
    publicAccess?: outputs.ServiceKafkaUserConfigPublicAccess;
    schemaRegistry?: string;
}

export interface ServiceKafkaUserConfigKafka {
    autoCreateTopicsEnable?: string;
    compressionType?: string;
    connectionsMaxIdleMs?: string;
    defaultReplicationFactor?: string;
    groupMaxSessionTimeoutMs?: string;
    groupMinSessionTimeoutMs?: string;
    logCleanerMaxCompactionLagMs?: string;
    logCleanerMinCleanableRatio?: string;
    logCleanerMinCompactionLagMs?: string;
    logCleanupPolicy?: string;
    logMessageTimestampDifferenceMaxMs?: string;
    logMessageTimestampType?: string;
    logRetentionBytes?: string;
    logRetentionHours?: string;
    logSegmentBytes?: string;
    maxConnectionsPerIp?: string;
    maxIncrementalFetchSessionCacheSlots?: string;
    messageMaxBytes?: string;
    numPartitions?: string;
    offsetsRetentionMinutes?: string;
    producerPurgatoryPurgeIntervalRequests?: string;
    replicaFetchMaxBytes?: string;
    replicaFetchResponseMaxBytes?: string;
    socketRequestMaxBytes?: string;
}

export interface ServiceKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: string;
    sasl?: string;
}

export interface ServiceKafkaUserConfigKafkaConnectConfig {
    connectorClientConfigOverridePolicy?: string;
    consumerAutoOffsetReset?: string;
    consumerIsolationLevel?: string;
    consumerMaxPollIntervalMs?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
    offsetFlushTimeoutMs?: string;
    sessionTimeoutMs?: string;
}

export interface ServiceKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: string;
    consumerRequestMaxBytes?: string;
    consumerRequestTimeoutMs?: string;
    producerAcks?: string;
    producerLingerMs?: string;
    simpleconsumerPoolSizeMax?: string;
}

export interface ServiceKafkaUserConfigPrivateAccess {
    prometheus?: string;
}

export interface ServiceKafkaUserConfigPublicAccess {
    kafka?: string;
    kafkaConnect?: string;
    kafkaRest?: string;
    prometheus?: string;
    schemaRegistry?: string;
}

export interface ServiceMysql {
}

export interface ServiceMysqlUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    ipFilters?: string[];
    mysql?: outputs.ServiceMysqlUserConfigMysql;
    mysqlVersion?: string;
    privateAccess?: outputs.ServiceMysqlUserConfigPrivateAccess;
    publicAccess?: outputs.ServiceMysqlUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
}

export interface ServiceMysqlUserConfigMysql {
    connectTimeout?: string;
    defaultTimeZone?: string;
    groupConcatMaxLen?: string;
    informationSchemaStatsExpiry?: string;
    innodbFtMinTokenSize?: string;
    innodbFtServerStopwordTable?: string;
    innodbLockWaitTimeout?: string;
    innodbLogBufferSize?: string;
    innodbOnlineAlterLogMaxSize?: string;
    innodbPrintAllDeadlocks?: string;
    innodbRollbackOnTimeout?: string;
    interactiveTimeout?: string;
    maxAllowedPacket?: string;
    maxHeapTableSize?: string;
    netReadTimeout?: string;
    netWriteTimeout?: string;
    sortBufferSize?: string;
    sqlMode?: string;
    sqlRequirePrimaryKey?: string;
    tmpTableSize?: string;
    waitTimeout?: string;
}

export interface ServiceMysqlUserConfigPrivateAccess {
    mysql?: string;
    prometheus?: string;
}

export interface ServiceMysqlUserConfigPublicAccess {
    mysql?: string;
    prometheus?: string;
}

export interface ServicePg {
    dbname: string;
    host: string;
    password: string;
    port: number;
    replicaUri: string;
    sslmode: string;
    uri: string;
    user: string;
}

export interface ServicePgUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    ipFilters?: string[];
    pg?: outputs.ServicePgUserConfigPg;
    pgReadReplica?: string;
    pgServiceToForkFrom?: string;
    pgVersion?: string;
    pgbouncer?: outputs.ServicePgUserConfigPgbouncer;
    pglookout?: outputs.ServicePgUserConfigPglookout;
    privateAccess?: outputs.ServicePgUserConfigPrivateAccess;
    publicAccess?: outputs.ServicePgUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    sharedBuffersPercentage?: string;
    synchronousReplication?: string;
    timescaledb?: outputs.ServicePgUserConfigTimescaledb;
    variant?: string;
    workMem?: string;
}

export interface ServicePgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: string;
    autovacuumAnalyzeThreshold?: string;
    autovacuumFreezeMaxAge?: string;
    autovacuumMaxWorkers?: string;
    autovacuumNaptime?: string;
    autovacuumVacuumCostDelay?: string;
    autovacuumVacuumCostLimit?: string;
    autovacuumVacuumScaleFactor?: string;
    autovacuumVacuumThreshold?: string;
    deadlockTimeout?: string;
    idleInTransactionSessionTimeout?: string;
    jit?: string;
    logAutovacuumMinDuration?: string;
    logErrorVerbosity?: string;
    logMinDurationStatement?: string;
    maxLocksPerTransaction?: string;
    maxParallelWorkers?: string;
    maxParallelWorkersPerGather?: string;
    maxPredLocksPerTransaction?: string;
    maxPreparedTransactions?: string;
    maxStackDepth?: string;
    maxStandbyArchiveDelay?: string;
    maxStandbyStreamingDelay?: string;
    maxWorkerProcesses?: string;
    pgStatStatementsTrack?: string;
    tempFileLimit?: string;
    timezone?: string;
    trackActivityQuerySize?: string;
    trackCommitTimestamp?: string;
    trackFunctions?: string;
    walSenderTimeout?: string;
    walWriterDelay?: string;
}

export interface ServicePgUserConfigPgbouncer {
    ignoreStartupParameters?: string[];
    serverResetQueryAlways?: string;
}

export interface ServicePgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: string;
}

export interface ServicePgUserConfigPrivateAccess {
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface ServicePgUserConfigPublicAccess {
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface ServicePgUserConfigTimescaledb {
    maxBackgroundWorkers?: string;
}

export interface ServiceRedis {
}

export interface ServiceRedisUserConfig {
    ipFilters?: string[];
    migration?: outputs.ServiceRedisUserConfigMigration;
    privateAccess?: outputs.ServiceRedisUserConfigPrivateAccess;
    publicAccess?: outputs.ServiceRedisUserConfigPublicAccess;
    redisLfuDecayTime?: string;
    redisLfuLogFactor?: string;
    redisMaxmemoryPolicy?: string;
    redisNotifyKeyspaceEvents?: string;
    redisSsl?: string;
    redisTimeout?: string;
}

export interface ServiceRedisUserConfigMigration {
    host?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface ServiceRedisUserConfigPrivateAccess {
    prometheus?: string;
    redis?: string;
}

export interface ServiceRedisUserConfigPublicAccess {
    prometheus?: string;
    redis?: string;
}

export interface ServiceServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}
