// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface CassandraCassandra {
}

export interface CassandraCassandraUserConfig {
    cassandra?: pulumi.Input<inputs.CassandraCassandraUserConfigCassandra>;
    cassandraVersion?: pulumi.Input<string>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    migrateSstableloader?: pulumi.Input<string>;
    privateAccess?: pulumi.Input<inputs.CassandraCassandraUserConfigPrivateAccess>;
    projectToForkFrom?: pulumi.Input<string>;
    publicAccess?: pulumi.Input<inputs.CassandraCassandraUserConfigPublicAccess>;
    serviceToForkFrom?: pulumi.Input<string>;
    staticIps?: pulumi.Input<string>;
}

export interface CassandraCassandraUserConfigCassandra {
    batchSizeFailThresholdInKb?: pulumi.Input<string>;
    batchSizeWarnThresholdInKb?: pulumi.Input<string>;
}

export interface CassandraCassandraUserConfigPrivateAccess {
    prometheus?: pulumi.Input<string>;
}

export interface CassandraCassandraUserConfigPublicAccess {
    prometheus?: pulumi.Input<string>;
}

export interface CassandraComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface CassandraServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface CassandraTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface ClickhouseClickhouse {
}

export interface ClickhouseClickhouseUserConfig {
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    projectToForkFrom?: pulumi.Input<string>;
    serviceToForkFrom?: pulumi.Input<string>;
}

export interface ClickhouseComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface ClickhouseGrantPrivilegeGrant {
    column?: pulumi.Input<string>;
    database: pulumi.Input<string>;
    privilege?: pulumi.Input<string>;
    table?: pulumi.Input<string>;
    withGrant?: pulumi.Input<boolean>;
}

export interface ClickhouseGrantRoleGrant {
    role?: pulumi.Input<string>;
}

export interface ClickhouseServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface ClickhouseTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface FlinkComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface FlinkFlink {
    hostPorts?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface FlinkFlinkUserConfig {
    executionCheckpointingIntervalMs?: pulumi.Input<string>;
    executionCheckpointingTimeoutMs?: pulumi.Input<string>;
    flinkVersion?: pulumi.Input<string>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    numberOfTaskSlots?: pulumi.Input<string>;
    parallelismDefault?: pulumi.Input<string>;
    privatelinkAccess?: pulumi.Input<inputs.FlinkFlinkUserConfigPrivatelinkAccess>;
    restartStrategy?: pulumi.Input<string>;
    restartStrategyDelaySec?: pulumi.Input<string>;
    restartStrategyFailureRateIntervalMin?: pulumi.Input<string>;
    restartStrategyMaxFailures?: pulumi.Input<string>;
}

export interface FlinkFlinkUserConfigPrivatelinkAccess {
    flink?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface FlinkJobTableUpsertKafka {
    keyFields?: pulumi.Input<pulumi.Input<string>[]>;
    keyFormat?: pulumi.Input<string>;
    scanStartupMode?: pulumi.Input<string>;
    topic?: pulumi.Input<string>;
    valueFieldsInclude?: pulumi.Input<string>;
    valueFormat?: pulumi.Input<string>;
}

export interface FlinkServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface FlinkTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface GrafanaComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface GrafanaGrafana {
}

export interface GrafanaGrafanaUserConfig {
    alertingEnabled?: pulumi.Input<string>;
    alertingErrorOrTimeout?: pulumi.Input<string>;
    alertingMaxAnnotationsToKeep?: pulumi.Input<string>;
    alertingNodataOrNullvalues?: pulumi.Input<string>;
    allowEmbedding?: pulumi.Input<string>;
    authAzuread?: pulumi.Input<inputs.GrafanaGrafanaUserConfigAuthAzuread>;
    authBasicEnabled?: pulumi.Input<string>;
    authGenericOauth?: pulumi.Input<inputs.GrafanaGrafanaUserConfigAuthGenericOauth>;
    authGithub?: pulumi.Input<inputs.GrafanaGrafanaUserConfigAuthGithub>;
    authGitlab?: pulumi.Input<inputs.GrafanaGrafanaUserConfigAuthGitlab>;
    authGoogle?: pulumi.Input<inputs.GrafanaGrafanaUserConfigAuthGoogle>;
    cookieSamesite?: pulumi.Input<string>;
    customDomain?: pulumi.Input<string>;
    dashboardsMinRefreshInterval?: pulumi.Input<string>;
    dashboardsVersionsToKeep?: pulumi.Input<string>;
    dataproxySendUserHeader?: pulumi.Input<string>;
    dataproxyTimeout?: pulumi.Input<string>;
    dateFormats?: pulumi.Input<inputs.GrafanaGrafanaUserConfigDateFormats>;
    disableGravatar?: pulumi.Input<string>;
    editorsCanAdmin?: pulumi.Input<string>;
    externalImageStorage?: pulumi.Input<inputs.GrafanaGrafanaUserConfigExternalImageStorage>;
    googleAnalyticsUaId?: pulumi.Input<string>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    metricsEnabled?: pulumi.Input<string>;
    privateAccess?: pulumi.Input<inputs.GrafanaGrafanaUserConfigPrivateAccess>;
    privatelinkAccess?: pulumi.Input<inputs.GrafanaGrafanaUserConfigPrivatelinkAccess>;
    projectToForkFrom?: pulumi.Input<string>;
    publicAccess?: pulumi.Input<inputs.GrafanaGrafanaUserConfigPublicAccess>;
    recoveryBasebackupName?: pulumi.Input<string>;
    serviceToForkFrom?: pulumi.Input<string>;
    smtpServer?: pulumi.Input<inputs.GrafanaGrafanaUserConfigSmtpServer>;
    staticIps?: pulumi.Input<string>;
    userAutoAssignOrg?: pulumi.Input<string>;
    userAutoAssignOrgRole?: pulumi.Input<string>;
    viewersCanEdit?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigAuthAzuread {
    allowSignUp?: pulumi.Input<string>;
    allowedDomains?: pulumi.Input<pulumi.Input<string>[]>;
    allowedGroups?: pulumi.Input<pulumi.Input<string>[]>;
    authUrl?: pulumi.Input<string>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    tokenUrl?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: pulumi.Input<string>;
    allowedDomains?: pulumi.Input<pulumi.Input<string>[]>;
    allowedOrganizations?: pulumi.Input<pulumi.Input<string>[]>;
    apiUrl?: pulumi.Input<string>;
    authUrl?: pulumi.Input<string>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    scopes?: pulumi.Input<pulumi.Input<string>[]>;
    tokenUrl?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigAuthGithub {
    allowSignUp?: pulumi.Input<string>;
    allowedOrganizations?: pulumi.Input<pulumi.Input<string>[]>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    teamIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface GrafanaGrafanaUserConfigAuthGitlab {
    allowSignUp?: pulumi.Input<string>;
    allowedGroups?: pulumi.Input<pulumi.Input<string>[]>;
    apiUrl?: pulumi.Input<string>;
    authUrl?: pulumi.Input<string>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    tokenUrl?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigAuthGoogle {
    allowSignUp?: pulumi.Input<string>;
    allowedDomains?: pulumi.Input<pulumi.Input<string>[]>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigDateFormats {
    defaultTimezone?: pulumi.Input<string>;
    fullDate?: pulumi.Input<string>;
    intervalDay?: pulumi.Input<string>;
    intervalHour?: pulumi.Input<string>;
    intervalMinute?: pulumi.Input<string>;
    intervalMonth?: pulumi.Input<string>;
    intervalSecond?: pulumi.Input<string>;
    intervalYear?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigExternalImageStorage {
    accessKey?: pulumi.Input<string>;
    bucketUrl?: pulumi.Input<string>;
    provider?: pulumi.Input<string>;
    secretKey?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigPrivateAccess {
    grafana?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigPrivatelinkAccess {
    grafana?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigPublicAccess {
    grafana?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigSmtpServer {
    fromAddress?: pulumi.Input<string>;
    fromName?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    skipVerify?: pulumi.Input<string>;
    starttlsPolicy?: pulumi.Input<string>;
    username?: pulumi.Input<string>;
}

export interface GrafanaServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface GrafanaTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface InfluxDbComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdb {
    databaseName?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdbUserConfig {
    customDomain?: pulumi.Input<string>;
    influxdb?: pulumi.Input<inputs.InfluxDbInfluxdbUserConfigInfluxdb>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    privateAccess?: pulumi.Input<inputs.InfluxDbInfluxdbUserConfigPrivateAccess>;
    privatelinkAccess?: pulumi.Input<inputs.InfluxDbInfluxdbUserConfigPrivatelinkAccess>;
    projectToForkFrom?: pulumi.Input<string>;
    publicAccess?: pulumi.Input<inputs.InfluxDbInfluxdbUserConfigPublicAccess>;
    recoveryBasebackupName?: pulumi.Input<string>;
    serviceToForkFrom?: pulumi.Input<string>;
    staticIps?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdbUserConfigInfluxdb {
    logQueriesAfter?: pulumi.Input<string>;
    maxConnectionLimit?: pulumi.Input<string>;
    maxRowLimit?: pulumi.Input<string>;
    maxSelectBuckets?: pulumi.Input<string>;
    maxSelectPoint?: pulumi.Input<string>;
    queryTimeout?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdbUserConfigPrivateAccess {
    influxdb?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdbUserConfigPrivatelinkAccess {
    influxdb?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdbUserConfigPublicAccess {
    influxdb?: pulumi.Input<string>;
}

export interface InfluxDbServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface InfluxDbTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface KafkaComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface KafkaConnectComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface KafkaConnectKafkaConnect {
}

export interface KafkaConnectKafkaConnectUserConfig {
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    kafkaConnect?: pulumi.Input<inputs.KafkaConnectKafkaConnectUserConfigKafkaConnect>;
    privateAccess?: pulumi.Input<inputs.KafkaConnectKafkaConnectUserConfigPrivateAccess>;
    privatelinkAccess?: pulumi.Input<inputs.KafkaConnectKafkaConnectUserConfigPrivatelinkAccess>;
    publicAccess?: pulumi.Input<inputs.KafkaConnectKafkaConnectUserConfigPublicAccess>;
    staticIps?: pulumi.Input<string>;
}

export interface KafkaConnectKafkaConnectUserConfigKafkaConnect {
    connectorClientConfigOverridePolicy?: pulumi.Input<string>;
    consumerAutoOffsetReset?: pulumi.Input<string>;
    consumerFetchMaxBytes?: pulumi.Input<string>;
    consumerIsolationLevel?: pulumi.Input<string>;
    consumerMaxPartitionFetchBytes?: pulumi.Input<string>;
    consumerMaxPollIntervalMs?: pulumi.Input<string>;
    consumerMaxPollRecords?: pulumi.Input<string>;
    offsetFlushIntervalMs?: pulumi.Input<string>;
    offsetFlushTimeoutMs?: pulumi.Input<string>;
    producerCompressionType?: pulumi.Input<string>;
    producerMaxRequestSize?: pulumi.Input<string>;
    sessionTimeoutMs?: pulumi.Input<string>;
}

export interface KafkaConnectKafkaConnectUserConfigPrivateAccess {
    kafkaConnect?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface KafkaConnectKafkaConnectUserConfigPrivatelinkAccess {
    jolokia?: pulumi.Input<string>;
    kafkaConnect?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface KafkaConnectKafkaConnectUserConfigPublicAccess {
    kafkaConnect?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface KafkaConnectServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface KafkaConnectTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface KafkaConnectorTask {
    connector?: pulumi.Input<string>;
    task?: pulumi.Input<number>;
}

export interface KafkaKafka {
    accessCert?: pulumi.Input<string>;
    accessKey?: pulumi.Input<string>;
    connectUri?: pulumi.Input<string>;
    restUri?: pulumi.Input<string>;
    schemaRegistryUri?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfig {
    customDomain?: pulumi.Input<string>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    kafka?: pulumi.Input<inputs.KafkaKafkaUserConfigKafka>;
    kafkaAuthenticationMethods?: pulumi.Input<inputs.KafkaKafkaUserConfigKafkaAuthenticationMethods>;
    kafkaConnect?: pulumi.Input<string>;
    kafkaConnectConfig?: pulumi.Input<inputs.KafkaKafkaUserConfigKafkaConnectConfig>;
    kafkaRest?: pulumi.Input<string>;
    kafkaRestConfig?: pulumi.Input<inputs.KafkaKafkaUserConfigKafkaRestConfig>;
    kafkaVersion?: pulumi.Input<string>;
    privateAccess?: pulumi.Input<inputs.KafkaKafkaUserConfigPrivateAccess>;
    privatelinkAccess?: pulumi.Input<inputs.KafkaKafkaUserConfigPrivatelinkAccess>;
    publicAccess?: pulumi.Input<inputs.KafkaKafkaUserConfigPublicAccess>;
    schemaRegistry?: pulumi.Input<string>;
    schemaRegistryConfig?: pulumi.Input<inputs.KafkaKafkaUserConfigSchemaRegistryConfig>;
    staticIps?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigKafka {
    autoCreateTopicsEnable?: pulumi.Input<string>;
    compressionType?: pulumi.Input<string>;
    connectionsMaxIdleMs?: pulumi.Input<string>;
    defaultReplicationFactor?: pulumi.Input<string>;
    groupInitialRebalanceDelayMs?: pulumi.Input<string>;
    groupMaxSessionTimeoutMs?: pulumi.Input<string>;
    groupMinSessionTimeoutMs?: pulumi.Input<string>;
    logCleanerDeleteRetentionMs?: pulumi.Input<string>;
    logCleanerMaxCompactionLagMs?: pulumi.Input<string>;
    logCleanerMinCleanableRatio?: pulumi.Input<string>;
    logCleanerMinCompactionLagMs?: pulumi.Input<string>;
    logCleanupPolicy?: pulumi.Input<string>;
    logFlushIntervalMessages?: pulumi.Input<string>;
    logFlushIntervalMs?: pulumi.Input<string>;
    logIndexIntervalBytes?: pulumi.Input<string>;
    logIndexSizeMaxBytes?: pulumi.Input<string>;
    logMessageDownconversionEnable?: pulumi.Input<string>;
    logMessageTimestampDifferenceMaxMs?: pulumi.Input<string>;
    logMessageTimestampType?: pulumi.Input<string>;
    logPreallocate?: pulumi.Input<string>;
    logRetentionBytes?: pulumi.Input<string>;
    logRetentionHours?: pulumi.Input<string>;
    logRetentionMs?: pulumi.Input<string>;
    logRollJitterMs?: pulumi.Input<string>;
    logRollMs?: pulumi.Input<string>;
    logSegmentBytes?: pulumi.Input<string>;
    logSegmentDeleteDelayMs?: pulumi.Input<string>;
    maxConnectionsPerIp?: pulumi.Input<string>;
    maxIncrementalFetchSessionCacheSlots?: pulumi.Input<string>;
    messageMaxBytes?: pulumi.Input<string>;
    minInsyncReplicas?: pulumi.Input<string>;
    numPartitions?: pulumi.Input<string>;
    offsetsRetentionMinutes?: pulumi.Input<string>;
    producerPurgatoryPurgeIntervalRequests?: pulumi.Input<string>;
    replicaFetchMaxBytes?: pulumi.Input<string>;
    replicaFetchResponseMaxBytes?: pulumi.Input<string>;
    socketRequestMaxBytes?: pulumi.Input<string>;
    transactionRemoveExpiredTransactionCleanupIntervalMs?: pulumi.Input<string>;
    transactionStateLogSegmentBytes?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: pulumi.Input<string>;
    sasl?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigKafkaConnectConfig {
    connectorClientConfigOverridePolicy?: pulumi.Input<string>;
    consumerAutoOffsetReset?: pulumi.Input<string>;
    consumerFetchMaxBytes?: pulumi.Input<string>;
    consumerIsolationLevel?: pulumi.Input<string>;
    consumerMaxPartitionFetchBytes?: pulumi.Input<string>;
    consumerMaxPollIntervalMs?: pulumi.Input<string>;
    consumerMaxPollRecords?: pulumi.Input<string>;
    offsetFlushIntervalMs?: pulumi.Input<string>;
    offsetFlushTimeoutMs?: pulumi.Input<string>;
    producerCompressionType?: pulumi.Input<string>;
    producerMaxRequestSize?: pulumi.Input<string>;
    sessionTimeoutMs?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: pulumi.Input<string>;
    consumerRequestMaxBytes?: pulumi.Input<string>;
    consumerRequestTimeoutMs?: pulumi.Input<string>;
    producerAcks?: pulumi.Input<string>;
    producerLingerMs?: pulumi.Input<string>;
    simpleconsumerPoolSizeMax?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigPrivateAccess {
    prometheus?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigPrivatelinkAccess {
    jolokia?: pulumi.Input<string>;
    kafka?: pulumi.Input<string>;
    kafkaConnect?: pulumi.Input<string>;
    kafkaRest?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
    schemaRegistry?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigPublicAccess {
    kafka?: pulumi.Input<string>;
    kafkaConnect?: pulumi.Input<string>;
    kafkaRest?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
    schemaRegistry?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigSchemaRegistryConfig {
    leaderEligibility?: pulumi.Input<string>;
    topicName?: pulumi.Input<string>;
}

export interface KafkaMirrorMakerComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface KafkaMirrorMakerKafkaMirrormaker {
}

export interface KafkaMirrorMakerKafkaMirrormakerUserConfig {
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    kafkaMirrormaker?: pulumi.Input<inputs.KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker>;
    staticIps?: pulumi.Input<string>;
}

export interface KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker {
    emitCheckpointsEnabled?: pulumi.Input<string>;
    emitCheckpointsIntervalSeconds?: pulumi.Input<string>;
    refreshGroupsEnabled?: pulumi.Input<string>;
    refreshGroupsIntervalSeconds?: pulumi.Input<string>;
    refreshTopicsEnabled?: pulumi.Input<string>;
    refreshTopicsIntervalSeconds?: pulumi.Input<string>;
    syncGroupOffsetsEnabled?: pulumi.Input<string>;
    syncGroupOffsetsIntervalSeconds?: pulumi.Input<string>;
    syncTopicConfigsEnabled?: pulumi.Input<string>;
    tasksMaxPerCpu?: pulumi.Input<string>;
}

export interface KafkaMirrorMakerServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface KafkaMirrorMakerTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface KafkaServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface KafkaTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface KafkaTopicConfig {
    cleanupPolicy?: pulumi.Input<string>;
    compressionType?: pulumi.Input<string>;
    deleteRetentionMs?: pulumi.Input<string>;
    fileDeleteDelayMs?: pulumi.Input<string>;
    flushMessages?: pulumi.Input<string>;
    flushMs?: pulumi.Input<string>;
    indexIntervalBytes?: pulumi.Input<string>;
    maxCompactionLagMs?: pulumi.Input<string>;
    maxMessageBytes?: pulumi.Input<string>;
    messageDownconversionEnable?: pulumi.Input<string>;
    messageFormatVersion?: pulumi.Input<string>;
    messageTimestampDifferenceMaxMs?: pulumi.Input<string>;
    messageTimestampType?: pulumi.Input<string>;
    minCleanableDirtyRatio?: pulumi.Input<string>;
    minCompactionLagMs?: pulumi.Input<string>;
    minInsyncReplicas?: pulumi.Input<string>;
    preallocate?: pulumi.Input<string>;
    retentionBytes?: pulumi.Input<string>;
    retentionMs?: pulumi.Input<string>;
    segmentBytes?: pulumi.Input<string>;
    segmentIndexBytes?: pulumi.Input<string>;
    segmentJitterMs?: pulumi.Input<string>;
    segmentMs?: pulumi.Input<string>;
    uncleanLeaderElectionEnable?: pulumi.Input<string>;
}

export interface KafkaTopicTag {
    key: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface M3AggregatorComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface M3AggregatorM3aggregator {
}

export interface M3AggregatorM3aggregatorUserConfig {
    customDomain?: pulumi.Input<string>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    m3Version?: pulumi.Input<string>;
    m3aggregatorVersion?: pulumi.Input<string>;
    staticIps?: pulumi.Input<string>;
}

export interface M3AggregatorServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface M3AggregatorTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface M3DbComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface M3DbM3db {
}

export interface M3DbM3dbUserConfig {
    customDomain?: pulumi.Input<string>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    limits?: pulumi.Input<inputs.M3DbM3dbUserConfigLimits>;
    m3Version?: pulumi.Input<string>;
    m3coordinatorEnableGraphiteCarbonIngest?: pulumi.Input<string>;
    m3dbVersion?: pulumi.Input<string>;
    namespaces?: pulumi.Input<pulumi.Input<inputs.M3DbM3dbUserConfigNamespace>[]>;
    privateAccess?: pulumi.Input<inputs.M3DbM3dbUserConfigPrivateAccess>;
    projectToForkFrom?: pulumi.Input<string>;
    publicAccess?: pulumi.Input<inputs.M3DbM3dbUserConfigPublicAccess>;
    rules?: pulumi.Input<inputs.M3DbM3dbUserConfigRules>;
    serviceToForkFrom?: pulumi.Input<string>;
    staticIps?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigLimits {
    queryRequireExhaustive?: pulumi.Input<string>;
    querySeries?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigNamespace {
    name?: pulumi.Input<string>;
    options?: pulumi.Input<inputs.M3DbM3dbUserConfigNamespaceOptions>;
    resolution?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigNamespaceOptions {
    retentionOptions?: pulumi.Input<inputs.M3DbM3dbUserConfigNamespaceOptionsRetentionOptions>;
    snapshotEnabled?: pulumi.Input<string>;
    writesToCommitlog?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigNamespaceOptionsRetentionOptions {
    blockDataExpiryDuration?: pulumi.Input<string>;
    blocksizeDuration?: pulumi.Input<string>;
    bufferFutureDuration?: pulumi.Input<string>;
    bufferPastDuration?: pulumi.Input<string>;
    retentionPeriodDuration?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigPrivateAccess {
    m3coordinator?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigPublicAccess {
    m3coordinator?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigRules {
    mappings?: pulumi.Input<pulumi.Input<inputs.M3DbM3dbUserConfigRulesMapping>[]>;
}

export interface M3DbM3dbUserConfigRulesMapping {
    aggregations?: pulumi.Input<pulumi.Input<string>[]>;
    drop?: pulumi.Input<string>;
    filter?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    namespaces?: pulumi.Input<pulumi.Input<string>[]>;
    tags?: pulumi.Input<pulumi.Input<inputs.M3DbM3dbUserConfigRulesMappingTag>[]>;
}

export interface M3DbM3dbUserConfigRulesMappingTag {
    name?: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface M3DbServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface M3DbTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface MySqlComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface MySqlMysql {
}

export interface MySqlMysqlUserConfig {
    adminPassword?: pulumi.Input<string>;
    adminUsername?: pulumi.Input<string>;
    backupHour?: pulumi.Input<string>;
    backupMinute?: pulumi.Input<string>;
    binlogRetentionPeriod?: pulumi.Input<string>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    migration?: pulumi.Input<inputs.MySqlMysqlUserConfigMigration>;
    mysql?: pulumi.Input<inputs.MySqlMysqlUserConfigMysql>;
    mysqlVersion?: pulumi.Input<string>;
    privateAccess?: pulumi.Input<inputs.MySqlMysqlUserConfigPrivateAccess>;
    privatelinkAccess?: pulumi.Input<inputs.MySqlMysqlUserConfigPrivatelinkAccess>;
    projectToForkFrom?: pulumi.Input<string>;
    publicAccess?: pulumi.Input<inputs.MySqlMysqlUserConfigPublicAccess>;
    recoveryTargetTime?: pulumi.Input<string>;
    serviceToForkFrom?: pulumi.Input<string>;
    staticIps?: pulumi.Input<string>;
}

export interface MySqlMysqlUserConfigMigration {
    dbname?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    ignoreDbs?: pulumi.Input<string>;
    method?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    ssl?: pulumi.Input<string>;
    username?: pulumi.Input<string>;
}

export interface MySqlMysqlUserConfigMysql {
    connectTimeout?: pulumi.Input<string>;
    defaultTimeZone?: pulumi.Input<string>;
    groupConcatMaxLen?: pulumi.Input<string>;
    informationSchemaStatsExpiry?: pulumi.Input<string>;
    innodbFtMinTokenSize?: pulumi.Input<string>;
    innodbFtServerStopwordTable?: pulumi.Input<string>;
    innodbLockWaitTimeout?: pulumi.Input<string>;
    innodbLogBufferSize?: pulumi.Input<string>;
    innodbOnlineAlterLogMaxSize?: pulumi.Input<string>;
    innodbPrintAllDeadlocks?: pulumi.Input<string>;
    innodbRollbackOnTimeout?: pulumi.Input<string>;
    interactiveTimeout?: pulumi.Input<string>;
    internalTmpMemStorageEngine?: pulumi.Input<string>;
    longQueryTime?: pulumi.Input<string>;
    maxAllowedPacket?: pulumi.Input<string>;
    maxHeapTableSize?: pulumi.Input<string>;
    netReadTimeout?: pulumi.Input<string>;
    netWriteTimeout?: pulumi.Input<string>;
    slowQueryLog?: pulumi.Input<string>;
    sortBufferSize?: pulumi.Input<string>;
    sqlMode?: pulumi.Input<string>;
    sqlRequirePrimaryKey?: pulumi.Input<string>;
    tmpTableSize?: pulumi.Input<string>;
    waitTimeout?: pulumi.Input<string>;
}

export interface MySqlMysqlUserConfigPrivateAccess {
    mysql?: pulumi.Input<string>;
    mysqlx?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface MySqlMysqlUserConfigPrivatelinkAccess {
    mysql?: pulumi.Input<string>;
    mysqlx?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface MySqlMysqlUserConfigPublicAccess {
    mysql?: pulumi.Input<string>;
    mysqlx?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface MySqlServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface MySqlTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface OpenSearchComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface OpenSearchOpensearch {
    opensearchDashboardsUri?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfig {
    customDomain?: pulumi.Input<string>;
    disableReplicationFactorAdjustment?: pulumi.Input<string>;
    indexPatterns?: pulumi.Input<pulumi.Input<inputs.OpenSearchOpensearchUserConfigIndexPattern>[]>;
    indexTemplate?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigIndexTemplate>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    keepIndexRefreshInterval?: pulumi.Input<string>;
    maxIndexCount?: pulumi.Input<string>;
    opensearch?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigOpensearch>;
    opensearchDashboards?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigOpensearchDashboards>;
    opensearchVersion?: pulumi.Input<string>;
    privateAccess?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigPrivateAccess>;
    privatelinkAccess?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigPrivatelinkAccess>;
    projectToForkFrom?: pulumi.Input<string>;
    publicAccess?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigPublicAccess>;
    recoveryBasebackupName?: pulumi.Input<string>;
    serviceToForkFrom?: pulumi.Input<string>;
    staticIps?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigIndexPattern {
    maxIndexCount?: pulumi.Input<string>;
    pattern?: pulumi.Input<string>;
    sortingAlgorithm?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigIndexTemplate {
    mappingNestedObjectsLimit?: pulumi.Input<string>;
    numberOfReplicas?: pulumi.Input<string>;
    numberOfShards?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigOpensearch {
    actionAutoCreateIndexEnabled?: pulumi.Input<string>;
    actionDestructiveRequiresName?: pulumi.Input<string>;
    clusterMaxShardsPerNode?: pulumi.Input<string>;
    clusterRoutingAllocationNodeConcurrentRecoveries?: pulumi.Input<string>;
    httpMaxContentLength?: pulumi.Input<string>;
    httpMaxHeaderSize?: pulumi.Input<string>;
    httpMaxInitialLineLength?: pulumi.Input<string>;
    indicesFielddataCacheSize?: pulumi.Input<string>;
    indicesMemoryIndexBufferSize?: pulumi.Input<string>;
    indicesQueriesCacheSize?: pulumi.Input<string>;
    indicesQueryBoolMaxClauseCount?: pulumi.Input<string>;
    indicesRecoveryMaxBytesPerSec?: pulumi.Input<string>;
    indicesRecoveryMaxConcurrentFileChunks?: pulumi.Input<string>;
    overrideMainResponseVersion?: pulumi.Input<string>;
    reindexRemoteWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    scriptMaxCompilationsRate?: pulumi.Input<string>;
    searchMaxBuckets?: pulumi.Input<string>;
    threadPoolAnalyzeQueueSize?: pulumi.Input<string>;
    threadPoolAnalyzeSize?: pulumi.Input<string>;
    threadPoolForceMergeSize?: pulumi.Input<string>;
    threadPoolGetQueueSize?: pulumi.Input<string>;
    threadPoolGetSize?: pulumi.Input<string>;
    threadPoolSearchQueueSize?: pulumi.Input<string>;
    threadPoolSearchSize?: pulumi.Input<string>;
    threadPoolSearchThrottledQueueSize?: pulumi.Input<string>;
    threadPoolSearchThrottledSize?: pulumi.Input<string>;
    threadPoolWriteQueueSize?: pulumi.Input<string>;
    threadPoolWriteSize?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigOpensearchDashboards {
    enabled?: pulumi.Input<string>;
    maxOldSpaceSize?: pulumi.Input<string>;
    opensearchRequestTimeout?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigPrivateAccess {
    opensearch?: pulumi.Input<string>;
    opensearchDashboards?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigPrivatelinkAccess {
    opensearch?: pulumi.Input<string>;
    opensearchDashboards?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigPublicAccess {
    opensearch?: pulumi.Input<string>;
    opensearchDashboards?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface OpenSearchServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface OpenSearchTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface PgComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface PgPg {
    dbname?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    replicaUri?: pulumi.Input<string>;
    sslmode?: pulumi.Input<string>;
    uri?: pulumi.Input<string>;
    user?: pulumi.Input<string>;
}

export interface PgPgUserConfig {
    adminPassword?: pulumi.Input<string>;
    adminUsername?: pulumi.Input<string>;
    backupHour?: pulumi.Input<string>;
    backupMinute?: pulumi.Input<string>;
    enableIpv6?: pulumi.Input<string>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    migration?: pulumi.Input<inputs.PgPgUserConfigMigration>;
    pg?: pulumi.Input<inputs.PgPgUserConfigPg>;
    pgReadReplica?: pulumi.Input<string>;
    pgServiceToForkFrom?: pulumi.Input<string>;
    pgVersion?: pulumi.Input<string>;
    pgbouncer?: pulumi.Input<inputs.PgPgUserConfigPgbouncer>;
    pglookout?: pulumi.Input<inputs.PgPgUserConfigPglookout>;
    privateAccess?: pulumi.Input<inputs.PgPgUserConfigPrivateAccess>;
    privatelinkAccess?: pulumi.Input<inputs.PgPgUserConfigPrivatelinkAccess>;
    projectToForkFrom?: pulumi.Input<string>;
    publicAccess?: pulumi.Input<inputs.PgPgUserConfigPublicAccess>;
    recoveryTargetTime?: pulumi.Input<string>;
    serviceToForkFrom?: pulumi.Input<string>;
    sharedBuffersPercentage?: pulumi.Input<string>;
    staticIps?: pulumi.Input<string>;
    synchronousReplication?: pulumi.Input<string>;
    timescaledb?: pulumi.Input<inputs.PgPgUserConfigTimescaledb>;
    variant?: pulumi.Input<string>;
    workMem?: pulumi.Input<string>;
}

export interface PgPgUserConfigMigration {
    dbname?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    ignoreDbs?: pulumi.Input<string>;
    method?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    ssl?: pulumi.Input<string>;
    username?: pulumi.Input<string>;
}

export interface PgPgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: pulumi.Input<string>;
    autovacuumAnalyzeThreshold?: pulumi.Input<string>;
    autovacuumFreezeMaxAge?: pulumi.Input<string>;
    autovacuumMaxWorkers?: pulumi.Input<string>;
    autovacuumNaptime?: pulumi.Input<string>;
    autovacuumVacuumCostDelay?: pulumi.Input<string>;
    autovacuumVacuumCostLimit?: pulumi.Input<string>;
    autovacuumVacuumScaleFactor?: pulumi.Input<string>;
    autovacuumVacuumThreshold?: pulumi.Input<string>;
    bgwriterDelay?: pulumi.Input<string>;
    bgwriterFlushAfter?: pulumi.Input<string>;
    bgwriterLruMaxpages?: pulumi.Input<string>;
    bgwriterLruMultiplier?: pulumi.Input<string>;
    deadlockTimeout?: pulumi.Input<string>;
    defaultToastCompression?: pulumi.Input<string>;
    idleInTransactionSessionTimeout?: pulumi.Input<string>;
    jit?: pulumi.Input<string>;
    logAutovacuumMinDuration?: pulumi.Input<string>;
    logErrorVerbosity?: pulumi.Input<string>;
    logLinePrefix?: pulumi.Input<string>;
    logMinDurationStatement?: pulumi.Input<string>;
    maxFilesPerProcess?: pulumi.Input<string>;
    maxLocksPerTransaction?: pulumi.Input<string>;
    maxLogicalReplicationWorkers?: pulumi.Input<string>;
    maxParallelWorkers?: pulumi.Input<string>;
    maxParallelWorkersPerGather?: pulumi.Input<string>;
    maxPredLocksPerTransaction?: pulumi.Input<string>;
    maxPreparedTransactions?: pulumi.Input<string>;
    maxReplicationSlots?: pulumi.Input<string>;
    maxSlotWalKeepSize?: pulumi.Input<string>;
    maxStackDepth?: pulumi.Input<string>;
    maxStandbyArchiveDelay?: pulumi.Input<string>;
    maxStandbyStreamingDelay?: pulumi.Input<string>;
    maxWalSenders?: pulumi.Input<string>;
    maxWorkerProcesses?: pulumi.Input<string>;
    pgPartmanBgwDotInterval?: pulumi.Input<string>;
    pgPartmanBgwDotRole?: pulumi.Input<string>;
    pgStatStatementsDotTrack?: pulumi.Input<string>;
    tempFileLimit?: pulumi.Input<string>;
    timezone?: pulumi.Input<string>;
    trackActivityQuerySize?: pulumi.Input<string>;
    trackCommitTimestamp?: pulumi.Input<string>;
    trackFunctions?: pulumi.Input<string>;
    trackIoTiming?: pulumi.Input<string>;
    walSenderTimeout?: pulumi.Input<string>;
    walWriterDelay?: pulumi.Input<string>;
}

export interface PgPgUserConfigPgbouncer {
    autodbIdleTimeout?: pulumi.Input<string>;
    autodbMaxDbConnections?: pulumi.Input<string>;
    autodbPoolMode?: pulumi.Input<string>;
    autodbPoolSize?: pulumi.Input<string>;
    ignoreStartupParameters?: pulumi.Input<pulumi.Input<string>[]>;
    minPoolSize?: pulumi.Input<string>;
    serverIdleTimeout?: pulumi.Input<string>;
    serverLifetime?: pulumi.Input<string>;
    serverResetQueryAlways?: pulumi.Input<string>;
}

export interface PgPgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: pulumi.Input<string>;
}

export interface PgPgUserConfigPrivateAccess {
    pg?: pulumi.Input<string>;
    pgbouncer?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface PgPgUserConfigPrivatelinkAccess {
    pg?: pulumi.Input<string>;
    pgbouncer?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface PgPgUserConfigPublicAccess {
    pg?: pulumi.Input<string>;
    pgbouncer?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface PgPgUserConfigTimescaledb {
    maxBackgroundWorkers?: pulumi.Input<string>;
}

export interface PgServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface PgTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface ProjectTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface RedisComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface RedisRedi {
}

export interface RedisRedisUserConfig {
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    migration?: pulumi.Input<inputs.RedisRedisUserConfigMigration>;
    privateAccess?: pulumi.Input<inputs.RedisRedisUserConfigPrivateAccess>;
    privatelinkAccess?: pulumi.Input<inputs.RedisRedisUserConfigPrivatelinkAccess>;
    projectToForkFrom?: pulumi.Input<string>;
    publicAccess?: pulumi.Input<inputs.RedisRedisUserConfigPublicAccess>;
    recoveryBasebackupName?: pulumi.Input<string>;
    redisAclChannelsDefault?: pulumi.Input<string>;
    redisIoThreads?: pulumi.Input<string>;
    redisLfuDecayTime?: pulumi.Input<string>;
    redisLfuLogFactor?: pulumi.Input<string>;
    redisMaxmemoryPolicy?: pulumi.Input<string>;
    redisNotifyKeyspaceEvents?: pulumi.Input<string>;
    redisNumberOfDatabases?: pulumi.Input<string>;
    redisPersistence?: pulumi.Input<string>;
    redisPubsubClientOutputBufferLimit?: pulumi.Input<string>;
    redisSsl?: pulumi.Input<string>;
    redisTimeout?: pulumi.Input<string>;
    serviceToForkFrom?: pulumi.Input<string>;
    staticIps?: pulumi.Input<string>;
}

export interface RedisRedisUserConfigMigration {
    dbname?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    ignoreDbs?: pulumi.Input<string>;
    method?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    ssl?: pulumi.Input<string>;
    username?: pulumi.Input<string>;
}

export interface RedisRedisUserConfigPrivateAccess {
    prometheus?: pulumi.Input<string>;
    redis?: pulumi.Input<string>;
}

export interface RedisRedisUserConfigPrivatelinkAccess {
    prometheus?: pulumi.Input<string>;
    redis?: pulumi.Input<string>;
}

export interface RedisRedisUserConfigPublicAccess {
    prometheus?: pulumi.Input<string>;
    redis?: pulumi.Input<string>;
}

export interface RedisServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface RedisTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointDatadogUserConfig {
    datadogApiKey?: pulumi.Input<string>;
    datadogTags?: pulumi.Input<pulumi.Input<inputs.ServiceIntegrationEndpointDatadogUserConfigDatadogTag>[]>;
    disableConsumerStats?: pulumi.Input<string>;
    kafkaConsumerCheckInstances?: pulumi.Input<string>;
    kafkaConsumerStatsTimeout?: pulumi.Input<string>;
    maxPartitionContexts?: pulumi.Input<string>;
    site?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointDatadogUserConfigDatadogTag {
    comment?: pulumi.Input<string>;
    tag?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig {
    accessKey?: pulumi.Input<string>;
    logGroupName?: pulumi.Input<string>;
    region?: pulumi.Input<string>;
    secretKey?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig {
    accessKey?: pulumi.Input<string>;
    namespace?: pulumi.Input<string>;
    region?: pulumi.Input<string>;
    secretKey?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig {
    ca?: pulumi.Input<string>;
    indexDaysMax?: pulumi.Input<string>;
    indexPrefix?: pulumi.Input<string>;
    timeout?: pulumi.Input<string>;
    url?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig {
    logId?: pulumi.Input<string>;
    projectId?: pulumi.Input<string>;
    serviceAccountCredentials?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalKafkaUserConfig {
    bootstrapServers?: pulumi.Input<string>;
    saslMechanism?: pulumi.Input<string>;
    saslPlainPassword?: pulumi.Input<string>;
    saslPlainUsername?: pulumi.Input<string>;
    securityProtocol?: pulumi.Input<string>;
    sslCaCert?: pulumi.Input<string>;
    sslClientCert?: pulumi.Input<string>;
    sslClientKey?: pulumi.Input<string>;
    sslEndpointIdentificationAlgorithm?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalSchemaRegistryUserConfig {
    authentication?: pulumi.Input<string>;
    basicAuthPassword?: pulumi.Input<string>;
    basicAuthUsername?: pulumi.Input<string>;
    url?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointJolokiaUserConfig {
    basicAuthPassword?: pulumi.Input<string>;
    basicAuthUsername?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointPrometheusUserConfig {
    basicAuthPassword?: pulumi.Input<string>;
    basicAuthUsername?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointRsyslogUserConfig {
    ca?: pulumi.Input<string>;
    cert?: pulumi.Input<string>;
    format?: pulumi.Input<string>;
    key?: pulumi.Input<string>;
    logline?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    sd?: pulumi.Input<string>;
    server?: pulumi.Input<string>;
    tls?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointSignalfxUserConfig {
    enabledMetrics?: pulumi.Input<pulumi.Input<string>[]>;
    signalfxApiKey?: pulumi.Input<string>;
    signalfxRealm?: pulumi.Input<string>;
}

export interface ServiceIntegrationKafkaConnectUserConfig {
    kafkaConnect?: pulumi.Input<inputs.ServiceIntegrationKafkaConnectUserConfigKafkaConnect>;
}

export interface ServiceIntegrationKafkaConnectUserConfigKafkaConnect {
    configStorageTopic?: pulumi.Input<string>;
    groupId?: pulumi.Input<string>;
    offsetStorageTopic?: pulumi.Input<string>;
    statusStorageTopic?: pulumi.Input<string>;
}

export interface ServiceIntegrationKafkaLogsUserConfig {
    kafkaTopic?: pulumi.Input<string>;
}

export interface ServiceIntegrationKafkaMirrormakerUserConfig {
    clusterAlias?: pulumi.Input<string>;
    kafkaMirrormaker?: pulumi.Input<inputs.ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker>;
}

export interface ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker {
    consumerFetchMinBytes?: pulumi.Input<string>;
    producerBatchSize?: pulumi.Input<string>;
    producerBufferMemory?: pulumi.Input<string>;
    producerLingerMs?: pulumi.Input<string>;
    producerMaxRequestSize?: pulumi.Input<string>;
}

export interface ServiceIntegrationLogsUserConfig {
    elasticsearchIndexDaysMax?: pulumi.Input<string>;
    elasticsearchIndexPrefix?: pulumi.Input<string>;
}

export interface ServiceIntegrationMetricsUserConfig {
    database?: pulumi.Input<string>;
    retentionDays?: pulumi.Input<string>;
    roUsername?: pulumi.Input<string>;
    sourceMysql?: pulumi.Input<inputs.ServiceIntegrationMetricsUserConfigSourceMysql>;
    username?: pulumi.Input<string>;
}

export interface ServiceIntegrationMetricsUserConfigSourceMysql {
    telegraf?: pulumi.Input<inputs.ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf>;
}

export interface ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf {
    gatherEventWaits?: pulumi.Input<string>;
    gatherFileEventsStats?: pulumi.Input<string>;
    gatherIndexIoWaits?: pulumi.Input<string>;
    gatherInfoSchemaAutoInc?: pulumi.Input<string>;
    gatherInnodbMetrics?: pulumi.Input<string>;
    gatherPerfEventsStatements?: pulumi.Input<string>;
    gatherProcessList?: pulumi.Input<string>;
    gatherSlaveStatus?: pulumi.Input<string>;
    gatherTableIoWaits?: pulumi.Input<string>;
    gatherTableLockWaits?: pulumi.Input<string>;
    gatherTableSchema?: pulumi.Input<string>;
    perfEventsStatementsDigestTextLimit?: pulumi.Input<string>;
    perfEventsStatementsLimit?: pulumi.Input<string>;
    perfEventsStatementsTimeLimit?: pulumi.Input<string>;
}

export interface ServiceIntegrationMirrormakerUserConfig {
    mirrormakerWhitelist?: pulumi.Input<string>;
}
