// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface CassandraCassandra {
}

export interface CassandraCassandraUserConfig {
    /**
     * cassandra configuration values
     */
    cassandra?: pulumi.Input<inputs.CassandraCassandraUserConfigCassandra>;
    /**
     * Cassandra major version
     */
    cassandraVersion?: pulumi.Input<string>;
    /**
     * IP filter
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Migration mode for the sstableloader utility
     */
    migrateSstableloader?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: pulumi.Input<inputs.CassandraCassandraUserConfigPrivateAccess>;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: pulumi.Input<inputs.CassandraCassandraUserConfigPublicAccess>;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: pulumi.Input<string>;
    /**
     * Static IP addresses
     */
    staticIps?: pulumi.Input<string>;
}

export interface CassandraCassandraUserConfigCassandra {
    batchSizeFailThresholdInKb?: pulumi.Input<string>;
    batchSizeWarnThresholdInKb?: pulumi.Input<string>;
}

export interface CassandraCassandraUserConfigPrivateAccess {
    prometheus?: pulumi.Input<string>;
}

export interface CassandraCassandraUserConfigPublicAccess {
    prometheus?: pulumi.Input<string>;
}

export interface CassandraComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface CassandraServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface CassandraTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface ClickhouseClickhouse {
}

export interface ClickhouseClickhouseUserConfig {
    /**
     * IP filter
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: pulumi.Input<string>;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: pulumi.Input<string>;
}

export interface ClickhouseComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface ClickhouseGrantPrivilegeGrant {
    /**
     * The column that the grant refers to. This property cannot be changed, doing so forces recreation of the resource.
     */
    column?: pulumi.Input<string>;
    /**
     * The database that the grant refers to. To set up proper dependencies please refer to this variable as a reference. This property cannot be changed, doing so forces recreation of the resource.
     */
    database: pulumi.Input<string>;
    /**
     * The privilege to grant, i.e. 'INSERT', 'SELECT', etc. This property cannot be changed, doing so forces recreation of the resource.
     */
    privilege?: pulumi.Input<string>;
    /**
     * The table that the grant refers to. This property cannot be changed, doing so forces recreation of the resource.
     */
    table?: pulumi.Input<string>;
    /**
     * If true then the grantee gets the ability to grant the privileges he received too This property cannot be changed, doing so forces recreation of the resource.
     */
    withGrant?: pulumi.Input<boolean>;
}

export interface ClickhouseGrantRoleGrant {
    /**
     * The role that is to be granted. To set up proper dependencies please refer to this variable as a reference. This property cannot be changed, doing so forces recreation of the resource.
     */
    role?: pulumi.Input<string>;
}

export interface ClickhouseServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface ClickhouseTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface FlinkComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface FlinkFlink {
    /**
     * Host and Port of a Flink server
     */
    hostPorts?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface FlinkFlinkUserConfig {
    /**
     * Flink execution.checkpointing.interval in milliseconds
     */
    executionCheckpointingIntervalMs?: pulumi.Input<string>;
    /**
     * Flink execution.checkpointing.timeout in milliseconds
     */
    executionCheckpointingTimeoutMs?: pulumi.Input<string>;
    /**
     * Flink major version
     */
    flinkVersion?: pulumi.Input<string>;
    /**
     * IP filter
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Flink taskmanager.numberOfTaskSlots
     */
    numberOfTaskSlots?: pulumi.Input<string>;
    /**
     * Flink parallelism.default
     */
    parallelismDefault?: pulumi.Input<string>;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: pulumi.Input<inputs.FlinkFlinkUserConfigPrivatelinkAccess>;
    /**
     * Flink restart-strategy
     */
    restartStrategy?: pulumi.Input<string>;
    /**
     * Flink restart-strategy.failure-rate.delay in seconds
     */
    restartStrategyDelaySec?: pulumi.Input<string>;
    /**
     * Flink restart-strategy.failure-rate.failure-rate-interval in minutes
     */
    restartStrategyFailureRateIntervalMin?: pulumi.Input<string>;
    /**
     * Flink restart-strategy.failure-rate.max-failures-per-interval
     */
    restartStrategyMaxFailures?: pulumi.Input<string>;
}

export interface FlinkFlinkUserConfigPrivatelinkAccess {
    /**
     * Flink server provided values
     */
    flink?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface FlinkJobTableUpsertKafka {
    /**
     * Defines the columns from the SQL schema of the data table that are considered keys in the Kafka messages. This property cannot be changed, doing so forces recreation of the resource.
     */
    keyFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Sets the format that is used to convert the key part of Kafka messages. The possible values are `avro`, `avro-confluent`, `debezium-avro-confluent`, `debezium-json` and `json`. This property cannot be changed, doing so forces recreation of the resource.
     */
    keyFormat?: pulumi.Input<string>;
    /**
     * Controls the startup method for the Kafka consumer that Aiven for Apache Flink is using. The possible values are `earliest-offset`, `latest-offset`, `group-offsets` and `timestamp`. This property cannot be changed, doing so forces recreation of the resource.
     */
    scanStartupMode?: pulumi.Input<string>;
    /**
     * Topic name This property cannot be changed, doing so forces recreation of the resource.
     */
    topic?: pulumi.Input<string>;
    /**
     * Controls how key columns are handled in the message value. Select ALL to include the physical columns of the table schema in the message value. Select EXCEPT_KEY to exclude the physical columns of the table schema from the message value. This is the default for upsert Kafka connectors. The possible values are `[ALL EXCEPT_KEY]`. This property cannot be changed, doing so forces recreation of the resource.
     */
    valueFieldsInclude?: pulumi.Input<string>;
    /**
     * Sets the format that is used to convert the value part of Kafka messages. The possible values are `avro`, `avro-confluent`, `debezium-avro-confluent`, `debezium-json` and `json`. This property cannot be changed, doing so forces recreation of the resource.
     */
    valueFormat?: pulumi.Input<string>;
}

export interface FlinkServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface FlinkTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface GrafanaComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface GrafanaGrafana {
}

export interface GrafanaGrafanaUserConfig {
    /**
     * Enable or disable Grafana alerting functionality
     */
    alertingEnabled?: pulumi.Input<string>;
    /**
     * Default error or timeout setting for new alerting rules
     */
    alertingErrorOrTimeout?: pulumi.Input<string>;
    /**
     * Max number of alert annotations that Grafana stores. 0 (default) keeps all alert annotations.
     */
    alertingMaxAnnotationsToKeep?: pulumi.Input<string>;
    /**
     * Default value for 'no data or null values' for new alerting rules
     */
    alertingNodataOrNullvalues?: pulumi.Input<string>;
    /**
     * Allow embedding Grafana dashboards with iframe/frame/object/embed tags. Disabled by default to limit impact of clickjacking
     */
    allowEmbedding?: pulumi.Input<string>;
    /**
     * Azure AD OAuth integration
     */
    authAzuread?: pulumi.Input<inputs.GrafanaGrafanaUserConfigAuthAzuread>;
    /**
     * Enable or disable basic authentication form, used by Grafana built-in login
     */
    authBasicEnabled?: pulumi.Input<string>;
    /**
     * Generic OAuth integration
     */
    authGenericOauth?: pulumi.Input<inputs.GrafanaGrafanaUserConfigAuthGenericOauth>;
    /**
     * Github Auth integration
     */
    authGithub?: pulumi.Input<inputs.GrafanaGrafanaUserConfigAuthGithub>;
    /**
     * GitLab Auth integration
     */
    authGitlab?: pulumi.Input<inputs.GrafanaGrafanaUserConfigAuthGitlab>;
    /**
     * Google Auth integration
     */
    authGoogle?: pulumi.Input<inputs.GrafanaGrafanaUserConfigAuthGoogle>;
    /**
     * Cookie SameSite attribute: 'strict' prevents sending cookie for cross-site requests, effectively disabling direct linking from other sites to Grafana. 'lax' is the default value.
     */
    cookieSamesite?: pulumi.Input<string>;
    /**
     * Custom domain
     */
    customDomain?: pulumi.Input<string>;
    /**
     * Minimum refresh interval
     */
    dashboardsMinRefreshInterval?: pulumi.Input<string>;
    /**
     * Dashboard versions to keep per dashboard
     */
    dashboardsVersionsToKeep?: pulumi.Input<string>;
    /**
     * Send 'X-Grafana-User' header to data source
     */
    dataproxySendUserHeader?: pulumi.Input<string>;
    /**
     * Timeout for data proxy requests in seconds
     */
    dataproxyTimeout?: pulumi.Input<string>;
    /**
     * Grafana date format specifications
     */
    dateFormats?: pulumi.Input<inputs.GrafanaGrafanaUserConfigDateFormats>;
    /**
     * Set to true to disable gravatar. Defaults to false (gravatar is enabled)
     */
    disableGravatar?: pulumi.Input<string>;
    /**
     * Editors can manage folders, teams and dashboards created by them
     */
    editorsCanAdmin?: pulumi.Input<string>;
    /**
     * External image store settings
     */
    externalImageStorage?: pulumi.Input<inputs.GrafanaGrafanaUserConfigExternalImageStorage>;
    /**
     * Google Analytics ID
     */
    googleAnalyticsUaId?: pulumi.Input<string>;
    /**
     * IP filter
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Enable Grafana /metrics endpoint
     */
    metricsEnabled?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: pulumi.Input<inputs.GrafanaGrafanaUserConfigPrivateAccess>;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: pulumi.Input<inputs.GrafanaGrafanaUserConfigPrivatelinkAccess>;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: pulumi.Input<inputs.GrafanaGrafanaUserConfigPublicAccess>;
    /**
     * Name of the basebackup to restore in forked service
     */
    recoveryBasebackupName?: pulumi.Input<string>;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: pulumi.Input<string>;
    /**
     * SMTP server settings
     */
    smtpServer?: pulumi.Input<inputs.GrafanaGrafanaUserConfigSmtpServer>;
    /**
     * Static IP addresses
     */
    staticIps?: pulumi.Input<string>;
    /**
     * Auto-assign new users on signup to main organization. Defaults to false
     */
    userAutoAssignOrg?: pulumi.Input<string>;
    /**
     * Set role for new signups. Defaults to Viewer
     */
    userAutoAssignOrgRole?: pulumi.Input<string>;
    /**
     * Users with view-only permission can edit but not save dashboards
     */
    viewersCanEdit?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigAuthAzuread {
    allowSignUp?: pulumi.Input<string>;
    allowedDomains?: pulumi.Input<pulumi.Input<string>[]>;
    allowedGroups?: pulumi.Input<pulumi.Input<string>[]>;
    authUrl?: pulumi.Input<string>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    tokenUrl?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: pulumi.Input<string>;
    allowedDomains?: pulumi.Input<pulumi.Input<string>[]>;
    allowedOrganizations?: pulumi.Input<pulumi.Input<string>[]>;
    apiUrl?: pulumi.Input<string>;
    authUrl?: pulumi.Input<string>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    scopes?: pulumi.Input<pulumi.Input<string>[]>;
    tokenUrl?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigAuthGithub {
    allowSignUp?: pulumi.Input<string>;
    allowedOrganizations?: pulumi.Input<pulumi.Input<string>[]>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    teamIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface GrafanaGrafanaUserConfigAuthGitlab {
    allowSignUp?: pulumi.Input<string>;
    allowedGroups?: pulumi.Input<pulumi.Input<string>[]>;
    apiUrl?: pulumi.Input<string>;
    authUrl?: pulumi.Input<string>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    tokenUrl?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigAuthGoogle {
    allowSignUp?: pulumi.Input<string>;
    allowedDomains?: pulumi.Input<pulumi.Input<string>[]>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigDateFormats {
    defaultTimezone?: pulumi.Input<string>;
    fullDate?: pulumi.Input<string>;
    intervalDay?: pulumi.Input<string>;
    intervalHour?: pulumi.Input<string>;
    intervalMinute?: pulumi.Input<string>;
    intervalMonth?: pulumi.Input<string>;
    intervalSecond?: pulumi.Input<string>;
    intervalYear?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigExternalImageStorage {
    accessKey?: pulumi.Input<string>;
    bucketUrl?: pulumi.Input<string>;
    provider?: pulumi.Input<string>;
    secretKey?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigPrivateAccess {
    /**
     * Grafana server provided values
     */
    grafana?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigPrivatelinkAccess {
    /**
     * Grafana server provided values
     */
    grafana?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigPublicAccess {
    /**
     * Grafana server provided values
     */
    grafana?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigSmtpServer {
    fromAddress?: pulumi.Input<string>;
    fromName?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    skipVerify?: pulumi.Input<string>;
    starttlsPolicy?: pulumi.Input<string>;
    username?: pulumi.Input<string>;
}

export interface GrafanaServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface GrafanaTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface InfluxDbComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdb {
    databaseName?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdbUserConfig {
    /**
     * Custom domain
     */
    customDomain?: pulumi.Input<string>;
    /**
     * influxdb.conf configuration values
     */
    influxdb?: pulumi.Input<inputs.InfluxDbInfluxdbUserConfigInfluxdb>;
    /**
     * IP filter
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: pulumi.Input<inputs.InfluxDbInfluxdbUserConfigPrivateAccess>;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: pulumi.Input<inputs.InfluxDbInfluxdbUserConfigPrivatelinkAccess>;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: pulumi.Input<inputs.InfluxDbInfluxdbUserConfigPublicAccess>;
    /**
     * Name of the basebackup to restore in forked service
     */
    recoveryBasebackupName?: pulumi.Input<string>;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: pulumi.Input<string>;
    /**
     * Static IP addresses
     */
    staticIps?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdbUserConfigInfluxdb {
    logQueriesAfter?: pulumi.Input<string>;
    maxConnectionLimit?: pulumi.Input<string>;
    maxRowLimit?: pulumi.Input<string>;
    maxSelectBuckets?: pulumi.Input<string>;
    maxSelectPoint?: pulumi.Input<string>;
    queryTimeout?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdbUserConfigPrivateAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdbUserConfigPrivatelinkAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdbUserConfigPublicAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: pulumi.Input<string>;
}

export interface InfluxDbServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface InfluxDbTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface KafkaComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface KafkaConnectComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface KafkaConnectKafkaConnect {
}

export interface KafkaConnectKafkaConnectUserConfig {
    /**
     * IP filter
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Kafka Connect configuration values
     */
    kafkaConnect?: pulumi.Input<inputs.KafkaConnectKafkaConnectUserConfigKafkaConnect>;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: pulumi.Input<inputs.KafkaConnectKafkaConnectUserConfigPrivateAccess>;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: pulumi.Input<inputs.KafkaConnectKafkaConnectUserConfigPrivatelinkAccess>;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: pulumi.Input<inputs.KafkaConnectKafkaConnectUserConfigPublicAccess>;
    /**
     * Static IP addresses
     */
    staticIps?: pulumi.Input<string>;
}

export interface KafkaConnectKafkaConnectUserConfigKafkaConnect {
    connectorClientConfigOverridePolicy?: pulumi.Input<string>;
    consumerAutoOffsetReset?: pulumi.Input<string>;
    consumerFetchMaxBytes?: pulumi.Input<string>;
    consumerIsolationLevel?: pulumi.Input<string>;
    consumerMaxPartitionFetchBytes?: pulumi.Input<string>;
    consumerMaxPollIntervalMs?: pulumi.Input<string>;
    consumerMaxPollRecords?: pulumi.Input<string>;
    offsetFlushIntervalMs?: pulumi.Input<string>;
    offsetFlushTimeoutMs?: pulumi.Input<string>;
    producerCompressionType?: pulumi.Input<string>;
    producerMaxRequestSize?: pulumi.Input<string>;
    sessionTimeoutMs?: pulumi.Input<string>;
}

export interface KafkaConnectKafkaConnectUserConfigPrivateAccess {
    /**
     * Kafka Connect server provided values
     */
    kafkaConnect?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface KafkaConnectKafkaConnectUserConfigPrivatelinkAccess {
    jolokia?: pulumi.Input<string>;
    /**
     * Kafka Connect server provided values
     */
    kafkaConnect?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface KafkaConnectKafkaConnectUserConfigPublicAccess {
    /**
     * Kafka Connect server provided values
     */
    kafkaConnect?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface KafkaConnectServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface KafkaConnectTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface KafkaConnectorTask {
    connector?: pulumi.Input<string>;
    /**
     * List of tasks of a connector.
     */
    task?: pulumi.Input<number>;
}

export interface KafkaKafka {
    /**
     * The Kafka client certificate
     */
    accessCert?: pulumi.Input<string>;
    /**
     * The Kafka client certificate key
     */
    accessKey?: pulumi.Input<string>;
    /**
     * The Kafka Connect URI, if any
     */
    connectUri?: pulumi.Input<string>;
    /**
     * The Kafka REST URI, if any
     */
    restUri?: pulumi.Input<string>;
    /**
     * The Schema Registry URI, if any
     */
    schemaRegistryUri?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfig {
    /**
     * Custom domain
     */
    customDomain?: pulumi.Input<string>;
    /**
     * IP filter
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Kafka broker configuration values
     */
    kafka?: pulumi.Input<inputs.KafkaKafkaUserConfigKafka>;
    /**
     * Kafka authentication methods
     */
    kafkaAuthenticationMethods?: pulumi.Input<inputs.KafkaKafkaUserConfigKafkaAuthenticationMethods>;
    /**
     * Enable Kafka Connect service
     */
    kafkaConnect?: pulumi.Input<string>;
    /**
     * Kafka Connect configuration values
     */
    kafkaConnectConfig?: pulumi.Input<inputs.KafkaKafkaUserConfigKafkaConnectConfig>;
    /**
     * Enable Kafka-REST service
     */
    kafkaRest?: pulumi.Input<string>;
    /**
     * Kafka REST configuration
     */
    kafkaRestConfig?: pulumi.Input<inputs.KafkaKafkaUserConfigKafkaRestConfig>;
    /**
     * Kafka major version
     */
    kafkaVersion?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: pulumi.Input<inputs.KafkaKafkaUserConfigPrivateAccess>;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: pulumi.Input<inputs.KafkaKafkaUserConfigPrivatelinkAccess>;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: pulumi.Input<inputs.KafkaKafkaUserConfigPublicAccess>;
    /**
     * Enable Schema-Registry service
     */
    schemaRegistry?: pulumi.Input<string>;
    /**
     * Schema Registry configuration
     */
    schemaRegistryConfig?: pulumi.Input<inputs.KafkaKafkaUserConfigSchemaRegistryConfig>;
    /**
     * Static IP addresses
     */
    staticIps?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigKafka {
    autoCreateTopicsEnable?: pulumi.Input<string>;
    compressionType?: pulumi.Input<string>;
    connectionsMaxIdleMs?: pulumi.Input<string>;
    defaultReplicationFactor?: pulumi.Input<string>;
    groupInitialRebalanceDelayMs?: pulumi.Input<string>;
    groupMaxSessionTimeoutMs?: pulumi.Input<string>;
    groupMinSessionTimeoutMs?: pulumi.Input<string>;
    logCleanerDeleteRetentionMs?: pulumi.Input<string>;
    logCleanerMaxCompactionLagMs?: pulumi.Input<string>;
    logCleanerMinCleanableRatio?: pulumi.Input<string>;
    logCleanerMinCompactionLagMs?: pulumi.Input<string>;
    logCleanupPolicy?: pulumi.Input<string>;
    logFlushIntervalMessages?: pulumi.Input<string>;
    logFlushIntervalMs?: pulumi.Input<string>;
    logIndexIntervalBytes?: pulumi.Input<string>;
    logIndexSizeMaxBytes?: pulumi.Input<string>;
    logMessageDownconversionEnable?: pulumi.Input<string>;
    logMessageTimestampDifferenceMaxMs?: pulumi.Input<string>;
    logMessageTimestampType?: pulumi.Input<string>;
    logPreallocate?: pulumi.Input<string>;
    logRetentionBytes?: pulumi.Input<string>;
    logRetentionHours?: pulumi.Input<string>;
    logRetentionMs?: pulumi.Input<string>;
    logRollJitterMs?: pulumi.Input<string>;
    logRollMs?: pulumi.Input<string>;
    logSegmentBytes?: pulumi.Input<string>;
    logSegmentDeleteDelayMs?: pulumi.Input<string>;
    maxConnectionsPerIp?: pulumi.Input<string>;
    maxIncrementalFetchSessionCacheSlots?: pulumi.Input<string>;
    messageMaxBytes?: pulumi.Input<string>;
    minInsyncReplicas?: pulumi.Input<string>;
    numPartitions?: pulumi.Input<string>;
    offsetsRetentionMinutes?: pulumi.Input<string>;
    producerPurgatoryPurgeIntervalRequests?: pulumi.Input<string>;
    replicaFetchMaxBytes?: pulumi.Input<string>;
    replicaFetchResponseMaxBytes?: pulumi.Input<string>;
    socketRequestMaxBytes?: pulumi.Input<string>;
    transactionRemoveExpiredTransactionCleanupIntervalMs?: pulumi.Input<string>;
    transactionStateLogSegmentBytes?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: pulumi.Input<string>;
    sasl?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigKafkaConnectConfig {
    connectorClientConfigOverridePolicy?: pulumi.Input<string>;
    consumerAutoOffsetReset?: pulumi.Input<string>;
    consumerFetchMaxBytes?: pulumi.Input<string>;
    consumerIsolationLevel?: pulumi.Input<string>;
    consumerMaxPartitionFetchBytes?: pulumi.Input<string>;
    consumerMaxPollIntervalMs?: pulumi.Input<string>;
    consumerMaxPollRecords?: pulumi.Input<string>;
    offsetFlushIntervalMs?: pulumi.Input<string>;
    offsetFlushTimeoutMs?: pulumi.Input<string>;
    producerCompressionType?: pulumi.Input<string>;
    producerMaxRequestSize?: pulumi.Input<string>;
    sessionTimeoutMs?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: pulumi.Input<string>;
    consumerRequestMaxBytes?: pulumi.Input<string>;
    consumerRequestTimeoutMs?: pulumi.Input<string>;
    producerAcks?: pulumi.Input<string>;
    producerLingerMs?: pulumi.Input<string>;
    simpleconsumerPoolSizeMax?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigPrivateAccess {
    prometheus?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigPrivatelinkAccess {
    jolokia?: pulumi.Input<string>;
    /**
     * Kafka server provided values
     */
    kafka?: pulumi.Input<string>;
    kafkaConnect?: pulumi.Input<string>;
    kafkaRest?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
    schemaRegistry?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigPublicAccess {
    /**
     * Kafka server provided values
     */
    kafka?: pulumi.Input<string>;
    kafkaConnect?: pulumi.Input<string>;
    kafkaRest?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
    schemaRegistry?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigSchemaRegistryConfig {
    leaderEligibility?: pulumi.Input<string>;
    topicName?: pulumi.Input<string>;
}

export interface KafkaMirrorMakerComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface KafkaMirrorMakerKafkaMirrormaker {
}

export interface KafkaMirrorMakerKafkaMirrormakerUserConfig {
    /**
     * IP filter
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Kafka MirrorMaker configuration values
     */
    kafkaMirrormaker?: pulumi.Input<inputs.KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker>;
    /**
     * Static IP addresses
     */
    staticIps?: pulumi.Input<string>;
}

export interface KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker {
    emitCheckpointsEnabled?: pulumi.Input<string>;
    emitCheckpointsIntervalSeconds?: pulumi.Input<string>;
    refreshGroupsEnabled?: pulumi.Input<string>;
    refreshGroupsIntervalSeconds?: pulumi.Input<string>;
    refreshTopicsEnabled?: pulumi.Input<string>;
    refreshTopicsIntervalSeconds?: pulumi.Input<string>;
    syncGroupOffsetsEnabled?: pulumi.Input<string>;
    syncGroupOffsetsIntervalSeconds?: pulumi.Input<string>;
    syncTopicConfigsEnabled?: pulumi.Input<string>;
    tasksMaxPerCpu?: pulumi.Input<string>;
}

export interface KafkaMirrorMakerServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface KafkaMirrorMakerTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface KafkaServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface KafkaTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface KafkaTopicConfig {
    /**
     * cleanup.policy value
     */
    cleanupPolicy?: pulumi.Input<string>;
    /**
     * compression.type value
     */
    compressionType?: pulumi.Input<string>;
    /**
     * delete.retention.ms value
     */
    deleteRetentionMs?: pulumi.Input<string>;
    /**
     * file.delete.delay.ms value
     */
    fileDeleteDelayMs?: pulumi.Input<string>;
    /**
     * flush.messages value
     */
    flushMessages?: pulumi.Input<string>;
    /**
     * flush.ms value
     */
    flushMs?: pulumi.Input<string>;
    /**
     * index.interval.bytes value
     */
    indexIntervalBytes?: pulumi.Input<string>;
    /**
     * max.compaction.lag.ms value
     */
    maxCompactionLagMs?: pulumi.Input<string>;
    /**
     * max.message.bytes value
     */
    maxMessageBytes?: pulumi.Input<string>;
    /**
     * message.downconversion.enable value
     */
    messageDownconversionEnable?: pulumi.Input<string>;
    /**
     * message.format.version value
     */
    messageFormatVersion?: pulumi.Input<string>;
    /**
     * message.timestamp.difference.max.ms value
     */
    messageTimestampDifferenceMaxMs?: pulumi.Input<string>;
    /**
     * message.timestamp.type value
     */
    messageTimestampType?: pulumi.Input<string>;
    /**
     * min.cleanable.dirty.ratio value
     */
    minCleanableDirtyRatio?: pulumi.Input<string>;
    /**
     * min.compaction.lag.ms value
     */
    minCompactionLagMs?: pulumi.Input<string>;
    /**
     * min.insync.replicas value
     */
    minInsyncReplicas?: pulumi.Input<string>;
    /**
     * preallocate value
     */
    preallocate?: pulumi.Input<string>;
    /**
     * retention.bytes value
     */
    retentionBytes?: pulumi.Input<string>;
    /**
     * retention.ms value
     */
    retentionMs?: pulumi.Input<string>;
    /**
     * segment.bytes value
     */
    segmentBytes?: pulumi.Input<string>;
    /**
     * segment.index.bytes value
     */
    segmentIndexBytes?: pulumi.Input<string>;
    /**
     * segment.jitter.ms value
     */
    segmentJitterMs?: pulumi.Input<string>;
    /**
     * segment.ms value
     */
    segmentMs?: pulumi.Input<string>;
    /**
     * unclean.leader.election.enable value
     */
    uncleanLeaderElectionEnable?: pulumi.Input<string>;
}

export interface KafkaTopicTag {
    /**
     * Topic tag key. Maximum Length: `64`.
     */
    key: pulumi.Input<string>;
    /**
     * Topic tag value. Maximum Length: `256`.
     */
    value?: pulumi.Input<string>;
}

export interface M3AggregatorComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface M3AggregatorM3aggregator {
}

export interface M3AggregatorM3aggregatorUserConfig {
    /**
     * Custom domain
     */
    customDomain?: pulumi.Input<string>;
    /**
     * IP filter
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * M3 major version (deprecated, use m3aggregator_version)
     */
    m3Version?: pulumi.Input<string>;
    /**
     * M3 major version (the minimum compatible version)
     */
    m3aggregatorVersion?: pulumi.Input<string>;
    /**
     * Static IP addresses
     */
    staticIps?: pulumi.Input<string>;
}

export interface M3AggregatorServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface M3AggregatorTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface M3DbComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface M3DbM3db {
}

export interface M3DbM3dbUserConfig {
    /**
     * Custom domain
     */
    customDomain?: pulumi.Input<string>;
    /**
     * IP filter
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * M3 limits
     */
    limits?: pulumi.Input<inputs.M3DbM3dbUserConfigLimits>;
    /**
     * M3 major version (deprecated, use m3db_version)
     */
    m3Version?: pulumi.Input<string>;
    /**
     * Enable Graphite ingestion using Carbon plaintext protocol
     */
    m3coordinatorEnableGraphiteCarbonIngest?: pulumi.Input<string>;
    /**
     * M3 major version (the minimum compatible version)
     */
    m3dbVersion?: pulumi.Input<string>;
    /**
     * List of M3 namespaces
     */
    namespaces?: pulumi.Input<pulumi.Input<inputs.M3DbM3dbUserConfigNamespace>[]>;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: pulumi.Input<inputs.M3DbM3dbUserConfigPrivateAccess>;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: pulumi.Input<inputs.M3DbM3dbUserConfigPublicAccess>;
    /**
     * M3 rules
     */
    rules?: pulumi.Input<inputs.M3DbM3dbUserConfigRules>;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: pulumi.Input<string>;
    /**
     * Static IP addresses
     */
    staticIps?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigLimits {
    queryRequireExhaustive?: pulumi.Input<string>;
    querySeries?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigNamespace {
    name?: pulumi.Input<string>;
    options?: pulumi.Input<inputs.M3DbM3dbUserConfigNamespaceOptions>;
    resolution?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigNamespaceOptions {
    retentionOptions?: pulumi.Input<inputs.M3DbM3dbUserConfigNamespaceOptionsRetentionOptions>;
    snapshotEnabled?: pulumi.Input<string>;
    writesToCommitlog?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigNamespaceOptionsRetentionOptions {
    blockDataExpiryDuration?: pulumi.Input<string>;
    blocksizeDuration?: pulumi.Input<string>;
    bufferFutureDuration?: pulumi.Input<string>;
    bufferPastDuration?: pulumi.Input<string>;
    retentionPeriodDuration?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigPrivateAccess {
    m3coordinator?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigPublicAccess {
    m3coordinator?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigRules {
    mappings?: pulumi.Input<pulumi.Input<inputs.M3DbM3dbUserConfigRulesMapping>[]>;
}

export interface M3DbM3dbUserConfigRulesMapping {
    aggregations?: pulumi.Input<pulumi.Input<string>[]>;
    drop?: pulumi.Input<string>;
    filter?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    namespaces?: pulumi.Input<pulumi.Input<string>[]>;
    tags?: pulumi.Input<pulumi.Input<inputs.M3DbM3dbUserConfigRulesMappingTag>[]>;
}

export interface M3DbM3dbUserConfigRulesMappingTag {
    name?: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface M3DbServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface M3DbTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface MySqlComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface MySqlMysql {
}

export interface MySqlMysqlUserConfig {
    /**
     * Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
     */
    adminPassword?: pulumi.Input<string>;
    /**
     * Custom username for admin user. This must be set only when a new service is being created.
     */
    adminUsername?: pulumi.Input<string>;
    /**
     * The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
     */
    backupHour?: pulumi.Input<string>;
    /**
     * The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
     */
    backupMinute?: pulumi.Input<string>;
    /**
     * The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
     */
    binlogRetentionPeriod?: pulumi.Input<string>;
    /**
     * IP filter
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Migrate data from existing server
     */
    migration?: pulumi.Input<inputs.MySqlMysqlUserConfigMigration>;
    /**
     * mysql.conf configuration values
     */
    mysql?: pulumi.Input<inputs.MySqlMysqlUserConfigMysql>;
    /**
     * MySQL major version
     */
    mysqlVersion?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: pulumi.Input<inputs.MySqlMysqlUserConfigPrivateAccess>;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: pulumi.Input<inputs.MySqlMysqlUserConfigPrivatelinkAccess>;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: pulumi.Input<inputs.MySqlMysqlUserConfigPublicAccess>;
    /**
     * Recovery target time when forking a service. This has effect only when a new service is being created.
     */
    recoveryTargetTime?: pulumi.Input<string>;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: pulumi.Input<string>;
    /**
     * Static IP addresses
     */
    staticIps?: pulumi.Input<string>;
}

export interface MySqlMysqlUserConfigMigration {
    dbname?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    ignoreDbs?: pulumi.Input<string>;
    method?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    ssl?: pulumi.Input<string>;
    username?: pulumi.Input<string>;
}

export interface MySqlMysqlUserConfigMysql {
    connectTimeout?: pulumi.Input<string>;
    defaultTimeZone?: pulumi.Input<string>;
    groupConcatMaxLen?: pulumi.Input<string>;
    informationSchemaStatsExpiry?: pulumi.Input<string>;
    innodbFtMinTokenSize?: pulumi.Input<string>;
    innodbFtServerStopwordTable?: pulumi.Input<string>;
    innodbLockWaitTimeout?: pulumi.Input<string>;
    innodbLogBufferSize?: pulumi.Input<string>;
    innodbOnlineAlterLogMaxSize?: pulumi.Input<string>;
    innodbPrintAllDeadlocks?: pulumi.Input<string>;
    innodbRollbackOnTimeout?: pulumi.Input<string>;
    interactiveTimeout?: pulumi.Input<string>;
    internalTmpMemStorageEngine?: pulumi.Input<string>;
    longQueryTime?: pulumi.Input<string>;
    maxAllowedPacket?: pulumi.Input<string>;
    maxHeapTableSize?: pulumi.Input<string>;
    netReadTimeout?: pulumi.Input<string>;
    netWriteTimeout?: pulumi.Input<string>;
    slowQueryLog?: pulumi.Input<string>;
    sortBufferSize?: pulumi.Input<string>;
    sqlMode?: pulumi.Input<string>;
    sqlRequirePrimaryKey?: pulumi.Input<string>;
    tmpTableSize?: pulumi.Input<string>;
    waitTimeout?: pulumi.Input<string>;
}

export interface MySqlMysqlUserConfigPrivateAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: pulumi.Input<string>;
    mysqlx?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface MySqlMysqlUserConfigPrivatelinkAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: pulumi.Input<string>;
    mysqlx?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface MySqlMysqlUserConfigPublicAccess {
    /**
     * MySQL specific server provided values
     */
    mysql?: pulumi.Input<string>;
    mysqlx?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface MySqlServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface MySqlTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface OpenSearchComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface OpenSearchOpensearch {
    opensearchDashboardsUri?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfig {
    /**
     * Custom domain
     */
    customDomain?: pulumi.Input<string>;
    /**
     * Disable replication factor adjustment
     */
    disableReplicationFactorAdjustment?: pulumi.Input<string>;
    /**
     * Index patterns
     */
    indexPatterns?: pulumi.Input<pulumi.Input<inputs.OpenSearchOpensearchUserConfigIndexPattern>[]>;
    /**
     * Template settings for all new indexes
     */
    indexTemplate?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigIndexTemplate>;
    /**
     * IP filter
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Don't reset index.refresh_interval to the default value
     */
    keepIndexRefreshInterval?: pulumi.Input<string>;
    /**
     * Maximum index count
     */
    maxIndexCount?: pulumi.Input<string>;
    /**
     * OpenSearch settings
     */
    opensearch?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigOpensearch>;
    /**
     * OpenSearch Dashboards settings
     */
    opensearchDashboards?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigOpensearchDashboards>;
    /**
     * OpenSearch major version
     */
    opensearchVersion?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigPrivateAccess>;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigPrivatelinkAccess>;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigPublicAccess>;
    /**
     * Name of the basebackup to restore in forked service
     */
    recoveryBasebackupName?: pulumi.Input<string>;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: pulumi.Input<string>;
    /**
     * Static IP addresses
     */
    staticIps?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigIndexPattern {
    maxIndexCount?: pulumi.Input<string>;
    pattern?: pulumi.Input<string>;
    sortingAlgorithm?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigIndexTemplate {
    mappingNestedObjectsLimit?: pulumi.Input<string>;
    numberOfReplicas?: pulumi.Input<string>;
    numberOfShards?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigOpensearch {
    actionAutoCreateIndexEnabled?: pulumi.Input<string>;
    actionDestructiveRequiresName?: pulumi.Input<string>;
    clusterMaxShardsPerNode?: pulumi.Input<string>;
    clusterRoutingAllocationNodeConcurrentRecoveries?: pulumi.Input<string>;
    httpMaxContentLength?: pulumi.Input<string>;
    httpMaxHeaderSize?: pulumi.Input<string>;
    httpMaxInitialLineLength?: pulumi.Input<string>;
    indicesFielddataCacheSize?: pulumi.Input<string>;
    indicesMemoryIndexBufferSize?: pulumi.Input<string>;
    indicesQueriesCacheSize?: pulumi.Input<string>;
    indicesQueryBoolMaxClauseCount?: pulumi.Input<string>;
    indicesRecoveryMaxBytesPerSec?: pulumi.Input<string>;
    indicesRecoveryMaxConcurrentFileChunks?: pulumi.Input<string>;
    overrideMainResponseVersion?: pulumi.Input<string>;
    reindexRemoteWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    scriptMaxCompilationsRate?: pulumi.Input<string>;
    searchMaxBuckets?: pulumi.Input<string>;
    threadPoolAnalyzeQueueSize?: pulumi.Input<string>;
    threadPoolAnalyzeSize?: pulumi.Input<string>;
    threadPoolForceMergeSize?: pulumi.Input<string>;
    threadPoolGetQueueSize?: pulumi.Input<string>;
    threadPoolGetSize?: pulumi.Input<string>;
    threadPoolSearchQueueSize?: pulumi.Input<string>;
    threadPoolSearchSize?: pulumi.Input<string>;
    threadPoolSearchThrottledQueueSize?: pulumi.Input<string>;
    threadPoolSearchThrottledSize?: pulumi.Input<string>;
    threadPoolWriteQueueSize?: pulumi.Input<string>;
    threadPoolWriteSize?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigOpensearchDashboards {
    enabled?: pulumi.Input<string>;
    maxOldSpaceSize?: pulumi.Input<string>;
    opensearchRequestTimeout?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigPrivateAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: pulumi.Input<string>;
    opensearchDashboards?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigPrivatelinkAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: pulumi.Input<string>;
    opensearchDashboards?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigPublicAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: pulumi.Input<string>;
    opensearchDashboards?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface OpenSearchServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface OpenSearchTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface PgComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface PgPg {
    /**
     * Primary PostgreSQL database name
     */
    dbname?: pulumi.Input<string>;
    /**
     * PostgreSQL master node host IP or name
     */
    host?: pulumi.Input<string>;
    /**
     * PostgreSQL admin user password
     */
    password?: pulumi.Input<string>;
    /**
     * PostgreSQL port
     */
    port?: pulumi.Input<number>;
    /**
     * PostgreSQL replica URI for services with a replica
     */
    replicaUri?: pulumi.Input<string>;
    /**
     * PostgreSQL sslmode setting (currently always "require")
     */
    sslmode?: pulumi.Input<string>;
    /**
     * PostgreSQL master connection URI
     */
    uri?: pulumi.Input<string>;
    /**
     * PostgreSQL admin user name
     */
    user?: pulumi.Input<string>;
}

export interface PgPgUserConfig {
    /**
     * Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
     */
    adminPassword?: pulumi.Input<string>;
    /**
     * Custom username for admin user. This must be set only when a new service is being created.
     */
    adminUsername?: pulumi.Input<string>;
    /**
     * The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
     */
    backupHour?: pulumi.Input<string>;
    /**
     * The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
     */
    backupMinute?: pulumi.Input<string>;
    /**
     * Enable IPv6
     */
    enableIpv6?: pulumi.Input<string>;
    /**
     * IP filter
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Migrate data from existing server
     */
    migration?: pulumi.Input<inputs.PgPgUserConfigMigration>;
    /**
     * postgresql.conf configuration values
     */
    pg?: pulumi.Input<inputs.PgPgUserConfigPg>;
    /**
     * Should the service which is being forked be a read replica (deprecated, use readReplica service integration instead).
     */
    pgReadReplica?: pulumi.Input<string>;
    /**
     * Name of the PG Service from which to fork (deprecated, use service*to*fork_from). This has effect only when a new service is being created.
     */
    pgServiceToForkFrom?: pulumi.Input<string>;
    /**
     * PostgreSQL major version
     */
    pgVersion?: pulumi.Input<string>;
    /**
     * PGBouncer connection pooling settings
     */
    pgbouncer?: pulumi.Input<inputs.PgPgUserConfigPgbouncer>;
    /**
     * PGLookout settings
     */
    pglookout?: pulumi.Input<inputs.PgPgUserConfigPglookout>;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: pulumi.Input<inputs.PgPgUserConfigPrivateAccess>;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: pulumi.Input<inputs.PgPgUserConfigPrivatelinkAccess>;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: pulumi.Input<inputs.PgPgUserConfigPublicAccess>;
    /**
     * Recovery target time when forking a service. This has effect only when a new service is being created.
     */
    recoveryTargetTime?: pulumi.Input<string>;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: pulumi.Input<string>;
    /**
     * shared*buffers*percentage
     */
    sharedBuffersPercentage?: pulumi.Input<string>;
    /**
     * Static IP addresses
     */
    staticIps?: pulumi.Input<string>;
    /**
     * Synchronous replication type. Note that the service plan also needs to support synchronous replication.
     */
    synchronousReplication?: pulumi.Input<string>;
    /**
     * TimescaleDB extension configuration values
     */
    timescaledb?: pulumi.Input<inputs.PgPgUserConfigTimescaledb>;
    /**
     * Variant of the PostgreSQL service, may affect the features that are exposed by default
     */
    variant?: pulumi.Input<string>;
    /**
     * work_mem
     */
    workMem?: pulumi.Input<string>;
}

export interface PgPgUserConfigMigration {
    dbname?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    ignoreDbs?: pulumi.Input<string>;
    method?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    ssl?: pulumi.Input<string>;
    username?: pulumi.Input<string>;
}

export interface PgPgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: pulumi.Input<string>;
    autovacuumAnalyzeThreshold?: pulumi.Input<string>;
    autovacuumFreezeMaxAge?: pulumi.Input<string>;
    autovacuumMaxWorkers?: pulumi.Input<string>;
    autovacuumNaptime?: pulumi.Input<string>;
    autovacuumVacuumCostDelay?: pulumi.Input<string>;
    autovacuumVacuumCostLimit?: pulumi.Input<string>;
    autovacuumVacuumScaleFactor?: pulumi.Input<string>;
    autovacuumVacuumThreshold?: pulumi.Input<string>;
    bgwriterDelay?: pulumi.Input<string>;
    bgwriterFlushAfter?: pulumi.Input<string>;
    bgwriterLruMaxpages?: pulumi.Input<string>;
    bgwriterLruMultiplier?: pulumi.Input<string>;
    deadlockTimeout?: pulumi.Input<string>;
    defaultToastCompression?: pulumi.Input<string>;
    idleInTransactionSessionTimeout?: pulumi.Input<string>;
    jit?: pulumi.Input<string>;
    logAutovacuumMinDuration?: pulumi.Input<string>;
    logErrorVerbosity?: pulumi.Input<string>;
    logLinePrefix?: pulumi.Input<string>;
    logMinDurationStatement?: pulumi.Input<string>;
    maxFilesPerProcess?: pulumi.Input<string>;
    maxLocksPerTransaction?: pulumi.Input<string>;
    maxLogicalReplicationWorkers?: pulumi.Input<string>;
    maxParallelWorkers?: pulumi.Input<string>;
    maxParallelWorkersPerGather?: pulumi.Input<string>;
    maxPredLocksPerTransaction?: pulumi.Input<string>;
    maxPreparedTransactions?: pulumi.Input<string>;
    maxReplicationSlots?: pulumi.Input<string>;
    maxSlotWalKeepSize?: pulumi.Input<string>;
    maxStackDepth?: pulumi.Input<string>;
    maxStandbyArchiveDelay?: pulumi.Input<string>;
    maxStandbyStreamingDelay?: pulumi.Input<string>;
    maxWalSenders?: pulumi.Input<string>;
    maxWorkerProcesses?: pulumi.Input<string>;
    pgPartmanBgwDotInterval?: pulumi.Input<string>;
    pgPartmanBgwDotRole?: pulumi.Input<string>;
    pgStatStatementsDotTrack?: pulumi.Input<string>;
    tempFileLimit?: pulumi.Input<string>;
    timezone?: pulumi.Input<string>;
    trackActivityQuerySize?: pulumi.Input<string>;
    trackCommitTimestamp?: pulumi.Input<string>;
    trackFunctions?: pulumi.Input<string>;
    trackIoTiming?: pulumi.Input<string>;
    walSenderTimeout?: pulumi.Input<string>;
    walWriterDelay?: pulumi.Input<string>;
}

export interface PgPgUserConfigPgbouncer {
    autodbIdleTimeout?: pulumi.Input<string>;
    autodbMaxDbConnections?: pulumi.Input<string>;
    autodbPoolMode?: pulumi.Input<string>;
    autodbPoolSize?: pulumi.Input<string>;
    ignoreStartupParameters?: pulumi.Input<pulumi.Input<string>[]>;
    minPoolSize?: pulumi.Input<string>;
    serverIdleTimeout?: pulumi.Input<string>;
    serverLifetime?: pulumi.Input<string>;
    serverResetQueryAlways?: pulumi.Input<string>;
}

export interface PgPgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: pulumi.Input<string>;
}

export interface PgPgUserConfigPrivateAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: pulumi.Input<string>;
    pgbouncer?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface PgPgUserConfigPrivatelinkAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: pulumi.Input<string>;
    pgbouncer?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface PgPgUserConfigPublicAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: pulumi.Input<string>;
    pgbouncer?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface PgPgUserConfigTimescaledb {
    maxBackgroundWorkers?: pulumi.Input<string>;
}

export interface PgServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface PgTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface ProjectTag {
    /**
     * Project tag key
     */
    key: pulumi.Input<string>;
    /**
     * Project tag value
     */
    value: pulumi.Input<string>;
}

export interface RedisComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface RedisRedi {
}

export interface RedisRedisUserConfig {
    /**
     * IP filter
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Migrate data from existing server
     */
    migration?: pulumi.Input<inputs.RedisRedisUserConfigMigration>;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: pulumi.Input<inputs.RedisRedisUserConfigPrivateAccess>;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: pulumi.Input<inputs.RedisRedisUserConfigPrivatelinkAccess>;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: pulumi.Input<inputs.RedisRedisUserConfigPublicAccess>;
    /**
     * Name of the basebackup to restore in forked service
     */
    recoveryBasebackupName?: pulumi.Input<string>;
    /**
     * Default ACL for pub/sub channels used when Redis user is created
     */
    redisAclChannelsDefault?: pulumi.Input<string>;
    /**
     * Redis IO thread count
     */
    redisIoThreads?: pulumi.Input<string>;
    /**
     * LFU maxmemory-policy counter decay time in minutes
     */
    redisLfuDecayTime?: pulumi.Input<string>;
    /**
     * Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies
     */
    redisLfuLogFactor?: pulumi.Input<string>;
    /**
     * Redis maxmemory-policy
     */
    redisMaxmemoryPolicy?: pulumi.Input<string>;
    /**
     * Set notify-keyspace-events option
     */
    redisNotifyKeyspaceEvents?: pulumi.Input<string>;
    /**
     * Number of redis databases
     */
    redisNumberOfDatabases?: pulumi.Input<string>;
    /**
     * Redis persistence
     */
    redisPersistence?: pulumi.Input<string>;
    /**
     * Pub/sub client output buffer hard limit in MB
     */
    redisPubsubClientOutputBufferLimit?: pulumi.Input<string>;
    /**
     * Require SSL to access Redis
     */
    redisSsl?: pulumi.Input<string>;
    /**
     * Redis idle connection timeout in seconds
     */
    redisTimeout?: pulumi.Input<string>;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: pulumi.Input<string>;
    /**
     * Static IP addresses
     */
    staticIps?: pulumi.Input<string>;
}

export interface RedisRedisUserConfigMigration {
    dbname?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    ignoreDbs?: pulumi.Input<string>;
    method?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    ssl?: pulumi.Input<string>;
    username?: pulumi.Input<string>;
}

export interface RedisRedisUserConfigPrivateAccess {
    prometheus?: pulumi.Input<string>;
    /**
     * Redis server provided values
     */
    redis?: pulumi.Input<string>;
}

export interface RedisRedisUserConfigPrivatelinkAccess {
    prometheus?: pulumi.Input<string>;
    /**
     * Redis server provided values
     */
    redis?: pulumi.Input<string>;
}

export interface RedisRedisUserConfigPublicAccess {
    prometheus?: pulumi.Input<string>;
    /**
     * Redis server provided values
     */
    redis?: pulumi.Input<string>;
}

export interface RedisServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface RedisTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointDatadogUserConfig {
    /**
     * Datadog API key
     */
    datadogApiKey?: pulumi.Input<string>;
    /**
     * Custom tags provided by user
     */
    datadogTags?: pulumi.Input<pulumi.Input<inputs.ServiceIntegrationEndpointDatadogUserConfigDatadogTag>[]>;
    /**
     * Disable consumer group metrics
     */
    disableConsumerStats?: pulumi.Input<string>;
    /**
     * Number of separate instances to fetch kafka consumer statistics with
     */
    kafkaConsumerCheckInstances?: pulumi.Input<string>;
    /**
     * Number of seconds that datadog will wait to get consumer statistics from brokers
     */
    kafkaConsumerStatsTimeout?: pulumi.Input<string>;
    /**
     * Maximum number of partition contexts to send
     */
    maxPartitionContexts?: pulumi.Input<string>;
    /**
     * Datadog intake site. Defaults to datadoghq.com
     */
    site?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointDatadogUserConfigDatadogTag {
    comment?: pulumi.Input<string>;
    tag?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig {
    /**
     * AWS access key. Required permissions are logs:CreateLogGroup, logs:CreateLogStream, logs:PutLogEvents and logs:DescribeLogStreams
     */
    accessKey?: pulumi.Input<string>;
    /**
     * AWS CloudWatch log group name
     */
    logGroupName?: pulumi.Input<string>;
    /**
     * AWS region
     */
    region?: pulumi.Input<string>;
    /**
     * AWS secret key
     */
    secretKey?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig {
    /**
     * AWS access key. Required permissions are cloudwatch:PutMetricData
     */
    accessKey?: pulumi.Input<string>;
    /**
     * AWS CloudWatch Metrics Namespace
     */
    namespace?: pulumi.Input<string>;
    /**
     * AWS region
     */
    region?: pulumi.Input<string>;
    /**
     * AWS secret key
     */
    secretKey?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig {
    /**
     * PEM encoded CA certificate
     */
    ca?: pulumi.Input<string>;
    /**
     * Maximum number of days of logs to keep
     */
    indexDaysMax?: pulumi.Input<string>;
    /**
     * Elasticsearch index prefix
     */
    indexPrefix?: pulumi.Input<string>;
    /**
     * Elasticsearch request timeout limit
     */
    timeout?: pulumi.Input<string>;
    /**
     * Elasticsearch connection URL
     */
    url?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig {
    /**
     * Google Cloud Logging log id
     */
    logId?: pulumi.Input<string>;
    /**
     * GCP project id.
     */
    projectId?: pulumi.Input<string>;
    /**
     * Google Service Account Credentials
     */
    serviceAccountCredentials?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalKafkaUserConfig {
    /**
     * Bootstrap servers
     */
    bootstrapServers?: pulumi.Input<string>;
    /**
     * The list of SASL mechanisms enabled in the Kafka server.
     */
    saslMechanism?: pulumi.Input<string>;
    /**
     * Password for SASL PLAIN mechanism in the Kafka server.
     */
    saslPlainPassword?: pulumi.Input<string>;
    /**
     * Username for SASL PLAIN mechanism in the Kafka server.
     */
    saslPlainUsername?: pulumi.Input<string>;
    /**
     * Security protocol
     */
    securityProtocol?: pulumi.Input<string>;
    /**
     * PEM-encoded CA certificate
     */
    sslCaCert?: pulumi.Input<string>;
    /**
     * PEM-encoded client certificate
     */
    sslClientCert?: pulumi.Input<string>;
    /**
     * PEM-encoded client key
     */
    sslClientKey?: pulumi.Input<string>;
    /**
     * The endpoint identification algorithm to validate server hostname using server certificate.
     */
    sslEndpointIdentificationAlgorithm?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalSchemaRegistryUserConfig {
    /**
     * Authentication method
     */
    authentication?: pulumi.Input<string>;
    /**
     * Basic authentication password
     */
    basicAuthPassword?: pulumi.Input<string>;
    /**
     * Basic authentication user name
     */
    basicAuthUsername?: pulumi.Input<string>;
    /**
     * Schema Registry URL
     */
    url?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointJolokiaUserConfig {
    /**
     * Jolokia basic authentication password
     */
    basicAuthPassword?: pulumi.Input<string>;
    /**
     * Jolokia basic authentication username
     */
    basicAuthUsername?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointPrometheusUserConfig {
    /**
     * Prometheus basic authentication password
     */
    basicAuthPassword?: pulumi.Input<string>;
    /**
     * Prometheus basic authentication username
     */
    basicAuthUsername?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointRsyslogUserConfig {
    /**
     * PEM encoded CA certificate
     */
    ca?: pulumi.Input<string>;
    /**
     * PEM encoded client certificate
     */
    cert?: pulumi.Input<string>;
    /**
     * message format
     */
    format?: pulumi.Input<string>;
    /**
     * PEM encoded client key
     */
    key?: pulumi.Input<string>;
    /**
     * custom syslog message format
     */
    logline?: pulumi.Input<string>;
    /**
     * rsyslog server port
     */
    port?: pulumi.Input<string>;
    /**
     * Structured data block for log message
     */
    sd?: pulumi.Input<string>;
    /**
     * rsyslog server IP address or hostname
     */
    server?: pulumi.Input<string>;
    /**
     * Require TLS
     */
    tls?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointSignalfxUserConfig {
    /**
     * list of metrics to send
     */
    enabledMetrics?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * SignalFX API key
     */
    signalfxApiKey?: pulumi.Input<string>;
    /**
     * SignalFX realm
     */
    signalfxRealm?: pulumi.Input<string>;
}

export interface ServiceIntegrationKafkaConnectUserConfig {
    /**
     * Kafka Connect service configuration values
     */
    kafkaConnect?: pulumi.Input<inputs.ServiceIntegrationKafkaConnectUserConfigKafkaConnect>;
}

export interface ServiceIntegrationKafkaConnectUserConfigKafkaConnect {
    configStorageTopic?: pulumi.Input<string>;
    groupId?: pulumi.Input<string>;
    offsetStorageTopic?: pulumi.Input<string>;
    statusStorageTopic?: pulumi.Input<string>;
}

export interface ServiceIntegrationKafkaLogsUserConfig {
    /**
     * Topic name
     */
    kafkaTopic?: pulumi.Input<string>;
}

export interface ServiceIntegrationKafkaMirrormakerUserConfig {
    /**
     * Kafka cluster alias
     */
    clusterAlias?: pulumi.Input<string>;
    /**
     * Kafka MirrorMaker configuration values
     */
    kafkaMirrormaker?: pulumi.Input<inputs.ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker>;
}

export interface ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker {
    consumerFetchMinBytes?: pulumi.Input<string>;
    producerBatchSize?: pulumi.Input<string>;
    producerBufferMemory?: pulumi.Input<string>;
    producerLingerMs?: pulumi.Input<string>;
    producerMaxRequestSize?: pulumi.Input<string>;
}

export interface ServiceIntegrationLogsUserConfig {
    /**
     * Elasticsearch index retention limit
     */
    elasticsearchIndexDaysMax?: pulumi.Input<string>;
    /**
     * Elasticsearch index prefix
     */
    elasticsearchIndexPrefix?: pulumi.Input<string>;
}

export interface ServiceIntegrationMetricsUserConfig {
    /**
     * Name of the database where to store metric datapoints. Only affects PostgreSQL destinations. Defaults to 'metrics'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
     */
    database?: pulumi.Input<string>;
    /**
     * Number of days to keep old metrics. Only affects PostgreSQL destinations. Set to 0 for no automatic cleanup. Defaults to 30 days.
     */
    retentionDays?: pulumi.Input<string>;
    /**
     * Name of a user that can be used to read metrics. This will be used for Grafana integration (if enabled) to prevent Grafana users from making undesired changes. Only affects PostgreSQL destinations. Defaults to 'metrics_reader'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
     */
    roUsername?: pulumi.Input<string>;
    /**
     * Configuration options for metrics where source service is MySQL
     */
    sourceMysql?: pulumi.Input<inputs.ServiceIntegrationMetricsUserConfigSourceMysql>;
    /**
     * Name of the user used to write metrics. Only affects PostgreSQL destinations. Defaults to 'metrics_writer'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
     */
    username?: pulumi.Input<string>;
}

export interface ServiceIntegrationMetricsUserConfigSourceMysql {
    telegraf?: pulumi.Input<inputs.ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf>;
}

export interface ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf {
    gatherEventWaits?: pulumi.Input<string>;
    gatherFileEventsStats?: pulumi.Input<string>;
    gatherIndexIoWaits?: pulumi.Input<string>;
    gatherInfoSchemaAutoInc?: pulumi.Input<string>;
    gatherInnodbMetrics?: pulumi.Input<string>;
    gatherPerfEventsStatements?: pulumi.Input<string>;
    gatherProcessList?: pulumi.Input<string>;
    gatherSlaveStatus?: pulumi.Input<string>;
    gatherTableIoWaits?: pulumi.Input<string>;
    gatherTableLockWaits?: pulumi.Input<string>;
    gatherTableSchema?: pulumi.Input<string>;
    perfEventsStatementsDigestTextLimit?: pulumi.Input<string>;
    perfEventsStatementsLimit?: pulumi.Input<string>;
    perfEventsStatementsTimeLimit?: pulumi.Input<string>;
}

export interface ServiceIntegrationMirrormakerUserConfig {
    /**
     * Mirrormaker topic whitelist
     */
    mirrormakerWhitelist?: pulumi.Input<string>;
}
