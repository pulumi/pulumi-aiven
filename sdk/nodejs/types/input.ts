// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccountAuthenticationSamlFieldMapping {
    /**
     * Field name for user email
     */
    email?: pulumi.Input<string>;
    /**
     * Field name for user's first name
     */
    firstName?: pulumi.Input<string>;
    /**
     * Field name for user's identity. This field must always exist in responses, and must be immutable and unique. Contents of this field are used to identify the user. Using user ID (such as unix user id) is highly recommended, as email address may change, requiring relinking user to Aiven user.
     */
    identity?: pulumi.Input<string>;
    /**
     * Field name for user's last name
     */
    lastName?: pulumi.Input<string>;
    /**
     * Field name for user's full name. If specified, first*name and last*name mappings are ignored
     */
    realName?: pulumi.Input<string>;
}

export interface CassandraCassandra {
}

export interface CassandraCassandraUserConfig {
    /**
     * Additional Cloud Regions for Backup Replication
     */
    additionalBackupRegions?: pulumi.Input<string>;
    /**
     * cassandra configuration values
     */
    cassandra?: pulumi.Input<inputs.CassandraCassandraUserConfigCassandra>;
    /**
     * Cassandra major version
     */
    cassandraVersion?: pulumi.Input<string>;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    ipFilterObjects?: pulumi.Input<pulumi.Input<inputs.CassandraCassandraUserConfigIpFilterObject>[]>;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Sets the service into migration mode enabling the sstableloader utility to be used to upload Cassandra data files. Available only on service create.
     */
    migrateSstableloader?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: pulumi.Input<inputs.CassandraCassandraUserConfigPrivateAccess>;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: pulumi.Input<inputs.CassandraCassandraUserConfigPublicAccess>;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: pulumi.Input<string>;
    /**
     * When bootstrapping, instead of creating a new Cassandra cluster try to join an existing one from another service. Can only be set on service creation.
     */
    serviceToJoinWith?: pulumi.Input<string>;
    /**
     * Use static public IP addresses
     */
    staticIps?: pulumi.Input<string>;
}

export interface CassandraCassandraUserConfigCassandra {
    batchSizeFailThresholdInKb?: pulumi.Input<string>;
    batchSizeWarnThresholdInKb?: pulumi.Input<string>;
    datacenter?: pulumi.Input<string>;
}

export interface CassandraCassandraUserConfigIpFilterObject {
    description?: pulumi.Input<string>;
    network?: pulumi.Input<string>;
}

export interface CassandraCassandraUserConfigPrivateAccess {
    prometheus?: pulumi.Input<string>;
}

export interface CassandraCassandraUserConfigPublicAccess {
    prometheus?: pulumi.Input<string>;
}

export interface CassandraComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface CassandraServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface CassandraTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface ClickhouseClickhouse {
}

export interface ClickhouseClickhouseUserConfig {
    /**
     * Additional Cloud Regions for Backup Replication
     */
    additionalBackupRegions?: pulumi.Input<string>;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    ipFilterObjects?: pulumi.Input<pulumi.Input<inputs.ClickhouseClickhouseUserConfigIpFilterObject>[]>;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: pulumi.Input<string>;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: pulumi.Input<string>;
}

export interface ClickhouseClickhouseUserConfigIpFilterObject {
    description?: pulumi.Input<string>;
    network?: pulumi.Input<string>;
}

export interface ClickhouseComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface ClickhouseGrantPrivilegeGrant {
    /**
     * The column that the grant refers to. This property cannot be changed, doing so forces recreation of the resource.
     */
    column?: pulumi.Input<string>;
    /**
     * The database that the grant refers to. To set up proper dependencies please refer to this variable as a reference. This property cannot be changed, doing so forces recreation of the resource.
     */
    database: pulumi.Input<string>;
    /**
     * The privilege to grant, i.e. 'INSERT', 'SELECT', etc. This property cannot be changed, doing so forces recreation of the resource.
     */
    privilege?: pulumi.Input<string>;
    /**
     * The table that the grant refers to. This property cannot be changed, doing so forces recreation of the resource.
     */
    table?: pulumi.Input<string>;
    /**
     * If true then the grantee gets the ability to grant the privileges he received too This property cannot be changed, doing so forces recreation of the resource.
     */
    withGrant?: pulumi.Input<boolean>;
}

export interface ClickhouseGrantRoleGrant {
    /**
     * The role that is to be granted. To set up proper dependencies please refer to this variable as a reference. This property cannot be changed, doing so forces recreation of the resource.
     */
    role?: pulumi.Input<string>;
}

export interface ClickhouseServiceIntegration {
    /**
     * Type of the service integration. The only supported values at the moment are `clickhouseKafka` and `clickhousePostgresql`.
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface ClickhouseTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface FlinkApplicationVersionSink {
    /**
     * The CREATE TABLE statement
     */
    createTable: pulumi.Input<string>;
    /**
     * The integration ID
     */
    integrationId?: pulumi.Input<string>;
}

export interface FlinkApplicationVersionSource {
    /**
     * The CREATE TABLE statement
     */
    createTable: pulumi.Input<string>;
    /**
     * The integration ID
     */
    integrationId?: pulumi.Input<string>;
}

export interface FlinkComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface FlinkFlink {
    /**
     * Host and Port of a Flink server
     */
    hostPorts?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface FlinkFlinkUserConfig {
    /**
     * Additional Cloud Regions for Backup Replication
     */
    additionalBackupRegions?: pulumi.Input<string>;
    /**
     * Checkpointing is Flink’s primary fault-tolerance mechanism, wherein a snapshot of your job’s state persisted periodically to some durable location. In the case of failure, Flink will restart from the most recent checkpoint and resume processing. A jobs checkpoint interval configures how often Flink will take these snapshots.
     */
    executionCheckpointingIntervalMs?: pulumi.Input<string>;
    /**
     * The time after which a checkpoint-in-progress is aborted, if it did not complete by then.
     */
    executionCheckpointingTimeoutMs?: pulumi.Input<string>;
    /**
     * Flink major version
     */
    flinkVersion?: pulumi.Input<string>;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    ipFilterObjects?: pulumi.Input<pulumi.Input<inputs.FlinkFlinkUserConfigIpFilterObject>[]>;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Task slots per node. For a 3 node plan, total number of task slots is 3x this value
     */
    numberOfTaskSlots?: pulumi.Input<string>;
    /**
     * How many parallel task slots each new job is assigned. Unless you understand how Flink parallel dataflows work, please leave this at 1. Please do not set this value higher than (total number of nodes x number*of*task_slots), or every new job created will fail.
     */
    parallelismDefault?: pulumi.Input<string>;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: pulumi.Input<inputs.FlinkFlinkUserConfigPrivatelinkAccess>;
    /**
     * failure-rate (default): Restarts the job after failure, but when failure rate (failures per time interval) is exceeded, the job eventually fails. Restart strategy waits a fixed amount of time between attempts.fixed-delay: Attempts to restart the job a given number of times before it fails. Restart strategy waits a fixed amount of time between attempts. exponential-delay: Attempts to restart the job infinitely, with increasing delay up to the maximum delay. The job never fails. none: The job fails directly and no restart is attempted.
     */
    restartStrategy?: pulumi.Input<string>;
    /**
     * Delay between two consecutive restart attempts if restart-strategy has been set to fixed-delay or failure-rate. Delaying the retries can be helpful when the program interacts with external systems where for example connections or pending transactions should reach a timeout before re-execution is attempted.
     */
    restartStrategyDelaySec?: pulumi.Input<string>;
    /**
     * Time interval for measuring failure rate if restart-strategy has been set to failure-rate. Specified in minutes.
     */
    restartStrategyFailureRateIntervalMin?: pulumi.Input<string>;
    /**
     * The number of times that Flink retries the execution before the job is declared as failed if restart-strategy has been set to fixed-delay or failure-rate.
     */
    restartStrategyMaxFailures?: pulumi.Input<string>;
}

export interface FlinkFlinkUserConfigIpFilterObject {
    description?: pulumi.Input<string>;
    network?: pulumi.Input<string>;
}

export interface FlinkFlinkUserConfigPrivatelinkAccess {
    /**
     * Flink server provided values
     */
    flink?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface FlinkJobTableUpsertKafka {
    /**
     * Defines the columns from the SQL schema of the data table that are considered keys in the Kafka messages. This property cannot be changed, doing so forces recreation of the resource.
     */
    keyFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Sets the format that is used to convert the key part of Kafka messages. The possible values are `avro`, `avro-confluent`, `debezium-avro-confluent`, `debezium-json` and `json`. This property cannot be changed, doing so forces recreation of the resource.
     */
    keyFormat?: pulumi.Input<string>;
    /**
     * Controls the startup method for the Kafka consumer that Aiven for Apache Flink is using. The possible values are `earliest-offset`, `latest-offset`, `group-offsets` and `timestamp`. This property cannot be changed, doing so forces recreation of the resource.
     */
    scanStartupMode?: pulumi.Input<string>;
    /**
     * Topic name This property cannot be changed, doing so forces recreation of the resource.
     */
    topic?: pulumi.Input<string>;
    /**
     * Controls how key columns are handled in the message value. Select ALL to include the physical columns of the table schema in the message value. Select EXCEPT_KEY to exclude the physical columns of the table schema from the message value. This is the default for upsert Kafka connectors. The possible values are `[ALL EXCEPT_KEY]`. This property cannot be changed, doing so forces recreation of the resource.
     */
    valueFieldsInclude?: pulumi.Input<string>;
    /**
     * Sets the format that is used to convert the value part of Kafka messages. The possible values are `avro`, `avro-confluent`, `debezium-avro-confluent`, `debezium-json` and `json`. This property cannot be changed, doing so forces recreation of the resource.
     */
    valueFormat?: pulumi.Input<string>;
}

export interface FlinkServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface FlinkTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface GrafanaComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface GrafanaGrafana {
}

export interface GrafanaGrafanaUserConfig {
    additionalBackupRegions?: pulumi.Input<string>;
    alertingEnabled?: pulumi.Input<string>;
    alertingErrorOrTimeout?: pulumi.Input<string>;
    alertingMaxAnnotationsToKeep?: pulumi.Input<string>;
    alertingNodataOrNullvalues?: pulumi.Input<string>;
    allowEmbedding?: pulumi.Input<string>;
    authAzuread?: pulumi.Input<inputs.GrafanaGrafanaUserConfigAuthAzuread>;
    authBasicEnabled?: pulumi.Input<string>;
    authGenericOauth?: pulumi.Input<inputs.GrafanaGrafanaUserConfigAuthGenericOauth>;
    authGithub?: pulumi.Input<inputs.GrafanaGrafanaUserConfigAuthGithub>;
    authGitlab?: pulumi.Input<inputs.GrafanaGrafanaUserConfigAuthGitlab>;
    authGoogle?: pulumi.Input<inputs.GrafanaGrafanaUserConfigAuthGoogle>;
    cookieSamesite?: pulumi.Input<string>;
    customDomain?: pulumi.Input<string>;
    dashboardPreviewsEnabled?: pulumi.Input<string>;
    dashboardsMinRefreshInterval?: pulumi.Input<string>;
    dashboardsVersionsToKeep?: pulumi.Input<string>;
    dataproxySendUserHeader?: pulumi.Input<string>;
    dataproxyTimeout?: pulumi.Input<string>;
    dateFormats?: pulumi.Input<inputs.GrafanaGrafanaUserConfigDateFormats>;
    disableGravatar?: pulumi.Input<string>;
    editorsCanAdmin?: pulumi.Input<string>;
    externalImageStorage?: pulumi.Input<inputs.GrafanaGrafanaUserConfigExternalImageStorage>;
    googleAnalyticsUaId?: pulumi.Input<string>;
    ipFilterObjects?: pulumi.Input<pulumi.Input<inputs.GrafanaGrafanaUserConfigIpFilterObject>[]>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    metricsEnabled?: pulumi.Input<string>;
    privateAccess?: pulumi.Input<inputs.GrafanaGrafanaUserConfigPrivateAccess>;
    privatelinkAccess?: pulumi.Input<inputs.GrafanaGrafanaUserConfigPrivatelinkAccess>;
    projectToForkFrom?: pulumi.Input<string>;
    publicAccess?: pulumi.Input<inputs.GrafanaGrafanaUserConfigPublicAccess>;
    recoveryBasebackupName?: pulumi.Input<string>;
    serviceToForkFrom?: pulumi.Input<string>;
    smtpServer?: pulumi.Input<inputs.GrafanaGrafanaUserConfigSmtpServer>;
    staticIps?: pulumi.Input<string>;
    userAutoAssignOrg?: pulumi.Input<string>;
    userAutoAssignOrgRole?: pulumi.Input<string>;
    viewersCanEdit?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigAuthAzuread {
    allowSignUp?: pulumi.Input<string>;
    allowedDomains?: pulumi.Input<pulumi.Input<string>[]>;
    allowedGroups?: pulumi.Input<pulumi.Input<string>[]>;
    authUrl?: pulumi.Input<string>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    tokenUrl?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: pulumi.Input<string>;
    allowedDomains?: pulumi.Input<pulumi.Input<string>[]>;
    allowedOrganizations?: pulumi.Input<pulumi.Input<string>[]>;
    apiUrl?: pulumi.Input<string>;
    authUrl?: pulumi.Input<string>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    scopes?: pulumi.Input<pulumi.Input<string>[]>;
    tokenUrl?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigAuthGithub {
    allowSignUp?: pulumi.Input<string>;
    allowedOrganizations?: pulumi.Input<pulumi.Input<string>[]>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    teamIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface GrafanaGrafanaUserConfigAuthGitlab {
    allowSignUp?: pulumi.Input<string>;
    allowedGroups?: pulumi.Input<pulumi.Input<string>[]>;
    apiUrl?: pulumi.Input<string>;
    authUrl?: pulumi.Input<string>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    tokenUrl?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigAuthGoogle {
    allowSignUp?: pulumi.Input<string>;
    allowedDomains?: pulumi.Input<pulumi.Input<string>[]>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigDateFormats {
    defaultTimezone?: pulumi.Input<string>;
    fullDate?: pulumi.Input<string>;
    intervalDay?: pulumi.Input<string>;
    intervalHour?: pulumi.Input<string>;
    intervalMinute?: pulumi.Input<string>;
    intervalMonth?: pulumi.Input<string>;
    intervalSecond?: pulumi.Input<string>;
    intervalYear?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigExternalImageStorage {
    accessKey?: pulumi.Input<string>;
    bucketUrl?: pulumi.Input<string>;
    provider?: pulumi.Input<string>;
    secretKey?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigIpFilterObject {
    description?: pulumi.Input<string>;
    network?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigPrivateAccess {
    grafana?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigPrivatelinkAccess {
    grafana?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigPublicAccess {
    grafana?: pulumi.Input<string>;
}

export interface GrafanaGrafanaUserConfigSmtpServer {
    fromAddress?: pulumi.Input<string>;
    fromName?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    skipVerify?: pulumi.Input<string>;
    starttlsPolicy?: pulumi.Input<string>;
    username?: pulumi.Input<string>;
}

export interface GrafanaServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface GrafanaTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface InfluxDbComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdb {
    databaseName?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdbUserConfig {
    /**
     * Additional Cloud Regions for Backup Replication
     */
    additionalBackupRegions?: pulumi.Input<string>;
    /**
     * Serve the web frontend using a custom CNAME pointing to the Aiven DNS name
     */
    customDomain?: pulumi.Input<string>;
    /**
     * influxdb.conf configuration values
     */
    influxdb?: pulumi.Input<inputs.InfluxDbInfluxdbUserConfigInfluxdb>;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    ipFilterObjects?: pulumi.Input<pulumi.Input<inputs.InfluxDbInfluxdbUserConfigIpFilterObject>[]>;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: pulumi.Input<inputs.InfluxDbInfluxdbUserConfigPrivateAccess>;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: pulumi.Input<inputs.InfluxDbInfluxdbUserConfigPrivatelinkAccess>;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: pulumi.Input<inputs.InfluxDbInfluxdbUserConfigPublicAccess>;
    /**
     * Name of the basebackup to restore in forked service
     */
    recoveryBasebackupName?: pulumi.Input<string>;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: pulumi.Input<string>;
    /**
     * Use static public IP addresses
     */
    staticIps?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdbUserConfigInfluxdb {
    logQueriesAfter?: pulumi.Input<string>;
    maxConnectionLimit?: pulumi.Input<string>;
    maxRowLimit?: pulumi.Input<string>;
    maxSelectBuckets?: pulumi.Input<string>;
    maxSelectPoint?: pulumi.Input<string>;
    queryTimeout?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdbUserConfigIpFilterObject {
    description?: pulumi.Input<string>;
    network?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdbUserConfigPrivateAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdbUserConfigPrivatelinkAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: pulumi.Input<string>;
}

export interface InfluxDbInfluxdbUserConfigPublicAccess {
    /**
     * InfluxDB server provided values
     */
    influxdb?: pulumi.Input<string>;
}

export interface InfluxDbServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface InfluxDbTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface KafkaComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface KafkaConnectComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface KafkaConnectKafkaConnect {
}

export interface KafkaConnectKafkaConnectUserConfig {
    additionalBackupRegions?: pulumi.Input<string>;
    ipFilterObjects?: pulumi.Input<pulumi.Input<inputs.KafkaConnectKafkaConnectUserConfigIpFilterObject>[]>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    kafkaConnect?: pulumi.Input<inputs.KafkaConnectKafkaConnectUserConfigKafkaConnect>;
    privateAccess?: pulumi.Input<inputs.KafkaConnectKafkaConnectUserConfigPrivateAccess>;
    privatelinkAccess?: pulumi.Input<inputs.KafkaConnectKafkaConnectUserConfigPrivatelinkAccess>;
    publicAccess?: pulumi.Input<inputs.KafkaConnectKafkaConnectUserConfigPublicAccess>;
    staticIps?: pulumi.Input<string>;
}

export interface KafkaConnectKafkaConnectUserConfigIpFilterObject {
    description?: pulumi.Input<string>;
    network?: pulumi.Input<string>;
}

export interface KafkaConnectKafkaConnectUserConfigKafkaConnect {
    connectorClientConfigOverridePolicy?: pulumi.Input<string>;
    consumerAutoOffsetReset?: pulumi.Input<string>;
    consumerFetchMaxBytes?: pulumi.Input<string>;
    consumerIsolationLevel?: pulumi.Input<string>;
    consumerMaxPartitionFetchBytes?: pulumi.Input<string>;
    consumerMaxPollIntervalMs?: pulumi.Input<string>;
    consumerMaxPollRecords?: pulumi.Input<string>;
    offsetFlushIntervalMs?: pulumi.Input<string>;
    offsetFlushTimeoutMs?: pulumi.Input<string>;
    producerCompressionType?: pulumi.Input<string>;
    producerMaxRequestSize?: pulumi.Input<string>;
    sessionTimeoutMs?: pulumi.Input<string>;
}

export interface KafkaConnectKafkaConnectUserConfigPrivateAccess {
    kafkaConnect?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface KafkaConnectKafkaConnectUserConfigPrivatelinkAccess {
    jolokia?: pulumi.Input<string>;
    kafkaConnect?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface KafkaConnectKafkaConnectUserConfigPublicAccess {
    kafkaConnect?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface KafkaConnectServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface KafkaConnectTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface KafkaConnectorTask {
    connector?: pulumi.Input<string>;
    /**
     * List of tasks of a connector.
     */
    task?: pulumi.Input<number>;
}

export interface KafkaKafka {
    /**
     * The Kafka client certificate
     */
    accessCert?: pulumi.Input<string>;
    /**
     * The Kafka client certificate key
     */
    accessKey?: pulumi.Input<string>;
    /**
     * The Kafka Connect URI, if any
     */
    connectUri?: pulumi.Input<string>;
    /**
     * The Kafka REST URI, if any
     */
    restUri?: pulumi.Input<string>;
    /**
     * The Schema Registry URI, if any
     */
    schemaRegistryUri?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfig {
    /**
     * Additional Cloud Regions for Backup Replication
     */
    additionalBackupRegions?: pulumi.Input<string>;
    /**
     * Serve the web frontend using a custom CNAME pointing to the Aiven DNS name
     */
    customDomain?: pulumi.Input<string>;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    ipFilterObjects?: pulumi.Input<pulumi.Input<inputs.KafkaKafkaUserConfigIpFilterObject>[]>;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Kafka broker configuration values
     */
    kafka?: pulumi.Input<inputs.KafkaKafkaUserConfigKafka>;
    /**
     * Kafka authentication methods
     */
    kafkaAuthenticationMethods?: pulumi.Input<inputs.KafkaKafkaUserConfigKafkaAuthenticationMethods>;
    /**
     * Enable Kafka Connect service
     */
    kafkaConnect?: pulumi.Input<string>;
    /**
     * Kafka Connect configuration values
     */
    kafkaConnectConfig?: pulumi.Input<inputs.KafkaKafkaUserConfigKafkaConnectConfig>;
    /**
     * Enable Kafka-REST service
     */
    kafkaRest?: pulumi.Input<string>;
    /**
     * Kafka REST configuration
     */
    kafkaRestConfig?: pulumi.Input<inputs.KafkaKafkaUserConfigKafkaRestConfig>;
    /**
     * Kafka major version
     */
    kafkaVersion?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: pulumi.Input<inputs.KafkaKafkaUserConfigPrivateAccess>;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: pulumi.Input<inputs.KafkaKafkaUserConfigPrivatelinkAccess>;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: pulumi.Input<inputs.KafkaKafkaUserConfigPublicAccess>;
    /**
     * Enable Schema-Registry service
     */
    schemaRegistry?: pulumi.Input<string>;
    /**
     * Schema Registry configuration
     */
    schemaRegistryConfig?: pulumi.Input<inputs.KafkaKafkaUserConfigSchemaRegistryConfig>;
    /**
     * Use static public IP addresses
     */
    staticIps?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigIpFilterObject {
    description?: pulumi.Input<string>;
    network?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigKafka {
    autoCreateTopicsEnable?: pulumi.Input<string>;
    compressionType?: pulumi.Input<string>;
    connectionsMaxIdleMs?: pulumi.Input<string>;
    defaultReplicationFactor?: pulumi.Input<string>;
    groupInitialRebalanceDelayMs?: pulumi.Input<string>;
    groupMaxSessionTimeoutMs?: pulumi.Input<string>;
    groupMinSessionTimeoutMs?: pulumi.Input<string>;
    logCleanerDeleteRetentionMs?: pulumi.Input<string>;
    logCleanerMaxCompactionLagMs?: pulumi.Input<string>;
    logCleanerMinCleanableRatio?: pulumi.Input<string>;
    logCleanerMinCompactionLagMs?: pulumi.Input<string>;
    logCleanupPolicy?: pulumi.Input<string>;
    logFlushIntervalMessages?: pulumi.Input<string>;
    logFlushIntervalMs?: pulumi.Input<string>;
    logIndexIntervalBytes?: pulumi.Input<string>;
    logIndexSizeMaxBytes?: pulumi.Input<string>;
    logMessageDownconversionEnable?: pulumi.Input<string>;
    logMessageTimestampDifferenceMaxMs?: pulumi.Input<string>;
    logMessageTimestampType?: pulumi.Input<string>;
    logPreallocate?: pulumi.Input<string>;
    logRetentionBytes?: pulumi.Input<string>;
    logRetentionHours?: pulumi.Input<string>;
    logRetentionMs?: pulumi.Input<string>;
    logRollJitterMs?: pulumi.Input<string>;
    logRollMs?: pulumi.Input<string>;
    logSegmentBytes?: pulumi.Input<string>;
    logSegmentDeleteDelayMs?: pulumi.Input<string>;
    maxConnectionsPerIp?: pulumi.Input<string>;
    maxIncrementalFetchSessionCacheSlots?: pulumi.Input<string>;
    messageMaxBytes?: pulumi.Input<string>;
    minInsyncReplicas?: pulumi.Input<string>;
    numPartitions?: pulumi.Input<string>;
    offsetsRetentionMinutes?: pulumi.Input<string>;
    producerPurgatoryPurgeIntervalRequests?: pulumi.Input<string>;
    replicaFetchMaxBytes?: pulumi.Input<string>;
    replicaFetchResponseMaxBytes?: pulumi.Input<string>;
    socketRequestMaxBytes?: pulumi.Input<string>;
    transactionRemoveExpiredTransactionCleanupIntervalMs?: pulumi.Input<string>;
    transactionStateLogSegmentBytes?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: pulumi.Input<string>;
    sasl?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigKafkaConnectConfig {
    connectorClientConfigOverridePolicy?: pulumi.Input<string>;
    consumerAutoOffsetReset?: pulumi.Input<string>;
    consumerFetchMaxBytes?: pulumi.Input<string>;
    consumerIsolationLevel?: pulumi.Input<string>;
    consumerMaxPartitionFetchBytes?: pulumi.Input<string>;
    consumerMaxPollIntervalMs?: pulumi.Input<string>;
    consumerMaxPollRecords?: pulumi.Input<string>;
    offsetFlushIntervalMs?: pulumi.Input<string>;
    offsetFlushTimeoutMs?: pulumi.Input<string>;
    producerCompressionType?: pulumi.Input<string>;
    producerMaxRequestSize?: pulumi.Input<string>;
    sessionTimeoutMs?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: pulumi.Input<string>;
    consumerRequestMaxBytes?: pulumi.Input<string>;
    consumerRequestTimeoutMs?: pulumi.Input<string>;
    producerAcks?: pulumi.Input<string>;
    producerLingerMs?: pulumi.Input<string>;
    simpleconsumerPoolSizeMax?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigPrivateAccess {
    prometheus?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigPrivatelinkAccess {
    jolokia?: pulumi.Input<string>;
    /**
     * Kafka server provided values
     */
    kafka?: pulumi.Input<string>;
    kafkaConnect?: pulumi.Input<string>;
    kafkaRest?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
    schemaRegistry?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigPublicAccess {
    /**
     * Kafka server provided values
     */
    kafka?: pulumi.Input<string>;
    kafkaConnect?: pulumi.Input<string>;
    kafkaRest?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
    schemaRegistry?: pulumi.Input<string>;
}

export interface KafkaKafkaUserConfigSchemaRegistryConfig {
    leaderEligibility?: pulumi.Input<string>;
    topicName?: pulumi.Input<string>;
}

export interface KafkaMirrorMakerComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface KafkaMirrorMakerKafkaMirrormaker {
}

export interface KafkaMirrorMakerKafkaMirrormakerUserConfig {
    additionalBackupRegions?: pulumi.Input<string>;
    ipFilterObjects?: pulumi.Input<pulumi.Input<inputs.KafkaMirrorMakerKafkaMirrormakerUserConfigIpFilterObject>[]>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    kafkaMirrormaker?: pulumi.Input<inputs.KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker>;
    staticIps?: pulumi.Input<string>;
}

export interface KafkaMirrorMakerKafkaMirrormakerUserConfigIpFilterObject {
    description?: pulumi.Input<string>;
    network?: pulumi.Input<string>;
}

export interface KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker {
    emitCheckpointsEnabled?: pulumi.Input<string>;
    emitCheckpointsIntervalSeconds?: pulumi.Input<string>;
    refreshGroupsEnabled?: pulumi.Input<string>;
    refreshGroupsIntervalSeconds?: pulumi.Input<string>;
    refreshTopicsEnabled?: pulumi.Input<string>;
    refreshTopicsIntervalSeconds?: pulumi.Input<string>;
    syncGroupOffsetsEnabled?: pulumi.Input<string>;
    syncGroupOffsetsIntervalSeconds?: pulumi.Input<string>;
    syncTopicConfigsEnabled?: pulumi.Input<string>;
    tasksMaxPerCpu?: pulumi.Input<string>;
}

export interface KafkaMirrorMakerServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface KafkaMirrorMakerTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface KafkaServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface KafkaTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface KafkaTopicConfig {
    /**
     * cleanup.policy value
     */
    cleanupPolicy?: pulumi.Input<string>;
    /**
     * compression.type value
     */
    compressionType?: pulumi.Input<string>;
    /**
     * delete.retention.ms value
     */
    deleteRetentionMs?: pulumi.Input<string>;
    /**
     * file.delete.delay.ms value
     */
    fileDeleteDelayMs?: pulumi.Input<string>;
    /**
     * flush.messages value
     */
    flushMessages?: pulumi.Input<string>;
    /**
     * flush.ms value
     */
    flushMs?: pulumi.Input<string>;
    /**
     * index.interval.bytes value
     */
    indexIntervalBytes?: pulumi.Input<string>;
    /**
     * max.compaction.lag.ms value
     */
    maxCompactionLagMs?: pulumi.Input<string>;
    /**
     * max.message.bytes value
     */
    maxMessageBytes?: pulumi.Input<string>;
    /**
     * message.downconversion.enable value
     */
    messageDownconversionEnable?: pulumi.Input<string>;
    /**
     * message.format.version value
     */
    messageFormatVersion?: pulumi.Input<string>;
    /**
     * message.timestamp.difference.max.ms value
     */
    messageTimestampDifferenceMaxMs?: pulumi.Input<string>;
    /**
     * message.timestamp.type value
     */
    messageTimestampType?: pulumi.Input<string>;
    /**
     * min.cleanable.dirty.ratio value
     */
    minCleanableDirtyRatio?: pulumi.Input<string>;
    /**
     * min.compaction.lag.ms value
     */
    minCompactionLagMs?: pulumi.Input<string>;
    /**
     * min.insync.replicas value
     */
    minInsyncReplicas?: pulumi.Input<string>;
    /**
     * preallocate value
     */
    preallocate?: pulumi.Input<string>;
    /**
     * retention.bytes value
     */
    retentionBytes?: pulumi.Input<string>;
    /**
     * retention.ms value
     */
    retentionMs?: pulumi.Input<string>;
    /**
     * segment.bytes value
     */
    segmentBytes?: pulumi.Input<string>;
    /**
     * segment.index.bytes value
     */
    segmentIndexBytes?: pulumi.Input<string>;
    /**
     * segment.jitter.ms value
     */
    segmentJitterMs?: pulumi.Input<string>;
    /**
     * segment.ms value
     */
    segmentMs?: pulumi.Input<string>;
    /**
     * unclean.leader.election.enable value
     */
    uncleanLeaderElectionEnable?: pulumi.Input<string>;
}

export interface KafkaTopicTag {
    /**
     * Topic tag key. Maximum Length: `64`.
     */
    key: pulumi.Input<string>;
    /**
     * Topic tag value. Maximum Length: `256`.
     */
    value?: pulumi.Input<string>;
}

export interface M3AggregatorComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface M3AggregatorM3aggregator {
}

export interface M3AggregatorM3aggregatorUserConfig {
    customDomain?: pulumi.Input<string>;
    ipFilterObjects?: pulumi.Input<pulumi.Input<inputs.M3AggregatorM3aggregatorUserConfigIpFilterObject>[]>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    m3Version?: pulumi.Input<string>;
    m3aggregatorVersion?: pulumi.Input<string>;
    staticIps?: pulumi.Input<string>;
}

export interface M3AggregatorM3aggregatorUserConfigIpFilterObject {
    description?: pulumi.Input<string>;
    network?: pulumi.Input<string>;
}

export interface M3AggregatorServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface M3AggregatorTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface M3DbComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface M3DbM3db {
}

export interface M3DbM3dbUserConfig {
    additionalBackupRegions?: pulumi.Input<string>;
    customDomain?: pulumi.Input<string>;
    ipFilterObjects?: pulumi.Input<pulumi.Input<inputs.M3DbM3dbUserConfigIpFilterObject>[]>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    limits?: pulumi.Input<inputs.M3DbM3dbUserConfigLimits>;
    m3Version?: pulumi.Input<string>;
    m3coordinatorEnableGraphiteCarbonIngest?: pulumi.Input<string>;
    m3dbVersion?: pulumi.Input<string>;
    namespaces?: pulumi.Input<pulumi.Input<inputs.M3DbM3dbUserConfigNamespace>[]>;
    privateAccess?: pulumi.Input<inputs.M3DbM3dbUserConfigPrivateAccess>;
    projectToForkFrom?: pulumi.Input<string>;
    publicAccess?: pulumi.Input<inputs.M3DbM3dbUserConfigPublicAccess>;
    rules?: pulumi.Input<inputs.M3DbM3dbUserConfigRules>;
    serviceToForkFrom?: pulumi.Input<string>;
    staticIps?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigIpFilterObject {
    description?: pulumi.Input<string>;
    network?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigLimits {
    maxRecentlyQueriedSeriesBlocks?: pulumi.Input<string>;
    maxRecentlyQueriedSeriesDiskBytesRead?: pulumi.Input<string>;
    maxRecentlyQueriedSeriesLookback?: pulumi.Input<string>;
    queryDocs?: pulumi.Input<string>;
    queryRequireExhaustive?: pulumi.Input<string>;
    querySeries?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigNamespace {
    name?: pulumi.Input<string>;
    options?: pulumi.Input<inputs.M3DbM3dbUserConfigNamespaceOptions>;
    resolution?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigNamespaceOptions {
    retentionOptions?: pulumi.Input<inputs.M3DbM3dbUserConfigNamespaceOptionsRetentionOptions>;
    snapshotEnabled?: pulumi.Input<string>;
    writesToCommitlog?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigNamespaceOptionsRetentionOptions {
    blockDataExpiryDuration?: pulumi.Input<string>;
    blocksizeDuration?: pulumi.Input<string>;
    bufferFutureDuration?: pulumi.Input<string>;
    bufferPastDuration?: pulumi.Input<string>;
    retentionPeriodDuration?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigPrivateAccess {
    m3coordinator?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigPublicAccess {
    m3coordinator?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigRules {
    mappings?: pulumi.Input<pulumi.Input<inputs.M3DbM3dbUserConfigRulesMapping>[]>;
}

export interface M3DbM3dbUserConfigRulesMapping {
    aggregations?: pulumi.Input<pulumi.Input<string>[]>;
    drop?: pulumi.Input<string>;
    filter?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    namespaces?: pulumi.Input<pulumi.Input<string>[]>;
    namespacesObjects?: pulumi.Input<pulumi.Input<inputs.M3DbM3dbUserConfigRulesMappingNamespacesObject>[]>;
    tags?: pulumi.Input<pulumi.Input<inputs.M3DbM3dbUserConfigRulesMappingTag>[]>;
}

export interface M3DbM3dbUserConfigRulesMappingNamespacesObject {
    resolution?: pulumi.Input<string>;
    retention?: pulumi.Input<string>;
}

export interface M3DbM3dbUserConfigRulesMappingTag {
    name?: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface M3DbServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface M3DbTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface MySqlComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface MySqlMysql {
}

export interface MySqlMysqlUserConfig {
    additionalBackupRegions?: pulumi.Input<string>;
    adminPassword?: pulumi.Input<string>;
    adminUsername?: pulumi.Input<string>;
    backupHour?: pulumi.Input<string>;
    backupMinute?: pulumi.Input<string>;
    binlogRetentionPeriod?: pulumi.Input<string>;
    ipFilterObjects?: pulumi.Input<pulumi.Input<inputs.MySqlMysqlUserConfigIpFilterObject>[]>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    migration?: pulumi.Input<inputs.MySqlMysqlUserConfigMigration>;
    mysql?: pulumi.Input<inputs.MySqlMysqlUserConfigMysql>;
    mysqlVersion?: pulumi.Input<string>;
    privateAccess?: pulumi.Input<inputs.MySqlMysqlUserConfigPrivateAccess>;
    privatelinkAccess?: pulumi.Input<inputs.MySqlMysqlUserConfigPrivatelinkAccess>;
    projectToForkFrom?: pulumi.Input<string>;
    publicAccess?: pulumi.Input<inputs.MySqlMysqlUserConfigPublicAccess>;
    recoveryTargetTime?: pulumi.Input<string>;
    serviceToForkFrom?: pulumi.Input<string>;
    staticIps?: pulumi.Input<string>;
}

export interface MySqlMysqlUserConfigIpFilterObject {
    description?: pulumi.Input<string>;
    network?: pulumi.Input<string>;
}

export interface MySqlMysqlUserConfigMigration {
    dbname?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    ignoreDbs?: pulumi.Input<string>;
    method?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    ssl?: pulumi.Input<string>;
    username?: pulumi.Input<string>;
}

export interface MySqlMysqlUserConfigMysql {
    connectTimeout?: pulumi.Input<string>;
    defaultTimeZone?: pulumi.Input<string>;
    groupConcatMaxLen?: pulumi.Input<string>;
    informationSchemaStatsExpiry?: pulumi.Input<string>;
    innodbChangeBufferMaxSize?: pulumi.Input<string>;
    innodbFlushNeighbors?: pulumi.Input<string>;
    innodbFtMinTokenSize?: pulumi.Input<string>;
    innodbFtServerStopwordTable?: pulumi.Input<string>;
    innodbLockWaitTimeout?: pulumi.Input<string>;
    innodbLogBufferSize?: pulumi.Input<string>;
    innodbOnlineAlterLogMaxSize?: pulumi.Input<string>;
    innodbPrintAllDeadlocks?: pulumi.Input<string>;
    innodbReadIoThreads?: pulumi.Input<string>;
    innodbRollbackOnTimeout?: pulumi.Input<string>;
    innodbThreadConcurrency?: pulumi.Input<string>;
    innodbWriteIoThreads?: pulumi.Input<string>;
    interactiveTimeout?: pulumi.Input<string>;
    internalTmpMemStorageEngine?: pulumi.Input<string>;
    longQueryTime?: pulumi.Input<string>;
    maxAllowedPacket?: pulumi.Input<string>;
    maxHeapTableSize?: pulumi.Input<string>;
    netBufferLength?: pulumi.Input<string>;
    netReadTimeout?: pulumi.Input<string>;
    netWriteTimeout?: pulumi.Input<string>;
    slowQueryLog?: pulumi.Input<string>;
    sortBufferSize?: pulumi.Input<string>;
    sqlMode?: pulumi.Input<string>;
    sqlRequirePrimaryKey?: pulumi.Input<string>;
    tmpTableSize?: pulumi.Input<string>;
    waitTimeout?: pulumi.Input<string>;
}

export interface MySqlMysqlUserConfigPrivateAccess {
    mysql?: pulumi.Input<string>;
    mysqlx?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface MySqlMysqlUserConfigPrivatelinkAccess {
    mysql?: pulumi.Input<string>;
    mysqlx?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface MySqlMysqlUserConfigPublicAccess {
    mysql?: pulumi.Input<string>;
    mysqlx?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface MySqlServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface MySqlTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface OpenSearchComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface OpenSearchOpensearch {
    opensearchDashboardsUri?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfig {
    /**
     * Additional Cloud Regions for Backup Replication
     */
    additionalBackupRegions?: pulumi.Input<string>;
    /**
     * Serve the web frontend using a custom CNAME pointing to the Aiven DNS name
     */
    customDomain?: pulumi.Input<string>;
    /**
     * @deprecated DEPRECATED: Disable automatic replication factor adjustment for multi-node services. By default, Aiven ensures all indexes are replicated at least to two nodes. Note: Due to potential data loss in case of losing a service node, this setting can no longer be activated.
     */
    disableReplicationFactorAdjustment?: pulumi.Input<string>;
    /**
     * Index patterns
     */
    indexPatterns?: pulumi.Input<pulumi.Input<inputs.OpenSearchOpensearchUserConfigIndexPattern>[]>;
    /**
     * Template settings for all new indexes
     */
    indexTemplate?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigIndexTemplate>;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    ipFilterObjects?: pulumi.Input<pulumi.Input<inputs.OpenSearchOpensearchUserConfigIpFilterObject>[]>;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
     */
    keepIndexRefreshInterval?: pulumi.Input<string>;
    /**
     * @deprecated DEPRECATED: use index_patterns instead
     */
    maxIndexCount?: pulumi.Input<string>;
    /**
     * OpenSearch settings
     */
    opensearch?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigOpensearch>;
    /**
     * OpenSearch Dashboards settings
     */
    opensearchDashboards?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigOpensearchDashboards>;
    /**
     * OpenSearch major version
     */
    opensearchVersion?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigPrivateAccess>;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigPrivatelinkAccess>;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: pulumi.Input<inputs.OpenSearchOpensearchUserConfigPublicAccess>;
    /**
     * Name of the basebackup to restore in forked service
     */
    recoveryBasebackupName?: pulumi.Input<string>;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: pulumi.Input<string>;
    /**
     * Use static public IP addresses
     */
    staticIps?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigIndexPattern {
    maxIndexCount?: pulumi.Input<string>;
    pattern?: pulumi.Input<string>;
    sortingAlgorithm?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigIndexTemplate {
    mappingNestedObjectsLimit?: pulumi.Input<string>;
    numberOfReplicas?: pulumi.Input<string>;
    numberOfShards?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigIpFilterObject {
    description?: pulumi.Input<string>;
    network?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigOpensearch {
    actionAutoCreateIndexEnabled?: pulumi.Input<string>;
    actionDestructiveRequiresName?: pulumi.Input<string>;
    clusterMaxShardsPerNode?: pulumi.Input<string>;
    clusterRoutingAllocationNodeConcurrentRecoveries?: pulumi.Input<string>;
    emailSenderName?: pulumi.Input<string>;
    emailSenderPassword?: pulumi.Input<string>;
    emailSenderUsername?: pulumi.Input<string>;
    httpMaxContentLength?: pulumi.Input<string>;
    httpMaxHeaderSize?: pulumi.Input<string>;
    httpMaxInitialLineLength?: pulumi.Input<string>;
    indicesFielddataCacheSize?: pulumi.Input<string>;
    indicesMemoryIndexBufferSize?: pulumi.Input<string>;
    indicesQueriesCacheSize?: pulumi.Input<string>;
    indicesQueryBoolMaxClauseCount?: pulumi.Input<string>;
    indicesRecoveryMaxBytesPerSec?: pulumi.Input<string>;
    indicesRecoveryMaxConcurrentFileChunks?: pulumi.Input<string>;
    overrideMainResponseVersion?: pulumi.Input<string>;
    reindexRemoteWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    scriptMaxCompilationsRate?: pulumi.Input<string>;
    searchMaxBuckets?: pulumi.Input<string>;
    threadPoolAnalyzeQueueSize?: pulumi.Input<string>;
    threadPoolAnalyzeSize?: pulumi.Input<string>;
    threadPoolForceMergeSize?: pulumi.Input<string>;
    threadPoolGetQueueSize?: pulumi.Input<string>;
    threadPoolGetSize?: pulumi.Input<string>;
    threadPoolSearchQueueSize?: pulumi.Input<string>;
    threadPoolSearchSize?: pulumi.Input<string>;
    threadPoolSearchThrottledQueueSize?: pulumi.Input<string>;
    threadPoolSearchThrottledSize?: pulumi.Input<string>;
    threadPoolWriteQueueSize?: pulumi.Input<string>;
    threadPoolWriteSize?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigOpensearchDashboards {
    enabled?: pulumi.Input<string>;
    maxOldSpaceSize?: pulumi.Input<string>;
    opensearchRequestTimeout?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigPrivateAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: pulumi.Input<string>;
    opensearchDashboards?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigPrivatelinkAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: pulumi.Input<string>;
    opensearchDashboards?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface OpenSearchOpensearchUserConfigPublicAccess {
    /**
     * Opensearch server provided values
     */
    opensearch?: pulumi.Input<string>;
    opensearchDashboards?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface OpenSearchServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface OpenSearchTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface PgComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface PgPg {
    /**
     * Primary PostgreSQL database name
     */
    dbname?: pulumi.Input<string>;
    /**
     * PostgreSQL master node host IP or name
     */
    host?: pulumi.Input<string>;
    /**
     * Connection limit
     */
    maxConnections?: pulumi.Input<number>;
    /**
     * PostgreSQL admin user password
     */
    password?: pulumi.Input<string>;
    /**
     * PostgreSQL port
     */
    port?: pulumi.Input<number>;
    /**
     * PostgreSQL replica URI for services with a replica
     */
    replicaUri?: pulumi.Input<string>;
    /**
     * PostgreSQL sslmode setting (currently always "require")
     */
    sslmode?: pulumi.Input<string>;
    /**
     * PostgreSQL master connection URI
     */
    uri?: pulumi.Input<string>;
    /**
     * PostgreSQL admin user name
     */
    user?: pulumi.Input<string>;
}

export interface PgPgUserConfig {
    /**
     * Additional Cloud Regions for Backup Replication
     */
    additionalBackupRegions?: pulumi.Input<string>;
    /**
     * Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
     */
    adminPassword?: pulumi.Input<string>;
    /**
     * Custom username for admin user. This must be set only when a new service is being created.
     */
    adminUsername?: pulumi.Input<string>;
    /**
     * The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
     */
    backupHour?: pulumi.Input<string>;
    /**
     * The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
     */
    backupMinute?: pulumi.Input<string>;
    /**
     * Register AAAA DNS records for the service, and allow IPv6 packets to service ports
     */
    enableIpv6?: pulumi.Input<string>;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    ipFilterObjects?: pulumi.Input<pulumi.Input<inputs.PgPgUserConfigIpFilterObject>[]>;
    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Migrate data from existing server
     */
    migration?: pulumi.Input<inputs.PgPgUserConfigMigration>;
    /**
     * postgresql.conf configuration values
     */
    pg?: pulumi.Input<inputs.PgPgUserConfigPg>;
    /**
     * @deprecated This setting is deprecated. Use read_replica service integration instead.
     */
    pgReadReplica?: pulumi.Input<string>;
    /**
     * Name of the PG Service from which to fork (deprecated, use service*to*fork_from). This has effect only when a new service is being created.
     */
    pgServiceToForkFrom?: pulumi.Input<string>;
    /**
     * Enable the pg*stat*monitor extension. Enabling this extension will cause the cluster to be restarted.When this extension is enabled, pg*stat*statements results for utility commands are unreliable
     */
    pgStatMonitorEnable?: pulumi.Input<string>;
    /**
     * PostgreSQL major version
     */
    pgVersion?: pulumi.Input<string>;
    /**
     * PGBouncer connection pooling settings
     */
    pgbouncer?: pulumi.Input<inputs.PgPgUserConfigPgbouncer>;
    /**
     * PGLookout settings
     */
    pglookout?: pulumi.Input<inputs.PgPgUserConfigPglookout>;
    /**
     * Allow access to selected service ports from private networks
     */
    privateAccess?: pulumi.Input<inputs.PgPgUserConfigPrivateAccess>;
    /**
     * Allow access to selected service components through Privatelink
     */
    privatelinkAccess?: pulumi.Input<inputs.PgPgUserConfigPrivatelinkAccess>;
    /**
     * Name of another project to fork a service from. This has effect only when a new service is being created.
     */
    projectToForkFrom?: pulumi.Input<string>;
    /**
     * Allow access to selected service ports from the public Internet
     */
    publicAccess?: pulumi.Input<inputs.PgPgUserConfigPublicAccess>;
    /**
     * Recovery target time when forking a service. This has effect only when a new service is being created.
     */
    recoveryTargetTime?: pulumi.Input<string>;
    /**
     * Name of another service to fork from. This has effect only when a new service is being created.
     */
    serviceToForkFrom?: pulumi.Input<string>;
    /**
     * Percentage of total RAM that the database server uses for shared memory buffers. Valid range is 20-60 (float), which corresponds to 20% - 60%. This setting adjusts the sharedBuffers configuration value.
     */
    sharedBuffersPercentage?: pulumi.Input<string>;
    /**
     * Use static public IP addresses
     */
    staticIps?: pulumi.Input<string>;
    /**
     * Synchronous replication type. Note that the service plan also needs to support synchronous replication.
     */
    synchronousReplication?: pulumi.Input<string>;
    /**
     * TimescaleDB extension configuration values
     */
    timescaledb?: pulumi.Input<inputs.PgPgUserConfigTimescaledb>;
    /**
     * Variant of the PostgreSQL service, may affect the features that are exposed by default
     */
    variant?: pulumi.Input<string>;
    /**
     * Sets the maximum amount of memory to be used by a query operation (such as a sort or hash table) before writing to temporary disk files, in MB. Default is 1MB + 0.075% of total RAM (up to 32MB).
     */
    workMem?: pulumi.Input<string>;
}

export interface PgPgUserConfigIpFilterObject {
    description?: pulumi.Input<string>;
    network?: pulumi.Input<string>;
}

export interface PgPgUserConfigMigration {
    dbname?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    ignoreDbs?: pulumi.Input<string>;
    method?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    ssl?: pulumi.Input<string>;
    username?: pulumi.Input<string>;
}

export interface PgPgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: pulumi.Input<string>;
    autovacuumAnalyzeThreshold?: pulumi.Input<string>;
    autovacuumFreezeMaxAge?: pulumi.Input<string>;
    autovacuumMaxWorkers?: pulumi.Input<string>;
    autovacuumNaptime?: pulumi.Input<string>;
    autovacuumVacuumCostDelay?: pulumi.Input<string>;
    autovacuumVacuumCostLimit?: pulumi.Input<string>;
    autovacuumVacuumScaleFactor?: pulumi.Input<string>;
    autovacuumVacuumThreshold?: pulumi.Input<string>;
    bgwriterDelay?: pulumi.Input<string>;
    bgwriterFlushAfter?: pulumi.Input<string>;
    bgwriterLruMaxpages?: pulumi.Input<string>;
    bgwriterLruMultiplier?: pulumi.Input<string>;
    deadlockTimeout?: pulumi.Input<string>;
    defaultToastCompression?: pulumi.Input<string>;
    idleInTransactionSessionTimeout?: pulumi.Input<string>;
    jit?: pulumi.Input<string>;
    logAutovacuumMinDuration?: pulumi.Input<string>;
    logErrorVerbosity?: pulumi.Input<string>;
    logLinePrefix?: pulumi.Input<string>;
    logMinDurationStatement?: pulumi.Input<string>;
    logTempFiles?: pulumi.Input<string>;
    maxFilesPerProcess?: pulumi.Input<string>;
    maxLocksPerTransaction?: pulumi.Input<string>;
    maxLogicalReplicationWorkers?: pulumi.Input<string>;
    maxParallelWorkers?: pulumi.Input<string>;
    maxParallelWorkersPerGather?: pulumi.Input<string>;
    maxPredLocksPerTransaction?: pulumi.Input<string>;
    maxPreparedTransactions?: pulumi.Input<string>;
    maxReplicationSlots?: pulumi.Input<string>;
    maxSlotWalKeepSize?: pulumi.Input<string>;
    maxStackDepth?: pulumi.Input<string>;
    maxStandbyArchiveDelay?: pulumi.Input<string>;
    maxStandbyStreamingDelay?: pulumi.Input<string>;
    maxWalSenders?: pulumi.Input<string>;
    maxWorkerProcesses?: pulumi.Input<string>;
    pgPartmanBgwDotInterval?: pulumi.Input<string>;
    pgPartmanBgwDotRole?: pulumi.Input<string>;
    pgStatStatementsDotTrack?: pulumi.Input<string>;
    tempFileLimit?: pulumi.Input<string>;
    timezone?: pulumi.Input<string>;
    trackActivityQuerySize?: pulumi.Input<string>;
    trackCommitTimestamp?: pulumi.Input<string>;
    trackFunctions?: pulumi.Input<string>;
    trackIoTiming?: pulumi.Input<string>;
    walSenderTimeout?: pulumi.Input<string>;
    walWriterDelay?: pulumi.Input<string>;
}

export interface PgPgUserConfigPgbouncer {
    autodbIdleTimeout?: pulumi.Input<string>;
    autodbMaxDbConnections?: pulumi.Input<string>;
    autodbPoolMode?: pulumi.Input<string>;
    autodbPoolSize?: pulumi.Input<string>;
    ignoreStartupParameters?: pulumi.Input<pulumi.Input<string>[]>;
    minPoolSize?: pulumi.Input<string>;
    serverIdleTimeout?: pulumi.Input<string>;
    serverLifetime?: pulumi.Input<string>;
    serverResetQueryAlways?: pulumi.Input<string>;
}

export interface PgPgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: pulumi.Input<string>;
}

export interface PgPgUserConfigPrivateAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: pulumi.Input<string>;
    pgbouncer?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface PgPgUserConfigPrivatelinkAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: pulumi.Input<string>;
    pgbouncer?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface PgPgUserConfigPublicAccess {
    /**
     * PostgreSQL specific server provided values
     */
    pg?: pulumi.Input<string>;
    pgbouncer?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface PgPgUserConfigTimescaledb {
    maxBackgroundWorkers?: pulumi.Input<string>;
}

export interface PgServiceIntegration {
    /**
     * Type of the service integration. The only supported value at the moment is `readReplica`
     */
    integrationType: pulumi.Input<string>;
    /**
     * Name of the source service
     */
    sourceServiceName: pulumi.Input<string>;
}

export interface PgTag {
    /**
     * Service tag key
     */
    key: pulumi.Input<string>;
    /**
     * Service tag value
     */
    value: pulumi.Input<string>;
}

export interface ProjectTag {
    /**
     * Project tag key
     */
    key: pulumi.Input<string>;
    /**
     * Project tag value
     */
    value: pulumi.Input<string>;
}

export interface RedisComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface RedisRedi {
}

export interface RedisRedisUserConfig {
    additionalBackupRegions?: pulumi.Input<string>;
    ipFilterObjects?: pulumi.Input<pulumi.Input<inputs.RedisRedisUserConfigIpFilterObject>[]>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    migration?: pulumi.Input<inputs.RedisRedisUserConfigMigration>;
    privateAccess?: pulumi.Input<inputs.RedisRedisUserConfigPrivateAccess>;
    privatelinkAccess?: pulumi.Input<inputs.RedisRedisUserConfigPrivatelinkAccess>;
    projectToForkFrom?: pulumi.Input<string>;
    publicAccess?: pulumi.Input<inputs.RedisRedisUserConfigPublicAccess>;
    recoveryBasebackupName?: pulumi.Input<string>;
    redisAclChannelsDefault?: pulumi.Input<string>;
    redisIoThreads?: pulumi.Input<string>;
    redisLfuDecayTime?: pulumi.Input<string>;
    redisLfuLogFactor?: pulumi.Input<string>;
    redisMaxmemoryPolicy?: pulumi.Input<string>;
    redisNotifyKeyspaceEvents?: pulumi.Input<string>;
    redisNumberOfDatabases?: pulumi.Input<string>;
    redisPersistence?: pulumi.Input<string>;
    redisPubsubClientOutputBufferLimit?: pulumi.Input<string>;
    redisSsl?: pulumi.Input<string>;
    redisTimeout?: pulumi.Input<string>;
    serviceToForkFrom?: pulumi.Input<string>;
    staticIps?: pulumi.Input<string>;
}

export interface RedisRedisUserConfigIpFilterObject {
    description?: pulumi.Input<string>;
    network?: pulumi.Input<string>;
}

export interface RedisRedisUserConfigMigration {
    dbname?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    ignoreDbs?: pulumi.Input<string>;
    method?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    ssl?: pulumi.Input<string>;
    username?: pulumi.Input<string>;
}

export interface RedisRedisUserConfigPrivateAccess {
    prometheus?: pulumi.Input<string>;
    redis?: pulumi.Input<string>;
}

export interface RedisRedisUserConfigPrivatelinkAccess {
    prometheus?: pulumi.Input<string>;
    redis?: pulumi.Input<string>;
}

export interface RedisRedisUserConfigPublicAccess {
    prometheus?: pulumi.Input<string>;
    redis?: pulumi.Input<string>;
}

export interface RedisServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface RedisTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface ServiceIntegrationClickhouseKafkaUserConfig {
    /**
     * Tables to create
     */
    tables?: pulumi.Input<pulumi.Input<inputs.ServiceIntegrationClickhouseKafkaUserConfigTable>[]>;
}

export interface ServiceIntegrationClickhouseKafkaUserConfigTable {
    columns?: pulumi.Input<pulumi.Input<inputs.ServiceIntegrationClickhouseKafkaUserConfigTableColumn>[]>;
    dataFormat?: pulumi.Input<string>;
    groupName?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    topics?: pulumi.Input<pulumi.Input<inputs.ServiceIntegrationClickhouseKafkaUserConfigTableTopic>[]>;
}

export interface ServiceIntegrationClickhouseKafkaUserConfigTableColumn {
    name?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface ServiceIntegrationClickhouseKafkaUserConfigTableTopic {
    name?: pulumi.Input<string>;
}

export interface ServiceIntegrationClickhousePostgresqlUserConfig {
    /**
     * Databases to expose
     */
    databases?: pulumi.Input<pulumi.Input<inputs.ServiceIntegrationClickhousePostgresqlUserConfigDatabase>[]>;
}

export interface ServiceIntegrationClickhousePostgresqlUserConfigDatabase {
    database?: pulumi.Input<string>;
    schema?: pulumi.Input<string>;
}

export interface ServiceIntegrationDatadogUserConfig {
    /**
     * Enable Datadog Database Monitoring
     */
    datadogDbmEnabled?: pulumi.Input<string>;
    /**
     * Custom tags provided by user
     */
    datadogTags?: pulumi.Input<pulumi.Input<inputs.ServiceIntegrationDatadogUserConfigDatadogTag>[]>;
    /**
     * List of custom metrics
     */
    excludeConsumerGroups?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of topics to exclude
     */
    excludeTopics?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of custom metrics
     */
    includeConsumerGroups?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of topics to include
     */
    includeTopics?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of custom metrics
     */
    kafkaCustomMetrics?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Maximum number of JMX metrics to send
     */
    maxJmxMetrics?: pulumi.Input<string>;
}

export interface ServiceIntegrationDatadogUserConfigDatadogTag {
    comment?: pulumi.Input<string>;
    tag?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointDatadogUserConfig {
    /**
     * Datadog API key
     */
    datadogApiKey?: pulumi.Input<string>;
    /**
     * Custom tags provided by user
     */
    datadogTags?: pulumi.Input<pulumi.Input<inputs.ServiceIntegrationEndpointDatadogUserConfigDatadogTag>[]>;
    /**
     * Disable consumer group metrics
     */
    disableConsumerStats?: pulumi.Input<string>;
    /**
     * Number of separate instances to fetch kafka consumer statistics with
     */
    kafkaConsumerCheckInstances?: pulumi.Input<string>;
    /**
     * Number of seconds that datadog will wait to get consumer statistics from brokers
     */
    kafkaConsumerStatsTimeout?: pulumi.Input<string>;
    /**
     * Maximum number of partition contexts to send
     */
    maxPartitionContexts?: pulumi.Input<string>;
    /**
     * Datadog intake site. Defaults to datadoghq.com
     */
    site?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointDatadogUserConfigDatadogTag {
    comment?: pulumi.Input<string>;
    tag?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig {
    /**
     * AWS access key. Required permissions are logs:CreateLogGroup, logs:CreateLogStream, logs:PutLogEvents and logs:DescribeLogStreams
     */
    accessKey?: pulumi.Input<string>;
    /**
     * AWS CloudWatch log group name
     */
    logGroupName?: pulumi.Input<string>;
    /**
     * AWS region
     */
    region?: pulumi.Input<string>;
    /**
     * AWS secret key
     */
    secretKey?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig {
    /**
     * AWS access key. Required permissions are cloudwatch:PutMetricData
     */
    accessKey?: pulumi.Input<string>;
    /**
     * AWS CloudWatch Metrics Namespace
     */
    namespace?: pulumi.Input<string>;
    /**
     * AWS region
     */
    region?: pulumi.Input<string>;
    /**
     * AWS secret key
     */
    secretKey?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig {
    /**
     * PEM encoded CA certificate
     */
    ca?: pulumi.Input<string>;
    /**
     * Maximum number of days of logs to keep
     */
    indexDaysMax?: pulumi.Input<string>;
    /**
     * Elasticsearch index prefix
     */
    indexPrefix?: pulumi.Input<string>;
    /**
     * Elasticsearch request timeout limit
     */
    timeout?: pulumi.Input<string>;
    /**
     * Elasticsearch connection URL
     */
    url?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig {
    /**
     * Google Cloud Logging log id
     */
    logId?: pulumi.Input<string>;
    /**
     * GCP project id.
     */
    projectId?: pulumi.Input<string>;
    /**
     * This is a JSON object with the fields documented in https://cloud.google.com/iam/docs/creating-managing-service-account-keys .
     */
    serviceAccountCredentials?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalKafkaUserConfig {
    /**
     * Bootstrap servers
     */
    bootstrapServers?: pulumi.Input<string>;
    /**
     * The list of SASL mechanisms enabled in the Kafka server.
     */
    saslMechanism?: pulumi.Input<string>;
    /**
     * Password for SASL PLAIN mechanism in the Kafka server.
     */
    saslPlainPassword?: pulumi.Input<string>;
    /**
     * Username for SASL PLAIN mechanism in the Kafka server.
     */
    saslPlainUsername?: pulumi.Input<string>;
    /**
     * Security protocol
     */
    securityProtocol?: pulumi.Input<string>;
    /**
     * PEM-encoded CA certificate
     */
    sslCaCert?: pulumi.Input<string>;
    /**
     * PEM-encoded client certificate
     */
    sslClientCert?: pulumi.Input<string>;
    /**
     * PEM-encoded client key
     */
    sslClientKey?: pulumi.Input<string>;
    /**
     * The endpoint identification algorithm to validate server hostname using server certificate.
     */
    sslEndpointIdentificationAlgorithm?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalOpensearchLogsUserConfig {
    /**
     * PEM encoded CA certificate
     */
    ca?: pulumi.Input<string>;
    /**
     * Maximum number of days of logs to keep
     */
    indexDaysMax?: pulumi.Input<string>;
    /**
     * OpenSearch index prefix
     */
    indexPrefix?: pulumi.Input<string>;
    /**
     * OpenSearch request timeout limit
     */
    timeout?: pulumi.Input<string>;
    /**
     * OpenSearch connection URL
     */
    url?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalSchemaRegistryUserConfig {
    /**
     * Authentication method
     */
    authentication?: pulumi.Input<string>;
    /**
     * Basic authentication password
     */
    basicAuthPassword?: pulumi.Input<string>;
    /**
     * Basic authentication user name
     */
    basicAuthUsername?: pulumi.Input<string>;
    /**
     * Schema Registry URL
     */
    url?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointJolokiaUserConfig {
    /**
     * Jolokia basic authentication password
     */
    basicAuthPassword?: pulumi.Input<string>;
    /**
     * Jolokia basic authentication username
     */
    basicAuthUsername?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointPrometheusUserConfig {
    /**
     * Prometheus basic authentication password
     */
    basicAuthPassword?: pulumi.Input<string>;
    /**
     * Prometheus basic authentication username
     */
    basicAuthUsername?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointRsyslogUserConfig {
    /**
     * PEM encoded CA certificate
     */
    ca?: pulumi.Input<string>;
    /**
     * PEM encoded client certificate
     */
    cert?: pulumi.Input<string>;
    /**
     * message format
     */
    format?: pulumi.Input<string>;
    /**
     * PEM encoded client key
     */
    key?: pulumi.Input<string>;
    /**
     * custom syslog message format
     */
    logline?: pulumi.Input<string>;
    /**
     * rsyslog server port
     */
    port?: pulumi.Input<string>;
    /**
     * Structured data block for log message
     */
    sd?: pulumi.Input<string>;
    /**
     * rsyslog server IP address or hostname
     */
    server?: pulumi.Input<string>;
    /**
     * Require TLS
     */
    tls?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointSignalfxUserConfig {
    /**
     * list of metrics to send
     */
    enabledMetrics?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * SignalFX API key
     */
    signalfxApiKey?: pulumi.Input<string>;
    /**
     * SignalFX realm
     */
    signalfxRealm?: pulumi.Input<string>;
}

export interface ServiceIntegrationExternalAwsCloudwatchMetricsUserConfig {
    /**
     * Metrics to not send to AWS CloudWatch (takes precedence over extra*metrics)
     */
    droppedMetrics?: pulumi.Input<pulumi.Input<inputs.ServiceIntegrationExternalAwsCloudwatchMetricsUserConfigDroppedMetric>[]>;
    /**
     * Metrics to allow through to AWS CloudWatch (in addition to default metrics)
     */
    extraMetrics?: pulumi.Input<pulumi.Input<inputs.ServiceIntegrationExternalAwsCloudwatchMetricsUserConfigExtraMetric>[]>;
}

export interface ServiceIntegrationExternalAwsCloudwatchMetricsUserConfigDroppedMetric {
    field?: pulumi.Input<string>;
    metric?: pulumi.Input<string>;
}

export interface ServiceIntegrationExternalAwsCloudwatchMetricsUserConfigExtraMetric {
    field?: pulumi.Input<string>;
    metric?: pulumi.Input<string>;
}

export interface ServiceIntegrationKafkaConnectUserConfig {
    /**
     * Kafka Connect service configuration values
     */
    kafkaConnect?: pulumi.Input<inputs.ServiceIntegrationKafkaConnectUserConfigKafkaConnect>;
}

export interface ServiceIntegrationKafkaConnectUserConfigKafkaConnect {
    configStorageTopic?: pulumi.Input<string>;
    groupId?: pulumi.Input<string>;
    offsetStorageTopic?: pulumi.Input<string>;
    statusStorageTopic?: pulumi.Input<string>;
}

export interface ServiceIntegrationKafkaLogsUserConfig {
    /**
     * Topic name
     */
    kafkaTopic?: pulumi.Input<string>;
}

export interface ServiceIntegrationKafkaMirrormakerUserConfig {
    /**
     * The alias under which the Kafka cluster is known to MirrorMaker. Can contain the following symbols: ASCII alphanumerics, '.', '_', and '-'.
     */
    clusterAlias?: pulumi.Input<string>;
    /**
     * Kafka MirrorMaker configuration values
     */
    kafkaMirrormaker?: pulumi.Input<inputs.ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker>;
}

export interface ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker {
    consumerFetchMinBytes?: pulumi.Input<string>;
    producerBatchSize?: pulumi.Input<string>;
    producerBufferMemory?: pulumi.Input<string>;
    producerLingerMs?: pulumi.Input<string>;
    producerMaxRequestSize?: pulumi.Input<string>;
}

export interface ServiceIntegrationLogsUserConfig {
    /**
     * Elasticsearch index retention limit
     */
    elasticsearchIndexDaysMax?: pulumi.Input<string>;
    /**
     * Elasticsearch index prefix
     */
    elasticsearchIndexPrefix?: pulumi.Input<string>;
}

export interface ServiceIntegrationMetricsUserConfig {
    /**
     * Name of the database where to store metric datapoints. Only affects PostgreSQL destinations. Defaults to 'metrics'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
     */
    database?: pulumi.Input<string>;
    /**
     * Number of days to keep old metrics. Only affects PostgreSQL destinations. Set to 0 for no automatic cleanup. Defaults to 30 days.
     */
    retentionDays?: pulumi.Input<string>;
    /**
     * Name of a user that can be used to read metrics. This will be used for Grafana integration (if enabled) to prevent Grafana users from making undesired changes. Only affects PostgreSQL destinations. Defaults to 'metrics_reader'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
     */
    roUsername?: pulumi.Input<string>;
    /**
     * Configuration options for metrics where source service is MySQL
     */
    sourceMysql?: pulumi.Input<inputs.ServiceIntegrationMetricsUserConfigSourceMysql>;
    /**
     * Name of the user used to write metrics. Only affects PostgreSQL destinations. Defaults to 'metrics_writer'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
     */
    username?: pulumi.Input<string>;
}

export interface ServiceIntegrationMetricsUserConfigSourceMysql {
    telegraf?: pulumi.Input<inputs.ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf>;
}

export interface ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf {
    gatherEventWaits?: pulumi.Input<string>;
    gatherFileEventsStats?: pulumi.Input<string>;
    gatherIndexIoWaits?: pulumi.Input<string>;
    gatherInfoSchemaAutoInc?: pulumi.Input<string>;
    gatherInnodbMetrics?: pulumi.Input<string>;
    gatherPerfEventsStatements?: pulumi.Input<string>;
    gatherProcessList?: pulumi.Input<string>;
    gatherSlaveStatus?: pulumi.Input<string>;
    gatherTableIoWaits?: pulumi.Input<string>;
    gatherTableLockWaits?: pulumi.Input<string>;
    gatherTableSchema?: pulumi.Input<string>;
    perfEventsStatementsDigestTextLimit?: pulumi.Input<string>;
    perfEventsStatementsLimit?: pulumi.Input<string>;
    perfEventsStatementsTimeLimit?: pulumi.Input<string>;
}

export interface ServiceIntegrationMirrormakerUserConfig {
    /**
     * Mirrormaker topic whitelist
     */
    mirrormakerWhitelist?: pulumi.Input<string>;
}
