// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ElasticSearchAclAcl {
    rules: pulumi.Input<pulumi.Input<inputs.ElasticSearchAclAclRule>[]>;
    username: pulumi.Input<string>;
}

export interface ElasticSearchAclAclRule {
    index: pulumi.Input<string>;
    permission: pulumi.Input<string>;
}

export interface GetElasticSearchAclAcl {
    rules: inputs.GetElasticSearchAclAclRule[];
    username: string;
}

export interface GetElasticSearchAclAclRule {
    index: string;
    permission: string;
}

export interface GetKafkaConnectorTask {
    connector?: string;
    task?: number;
}

export interface GetKafkaTopicClientTimeout {
    create?: string;
    read?: string;
}

export interface GetProjectVpcClientTimeout {
    create?: string;
    delete?: string;
}

export interface GetServiceCassandra {
}

export interface GetServiceCassandraUserConfig {
    ipFilters?: string[];
    migrateSstableloader?: string;
    privateAccess?: inputs.GetServiceCassandraUserConfigPrivateAccess;
    publicAccess?: inputs.GetServiceCassandraUserConfigPublicAccess;
    serviceToForkFrom?: string;
}

export interface GetServiceCassandraUserConfigPrivateAccess {
    prometheus?: string;
}

export interface GetServiceCassandraUserConfigPublicAccess {
    prometheus?: string;
}

export interface GetServiceClientTimeout {
    create?: string;
    update?: string;
}

export interface GetServiceComponent {
    component?: string;
    host?: string;
    kafkaAuthenticationMethod?: string;
    port?: number;
    route?: string;
    ssl?: boolean;
    usage?: string;
}

export interface GetServiceElasticsearch {
    kibanaUri?: string;
}

export interface GetServiceElasticsearchUserConfig {
    customDomain?: string;
    disableReplicationFactorAdjustment?: string;
    elasticsearch?: inputs.GetServiceElasticsearchUserConfigElasticsearch;
    elasticsearchVersion?: string;
    indexPatterns?: inputs.GetServiceElasticsearchUserConfigIndexPattern[];
    ipFilters?: string[];
    kibana?: inputs.GetServiceElasticsearchUserConfigKibana;
    maxIndexCount?: string;
    privateAccess?: inputs.GetServiceElasticsearchUserConfigPrivateAccess;
    publicAccess?: inputs.GetServiceElasticsearchUserConfigPublicAccess;
    recoveryBasebackupName?: string;
    serviceToForkFrom?: string;
}

export interface GetServiceElasticsearchUserConfigElasticsearch {
    actionAutoCreateIndexEnabled?: string;
    actionDestructiveRequiresName?: string;
    httpMaxContentLength?: string;
    httpMaxHeaderSize?: string;
    httpMaxInitialLineLength?: string;
    indicesFielddataCacheSize?: string;
    indicesMemoryIndexBufferSize?: string;
    indicesQueriesCacheSize?: string;
    indicesQueryBoolMaxClauseCount?: string;
    reindexRemoteWhitelists?: string[];
    threadPoolAnalyzeQueueSize?: string;
    threadPoolAnalyzeSize?: string;
    threadPoolForceMergeSize?: string;
    threadPoolGetQueueSize?: string;
    threadPoolGetSize?: string;
    threadPoolIndexQueueSize?: string;
    threadPoolIndexSize?: string;
    threadPoolSearchQueueSize?: string;
    threadPoolSearchSize?: string;
    threadPoolSearchThrottledQueueSize?: string;
    threadPoolSearchThrottledSize?: string;
    threadPoolWriteQueueSize?: string;
    threadPoolWriteSize?: string;
}

export interface GetServiceElasticsearchUserConfigIndexPattern {
    maxIndexCount?: string;
    pattern?: string;
}

export interface GetServiceElasticsearchUserConfigKibana {
    elasticsearchRequestTimeout?: string;
    enabled?: string;
    maxOldSpaceSize?: string;
}

export interface GetServiceElasticsearchUserConfigPrivateAccess {
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface GetServiceElasticsearchUserConfigPublicAccess {
    elasticsearch?: string;
    kibana?: string;
    prometheus?: string;
}

export interface GetServiceGrafana {
}

export interface GetServiceGrafanaUserConfig {
    alertingEnabled?: string;
    alertingErrorOrTimeout?: string;
    alertingNodataOrNullvalues?: string;
    allowEmbedding?: string;
    authBasicEnabled?: string;
    authGenericOauth?: inputs.GetServiceGrafanaUserConfigAuthGenericOauth;
    authGithub?: inputs.GetServiceGrafanaUserConfigAuthGithub;
    authGitlab?: inputs.GetServiceGrafanaUserConfigAuthGitlab;
    authGoogle?: inputs.GetServiceGrafanaUserConfigAuthGoogle;
    cookieSamesite?: string;
    customDomain?: string;
    dashboardsVersionsToKeep?: string;
    dataproxySendUserHeader?: string;
    dataproxyTimeout?: string;
    disableGravatar?: string;
    editorsCanAdmin?: string;
    externalImageStorage?: inputs.GetServiceGrafanaUserConfigExternalImageStorage;
    googleAnalyticsUaId?: string;
    ipFilters?: string[];
    metricsEnabled?: string;
    privateAccess?: inputs.GetServiceGrafanaUserConfigPrivateAccess;
    publicAccess?: inputs.GetServiceGrafanaUserConfigPublicAccess;
    smtpServer?: inputs.GetServiceGrafanaUserConfigSmtpServer;
    userAutoAssignOrg?: string;
    userAutoAssignOrgRole?: string;
    viewersCanEdit?: string;
}

export interface GetServiceGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: string;
    allowedDomains?: string[];
    allowedOrganizations?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    name?: string;
    scopes?: string[];
    tokenUrl?: string;
}

export interface GetServiceGrafanaUserConfigAuthGithub {
    allowSignUp?: string;
    allowedOrganizations?: string[];
    clientId?: string;
    clientSecret?: string;
    teamIds?: number[];
}

export interface GetServiceGrafanaUserConfigAuthGitlab {
    allowSignUp?: string;
    allowedGroups?: string[];
    apiUrl?: string;
    authUrl?: string;
    clientId?: string;
    clientSecret?: string;
    tokenUrl?: string;
}

export interface GetServiceGrafanaUserConfigAuthGoogle {
    allowSignUp?: string;
    allowedDomains?: string[];
    clientId?: string;
    clientSecret?: string;
}

export interface GetServiceGrafanaUserConfigExternalImageStorage {
    accessKey?: string;
    bucketUrl?: string;
    provider?: string;
    secretKey?: string;
}

export interface GetServiceGrafanaUserConfigPrivateAccess {
    grafana?: string;
}

export interface GetServiceGrafanaUserConfigPublicAccess {
    grafana?: string;
}

export interface GetServiceGrafanaUserConfigSmtpServer {
    fromAddress?: string;
    fromName?: string;
    host?: string;
    password?: string;
    port?: string;
    skipVerify?: string;
    username?: string;
}

export interface GetServiceInfluxdb {
    databaseName?: string;
}

export interface GetServiceInfluxdbUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    privateAccess?: inputs.GetServiceInfluxdbUserConfigPrivateAccess;
    publicAccess?: inputs.GetServiceInfluxdbUserConfigPublicAccess;
    serviceToForkFrom?: string;
}

export interface GetServiceInfluxdbUserConfigPrivateAccess {
    influxdb?: string;
}

export interface GetServiceInfluxdbUserConfigPublicAccess {
    influxdb?: string;
}

export interface GetServiceIntegrationEndpointDatadogUserConfig {
    datadogApiKey?: string;
    disableConsumerStats?: string;
    maxPartitionContexts?: string;
    site?: string;
}

export interface GetServiceIntegrationEndpointExternalElasticsearchLogsUserConfig {
    ca?: string;
    indexDaysMax?: string;
    indexPrefix?: string;
    timeout?: string;
    url?: string;
}

export interface GetServiceIntegrationEndpointPrometheusUserConfig {
    basicAuthPassword?: string;
    basicAuthUsername?: string;
}

export interface GetServiceIntegrationEndpointRsyslogUserConfig {
    ca?: string;
    cert?: string;
    format?: string;
    key?: string;
    logline?: string;
    port?: string;
    sd?: string;
    server?: string;
    tls?: string;
}

export interface GetServiceIntegrationKafkaConnectUserConfig {
    kafkaConnect?: inputs.GetServiceIntegrationKafkaConnectUserConfigKafkaConnect;
}

export interface GetServiceIntegrationKafkaConnectUserConfigKafkaConnect {
    configStorageTopic?: string;
    groupId?: string;
    offsetStorageTopic?: string;
    statusStorageTopic?: string;
}

export interface GetServiceIntegrationKafkaMirrormakerUserConfig {
    clusterAlias?: string;
}

export interface GetServiceIntegrationLogsUserConfig {
    elasticsearchIndexDaysMax?: string;
    elasticsearchIndexPrefix?: string;
}

export interface GetServiceIntegrationMirrormakerUserConfig {
    mirrormakerWhitelist?: string;
}

export interface GetServiceKafka {
    accessCert?: string;
    accessKey?: string;
    connectUri?: string;
    restUri?: string;
    schemaRegistryUri?: string;
}

export interface GetServiceKafkaConnect {
}

export interface GetServiceKafkaConnectUserConfig {
    ipFilters?: string[];
    kafkaConnect?: inputs.GetServiceKafkaConnectUserConfigKafkaConnect;
    privateAccess?: inputs.GetServiceKafkaConnectUserConfigPrivateAccess;
    publicAccess?: inputs.GetServiceKafkaConnectUserConfigPublicAccess;
}

export interface GetServiceKafkaConnectUserConfigKafkaConnect {
    consumerIsolationLevel?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
}

export interface GetServiceKafkaConnectUserConfigPrivateAccess {
    kafkaConnect?: string;
    prometheus?: string;
}

export interface GetServiceKafkaConnectUserConfigPublicAccess {
    kafkaConnect?: string;
    prometheus?: string;
}

export interface GetServiceKafkaMirrormaker {
}

export interface GetServiceKafkaMirrormakerUserConfig {
    ipFilters?: string[];
    kafkaMirrormaker?: inputs.GetServiceKafkaMirrormakerUserConfigKafkaMirrormaker;
}

export interface GetServiceKafkaMirrormakerUserConfigKafkaMirrormaker {
    refreshGroupsEnabled?: string;
    refreshGroupsIntervalSeconds?: string;
    refreshTopicsEnabled?: string;
    refreshTopicsIntervalSeconds?: string;
}

export interface GetServiceKafkaUserConfig {
    customDomain?: string;
    ipFilters?: string[];
    kafka?: inputs.GetServiceKafkaUserConfigKafka;
    kafkaAuthenticationMethods?: inputs.GetServiceKafkaUserConfigKafkaAuthenticationMethods;
    kafkaConnect?: string;
    kafkaConnectConfig?: inputs.GetServiceKafkaUserConfigKafkaConnectConfig;
    kafkaRest?: string;
    kafkaRestConfig?: inputs.GetServiceKafkaUserConfigKafkaRestConfig;
    kafkaVersion?: string;
    privateAccess?: inputs.GetServiceKafkaUserConfigPrivateAccess;
    publicAccess?: inputs.GetServiceKafkaUserConfigPublicAccess;
    schemaRegistry?: string;
}

export interface GetServiceKafkaUserConfigKafka {
    autoCreateTopicsEnable?: string;
    compressionType?: string;
    connectionsMaxIdleMs?: string;
    defaultReplicationFactor?: string;
    groupMaxSessionTimeoutMs?: string;
    groupMinSessionTimeoutMs?: string;
    logCleanerMaxCompactionLagMs?: string;
    logCleanerMinCleanableRatio?: string;
    logCleanerMinCompactionLagMs?: string;
    logCleanupPolicy?: string;
    logMessageTimestampDifferenceMaxMs?: string;
    logMessageTimestampType?: string;
    logRetentionBytes?: string;
    logRetentionHours?: string;
    logSegmentBytes?: string;
    maxConnectionsPerIp?: string;
    messageMaxBytes?: string;
    numPartitions?: string;
    offsetsRetentionMinutes?: string;
    producerPurgatoryPurgeIntervalRequests?: string;
    replicaFetchMaxBytes?: string;
    replicaFetchResponseMaxBytes?: string;
    socketRequestMaxBytes?: string;
}

export interface GetServiceKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: string;
    sasl?: string;
}

export interface GetServiceKafkaUserConfigKafkaConnectConfig {
    consumerIsolationLevel?: string;
    consumerMaxPollRecords?: string;
    offsetFlushIntervalMs?: string;
}

export interface GetServiceKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: string;
    consumerRequestMaxBytes?: string;
    consumerRequestTimeoutMs?: string;
    producerAcks?: string;
    producerLingerMs?: string;
    simpleconsumerPoolSizeMax?: string;
}

export interface GetServiceKafkaUserConfigPrivateAccess {
    prometheus?: string;
}

export interface GetServiceKafkaUserConfigPublicAccess {
    kafka?: string;
    kafkaConnect?: string;
    kafkaRest?: string;
    prometheus?: string;
    schemaRegistry?: string;
}

export interface GetServiceMysql {
}

export interface GetServiceMysqlUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    ipFilters?: string[];
    mysql?: inputs.GetServiceMysqlUserConfigMysql;
    mysqlVersion?: string;
    privateAccess?: inputs.GetServiceMysqlUserConfigPrivateAccess;
    publicAccess?: inputs.GetServiceMysqlUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
}

export interface GetServiceMysqlUserConfigMysql {
    connectTimeout?: string;
    defaultTimeZone?: string;
    groupConcatMaxLen?: string;
    informationSchemaStatsExpiry?: string;
    innodbFtMinTokenSize?: string;
    innodbFtServerStopwordTable?: string;
    innodbLockWaitTimeout?: string;
    innodbLogBufferSize?: string;
    innodbOnlineAlterLogMaxSize?: string;
    innodbRollbackOnTimeout?: string;
    interactiveTimeout?: string;
    maxAllowedPacket?: string;
    maxHeapTableSize?: string;
    netReadTimeout?: string;
    netWriteTimeout?: string;
    sortBufferSize?: string;
    sqlMode?: string;
    sqlRequirePrimaryKey?: string;
    tmpTableSize?: string;
    waitTimeout?: string;
}

export interface GetServiceMysqlUserConfigPrivateAccess {
    mysql?: string;
    prometheus?: string;
}

export interface GetServiceMysqlUserConfigPublicAccess {
    mysql?: string;
    prometheus?: string;
}

export interface GetServicePg {
    dbname?: string;
    host?: string;
    password?: string;
    port?: number;
    replicaUri?: string;
    sslmode?: string;
    uri?: string;
    user?: string;
}

export interface GetServicePgUserConfig {
    adminPassword?: string;
    adminUsername?: string;
    backupHour?: string;
    backupMinute?: string;
    ipFilters?: string[];
    pg?: inputs.GetServicePgUserConfigPg;
    pgReadReplica?: string;
    pgServiceToForkFrom?: string;
    pgVersion?: string;
    pgbouncer?: inputs.GetServicePgUserConfigPgbouncer;
    pglookout?: inputs.GetServicePgUserConfigPglookout;
    privateAccess?: inputs.GetServicePgUserConfigPrivateAccess;
    publicAccess?: inputs.GetServicePgUserConfigPublicAccess;
    recoveryTargetTime?: string;
    serviceToForkFrom?: string;
    synchronousReplication?: string;
    timescaledb?: inputs.GetServicePgUserConfigTimescaledb;
    variant?: string;
}

export interface GetServicePgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: string;
    autovacuumAnalyzeThreshold?: string;
    autovacuumFreezeMaxAge?: string;
    autovacuumMaxWorkers?: string;
    autovacuumNaptime?: string;
    autovacuumVacuumCostDelay?: string;
    autovacuumVacuumCostLimit?: string;
    autovacuumVacuumScaleFactor?: string;
    autovacuumVacuumThreshold?: string;
    deadlockTimeout?: string;
    idleInTransactionSessionTimeout?: string;
    jit?: string;
    logAutovacuumMinDuration?: string;
    logErrorVerbosity?: string;
    logMinDurationStatement?: string;
    maxLocksPerTransaction?: string;
    maxParallelWorkers?: string;
    maxParallelWorkersPerGather?: string;
    maxPredLocksPerTransaction?: string;
    maxPreparedTransactions?: string;
    maxStackDepth?: string;
    maxStandbyArchiveDelay?: string;
    maxStandbyStreamingDelay?: string;
    maxWorkerProcesses?: string;
    pgStatStatementsTrack?: string;
    tempFileLimit?: string;
    timezone?: string;
    trackActivityQuerySize?: string;
    trackCommitTimestamp?: string;
    trackFunctions?: string;
    walSenderTimeout?: string;
    walWriterDelay?: string;
}

export interface GetServicePgUserConfigPgbouncer {
    ignoreStartupParameters?: string[];
    serverResetQueryAlways?: string;
}

export interface GetServicePgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: string;
}

export interface GetServicePgUserConfigPrivateAccess {
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface GetServicePgUserConfigPublicAccess {
    pg?: string;
    pgbouncer?: string;
    prometheus?: string;
}

export interface GetServicePgUserConfigTimescaledb {
    maxBackgroundWorkers?: string;
}

export interface GetServiceRedis {
}

export interface GetServiceRedisUserConfig {
    ipFilters?: string[];
    migration?: inputs.GetServiceRedisUserConfigMigration;
    privateAccess?: inputs.GetServiceRedisUserConfigPrivateAccess;
    publicAccess?: inputs.GetServiceRedisUserConfigPublicAccess;
    redisLfuDecayTime?: string;
    redisLfuLogFactor?: string;
    redisMaxmemoryPolicy?: string;
    redisNotifyKeyspaceEvents?: string;
    redisSsl?: string;
    redisTimeout?: string;
}

export interface GetServiceRedisUserConfigMigration {
    host?: string;
    password?: string;
    port?: string;
    ssl?: string;
    username?: string;
}

export interface GetServiceRedisUserConfigPrivateAccess {
    prometheus?: string;
    redis?: string;
}

export interface GetServiceRedisUserConfigPublicAccess {
    prometheus?: string;
    redis?: string;
}

export interface GetServiceServiceIntegration {
    integrationType: string;
    sourceServiceName: string;
}

export interface GetVpcPeeringConnectionClientTimeout {
    create?: string;
}

export interface KafkaConnectorTask {
    connector?: pulumi.Input<string>;
    task?: pulumi.Input<number>;
}

export interface KafkaTopicClientTimeout {
    create?: pulumi.Input<string>;
    read?: pulumi.Input<string>;
}

export interface ProjectVpcClientTimeout {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface ServiceCassandra {
}

export interface ServiceCassandraUserConfig {
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    migrateSstableloader?: pulumi.Input<string>;
    privateAccess?: pulumi.Input<inputs.ServiceCassandraUserConfigPrivateAccess>;
    publicAccess?: pulumi.Input<inputs.ServiceCassandraUserConfigPublicAccess>;
    serviceToForkFrom?: pulumi.Input<string>;
}

export interface ServiceCassandraUserConfigPrivateAccess {
    prometheus?: pulumi.Input<string>;
}

export interface ServiceCassandraUserConfigPublicAccess {
    prometheus?: pulumi.Input<string>;
}

export interface ServiceClientTimeout {
    create?: pulumi.Input<string>;
    update?: pulumi.Input<string>;
}

export interface ServiceComponent {
    component?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    kafkaAuthenticationMethod?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    route?: pulumi.Input<string>;
    ssl?: pulumi.Input<boolean>;
    usage?: pulumi.Input<string>;
}

export interface ServiceElasticsearch {
    kibanaUri?: pulumi.Input<string>;
}

export interface ServiceElasticsearchUserConfig {
    customDomain?: pulumi.Input<string>;
    disableReplicationFactorAdjustment?: pulumi.Input<string>;
    elasticsearch?: pulumi.Input<inputs.ServiceElasticsearchUserConfigElasticsearch>;
    elasticsearchVersion?: pulumi.Input<string>;
    indexPatterns?: pulumi.Input<pulumi.Input<inputs.ServiceElasticsearchUserConfigIndexPattern>[]>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    kibana?: pulumi.Input<inputs.ServiceElasticsearchUserConfigKibana>;
    maxIndexCount?: pulumi.Input<string>;
    privateAccess?: pulumi.Input<inputs.ServiceElasticsearchUserConfigPrivateAccess>;
    publicAccess?: pulumi.Input<inputs.ServiceElasticsearchUserConfigPublicAccess>;
    recoveryBasebackupName?: pulumi.Input<string>;
    serviceToForkFrom?: pulumi.Input<string>;
}

export interface ServiceElasticsearchUserConfigElasticsearch {
    actionAutoCreateIndexEnabled?: pulumi.Input<string>;
    actionDestructiveRequiresName?: pulumi.Input<string>;
    httpMaxContentLength?: pulumi.Input<string>;
    httpMaxHeaderSize?: pulumi.Input<string>;
    httpMaxInitialLineLength?: pulumi.Input<string>;
    indicesFielddataCacheSize?: pulumi.Input<string>;
    indicesMemoryIndexBufferSize?: pulumi.Input<string>;
    indicesQueriesCacheSize?: pulumi.Input<string>;
    indicesQueryBoolMaxClauseCount?: pulumi.Input<string>;
    reindexRemoteWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    threadPoolAnalyzeQueueSize?: pulumi.Input<string>;
    threadPoolAnalyzeSize?: pulumi.Input<string>;
    threadPoolForceMergeSize?: pulumi.Input<string>;
    threadPoolGetQueueSize?: pulumi.Input<string>;
    threadPoolGetSize?: pulumi.Input<string>;
    threadPoolIndexQueueSize?: pulumi.Input<string>;
    threadPoolIndexSize?: pulumi.Input<string>;
    threadPoolSearchQueueSize?: pulumi.Input<string>;
    threadPoolSearchSize?: pulumi.Input<string>;
    threadPoolSearchThrottledQueueSize?: pulumi.Input<string>;
    threadPoolSearchThrottledSize?: pulumi.Input<string>;
    threadPoolWriteQueueSize?: pulumi.Input<string>;
    threadPoolWriteSize?: pulumi.Input<string>;
}

export interface ServiceElasticsearchUserConfigIndexPattern {
    maxIndexCount?: pulumi.Input<string>;
    pattern?: pulumi.Input<string>;
}

export interface ServiceElasticsearchUserConfigKibana {
    elasticsearchRequestTimeout?: pulumi.Input<string>;
    enabled?: pulumi.Input<string>;
    maxOldSpaceSize?: pulumi.Input<string>;
}

export interface ServiceElasticsearchUserConfigPrivateAccess {
    elasticsearch?: pulumi.Input<string>;
    kibana?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface ServiceElasticsearchUserConfigPublicAccess {
    elasticsearch?: pulumi.Input<string>;
    kibana?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface ServiceGrafana {
}

export interface ServiceGrafanaUserConfig {
    alertingEnabled?: pulumi.Input<string>;
    alertingErrorOrTimeout?: pulumi.Input<string>;
    alertingNodataOrNullvalues?: pulumi.Input<string>;
    allowEmbedding?: pulumi.Input<string>;
    authBasicEnabled?: pulumi.Input<string>;
    authGenericOauth?: pulumi.Input<inputs.ServiceGrafanaUserConfigAuthGenericOauth>;
    authGithub?: pulumi.Input<inputs.ServiceGrafanaUserConfigAuthGithub>;
    authGitlab?: pulumi.Input<inputs.ServiceGrafanaUserConfigAuthGitlab>;
    authGoogle?: pulumi.Input<inputs.ServiceGrafanaUserConfigAuthGoogle>;
    cookieSamesite?: pulumi.Input<string>;
    customDomain?: pulumi.Input<string>;
    dashboardsVersionsToKeep?: pulumi.Input<string>;
    dataproxySendUserHeader?: pulumi.Input<string>;
    dataproxyTimeout?: pulumi.Input<string>;
    disableGravatar?: pulumi.Input<string>;
    editorsCanAdmin?: pulumi.Input<string>;
    externalImageStorage?: pulumi.Input<inputs.ServiceGrafanaUserConfigExternalImageStorage>;
    googleAnalyticsUaId?: pulumi.Input<string>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    metricsEnabled?: pulumi.Input<string>;
    privateAccess?: pulumi.Input<inputs.ServiceGrafanaUserConfigPrivateAccess>;
    publicAccess?: pulumi.Input<inputs.ServiceGrafanaUserConfigPublicAccess>;
    smtpServer?: pulumi.Input<inputs.ServiceGrafanaUserConfigSmtpServer>;
    userAutoAssignOrg?: pulumi.Input<string>;
    userAutoAssignOrgRole?: pulumi.Input<string>;
    viewersCanEdit?: pulumi.Input<string>;
}

export interface ServiceGrafanaUserConfigAuthGenericOauth {
    allowSignUp?: pulumi.Input<string>;
    allowedDomains?: pulumi.Input<pulumi.Input<string>[]>;
    allowedOrganizations?: pulumi.Input<pulumi.Input<string>[]>;
    apiUrl?: pulumi.Input<string>;
    authUrl?: pulumi.Input<string>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    scopes?: pulumi.Input<pulumi.Input<string>[]>;
    tokenUrl?: pulumi.Input<string>;
}

export interface ServiceGrafanaUserConfigAuthGithub {
    allowSignUp?: pulumi.Input<string>;
    allowedOrganizations?: pulumi.Input<pulumi.Input<string>[]>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    teamIds?: pulumi.Input<pulumi.Input<number>[]>;
}

export interface ServiceGrafanaUserConfigAuthGitlab {
    allowSignUp?: pulumi.Input<string>;
    allowedGroups?: pulumi.Input<pulumi.Input<string>[]>;
    apiUrl?: pulumi.Input<string>;
    authUrl?: pulumi.Input<string>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    tokenUrl?: pulumi.Input<string>;
}

export interface ServiceGrafanaUserConfigAuthGoogle {
    allowSignUp?: pulumi.Input<string>;
    allowedDomains?: pulumi.Input<pulumi.Input<string>[]>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
}

export interface ServiceGrafanaUserConfigExternalImageStorage {
    accessKey?: pulumi.Input<string>;
    bucketUrl?: pulumi.Input<string>;
    provider?: pulumi.Input<string>;
    secretKey?: pulumi.Input<string>;
}

export interface ServiceGrafanaUserConfigPrivateAccess {
    grafana?: pulumi.Input<string>;
}

export interface ServiceGrafanaUserConfigPublicAccess {
    grafana?: pulumi.Input<string>;
}

export interface ServiceGrafanaUserConfigSmtpServer {
    fromAddress?: pulumi.Input<string>;
    fromName?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    skipVerify?: pulumi.Input<string>;
    username?: pulumi.Input<string>;
}

export interface ServiceInfluxdb {
    databaseName?: pulumi.Input<string>;
}

export interface ServiceInfluxdbUserConfig {
    customDomain?: pulumi.Input<string>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    privateAccess?: pulumi.Input<inputs.ServiceInfluxdbUserConfigPrivateAccess>;
    publicAccess?: pulumi.Input<inputs.ServiceInfluxdbUserConfigPublicAccess>;
    serviceToForkFrom?: pulumi.Input<string>;
}

export interface ServiceInfluxdbUserConfigPrivateAccess {
    influxdb?: pulumi.Input<string>;
}

export interface ServiceInfluxdbUserConfigPublicAccess {
    influxdb?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointDatadogUserConfig {
    datadogApiKey?: pulumi.Input<string>;
    disableConsumerStats?: pulumi.Input<string>;
    maxPartitionContexts?: pulumi.Input<string>;
    site?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig {
    ca?: pulumi.Input<string>;
    indexDaysMax?: pulumi.Input<string>;
    indexPrefix?: pulumi.Input<string>;
    timeout?: pulumi.Input<string>;
    url?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointPrometheusUserConfig {
    basicAuthPassword?: pulumi.Input<string>;
    basicAuthUsername?: pulumi.Input<string>;
}

export interface ServiceIntegrationEndpointRsyslogUserConfig {
    ca?: pulumi.Input<string>;
    cert?: pulumi.Input<string>;
    format?: pulumi.Input<string>;
    key?: pulumi.Input<string>;
    logline?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    sd?: pulumi.Input<string>;
    server?: pulumi.Input<string>;
    tls?: pulumi.Input<string>;
}

export interface ServiceIntegrationKafkaConnectUserConfig {
    kafkaConnect?: pulumi.Input<inputs.ServiceIntegrationKafkaConnectUserConfigKafkaConnect>;
}

export interface ServiceIntegrationKafkaConnectUserConfigKafkaConnect {
    configStorageTopic?: pulumi.Input<string>;
    groupId?: pulumi.Input<string>;
    offsetStorageTopic?: pulumi.Input<string>;
    statusStorageTopic?: pulumi.Input<string>;
}

export interface ServiceIntegrationKafkaMirrormakerUserConfig {
    clusterAlias?: pulumi.Input<string>;
}

export interface ServiceIntegrationLogsUserConfig {
    elasticsearchIndexDaysMax?: pulumi.Input<string>;
    elasticsearchIndexPrefix?: pulumi.Input<string>;
}

export interface ServiceIntegrationMirrormakerUserConfig {
    mirrormakerWhitelist?: pulumi.Input<string>;
}

export interface ServiceKafka {
    accessCert?: pulumi.Input<string>;
    accessKey?: pulumi.Input<string>;
    connectUri?: pulumi.Input<string>;
    restUri?: pulumi.Input<string>;
    schemaRegistryUri?: pulumi.Input<string>;
}

export interface ServiceKafkaConnect {
}

export interface ServiceKafkaConnectUserConfig {
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    kafkaConnect?: pulumi.Input<inputs.ServiceKafkaConnectUserConfigKafkaConnect>;
    privateAccess?: pulumi.Input<inputs.ServiceKafkaConnectUserConfigPrivateAccess>;
    publicAccess?: pulumi.Input<inputs.ServiceKafkaConnectUserConfigPublicAccess>;
}

export interface ServiceKafkaConnectUserConfigKafkaConnect {
    consumerIsolationLevel?: pulumi.Input<string>;
    consumerMaxPollRecords?: pulumi.Input<string>;
    offsetFlushIntervalMs?: pulumi.Input<string>;
}

export interface ServiceKafkaConnectUserConfigPrivateAccess {
    kafkaConnect?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface ServiceKafkaConnectUserConfigPublicAccess {
    kafkaConnect?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface ServiceKafkaMirrormaker {
}

export interface ServiceKafkaMirrormakerUserConfig {
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    kafkaMirrormaker?: pulumi.Input<inputs.ServiceKafkaMirrormakerUserConfigKafkaMirrormaker>;
}

export interface ServiceKafkaMirrormakerUserConfigKafkaMirrormaker {
    refreshGroupsEnabled?: pulumi.Input<string>;
    refreshGroupsIntervalSeconds?: pulumi.Input<string>;
    refreshTopicsEnabled?: pulumi.Input<string>;
    refreshTopicsIntervalSeconds?: pulumi.Input<string>;
}

export interface ServiceKafkaUserConfig {
    customDomain?: pulumi.Input<string>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    kafka?: pulumi.Input<inputs.ServiceKafkaUserConfigKafka>;
    kafkaAuthenticationMethods?: pulumi.Input<inputs.ServiceKafkaUserConfigKafkaAuthenticationMethods>;
    kafkaConnect?: pulumi.Input<string>;
    kafkaConnectConfig?: pulumi.Input<inputs.ServiceKafkaUserConfigKafkaConnectConfig>;
    kafkaRest?: pulumi.Input<string>;
    kafkaRestConfig?: pulumi.Input<inputs.ServiceKafkaUserConfigKafkaRestConfig>;
    kafkaVersion?: pulumi.Input<string>;
    privateAccess?: pulumi.Input<inputs.ServiceKafkaUserConfigPrivateAccess>;
    publicAccess?: pulumi.Input<inputs.ServiceKafkaUserConfigPublicAccess>;
    schemaRegistry?: pulumi.Input<string>;
}

export interface ServiceKafkaUserConfigKafka {
    autoCreateTopicsEnable?: pulumi.Input<string>;
    compressionType?: pulumi.Input<string>;
    connectionsMaxIdleMs?: pulumi.Input<string>;
    defaultReplicationFactor?: pulumi.Input<string>;
    groupMaxSessionTimeoutMs?: pulumi.Input<string>;
    groupMinSessionTimeoutMs?: pulumi.Input<string>;
    logCleanerMaxCompactionLagMs?: pulumi.Input<string>;
    logCleanerMinCleanableRatio?: pulumi.Input<string>;
    logCleanerMinCompactionLagMs?: pulumi.Input<string>;
    logCleanupPolicy?: pulumi.Input<string>;
    logMessageTimestampDifferenceMaxMs?: pulumi.Input<string>;
    logMessageTimestampType?: pulumi.Input<string>;
    logRetentionBytes?: pulumi.Input<string>;
    logRetentionHours?: pulumi.Input<string>;
    logSegmentBytes?: pulumi.Input<string>;
    maxConnectionsPerIp?: pulumi.Input<string>;
    messageMaxBytes?: pulumi.Input<string>;
    numPartitions?: pulumi.Input<string>;
    offsetsRetentionMinutes?: pulumi.Input<string>;
    producerPurgatoryPurgeIntervalRequests?: pulumi.Input<string>;
    replicaFetchMaxBytes?: pulumi.Input<string>;
    replicaFetchResponseMaxBytes?: pulumi.Input<string>;
    socketRequestMaxBytes?: pulumi.Input<string>;
}

export interface ServiceKafkaUserConfigKafkaAuthenticationMethods {
    certificate?: pulumi.Input<string>;
    sasl?: pulumi.Input<string>;
}

export interface ServiceKafkaUserConfigKafkaConnectConfig {
    consumerIsolationLevel?: pulumi.Input<string>;
    consumerMaxPollRecords?: pulumi.Input<string>;
    offsetFlushIntervalMs?: pulumi.Input<string>;
}

export interface ServiceKafkaUserConfigKafkaRestConfig {
    consumerEnableAutoCommit?: pulumi.Input<string>;
    consumerRequestMaxBytes?: pulumi.Input<string>;
    consumerRequestTimeoutMs?: pulumi.Input<string>;
    producerAcks?: pulumi.Input<string>;
    producerLingerMs?: pulumi.Input<string>;
    simpleconsumerPoolSizeMax?: pulumi.Input<string>;
}

export interface ServiceKafkaUserConfigPrivateAccess {
    prometheus?: pulumi.Input<string>;
}

export interface ServiceKafkaUserConfigPublicAccess {
    kafka?: pulumi.Input<string>;
    kafkaConnect?: pulumi.Input<string>;
    kafkaRest?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
    schemaRegistry?: pulumi.Input<string>;
}

export interface ServiceMysql {
}

export interface ServiceMysqlUserConfig {
    adminPassword?: pulumi.Input<string>;
    adminUsername?: pulumi.Input<string>;
    backupHour?: pulumi.Input<string>;
    backupMinute?: pulumi.Input<string>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    mysql?: pulumi.Input<inputs.ServiceMysqlUserConfigMysql>;
    mysqlVersion?: pulumi.Input<string>;
    privateAccess?: pulumi.Input<inputs.ServiceMysqlUserConfigPrivateAccess>;
    publicAccess?: pulumi.Input<inputs.ServiceMysqlUserConfigPublicAccess>;
    recoveryTargetTime?: pulumi.Input<string>;
    serviceToForkFrom?: pulumi.Input<string>;
}

export interface ServiceMysqlUserConfigMysql {
    connectTimeout?: pulumi.Input<string>;
    defaultTimeZone?: pulumi.Input<string>;
    groupConcatMaxLen?: pulumi.Input<string>;
    informationSchemaStatsExpiry?: pulumi.Input<string>;
    innodbFtMinTokenSize?: pulumi.Input<string>;
    innodbFtServerStopwordTable?: pulumi.Input<string>;
    innodbLockWaitTimeout?: pulumi.Input<string>;
    innodbLogBufferSize?: pulumi.Input<string>;
    innodbOnlineAlterLogMaxSize?: pulumi.Input<string>;
    innodbRollbackOnTimeout?: pulumi.Input<string>;
    interactiveTimeout?: pulumi.Input<string>;
    maxAllowedPacket?: pulumi.Input<string>;
    maxHeapTableSize?: pulumi.Input<string>;
    netReadTimeout?: pulumi.Input<string>;
    netWriteTimeout?: pulumi.Input<string>;
    sortBufferSize?: pulumi.Input<string>;
    sqlMode?: pulumi.Input<string>;
    sqlRequirePrimaryKey?: pulumi.Input<string>;
    tmpTableSize?: pulumi.Input<string>;
    waitTimeout?: pulumi.Input<string>;
}

export interface ServiceMysqlUserConfigPrivateAccess {
    mysql?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface ServiceMysqlUserConfigPublicAccess {
    mysql?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface ServicePg {
    dbname?: pulumi.Input<string>;
    host?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    replicaUri?: pulumi.Input<string>;
    sslmode?: pulumi.Input<string>;
    uri?: pulumi.Input<string>;
    user?: pulumi.Input<string>;
}

export interface ServicePgUserConfig {
    adminPassword?: pulumi.Input<string>;
    adminUsername?: pulumi.Input<string>;
    backupHour?: pulumi.Input<string>;
    backupMinute?: pulumi.Input<string>;
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    pg?: pulumi.Input<inputs.ServicePgUserConfigPg>;
    pgReadReplica?: pulumi.Input<string>;
    pgServiceToForkFrom?: pulumi.Input<string>;
    pgVersion?: pulumi.Input<string>;
    pgbouncer?: pulumi.Input<inputs.ServicePgUserConfigPgbouncer>;
    pglookout?: pulumi.Input<inputs.ServicePgUserConfigPglookout>;
    privateAccess?: pulumi.Input<inputs.ServicePgUserConfigPrivateAccess>;
    publicAccess?: pulumi.Input<inputs.ServicePgUserConfigPublicAccess>;
    recoveryTargetTime?: pulumi.Input<string>;
    serviceToForkFrom?: pulumi.Input<string>;
    synchronousReplication?: pulumi.Input<string>;
    timescaledb?: pulumi.Input<inputs.ServicePgUserConfigTimescaledb>;
    variant?: pulumi.Input<string>;
}

export interface ServicePgUserConfigPg {
    autovacuumAnalyzeScaleFactor?: pulumi.Input<string>;
    autovacuumAnalyzeThreshold?: pulumi.Input<string>;
    autovacuumFreezeMaxAge?: pulumi.Input<string>;
    autovacuumMaxWorkers?: pulumi.Input<string>;
    autovacuumNaptime?: pulumi.Input<string>;
    autovacuumVacuumCostDelay?: pulumi.Input<string>;
    autovacuumVacuumCostLimit?: pulumi.Input<string>;
    autovacuumVacuumScaleFactor?: pulumi.Input<string>;
    autovacuumVacuumThreshold?: pulumi.Input<string>;
    deadlockTimeout?: pulumi.Input<string>;
    idleInTransactionSessionTimeout?: pulumi.Input<string>;
    jit?: pulumi.Input<string>;
    logAutovacuumMinDuration?: pulumi.Input<string>;
    logErrorVerbosity?: pulumi.Input<string>;
    logMinDurationStatement?: pulumi.Input<string>;
    maxLocksPerTransaction?: pulumi.Input<string>;
    maxParallelWorkers?: pulumi.Input<string>;
    maxParallelWorkersPerGather?: pulumi.Input<string>;
    maxPredLocksPerTransaction?: pulumi.Input<string>;
    maxPreparedTransactions?: pulumi.Input<string>;
    maxStackDepth?: pulumi.Input<string>;
    maxStandbyArchiveDelay?: pulumi.Input<string>;
    maxStandbyStreamingDelay?: pulumi.Input<string>;
    maxWorkerProcesses?: pulumi.Input<string>;
    pgStatStatementsTrack?: pulumi.Input<string>;
    tempFileLimit?: pulumi.Input<string>;
    timezone?: pulumi.Input<string>;
    trackActivityQuerySize?: pulumi.Input<string>;
    trackCommitTimestamp?: pulumi.Input<string>;
    trackFunctions?: pulumi.Input<string>;
    walSenderTimeout?: pulumi.Input<string>;
    walWriterDelay?: pulumi.Input<string>;
}

export interface ServicePgUserConfigPgbouncer {
    ignoreStartupParameters?: pulumi.Input<pulumi.Input<string>[]>;
    serverResetQueryAlways?: pulumi.Input<string>;
}

export interface ServicePgUserConfigPglookout {
    maxFailoverReplicationTimeLag?: pulumi.Input<string>;
}

export interface ServicePgUserConfigPrivateAccess {
    pg?: pulumi.Input<string>;
    pgbouncer?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface ServicePgUserConfigPublicAccess {
    pg?: pulumi.Input<string>;
    pgbouncer?: pulumi.Input<string>;
    prometheus?: pulumi.Input<string>;
}

export interface ServicePgUserConfigTimescaledb {
    maxBackgroundWorkers?: pulumi.Input<string>;
}

export interface ServiceRedis {
}

export interface ServiceRedisUserConfig {
    ipFilters?: pulumi.Input<pulumi.Input<string>[]>;
    migration?: pulumi.Input<inputs.ServiceRedisUserConfigMigration>;
    privateAccess?: pulumi.Input<inputs.ServiceRedisUserConfigPrivateAccess>;
    publicAccess?: pulumi.Input<inputs.ServiceRedisUserConfigPublicAccess>;
    redisLfuDecayTime?: pulumi.Input<string>;
    redisLfuLogFactor?: pulumi.Input<string>;
    redisMaxmemoryPolicy?: pulumi.Input<string>;
    redisNotifyKeyspaceEvents?: pulumi.Input<string>;
    redisSsl?: pulumi.Input<string>;
    redisTimeout?: pulumi.Input<string>;
}

export interface ServiceRedisUserConfigMigration {
    host?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    ssl?: pulumi.Input<string>;
    username?: pulumi.Input<string>;
}

export interface ServiceRedisUserConfigPrivateAccess {
    prometheus?: pulumi.Input<string>;
    redis?: pulumi.Input<string>;
}

export interface ServiceRedisUserConfigPublicAccess {
    prometheus?: pulumi.Input<string>;
    redis?: pulumi.Input<string>;
}

export interface ServiceServiceIntegration {
    integrationType: pulumi.Input<string>;
    sourceServiceName: pulumi.Input<string>;
}

export interface VpcPeeringConnectionClientTimeout {
    create?: pulumi.Input<string>;
}
