// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Aiven.Outputs
{

    [OutputType]
    public sealed class GetKafkaTopicListTopicResult
    {
        /// <summary>
        /// The retention policy to use on old segments. Possible values include 'delete', 'compact', or a comma-separated list of them. The default policy ('delete') will discard old segments when their retention time or size limit has been reached. The 'compact' setting will enable log compaction on the topic.
        /// </summary>
        public readonly string CleanupPolicy;
        /// <summary>
        /// Indicates whether diskless should be enabled. This is only available for BYOC services with Diskless feature enabled.
        /// </summary>
        public readonly bool DisklessEnable;
        /// <summary>
        /// When a producer sets acks to 'all' (or '-1'), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. If this minimum cannot be met, then the producer will raise an exception (either NotEnoughReplicas or NotEnoughReplicasAfterAppend). When used together, min.insync.replicas and acks allow you to enforce greater durability guarantees. A typical scenario would be to create a topic with a replication factor of 3, set min.insync.replicas to 2, and produce with acks of 'all'. This will ensure that the producer raises an exception if a majority of replicas do not receive a write.
        /// </summary>
        public readonly int MinInsyncReplicas;
        /// <summary>
        /// The user group that owns this topic.
        /// </summary>
        public readonly string OwnerUserGroupId;
        /// <summary>
        /// Number of partitions.
        /// </summary>
        public readonly int Partitions;
        /// <summary>
        /// Indicates whether tiered storage should be enabled. This is only available for services with Tiered Storage feature enabled.
        /// </summary>
        public readonly bool RemoteStorageEnable;
        /// <summary>
        /// Number of replicas.
        /// </summary>
        public readonly int Replication;
        /// <summary>
        /// This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the 'delete' retention policy. By default there is no size limit only a time limit. Since this limit is enforced at the partition level, multiply it by the number of partitions to compute the topic retention in bytes.
        /// </summary>
        public readonly int RetentionBytes;
        /// <summary>
        /// Retention period (hours).
        /// </summary>
        public readonly int RetentionHours;
        /// <summary>
        /// Topic state. The possible values are `ACTIVE`, `CONFIGURING` and `DELETING`.
        /// </summary>
        public readonly string State;
        /// <summary>
        /// Topic tags.
        /// </summary>
        public readonly ImmutableArray<Outputs.GetKafkaTopicListTopicTagResult> Tags;
        /// <summary>
        /// Topic description.
        /// </summary>
        public readonly string TopicDescription;
        /// <summary>
        /// Topic name.
        /// </summary>
        public readonly string TopicName;

        [OutputConstructor]
        private GetKafkaTopicListTopicResult(
            string cleanupPolicy,

            bool disklessEnable,

            int minInsyncReplicas,

            string ownerUserGroupId,

            int partitions,

            bool remoteStorageEnable,

            int replication,

            int retentionBytes,

            int retentionHours,

            string state,

            ImmutableArray<Outputs.GetKafkaTopicListTopicTagResult> tags,

            string topicDescription,

            string topicName)
        {
            CleanupPolicy = cleanupPolicy;
            DisklessEnable = disklessEnable;
            MinInsyncReplicas = minInsyncReplicas;
            OwnerUserGroupId = ownerUserGroupId;
            Partitions = partitions;
            RemoteStorageEnable = remoteStorageEnable;
            Replication = replication;
            RetentionBytes = retentionBytes;
            RetentionHours = retentionHours;
            State = state;
            Tags = tags;
            TopicDescription = topicDescription;
            TopicName = topicName;
        }
    }
}
