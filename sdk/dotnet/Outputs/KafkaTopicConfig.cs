// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Aiven.Outputs
{

    [OutputType]
    public sealed class KafkaTopicConfig
    {
        /// <summary>
        /// cleanup.policy value, can be `create`, `delete` or `compact,delete`
        /// </summary>
        public readonly string? CleanupPolicy;
        /// <summary>
        /// compression.type value
        /// </summary>
        public readonly string? CompressionType;
        /// <summary>
        /// delete.retention.ms value
        /// </summary>
        public readonly string? DeleteRetentionMs;
        /// <summary>
        /// file.delete.delay.ms value
        /// </summary>
        public readonly string? FileDeleteDelayMs;
        /// <summary>
        /// flush.messages value
        /// </summary>
        public readonly string? FlushMessages;
        /// <summary>
        /// flush.ms value
        /// </summary>
        public readonly string? FlushMs;
        /// <summary>
        /// index.interval.bytes value
        /// </summary>
        public readonly string? IndexIntervalBytes;
        /// <summary>
        /// max.compaction.lag.ms value
        /// </summary>
        public readonly string? MaxCompactionLagMs;
        /// <summary>
        /// max.message.bytes value
        /// </summary>
        public readonly string? MaxMessageBytes;
        /// <summary>
        /// message.downconversion.enable value
        /// </summary>
        public readonly string? MessageDownconversionEnable;
        /// <summary>
        /// message.format.version value
        /// </summary>
        public readonly string? MessageFormatVersion;
        /// <summary>
        /// message.timestamp.difference.max.ms value
        /// </summary>
        public readonly string? MessageTimestampDifferenceMaxMs;
        /// <summary>
        /// message.timestamp.type value
        /// </summary>
        public readonly string? MessageTimestampType;
        /// <summary>
        /// min.cleanable.dirty.ratio value
        /// </summary>
        public readonly string? MinCleanableDirtyRatio;
        /// <summary>
        /// min.compaction.lag.ms value
        /// </summary>
        public readonly string? MinCompactionLagMs;
        /// <summary>
        /// min.insync.replicas value
        /// </summary>
        public readonly string? MinInsyncReplicas;
        /// <summary>
        /// preallocate value
        /// </summary>
        public readonly string? Preallocate;
        /// <summary>
        /// retention.bytes value
        /// </summary>
        public readonly string? RetentionBytes;
        /// <summary>
        /// retention.ms value
        /// </summary>
        public readonly string? RetentionMs;
        /// <summary>
        /// segment.bytes value
        /// </summary>
        public readonly string? SegmentBytes;
        /// <summary>
        /// segment.index.bytes value
        /// </summary>
        public readonly string? SegmentIndexBytes;
        /// <summary>
        /// segment.jitter.ms value
        /// </summary>
        public readonly string? SegmentJitterMs;
        /// <summary>
        /// segment.ms value
        /// </summary>
        public readonly string? SegmentMs;
        /// <summary>
        /// unclean.leader.election.enable value
        /// </summary>
        public readonly string? UncleanLeaderElectionEnable;

        [OutputConstructor]
        private KafkaTopicConfig(
            string? cleanupPolicy,

            string? compressionType,

            string? deleteRetentionMs,

            string? fileDeleteDelayMs,

            string? flushMessages,

            string? flushMs,

            string? indexIntervalBytes,

            string? maxCompactionLagMs,

            string? maxMessageBytes,

            string? messageDownconversionEnable,

            string? messageFormatVersion,

            string? messageTimestampDifferenceMaxMs,

            string? messageTimestampType,

            string? minCleanableDirtyRatio,

            string? minCompactionLagMs,

            string? minInsyncReplicas,

            string? preallocate,

            string? retentionBytes,

            string? retentionMs,

            string? segmentBytes,

            string? segmentIndexBytes,

            string? segmentJitterMs,

            string? segmentMs,

            string? uncleanLeaderElectionEnable)
        {
            CleanupPolicy = cleanupPolicy;
            CompressionType = compressionType;
            DeleteRetentionMs = deleteRetentionMs;
            FileDeleteDelayMs = fileDeleteDelayMs;
            FlushMessages = flushMessages;
            FlushMs = flushMs;
            IndexIntervalBytes = indexIntervalBytes;
            MaxCompactionLagMs = maxCompactionLagMs;
            MaxMessageBytes = maxMessageBytes;
            MessageDownconversionEnable = messageDownconversionEnable;
            MessageFormatVersion = messageFormatVersion;
            MessageTimestampDifferenceMaxMs = messageTimestampDifferenceMaxMs;
            MessageTimestampType = messageTimestampType;
            MinCleanableDirtyRatio = minCleanableDirtyRatio;
            MinCompactionLagMs = minCompactionLagMs;
            MinInsyncReplicas = minInsyncReplicas;
            Preallocate = preallocate;
            RetentionBytes = retentionBytes;
            RetentionMs = retentionMs;
            SegmentBytes = segmentBytes;
            SegmentIndexBytes = segmentIndexBytes;
            SegmentJitterMs = segmentJitterMs;
            SegmentMs = segmentMs;
            UncleanLeaderElectionEnable = uncleanLeaderElectionEnable;
        }
    }
}
