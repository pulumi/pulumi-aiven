// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aiven.inputs;

import com.pulumi.aiven.inputs.GetKafkaTopicListTopicTagArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class GetKafkaTopicListTopicArgs extends com.pulumi.resources.ResourceArgs {

    public static final GetKafkaTopicListTopicArgs Empty = new GetKafkaTopicListTopicArgs();

    /**
     * The retention policy to use on old segments. Possible values include &#39;delete&#39;, &#39;compact&#39;, or a comma-separated list of them. The default policy (&#39;delete&#39;) will discard old segments when their retention time or size limit has been reached. The &#39;compact&#39; setting will enable log compaction on the topic.
     * 
     */
    @Import(name="cleanupPolicy", required=true)
    private Output<String> cleanupPolicy;

    /**
     * @return The retention policy to use on old segments. Possible values include &#39;delete&#39;, &#39;compact&#39;, or a comma-separated list of them. The default policy (&#39;delete&#39;) will discard old segments when their retention time or size limit has been reached. The &#39;compact&#39; setting will enable log compaction on the topic.
     * 
     */
    public Output<String> cleanupPolicy() {
        return this.cleanupPolicy;
    }

    /**
     * Indicates whether diskless should be enabled. This is only available for BYOC services with Diskless feature enabled.
     * 
     */
    @Import(name="disklessEnable", required=true)
    private Output<Boolean> disklessEnable;

    /**
     * @return Indicates whether diskless should be enabled. This is only available for BYOC services with Diskless feature enabled.
     * 
     */
    public Output<Boolean> disklessEnable() {
        return this.disklessEnable;
    }

    /**
     * When a producer sets acks to &#39;all&#39; (or &#39;-1&#39;), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. If this minimum cannot be met, then the producer will raise an exception (either NotEnoughReplicas or NotEnoughReplicasAfterAppend). When used together, min.insync.replicas and acks allow you to enforce greater durability guarantees. A typical scenario would be to create a topic with a replication factor of 3, set min.insync.replicas to 2, and produce with acks of &#39;all&#39;. This will ensure that the producer raises an exception if a majority of replicas do not receive a write.
     * 
     */
    @Import(name="minInsyncReplicas", required=true)
    private Output<Integer> minInsyncReplicas;

    /**
     * @return When a producer sets acks to &#39;all&#39; (or &#39;-1&#39;), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. If this minimum cannot be met, then the producer will raise an exception (either NotEnoughReplicas or NotEnoughReplicasAfterAppend). When used together, min.insync.replicas and acks allow you to enforce greater durability guarantees. A typical scenario would be to create a topic with a replication factor of 3, set min.insync.replicas to 2, and produce with acks of &#39;all&#39;. This will ensure that the producer raises an exception if a majority of replicas do not receive a write.
     * 
     */
    public Output<Integer> minInsyncReplicas() {
        return this.minInsyncReplicas;
    }

    /**
     * The user group that owns this topic.
     * 
     */
    @Import(name="ownerUserGroupId", required=true)
    private Output<String> ownerUserGroupId;

    /**
     * @return The user group that owns this topic.
     * 
     */
    public Output<String> ownerUserGroupId() {
        return this.ownerUserGroupId;
    }

    /**
     * Number of partitions.
     * 
     */
    @Import(name="partitions", required=true)
    private Output<Integer> partitions;

    /**
     * @return Number of partitions.
     * 
     */
    public Output<Integer> partitions() {
        return this.partitions;
    }

    /**
     * Indicates whether tiered storage should be enabled. This is only available for services with Tiered Storage feature enabled.
     * 
     */
    @Import(name="remoteStorageEnable", required=true)
    private Output<Boolean> remoteStorageEnable;

    /**
     * @return Indicates whether tiered storage should be enabled. This is only available for services with Tiered Storage feature enabled.
     * 
     */
    public Output<Boolean> remoteStorageEnable() {
        return this.remoteStorageEnable;
    }

    /**
     * Number of replicas.
     * 
     */
    @Import(name="replication", required=true)
    private Output<Integer> replication;

    /**
     * @return Number of replicas.
     * 
     */
    public Output<Integer> replication() {
        return this.replication;
    }

    /**
     * This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the &#39;delete&#39; retention policy. By default there is no size limit only a time limit. Since this limit is enforced at the partition level, multiply it by the number of partitions to compute the topic retention in bytes.
     * 
     */
    @Import(name="retentionBytes", required=true)
    private Output<Integer> retentionBytes;

    /**
     * @return This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the &#39;delete&#39; retention policy. By default there is no size limit only a time limit. Since this limit is enforced at the partition level, multiply it by the number of partitions to compute the topic retention in bytes.
     * 
     */
    public Output<Integer> retentionBytes() {
        return this.retentionBytes;
    }

    /**
     * Retention period (hours).
     * 
     */
    @Import(name="retentionHours", required=true)
    private Output<Integer> retentionHours;

    /**
     * @return Retention period (hours).
     * 
     */
    public Output<Integer> retentionHours() {
        return this.retentionHours;
    }

    /**
     * Topic state. The possible values are `ACTIVE`, `CONFIGURING` and `DELETING`.
     * 
     */
    @Import(name="state", required=true)
    private Output<String> state;

    /**
     * @return Topic state. The possible values are `ACTIVE`, `CONFIGURING` and `DELETING`.
     * 
     */
    public Output<String> state() {
        return this.state;
    }

    /**
     * Topic tags.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<List<GetKafkaTopicListTopicTagArgs>> tags;

    /**
     * @return Topic tags.
     * 
     */
    public Optional<Output<List<GetKafkaTopicListTopicTagArgs>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * Topic description.
     * 
     */
    @Import(name="topicDescription", required=true)
    private Output<String> topicDescription;

    /**
     * @return Topic description.
     * 
     */
    public Output<String> topicDescription() {
        return this.topicDescription;
    }

    /**
     * Topic name.
     * 
     */
    @Import(name="topicName", required=true)
    private Output<String> topicName;

    /**
     * @return Topic name.
     * 
     */
    public Output<String> topicName() {
        return this.topicName;
    }

    private GetKafkaTopicListTopicArgs() {}

    private GetKafkaTopicListTopicArgs(GetKafkaTopicListTopicArgs $) {
        this.cleanupPolicy = $.cleanupPolicy;
        this.disklessEnable = $.disklessEnable;
        this.minInsyncReplicas = $.minInsyncReplicas;
        this.ownerUserGroupId = $.ownerUserGroupId;
        this.partitions = $.partitions;
        this.remoteStorageEnable = $.remoteStorageEnable;
        this.replication = $.replication;
        this.retentionBytes = $.retentionBytes;
        this.retentionHours = $.retentionHours;
        this.state = $.state;
        this.tags = $.tags;
        this.topicDescription = $.topicDescription;
        this.topicName = $.topicName;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(GetKafkaTopicListTopicArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private GetKafkaTopicListTopicArgs $;

        public Builder() {
            $ = new GetKafkaTopicListTopicArgs();
        }

        public Builder(GetKafkaTopicListTopicArgs defaults) {
            $ = new GetKafkaTopicListTopicArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param cleanupPolicy The retention policy to use on old segments. Possible values include &#39;delete&#39;, &#39;compact&#39;, or a comma-separated list of them. The default policy (&#39;delete&#39;) will discard old segments when their retention time or size limit has been reached. The &#39;compact&#39; setting will enable log compaction on the topic.
         * 
         * @return builder
         * 
         */
        public Builder cleanupPolicy(Output<String> cleanupPolicy) {
            $.cleanupPolicy = cleanupPolicy;
            return this;
        }

        /**
         * @param cleanupPolicy The retention policy to use on old segments. Possible values include &#39;delete&#39;, &#39;compact&#39;, or a comma-separated list of them. The default policy (&#39;delete&#39;) will discard old segments when their retention time or size limit has been reached. The &#39;compact&#39; setting will enable log compaction on the topic.
         * 
         * @return builder
         * 
         */
        public Builder cleanupPolicy(String cleanupPolicy) {
            return cleanupPolicy(Output.of(cleanupPolicy));
        }

        /**
         * @param disklessEnable Indicates whether diskless should be enabled. This is only available for BYOC services with Diskless feature enabled.
         * 
         * @return builder
         * 
         */
        public Builder disklessEnable(Output<Boolean> disklessEnable) {
            $.disklessEnable = disklessEnable;
            return this;
        }

        /**
         * @param disklessEnable Indicates whether diskless should be enabled. This is only available for BYOC services with Diskless feature enabled.
         * 
         * @return builder
         * 
         */
        public Builder disklessEnable(Boolean disklessEnable) {
            return disklessEnable(Output.of(disklessEnable));
        }

        /**
         * @param minInsyncReplicas When a producer sets acks to &#39;all&#39; (or &#39;-1&#39;), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. If this minimum cannot be met, then the producer will raise an exception (either NotEnoughReplicas or NotEnoughReplicasAfterAppend). When used together, min.insync.replicas and acks allow you to enforce greater durability guarantees. A typical scenario would be to create a topic with a replication factor of 3, set min.insync.replicas to 2, and produce with acks of &#39;all&#39;. This will ensure that the producer raises an exception if a majority of replicas do not receive a write.
         * 
         * @return builder
         * 
         */
        public Builder minInsyncReplicas(Output<Integer> minInsyncReplicas) {
            $.minInsyncReplicas = minInsyncReplicas;
            return this;
        }

        /**
         * @param minInsyncReplicas When a producer sets acks to &#39;all&#39; (or &#39;-1&#39;), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. If this minimum cannot be met, then the producer will raise an exception (either NotEnoughReplicas or NotEnoughReplicasAfterAppend). When used together, min.insync.replicas and acks allow you to enforce greater durability guarantees. A typical scenario would be to create a topic with a replication factor of 3, set min.insync.replicas to 2, and produce with acks of &#39;all&#39;. This will ensure that the producer raises an exception if a majority of replicas do not receive a write.
         * 
         * @return builder
         * 
         */
        public Builder minInsyncReplicas(Integer minInsyncReplicas) {
            return minInsyncReplicas(Output.of(minInsyncReplicas));
        }

        /**
         * @param ownerUserGroupId The user group that owns this topic.
         * 
         * @return builder
         * 
         */
        public Builder ownerUserGroupId(Output<String> ownerUserGroupId) {
            $.ownerUserGroupId = ownerUserGroupId;
            return this;
        }

        /**
         * @param ownerUserGroupId The user group that owns this topic.
         * 
         * @return builder
         * 
         */
        public Builder ownerUserGroupId(String ownerUserGroupId) {
            return ownerUserGroupId(Output.of(ownerUserGroupId));
        }

        /**
         * @param partitions Number of partitions.
         * 
         * @return builder
         * 
         */
        public Builder partitions(Output<Integer> partitions) {
            $.partitions = partitions;
            return this;
        }

        /**
         * @param partitions Number of partitions.
         * 
         * @return builder
         * 
         */
        public Builder partitions(Integer partitions) {
            return partitions(Output.of(partitions));
        }

        /**
         * @param remoteStorageEnable Indicates whether tiered storage should be enabled. This is only available for services with Tiered Storage feature enabled.
         * 
         * @return builder
         * 
         */
        public Builder remoteStorageEnable(Output<Boolean> remoteStorageEnable) {
            $.remoteStorageEnable = remoteStorageEnable;
            return this;
        }

        /**
         * @param remoteStorageEnable Indicates whether tiered storage should be enabled. This is only available for services with Tiered Storage feature enabled.
         * 
         * @return builder
         * 
         */
        public Builder remoteStorageEnable(Boolean remoteStorageEnable) {
            return remoteStorageEnable(Output.of(remoteStorageEnable));
        }

        /**
         * @param replication Number of replicas.
         * 
         * @return builder
         * 
         */
        public Builder replication(Output<Integer> replication) {
            $.replication = replication;
            return this;
        }

        /**
         * @param replication Number of replicas.
         * 
         * @return builder
         * 
         */
        public Builder replication(Integer replication) {
            return replication(Output.of(replication));
        }

        /**
         * @param retentionBytes This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the &#39;delete&#39; retention policy. By default there is no size limit only a time limit. Since this limit is enforced at the partition level, multiply it by the number of partitions to compute the topic retention in bytes.
         * 
         * @return builder
         * 
         */
        public Builder retentionBytes(Output<Integer> retentionBytes) {
            $.retentionBytes = retentionBytes;
            return this;
        }

        /**
         * @param retentionBytes This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the &#39;delete&#39; retention policy. By default there is no size limit only a time limit. Since this limit is enforced at the partition level, multiply it by the number of partitions to compute the topic retention in bytes.
         * 
         * @return builder
         * 
         */
        public Builder retentionBytes(Integer retentionBytes) {
            return retentionBytes(Output.of(retentionBytes));
        }

        /**
         * @param retentionHours Retention period (hours).
         * 
         * @return builder
         * 
         */
        public Builder retentionHours(Output<Integer> retentionHours) {
            $.retentionHours = retentionHours;
            return this;
        }

        /**
         * @param retentionHours Retention period (hours).
         * 
         * @return builder
         * 
         */
        public Builder retentionHours(Integer retentionHours) {
            return retentionHours(Output.of(retentionHours));
        }

        /**
         * @param state Topic state. The possible values are `ACTIVE`, `CONFIGURING` and `DELETING`.
         * 
         * @return builder
         * 
         */
        public Builder state(Output<String> state) {
            $.state = state;
            return this;
        }

        /**
         * @param state Topic state. The possible values are `ACTIVE`, `CONFIGURING` and `DELETING`.
         * 
         * @return builder
         * 
         */
        public Builder state(String state) {
            return state(Output.of(state));
        }

        /**
         * @param tags Topic tags.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<List<GetKafkaTopicListTopicTagArgs>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags Topic tags.
         * 
         * @return builder
         * 
         */
        public Builder tags(List<GetKafkaTopicListTopicTagArgs> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param tags Topic tags.
         * 
         * @return builder
         * 
         */
        public Builder tags(GetKafkaTopicListTopicTagArgs... tags) {
            return tags(List.of(tags));
        }

        /**
         * @param topicDescription Topic description.
         * 
         * @return builder
         * 
         */
        public Builder topicDescription(Output<String> topicDescription) {
            $.topicDescription = topicDescription;
            return this;
        }

        /**
         * @param topicDescription Topic description.
         * 
         * @return builder
         * 
         */
        public Builder topicDescription(String topicDescription) {
            return topicDescription(Output.of(topicDescription));
        }

        /**
         * @param topicName Topic name.
         * 
         * @return builder
         * 
         */
        public Builder topicName(Output<String> topicName) {
            $.topicName = topicName;
            return this;
        }

        /**
         * @param topicName Topic name.
         * 
         * @return builder
         * 
         */
        public Builder topicName(String topicName) {
            return topicName(Output.of(topicName));
        }

        public GetKafkaTopicListTopicArgs build() {
            if ($.cleanupPolicy == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopicArgs", "cleanupPolicy");
            }
            if ($.disklessEnable == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopicArgs", "disklessEnable");
            }
            if ($.minInsyncReplicas == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopicArgs", "minInsyncReplicas");
            }
            if ($.ownerUserGroupId == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopicArgs", "ownerUserGroupId");
            }
            if ($.partitions == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopicArgs", "partitions");
            }
            if ($.remoteStorageEnable == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopicArgs", "remoteStorageEnable");
            }
            if ($.replication == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopicArgs", "replication");
            }
            if ($.retentionBytes == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopicArgs", "retentionBytes");
            }
            if ($.retentionHours == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopicArgs", "retentionHours");
            }
            if ($.state == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopicArgs", "state");
            }
            if ($.topicDescription == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopicArgs", "topicDescription");
            }
            if ($.topicName == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopicArgs", "topicName");
            }
            return $;
        }
    }

}
