// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aiven.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetMirrorMakerReplicationFlowResult {
    /**
     * @return List of topic configuration properties and regular expressions to not replicate. The properties that are not replicated by default are: `follower.replication.throttled.replicas`, `leader.replication.throttled.replicas`, `message.timestamp.difference.max.ms`, `message.timestamp.type`, `unclean.leader.election.enable`, and `min.insync.replicas`. Setting this overrides the defaults. For example, to enable replication for &#39;min.insync.replicas&#39; and &#39;unclean.leader.election.enable&#39; set this to: [&#34;follower\\.replication\\.throttled\\.replicas&#34;, &#34;leader\\.replication\\.throttled\\.replicas&#34;, &#34;message\\.timestamp\\.difference\\.max\\.ms&#34;,  &#34;message\\.timestamp\\.type&#34;]
     * 
     */
    private List<String> configPropertiesExcludes;
    /**
     * @return Enables emitting heartbeats to the direction opposite to the flow, i.e. to the source cluster. The default value is `false`.
     * 
     */
    private Boolean emitBackwardHeartbeatsEnabled;
    /**
     * @return Enables emitting heartbeats to the target cluster. The default value is `false`.
     * 
     */
    private Boolean emitHeartbeatsEnabled;
    /**
     * @return Enables replication flow for a service.
     * 
     */
    private Boolean enable;
    /**
     * @return Enables exactly-once message delivery. Set this to `enabled` for new replications. The default value is `false`.
     * 
     */
    private Boolean exactlyOnceDeliveryEnabled;
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    private String id;
    /**
     * @return Offset syncs topic location. The possible values are `source` and `target`.
     * 
     */
    private String offsetSyncsTopicLocation;
    /**
     * @return The name of the project this resource belongs to. To set up proper dependencies please refer to this variable as a reference. Changing this property forces recreation of the resource.
     * 
     */
    private String project;
    /**
     * @return Replication factor, `&gt;= 1`.
     * 
     */
    private Integer replicationFactor;
    /**
     * @return Replication policy class. The possible values are `org.apache.kafka.connect.mirror.DefaultReplicationPolicy` and `org.apache.kafka.connect.mirror.IdentityReplicationPolicy`. The default value is `org.apache.kafka.connect.mirror.DefaultReplicationPolicy`.
     * 
     */
    private String replicationPolicyClass;
    /**
     * @return The name of the project this resource belongs to. To set up proper dependencies please refer to this variable as a reference. Changing this property forces recreation of the resource.
     * 
     */
    private String serviceName;
    /**
     * @return Source cluster alias. Maximum length: `128`.
     * 
     */
    private String sourceCluster;
    /**
     * @return Sync consumer group offsets. The default value is `false`.
     * 
     */
    private Boolean syncGroupOffsetsEnabled;
    /**
     * @return Frequency of consumer group offset sync. The default value is `1`.
     * 
     */
    private Integer syncGroupOffsetsIntervalSeconds;
    /**
     * @return Target cluster alias. Maximum length: `128`.
     * 
     */
    private String targetCluster;
    /**
     * @return The topics to include in the replica defined by a [list of regular expressions in Java format](https://aiven.io/docs/products/kafka/kafka-mirrormaker/concepts/replication-flow-topics-regex).
     * 
     */
    private List<String> topics;
    /**
     * @return The topics to exclude from the replica defined by a [list of regular expressions in Java format](https://aiven.io/docs/products/kafka/kafka-mirrormaker/concepts/replication-flow-topics-regex).
     * 
     */
    private List<String> topicsBlacklists;

    private GetMirrorMakerReplicationFlowResult() {}
    /**
     * @return List of topic configuration properties and regular expressions to not replicate. The properties that are not replicated by default are: `follower.replication.throttled.replicas`, `leader.replication.throttled.replicas`, `message.timestamp.difference.max.ms`, `message.timestamp.type`, `unclean.leader.election.enable`, and `min.insync.replicas`. Setting this overrides the defaults. For example, to enable replication for &#39;min.insync.replicas&#39; and &#39;unclean.leader.election.enable&#39; set this to: [&#34;follower\\.replication\\.throttled\\.replicas&#34;, &#34;leader\\.replication\\.throttled\\.replicas&#34;, &#34;message\\.timestamp\\.difference\\.max\\.ms&#34;,  &#34;message\\.timestamp\\.type&#34;]
     * 
     */
    public List<String> configPropertiesExcludes() {
        return this.configPropertiesExcludes;
    }
    /**
     * @return Enables emitting heartbeats to the direction opposite to the flow, i.e. to the source cluster. The default value is `false`.
     * 
     */
    public Boolean emitBackwardHeartbeatsEnabled() {
        return this.emitBackwardHeartbeatsEnabled;
    }
    /**
     * @return Enables emitting heartbeats to the target cluster. The default value is `false`.
     * 
     */
    public Boolean emitHeartbeatsEnabled() {
        return this.emitHeartbeatsEnabled;
    }
    /**
     * @return Enables replication flow for a service.
     * 
     */
    public Boolean enable() {
        return this.enable;
    }
    /**
     * @return Enables exactly-once message delivery. Set this to `enabled` for new replications. The default value is `false`.
     * 
     */
    public Boolean exactlyOnceDeliveryEnabled() {
        return this.exactlyOnceDeliveryEnabled;
    }
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return Offset syncs topic location. The possible values are `source` and `target`.
     * 
     */
    public String offsetSyncsTopicLocation() {
        return this.offsetSyncsTopicLocation;
    }
    /**
     * @return The name of the project this resource belongs to. To set up proper dependencies please refer to this variable as a reference. Changing this property forces recreation of the resource.
     * 
     */
    public String project() {
        return this.project;
    }
    /**
     * @return Replication factor, `&gt;= 1`.
     * 
     */
    public Integer replicationFactor() {
        return this.replicationFactor;
    }
    /**
     * @return Replication policy class. The possible values are `org.apache.kafka.connect.mirror.DefaultReplicationPolicy` and `org.apache.kafka.connect.mirror.IdentityReplicationPolicy`. The default value is `org.apache.kafka.connect.mirror.DefaultReplicationPolicy`.
     * 
     */
    public String replicationPolicyClass() {
        return this.replicationPolicyClass;
    }
    /**
     * @return The name of the project this resource belongs to. To set up proper dependencies please refer to this variable as a reference. Changing this property forces recreation of the resource.
     * 
     */
    public String serviceName() {
        return this.serviceName;
    }
    /**
     * @return Source cluster alias. Maximum length: `128`.
     * 
     */
    public String sourceCluster() {
        return this.sourceCluster;
    }
    /**
     * @return Sync consumer group offsets. The default value is `false`.
     * 
     */
    public Boolean syncGroupOffsetsEnabled() {
        return this.syncGroupOffsetsEnabled;
    }
    /**
     * @return Frequency of consumer group offset sync. The default value is `1`.
     * 
     */
    public Integer syncGroupOffsetsIntervalSeconds() {
        return this.syncGroupOffsetsIntervalSeconds;
    }
    /**
     * @return Target cluster alias. Maximum length: `128`.
     * 
     */
    public String targetCluster() {
        return this.targetCluster;
    }
    /**
     * @return The topics to include in the replica defined by a [list of regular expressions in Java format](https://aiven.io/docs/products/kafka/kafka-mirrormaker/concepts/replication-flow-topics-regex).
     * 
     */
    public List<String> topics() {
        return this.topics;
    }
    /**
     * @return The topics to exclude from the replica defined by a [list of regular expressions in Java format](https://aiven.io/docs/products/kafka/kafka-mirrormaker/concepts/replication-flow-topics-regex).
     * 
     */
    public List<String> topicsBlacklists() {
        return this.topicsBlacklists;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetMirrorMakerReplicationFlowResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private List<String> configPropertiesExcludes;
        private Boolean emitBackwardHeartbeatsEnabled;
        private Boolean emitHeartbeatsEnabled;
        private Boolean enable;
        private Boolean exactlyOnceDeliveryEnabled;
        private String id;
        private String offsetSyncsTopicLocation;
        private String project;
        private Integer replicationFactor;
        private String replicationPolicyClass;
        private String serviceName;
        private String sourceCluster;
        private Boolean syncGroupOffsetsEnabled;
        private Integer syncGroupOffsetsIntervalSeconds;
        private String targetCluster;
        private List<String> topics;
        private List<String> topicsBlacklists;
        public Builder() {}
        public Builder(GetMirrorMakerReplicationFlowResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.configPropertiesExcludes = defaults.configPropertiesExcludes;
    	      this.emitBackwardHeartbeatsEnabled = defaults.emitBackwardHeartbeatsEnabled;
    	      this.emitHeartbeatsEnabled = defaults.emitHeartbeatsEnabled;
    	      this.enable = defaults.enable;
    	      this.exactlyOnceDeliveryEnabled = defaults.exactlyOnceDeliveryEnabled;
    	      this.id = defaults.id;
    	      this.offsetSyncsTopicLocation = defaults.offsetSyncsTopicLocation;
    	      this.project = defaults.project;
    	      this.replicationFactor = defaults.replicationFactor;
    	      this.replicationPolicyClass = defaults.replicationPolicyClass;
    	      this.serviceName = defaults.serviceName;
    	      this.sourceCluster = defaults.sourceCluster;
    	      this.syncGroupOffsetsEnabled = defaults.syncGroupOffsetsEnabled;
    	      this.syncGroupOffsetsIntervalSeconds = defaults.syncGroupOffsetsIntervalSeconds;
    	      this.targetCluster = defaults.targetCluster;
    	      this.topics = defaults.topics;
    	      this.topicsBlacklists = defaults.topicsBlacklists;
        }

        @CustomType.Setter
        public Builder configPropertiesExcludes(List<String> configPropertiesExcludes) {
            if (configPropertiesExcludes == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "configPropertiesExcludes");
            }
            this.configPropertiesExcludes = configPropertiesExcludes;
            return this;
        }
        public Builder configPropertiesExcludes(String... configPropertiesExcludes) {
            return configPropertiesExcludes(List.of(configPropertiesExcludes));
        }
        @CustomType.Setter
        public Builder emitBackwardHeartbeatsEnabled(Boolean emitBackwardHeartbeatsEnabled) {
            if (emitBackwardHeartbeatsEnabled == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "emitBackwardHeartbeatsEnabled");
            }
            this.emitBackwardHeartbeatsEnabled = emitBackwardHeartbeatsEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder emitHeartbeatsEnabled(Boolean emitHeartbeatsEnabled) {
            if (emitHeartbeatsEnabled == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "emitHeartbeatsEnabled");
            }
            this.emitHeartbeatsEnabled = emitHeartbeatsEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder enable(Boolean enable) {
            if (enable == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "enable");
            }
            this.enable = enable;
            return this;
        }
        @CustomType.Setter
        public Builder exactlyOnceDeliveryEnabled(Boolean exactlyOnceDeliveryEnabled) {
            if (exactlyOnceDeliveryEnabled == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "exactlyOnceDeliveryEnabled");
            }
            this.exactlyOnceDeliveryEnabled = exactlyOnceDeliveryEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder offsetSyncsTopicLocation(String offsetSyncsTopicLocation) {
            if (offsetSyncsTopicLocation == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "offsetSyncsTopicLocation");
            }
            this.offsetSyncsTopicLocation = offsetSyncsTopicLocation;
            return this;
        }
        @CustomType.Setter
        public Builder project(String project) {
            if (project == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "project");
            }
            this.project = project;
            return this;
        }
        @CustomType.Setter
        public Builder replicationFactor(Integer replicationFactor) {
            if (replicationFactor == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "replicationFactor");
            }
            this.replicationFactor = replicationFactor;
            return this;
        }
        @CustomType.Setter
        public Builder replicationPolicyClass(String replicationPolicyClass) {
            if (replicationPolicyClass == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "replicationPolicyClass");
            }
            this.replicationPolicyClass = replicationPolicyClass;
            return this;
        }
        @CustomType.Setter
        public Builder serviceName(String serviceName) {
            if (serviceName == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "serviceName");
            }
            this.serviceName = serviceName;
            return this;
        }
        @CustomType.Setter
        public Builder sourceCluster(String sourceCluster) {
            if (sourceCluster == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "sourceCluster");
            }
            this.sourceCluster = sourceCluster;
            return this;
        }
        @CustomType.Setter
        public Builder syncGroupOffsetsEnabled(Boolean syncGroupOffsetsEnabled) {
            if (syncGroupOffsetsEnabled == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "syncGroupOffsetsEnabled");
            }
            this.syncGroupOffsetsEnabled = syncGroupOffsetsEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder syncGroupOffsetsIntervalSeconds(Integer syncGroupOffsetsIntervalSeconds) {
            if (syncGroupOffsetsIntervalSeconds == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "syncGroupOffsetsIntervalSeconds");
            }
            this.syncGroupOffsetsIntervalSeconds = syncGroupOffsetsIntervalSeconds;
            return this;
        }
        @CustomType.Setter
        public Builder targetCluster(String targetCluster) {
            if (targetCluster == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "targetCluster");
            }
            this.targetCluster = targetCluster;
            return this;
        }
        @CustomType.Setter
        public Builder topics(List<String> topics) {
            if (topics == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "topics");
            }
            this.topics = topics;
            return this;
        }
        public Builder topics(String... topics) {
            return topics(List.of(topics));
        }
        @CustomType.Setter
        public Builder topicsBlacklists(List<String> topicsBlacklists) {
            if (topicsBlacklists == null) {
              throw new MissingRequiredPropertyException("GetMirrorMakerReplicationFlowResult", "topicsBlacklists");
            }
            this.topicsBlacklists = topicsBlacklists;
            return this;
        }
        public Builder topicsBlacklists(String... topicsBlacklists) {
            return topicsBlacklists(List.of(topicsBlacklists));
        }
        public GetMirrorMakerReplicationFlowResult build() {
            final var _resultValue = new GetMirrorMakerReplicationFlowResult();
            _resultValue.configPropertiesExcludes = configPropertiesExcludes;
            _resultValue.emitBackwardHeartbeatsEnabled = emitBackwardHeartbeatsEnabled;
            _resultValue.emitHeartbeatsEnabled = emitHeartbeatsEnabled;
            _resultValue.enable = enable;
            _resultValue.exactlyOnceDeliveryEnabled = exactlyOnceDeliveryEnabled;
            _resultValue.id = id;
            _resultValue.offsetSyncsTopicLocation = offsetSyncsTopicLocation;
            _resultValue.project = project;
            _resultValue.replicationFactor = replicationFactor;
            _resultValue.replicationPolicyClass = replicationPolicyClass;
            _resultValue.serviceName = serviceName;
            _resultValue.sourceCluster = sourceCluster;
            _resultValue.syncGroupOffsetsEnabled = syncGroupOffsetsEnabled;
            _resultValue.syncGroupOffsetsIntervalSeconds = syncGroupOffsetsIntervalSeconds;
            _resultValue.targetCluster = targetCluster;
            _resultValue.topics = topics;
            _resultValue.topicsBlacklists = topicsBlacklists;
            return _resultValue;
        }
    }
}
