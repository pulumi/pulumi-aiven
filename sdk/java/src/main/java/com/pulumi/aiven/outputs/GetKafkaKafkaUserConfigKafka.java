// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aiven.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetKafkaKafkaUserConfigKafka {
    private @Nullable Boolean autoCreateTopicsEnable;
    private @Nullable String compressionType;
    private @Nullable Integer connectionsMaxIdleMs;
    private @Nullable Integer defaultReplicationFactor;
    private @Nullable Integer groupInitialRebalanceDelayMs;
    private @Nullable Integer groupMaxSessionTimeoutMs;
    private @Nullable Integer groupMinSessionTimeoutMs;
    private @Nullable Integer logCleanerDeleteRetentionMs;
    private @Nullable Integer logCleanerMaxCompactionLagMs;
    private @Nullable Double logCleanerMinCleanableRatio;
    private @Nullable Integer logCleanerMinCompactionLagMs;
    private @Nullable String logCleanupPolicy;
    private @Nullable Integer logFlushIntervalMessages;
    private @Nullable Integer logFlushIntervalMs;
    private @Nullable Integer logIndexIntervalBytes;
    private @Nullable Integer logIndexSizeMaxBytes;
    private @Nullable Boolean logMessageDownconversionEnable;
    private @Nullable Integer logMessageTimestampDifferenceMaxMs;
    private @Nullable String logMessageTimestampType;
    private @Nullable Boolean logPreallocate;
    private @Nullable Integer logRetentionBytes;
    private @Nullable Integer logRetentionHours;
    private @Nullable Integer logRetentionMs;
    private @Nullable Integer logRollJitterMs;
    private @Nullable Integer logRollMs;
    private @Nullable Integer logSegmentBytes;
    private @Nullable Integer logSegmentDeleteDelayMs;
    private @Nullable Integer maxConnectionsPerIp;
    private @Nullable Integer maxIncrementalFetchSessionCacheSlots;
    private @Nullable Integer messageMaxBytes;
    private @Nullable Integer minInsyncReplicas;
    private @Nullable Integer numPartitions;
    private @Nullable Integer offsetsRetentionMinutes;
    private @Nullable Integer producerPurgatoryPurgeIntervalRequests;
    private @Nullable Integer replicaFetchMaxBytes;
    private @Nullable Integer replicaFetchResponseMaxBytes;
    private @Nullable Integer socketRequestMaxBytes;
    private @Nullable Integer transactionRemoveExpiredTransactionCleanupIntervalMs;
    private @Nullable Integer transactionStateLogSegmentBytes;

    private GetKafkaKafkaUserConfigKafka() {}
    public Optional<Boolean> autoCreateTopicsEnable() {
        return Optional.ofNullable(this.autoCreateTopicsEnable);
    }
    public Optional<String> compressionType() {
        return Optional.ofNullable(this.compressionType);
    }
    public Optional<Integer> connectionsMaxIdleMs() {
        return Optional.ofNullable(this.connectionsMaxIdleMs);
    }
    public Optional<Integer> defaultReplicationFactor() {
        return Optional.ofNullable(this.defaultReplicationFactor);
    }
    public Optional<Integer> groupInitialRebalanceDelayMs() {
        return Optional.ofNullable(this.groupInitialRebalanceDelayMs);
    }
    public Optional<Integer> groupMaxSessionTimeoutMs() {
        return Optional.ofNullable(this.groupMaxSessionTimeoutMs);
    }
    public Optional<Integer> groupMinSessionTimeoutMs() {
        return Optional.ofNullable(this.groupMinSessionTimeoutMs);
    }
    public Optional<Integer> logCleanerDeleteRetentionMs() {
        return Optional.ofNullable(this.logCleanerDeleteRetentionMs);
    }
    public Optional<Integer> logCleanerMaxCompactionLagMs() {
        return Optional.ofNullable(this.logCleanerMaxCompactionLagMs);
    }
    public Optional<Double> logCleanerMinCleanableRatio() {
        return Optional.ofNullable(this.logCleanerMinCleanableRatio);
    }
    public Optional<Integer> logCleanerMinCompactionLagMs() {
        return Optional.ofNullable(this.logCleanerMinCompactionLagMs);
    }
    public Optional<String> logCleanupPolicy() {
        return Optional.ofNullable(this.logCleanupPolicy);
    }
    public Optional<Integer> logFlushIntervalMessages() {
        return Optional.ofNullable(this.logFlushIntervalMessages);
    }
    public Optional<Integer> logFlushIntervalMs() {
        return Optional.ofNullable(this.logFlushIntervalMs);
    }
    public Optional<Integer> logIndexIntervalBytes() {
        return Optional.ofNullable(this.logIndexIntervalBytes);
    }
    public Optional<Integer> logIndexSizeMaxBytes() {
        return Optional.ofNullable(this.logIndexSizeMaxBytes);
    }
    public Optional<Boolean> logMessageDownconversionEnable() {
        return Optional.ofNullable(this.logMessageDownconversionEnable);
    }
    public Optional<Integer> logMessageTimestampDifferenceMaxMs() {
        return Optional.ofNullable(this.logMessageTimestampDifferenceMaxMs);
    }
    public Optional<String> logMessageTimestampType() {
        return Optional.ofNullable(this.logMessageTimestampType);
    }
    public Optional<Boolean> logPreallocate() {
        return Optional.ofNullable(this.logPreallocate);
    }
    public Optional<Integer> logRetentionBytes() {
        return Optional.ofNullable(this.logRetentionBytes);
    }
    public Optional<Integer> logRetentionHours() {
        return Optional.ofNullable(this.logRetentionHours);
    }
    public Optional<Integer> logRetentionMs() {
        return Optional.ofNullable(this.logRetentionMs);
    }
    public Optional<Integer> logRollJitterMs() {
        return Optional.ofNullable(this.logRollJitterMs);
    }
    public Optional<Integer> logRollMs() {
        return Optional.ofNullable(this.logRollMs);
    }
    public Optional<Integer> logSegmentBytes() {
        return Optional.ofNullable(this.logSegmentBytes);
    }
    public Optional<Integer> logSegmentDeleteDelayMs() {
        return Optional.ofNullable(this.logSegmentDeleteDelayMs);
    }
    public Optional<Integer> maxConnectionsPerIp() {
        return Optional.ofNullable(this.maxConnectionsPerIp);
    }
    public Optional<Integer> maxIncrementalFetchSessionCacheSlots() {
        return Optional.ofNullable(this.maxIncrementalFetchSessionCacheSlots);
    }
    public Optional<Integer> messageMaxBytes() {
        return Optional.ofNullable(this.messageMaxBytes);
    }
    public Optional<Integer> minInsyncReplicas() {
        return Optional.ofNullable(this.minInsyncReplicas);
    }
    public Optional<Integer> numPartitions() {
        return Optional.ofNullable(this.numPartitions);
    }
    public Optional<Integer> offsetsRetentionMinutes() {
        return Optional.ofNullable(this.offsetsRetentionMinutes);
    }
    public Optional<Integer> producerPurgatoryPurgeIntervalRequests() {
        return Optional.ofNullable(this.producerPurgatoryPurgeIntervalRequests);
    }
    public Optional<Integer> replicaFetchMaxBytes() {
        return Optional.ofNullable(this.replicaFetchMaxBytes);
    }
    public Optional<Integer> replicaFetchResponseMaxBytes() {
        return Optional.ofNullable(this.replicaFetchResponseMaxBytes);
    }
    public Optional<Integer> socketRequestMaxBytes() {
        return Optional.ofNullable(this.socketRequestMaxBytes);
    }
    public Optional<Integer> transactionRemoveExpiredTransactionCleanupIntervalMs() {
        return Optional.ofNullable(this.transactionRemoveExpiredTransactionCleanupIntervalMs);
    }
    public Optional<Integer> transactionStateLogSegmentBytes() {
        return Optional.ofNullable(this.transactionStateLogSegmentBytes);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetKafkaKafkaUserConfigKafka defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable Boolean autoCreateTopicsEnable;
        private @Nullable String compressionType;
        private @Nullable Integer connectionsMaxIdleMs;
        private @Nullable Integer defaultReplicationFactor;
        private @Nullable Integer groupInitialRebalanceDelayMs;
        private @Nullable Integer groupMaxSessionTimeoutMs;
        private @Nullable Integer groupMinSessionTimeoutMs;
        private @Nullable Integer logCleanerDeleteRetentionMs;
        private @Nullable Integer logCleanerMaxCompactionLagMs;
        private @Nullable Double logCleanerMinCleanableRatio;
        private @Nullable Integer logCleanerMinCompactionLagMs;
        private @Nullable String logCleanupPolicy;
        private @Nullable Integer logFlushIntervalMessages;
        private @Nullable Integer logFlushIntervalMs;
        private @Nullable Integer logIndexIntervalBytes;
        private @Nullable Integer logIndexSizeMaxBytes;
        private @Nullable Boolean logMessageDownconversionEnable;
        private @Nullable Integer logMessageTimestampDifferenceMaxMs;
        private @Nullable String logMessageTimestampType;
        private @Nullable Boolean logPreallocate;
        private @Nullable Integer logRetentionBytes;
        private @Nullable Integer logRetentionHours;
        private @Nullable Integer logRetentionMs;
        private @Nullable Integer logRollJitterMs;
        private @Nullable Integer logRollMs;
        private @Nullable Integer logSegmentBytes;
        private @Nullable Integer logSegmentDeleteDelayMs;
        private @Nullable Integer maxConnectionsPerIp;
        private @Nullable Integer maxIncrementalFetchSessionCacheSlots;
        private @Nullable Integer messageMaxBytes;
        private @Nullable Integer minInsyncReplicas;
        private @Nullable Integer numPartitions;
        private @Nullable Integer offsetsRetentionMinutes;
        private @Nullable Integer producerPurgatoryPurgeIntervalRequests;
        private @Nullable Integer replicaFetchMaxBytes;
        private @Nullable Integer replicaFetchResponseMaxBytes;
        private @Nullable Integer socketRequestMaxBytes;
        private @Nullable Integer transactionRemoveExpiredTransactionCleanupIntervalMs;
        private @Nullable Integer transactionStateLogSegmentBytes;
        public Builder() {}
        public Builder(GetKafkaKafkaUserConfigKafka defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.autoCreateTopicsEnable = defaults.autoCreateTopicsEnable;
    	      this.compressionType = defaults.compressionType;
    	      this.connectionsMaxIdleMs = defaults.connectionsMaxIdleMs;
    	      this.defaultReplicationFactor = defaults.defaultReplicationFactor;
    	      this.groupInitialRebalanceDelayMs = defaults.groupInitialRebalanceDelayMs;
    	      this.groupMaxSessionTimeoutMs = defaults.groupMaxSessionTimeoutMs;
    	      this.groupMinSessionTimeoutMs = defaults.groupMinSessionTimeoutMs;
    	      this.logCleanerDeleteRetentionMs = defaults.logCleanerDeleteRetentionMs;
    	      this.logCleanerMaxCompactionLagMs = defaults.logCleanerMaxCompactionLagMs;
    	      this.logCleanerMinCleanableRatio = defaults.logCleanerMinCleanableRatio;
    	      this.logCleanerMinCompactionLagMs = defaults.logCleanerMinCompactionLagMs;
    	      this.logCleanupPolicy = defaults.logCleanupPolicy;
    	      this.logFlushIntervalMessages = defaults.logFlushIntervalMessages;
    	      this.logFlushIntervalMs = defaults.logFlushIntervalMs;
    	      this.logIndexIntervalBytes = defaults.logIndexIntervalBytes;
    	      this.logIndexSizeMaxBytes = defaults.logIndexSizeMaxBytes;
    	      this.logMessageDownconversionEnable = defaults.logMessageDownconversionEnable;
    	      this.logMessageTimestampDifferenceMaxMs = defaults.logMessageTimestampDifferenceMaxMs;
    	      this.logMessageTimestampType = defaults.logMessageTimestampType;
    	      this.logPreallocate = defaults.logPreallocate;
    	      this.logRetentionBytes = defaults.logRetentionBytes;
    	      this.logRetentionHours = defaults.logRetentionHours;
    	      this.logRetentionMs = defaults.logRetentionMs;
    	      this.logRollJitterMs = defaults.logRollJitterMs;
    	      this.logRollMs = defaults.logRollMs;
    	      this.logSegmentBytes = defaults.logSegmentBytes;
    	      this.logSegmentDeleteDelayMs = defaults.logSegmentDeleteDelayMs;
    	      this.maxConnectionsPerIp = defaults.maxConnectionsPerIp;
    	      this.maxIncrementalFetchSessionCacheSlots = defaults.maxIncrementalFetchSessionCacheSlots;
    	      this.messageMaxBytes = defaults.messageMaxBytes;
    	      this.minInsyncReplicas = defaults.minInsyncReplicas;
    	      this.numPartitions = defaults.numPartitions;
    	      this.offsetsRetentionMinutes = defaults.offsetsRetentionMinutes;
    	      this.producerPurgatoryPurgeIntervalRequests = defaults.producerPurgatoryPurgeIntervalRequests;
    	      this.replicaFetchMaxBytes = defaults.replicaFetchMaxBytes;
    	      this.replicaFetchResponseMaxBytes = defaults.replicaFetchResponseMaxBytes;
    	      this.socketRequestMaxBytes = defaults.socketRequestMaxBytes;
    	      this.transactionRemoveExpiredTransactionCleanupIntervalMs = defaults.transactionRemoveExpiredTransactionCleanupIntervalMs;
    	      this.transactionStateLogSegmentBytes = defaults.transactionStateLogSegmentBytes;
        }

        @CustomType.Setter
        public Builder autoCreateTopicsEnable(@Nullable Boolean autoCreateTopicsEnable) {
            this.autoCreateTopicsEnable = autoCreateTopicsEnable;
            return this;
        }
        @CustomType.Setter
        public Builder compressionType(@Nullable String compressionType) {
            this.compressionType = compressionType;
            return this;
        }
        @CustomType.Setter
        public Builder connectionsMaxIdleMs(@Nullable Integer connectionsMaxIdleMs) {
            this.connectionsMaxIdleMs = connectionsMaxIdleMs;
            return this;
        }
        @CustomType.Setter
        public Builder defaultReplicationFactor(@Nullable Integer defaultReplicationFactor) {
            this.defaultReplicationFactor = defaultReplicationFactor;
            return this;
        }
        @CustomType.Setter
        public Builder groupInitialRebalanceDelayMs(@Nullable Integer groupInitialRebalanceDelayMs) {
            this.groupInitialRebalanceDelayMs = groupInitialRebalanceDelayMs;
            return this;
        }
        @CustomType.Setter
        public Builder groupMaxSessionTimeoutMs(@Nullable Integer groupMaxSessionTimeoutMs) {
            this.groupMaxSessionTimeoutMs = groupMaxSessionTimeoutMs;
            return this;
        }
        @CustomType.Setter
        public Builder groupMinSessionTimeoutMs(@Nullable Integer groupMinSessionTimeoutMs) {
            this.groupMinSessionTimeoutMs = groupMinSessionTimeoutMs;
            return this;
        }
        @CustomType.Setter
        public Builder logCleanerDeleteRetentionMs(@Nullable Integer logCleanerDeleteRetentionMs) {
            this.logCleanerDeleteRetentionMs = logCleanerDeleteRetentionMs;
            return this;
        }
        @CustomType.Setter
        public Builder logCleanerMaxCompactionLagMs(@Nullable Integer logCleanerMaxCompactionLagMs) {
            this.logCleanerMaxCompactionLagMs = logCleanerMaxCompactionLagMs;
            return this;
        }
        @CustomType.Setter
        public Builder logCleanerMinCleanableRatio(@Nullable Double logCleanerMinCleanableRatio) {
            this.logCleanerMinCleanableRatio = logCleanerMinCleanableRatio;
            return this;
        }
        @CustomType.Setter
        public Builder logCleanerMinCompactionLagMs(@Nullable Integer logCleanerMinCompactionLagMs) {
            this.logCleanerMinCompactionLagMs = logCleanerMinCompactionLagMs;
            return this;
        }
        @CustomType.Setter
        public Builder logCleanupPolicy(@Nullable String logCleanupPolicy) {
            this.logCleanupPolicy = logCleanupPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder logFlushIntervalMessages(@Nullable Integer logFlushIntervalMessages) {
            this.logFlushIntervalMessages = logFlushIntervalMessages;
            return this;
        }
        @CustomType.Setter
        public Builder logFlushIntervalMs(@Nullable Integer logFlushIntervalMs) {
            this.logFlushIntervalMs = logFlushIntervalMs;
            return this;
        }
        @CustomType.Setter
        public Builder logIndexIntervalBytes(@Nullable Integer logIndexIntervalBytes) {
            this.logIndexIntervalBytes = logIndexIntervalBytes;
            return this;
        }
        @CustomType.Setter
        public Builder logIndexSizeMaxBytes(@Nullable Integer logIndexSizeMaxBytes) {
            this.logIndexSizeMaxBytes = logIndexSizeMaxBytes;
            return this;
        }
        @CustomType.Setter
        public Builder logMessageDownconversionEnable(@Nullable Boolean logMessageDownconversionEnable) {
            this.logMessageDownconversionEnable = logMessageDownconversionEnable;
            return this;
        }
        @CustomType.Setter
        public Builder logMessageTimestampDifferenceMaxMs(@Nullable Integer logMessageTimestampDifferenceMaxMs) {
            this.logMessageTimestampDifferenceMaxMs = logMessageTimestampDifferenceMaxMs;
            return this;
        }
        @CustomType.Setter
        public Builder logMessageTimestampType(@Nullable String logMessageTimestampType) {
            this.logMessageTimestampType = logMessageTimestampType;
            return this;
        }
        @CustomType.Setter
        public Builder logPreallocate(@Nullable Boolean logPreallocate) {
            this.logPreallocate = logPreallocate;
            return this;
        }
        @CustomType.Setter
        public Builder logRetentionBytes(@Nullable Integer logRetentionBytes) {
            this.logRetentionBytes = logRetentionBytes;
            return this;
        }
        @CustomType.Setter
        public Builder logRetentionHours(@Nullable Integer logRetentionHours) {
            this.logRetentionHours = logRetentionHours;
            return this;
        }
        @CustomType.Setter
        public Builder logRetentionMs(@Nullable Integer logRetentionMs) {
            this.logRetentionMs = logRetentionMs;
            return this;
        }
        @CustomType.Setter
        public Builder logRollJitterMs(@Nullable Integer logRollJitterMs) {
            this.logRollJitterMs = logRollJitterMs;
            return this;
        }
        @CustomType.Setter
        public Builder logRollMs(@Nullable Integer logRollMs) {
            this.logRollMs = logRollMs;
            return this;
        }
        @CustomType.Setter
        public Builder logSegmentBytes(@Nullable Integer logSegmentBytes) {
            this.logSegmentBytes = logSegmentBytes;
            return this;
        }
        @CustomType.Setter
        public Builder logSegmentDeleteDelayMs(@Nullable Integer logSegmentDeleteDelayMs) {
            this.logSegmentDeleteDelayMs = logSegmentDeleteDelayMs;
            return this;
        }
        @CustomType.Setter
        public Builder maxConnectionsPerIp(@Nullable Integer maxConnectionsPerIp) {
            this.maxConnectionsPerIp = maxConnectionsPerIp;
            return this;
        }
        @CustomType.Setter
        public Builder maxIncrementalFetchSessionCacheSlots(@Nullable Integer maxIncrementalFetchSessionCacheSlots) {
            this.maxIncrementalFetchSessionCacheSlots = maxIncrementalFetchSessionCacheSlots;
            return this;
        }
        @CustomType.Setter
        public Builder messageMaxBytes(@Nullable Integer messageMaxBytes) {
            this.messageMaxBytes = messageMaxBytes;
            return this;
        }
        @CustomType.Setter
        public Builder minInsyncReplicas(@Nullable Integer minInsyncReplicas) {
            this.minInsyncReplicas = minInsyncReplicas;
            return this;
        }
        @CustomType.Setter
        public Builder numPartitions(@Nullable Integer numPartitions) {
            this.numPartitions = numPartitions;
            return this;
        }
        @CustomType.Setter
        public Builder offsetsRetentionMinutes(@Nullable Integer offsetsRetentionMinutes) {
            this.offsetsRetentionMinutes = offsetsRetentionMinutes;
            return this;
        }
        @CustomType.Setter
        public Builder producerPurgatoryPurgeIntervalRequests(@Nullable Integer producerPurgatoryPurgeIntervalRequests) {
            this.producerPurgatoryPurgeIntervalRequests = producerPurgatoryPurgeIntervalRequests;
            return this;
        }
        @CustomType.Setter
        public Builder replicaFetchMaxBytes(@Nullable Integer replicaFetchMaxBytes) {
            this.replicaFetchMaxBytes = replicaFetchMaxBytes;
            return this;
        }
        @CustomType.Setter
        public Builder replicaFetchResponseMaxBytes(@Nullable Integer replicaFetchResponseMaxBytes) {
            this.replicaFetchResponseMaxBytes = replicaFetchResponseMaxBytes;
            return this;
        }
        @CustomType.Setter
        public Builder socketRequestMaxBytes(@Nullable Integer socketRequestMaxBytes) {
            this.socketRequestMaxBytes = socketRequestMaxBytes;
            return this;
        }
        @CustomType.Setter
        public Builder transactionRemoveExpiredTransactionCleanupIntervalMs(@Nullable Integer transactionRemoveExpiredTransactionCleanupIntervalMs) {
            this.transactionRemoveExpiredTransactionCleanupIntervalMs = transactionRemoveExpiredTransactionCleanupIntervalMs;
            return this;
        }
        @CustomType.Setter
        public Builder transactionStateLogSegmentBytes(@Nullable Integer transactionStateLogSegmentBytes) {
            this.transactionStateLogSegmentBytes = transactionStateLogSegmentBytes;
            return this;
        }
        public GetKafkaKafkaUserConfigKafka build() {
            final var o = new GetKafkaKafkaUserConfigKafka();
            o.autoCreateTopicsEnable = autoCreateTopicsEnable;
            o.compressionType = compressionType;
            o.connectionsMaxIdleMs = connectionsMaxIdleMs;
            o.defaultReplicationFactor = defaultReplicationFactor;
            o.groupInitialRebalanceDelayMs = groupInitialRebalanceDelayMs;
            o.groupMaxSessionTimeoutMs = groupMaxSessionTimeoutMs;
            o.groupMinSessionTimeoutMs = groupMinSessionTimeoutMs;
            o.logCleanerDeleteRetentionMs = logCleanerDeleteRetentionMs;
            o.logCleanerMaxCompactionLagMs = logCleanerMaxCompactionLagMs;
            o.logCleanerMinCleanableRatio = logCleanerMinCleanableRatio;
            o.logCleanerMinCompactionLagMs = logCleanerMinCompactionLagMs;
            o.logCleanupPolicy = logCleanupPolicy;
            o.logFlushIntervalMessages = logFlushIntervalMessages;
            o.logFlushIntervalMs = logFlushIntervalMs;
            o.logIndexIntervalBytes = logIndexIntervalBytes;
            o.logIndexSizeMaxBytes = logIndexSizeMaxBytes;
            o.logMessageDownconversionEnable = logMessageDownconversionEnable;
            o.logMessageTimestampDifferenceMaxMs = logMessageTimestampDifferenceMaxMs;
            o.logMessageTimestampType = logMessageTimestampType;
            o.logPreallocate = logPreallocate;
            o.logRetentionBytes = logRetentionBytes;
            o.logRetentionHours = logRetentionHours;
            o.logRetentionMs = logRetentionMs;
            o.logRollJitterMs = logRollJitterMs;
            o.logRollMs = logRollMs;
            o.logSegmentBytes = logSegmentBytes;
            o.logSegmentDeleteDelayMs = logSegmentDeleteDelayMs;
            o.maxConnectionsPerIp = maxConnectionsPerIp;
            o.maxIncrementalFetchSessionCacheSlots = maxIncrementalFetchSessionCacheSlots;
            o.messageMaxBytes = messageMaxBytes;
            o.minInsyncReplicas = minInsyncReplicas;
            o.numPartitions = numPartitions;
            o.offsetsRetentionMinutes = offsetsRetentionMinutes;
            o.producerPurgatoryPurgeIntervalRequests = producerPurgatoryPurgeIntervalRequests;
            o.replicaFetchMaxBytes = replicaFetchMaxBytes;
            o.replicaFetchResponseMaxBytes = replicaFetchResponseMaxBytes;
            o.socketRequestMaxBytes = socketRequestMaxBytes;
            o.transactionRemoveExpiredTransactionCleanupIntervalMs = transactionRemoveExpiredTransactionCleanupIntervalMs;
            o.transactionStateLogSegmentBytes = transactionStateLogSegmentBytes;
            return o;
        }
    }
}
