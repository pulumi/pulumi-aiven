// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aiven.inputs;

import com.pulumi.aiven.inputs.GetKafkaTopicListTopicTag;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class GetKafkaTopicListTopic extends com.pulumi.resources.InvokeArgs {

    public static final GetKafkaTopicListTopic Empty = new GetKafkaTopicListTopic();

    /**
     * The retention policy to use on old segments. Possible values include &#39;delete&#39;, &#39;compact&#39;, or a comma-separated list of them. The default policy (&#39;delete&#39;) will discard old segments when their retention time or size limit has been reached. The &#39;compact&#39; setting will enable log compaction on the topic.
     * 
     */
    @Import(name="cleanupPolicy", required=true)
    private String cleanupPolicy;

    /**
     * @return The retention policy to use on old segments. Possible values include &#39;delete&#39;, &#39;compact&#39;, or a comma-separated list of them. The default policy (&#39;delete&#39;) will discard old segments when their retention time or size limit has been reached. The &#39;compact&#39; setting will enable log compaction on the topic.
     * 
     */
    public String cleanupPolicy() {
        return this.cleanupPolicy;
    }

    /**
     * Indicates whether diskless should be enabled. This is only available for BYOC services with Diskless feature enabled.
     * 
     */
    @Import(name="disklessEnable", required=true)
    private Boolean disklessEnable;

    /**
     * @return Indicates whether diskless should be enabled. This is only available for BYOC services with Diskless feature enabled.
     * 
     */
    public Boolean disklessEnable() {
        return this.disklessEnable;
    }

    /**
     * When a producer sets acks to &#39;all&#39; (or &#39;-1&#39;), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. If this minimum cannot be met, then the producer will raise an exception (either NotEnoughReplicas or NotEnoughReplicasAfterAppend). When used together, min.insync.replicas and acks allow you to enforce greater durability guarantees. A typical scenario would be to create a topic with a replication factor of 3, set min.insync.replicas to 2, and produce with acks of &#39;all&#39;. This will ensure that the producer raises an exception if a majority of replicas do not receive a write.
     * 
     */
    @Import(name="minInsyncReplicas", required=true)
    private Integer minInsyncReplicas;

    /**
     * @return When a producer sets acks to &#39;all&#39; (or &#39;-1&#39;), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. If this minimum cannot be met, then the producer will raise an exception (either NotEnoughReplicas or NotEnoughReplicasAfterAppend). When used together, min.insync.replicas and acks allow you to enforce greater durability guarantees. A typical scenario would be to create a topic with a replication factor of 3, set min.insync.replicas to 2, and produce with acks of &#39;all&#39;. This will ensure that the producer raises an exception if a majority of replicas do not receive a write.
     * 
     */
    public Integer minInsyncReplicas() {
        return this.minInsyncReplicas;
    }

    /**
     * The user group that owns this topic.
     * 
     */
    @Import(name="ownerUserGroupId", required=true)
    private String ownerUserGroupId;

    /**
     * @return The user group that owns this topic.
     * 
     */
    public String ownerUserGroupId() {
        return this.ownerUserGroupId;
    }

    /**
     * Number of partitions.
     * 
     */
    @Import(name="partitions", required=true)
    private Integer partitions;

    /**
     * @return Number of partitions.
     * 
     */
    public Integer partitions() {
        return this.partitions;
    }

    /**
     * Indicates whether tiered storage should be enabled. This is only available for services with Tiered Storage feature enabled.
     * 
     */
    @Import(name="remoteStorageEnable", required=true)
    private Boolean remoteStorageEnable;

    /**
     * @return Indicates whether tiered storage should be enabled. This is only available for services with Tiered Storage feature enabled.
     * 
     */
    public Boolean remoteStorageEnable() {
        return this.remoteStorageEnable;
    }

    /**
     * Number of replicas.
     * 
     */
    @Import(name="replication", required=true)
    private Integer replication;

    /**
     * @return Number of replicas.
     * 
     */
    public Integer replication() {
        return this.replication;
    }

    /**
     * This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the &#39;delete&#39; retention policy. By default there is no size limit only a time limit. Since this limit is enforced at the partition level, multiply it by the number of partitions to compute the topic retention in bytes.
     * 
     */
    @Import(name="retentionBytes", required=true)
    private Integer retentionBytes;

    /**
     * @return This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the &#39;delete&#39; retention policy. By default there is no size limit only a time limit. Since this limit is enforced at the partition level, multiply it by the number of partitions to compute the topic retention in bytes.
     * 
     */
    public Integer retentionBytes() {
        return this.retentionBytes;
    }

    /**
     * Retention period (hours).
     * 
     */
    @Import(name="retentionHours", required=true)
    private Integer retentionHours;

    /**
     * @return Retention period (hours).
     * 
     */
    public Integer retentionHours() {
        return this.retentionHours;
    }

    /**
     * Topic state. The possible values are `ACTIVE`, `CONFIGURING` and `DELETING`.
     * 
     */
    @Import(name="state", required=true)
    private String state;

    /**
     * @return Topic state. The possible values are `ACTIVE`, `CONFIGURING` and `DELETING`.
     * 
     */
    public String state() {
        return this.state;
    }

    /**
     * Topic tags.
     * 
     */
    @Import(name="tags")
    private @Nullable List<GetKafkaTopicListTopicTag> tags;

    /**
     * @return Topic tags.
     * 
     */
    public Optional<List<GetKafkaTopicListTopicTag>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * Topic description.
     * 
     */
    @Import(name="topicDescription", required=true)
    private String topicDescription;

    /**
     * @return Topic description.
     * 
     */
    public String topicDescription() {
        return this.topicDescription;
    }

    /**
     * Topic name.
     * 
     */
    @Import(name="topicName", required=true)
    private String topicName;

    /**
     * @return Topic name.
     * 
     */
    public String topicName() {
        return this.topicName;
    }

    private GetKafkaTopicListTopic() {}

    private GetKafkaTopicListTopic(GetKafkaTopicListTopic $) {
        this.cleanupPolicy = $.cleanupPolicy;
        this.disklessEnable = $.disklessEnable;
        this.minInsyncReplicas = $.minInsyncReplicas;
        this.ownerUserGroupId = $.ownerUserGroupId;
        this.partitions = $.partitions;
        this.remoteStorageEnable = $.remoteStorageEnable;
        this.replication = $.replication;
        this.retentionBytes = $.retentionBytes;
        this.retentionHours = $.retentionHours;
        this.state = $.state;
        this.tags = $.tags;
        this.topicDescription = $.topicDescription;
        this.topicName = $.topicName;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(GetKafkaTopicListTopic defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private GetKafkaTopicListTopic $;

        public Builder() {
            $ = new GetKafkaTopicListTopic();
        }

        public Builder(GetKafkaTopicListTopic defaults) {
            $ = new GetKafkaTopicListTopic(Objects.requireNonNull(defaults));
        }

        /**
         * @param cleanupPolicy The retention policy to use on old segments. Possible values include &#39;delete&#39;, &#39;compact&#39;, or a comma-separated list of them. The default policy (&#39;delete&#39;) will discard old segments when their retention time or size limit has been reached. The &#39;compact&#39; setting will enable log compaction on the topic.
         * 
         * @return builder
         * 
         */
        public Builder cleanupPolicy(String cleanupPolicy) {
            $.cleanupPolicy = cleanupPolicy;
            return this;
        }

        /**
         * @param disklessEnable Indicates whether diskless should be enabled. This is only available for BYOC services with Diskless feature enabled.
         * 
         * @return builder
         * 
         */
        public Builder disklessEnable(Boolean disklessEnable) {
            $.disklessEnable = disklessEnable;
            return this;
        }

        /**
         * @param minInsyncReplicas When a producer sets acks to &#39;all&#39; (or &#39;-1&#39;), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. If this minimum cannot be met, then the producer will raise an exception (either NotEnoughReplicas or NotEnoughReplicasAfterAppend). When used together, min.insync.replicas and acks allow you to enforce greater durability guarantees. A typical scenario would be to create a topic with a replication factor of 3, set min.insync.replicas to 2, and produce with acks of &#39;all&#39;. This will ensure that the producer raises an exception if a majority of replicas do not receive a write.
         * 
         * @return builder
         * 
         */
        public Builder minInsyncReplicas(Integer minInsyncReplicas) {
            $.minInsyncReplicas = minInsyncReplicas;
            return this;
        }

        /**
         * @param ownerUserGroupId The user group that owns this topic.
         * 
         * @return builder
         * 
         */
        public Builder ownerUserGroupId(String ownerUserGroupId) {
            $.ownerUserGroupId = ownerUserGroupId;
            return this;
        }

        /**
         * @param partitions Number of partitions.
         * 
         * @return builder
         * 
         */
        public Builder partitions(Integer partitions) {
            $.partitions = partitions;
            return this;
        }

        /**
         * @param remoteStorageEnable Indicates whether tiered storage should be enabled. This is only available for services with Tiered Storage feature enabled.
         * 
         * @return builder
         * 
         */
        public Builder remoteStorageEnable(Boolean remoteStorageEnable) {
            $.remoteStorageEnable = remoteStorageEnable;
            return this;
        }

        /**
         * @param replication Number of replicas.
         * 
         * @return builder
         * 
         */
        public Builder replication(Integer replication) {
            $.replication = replication;
            return this;
        }

        /**
         * @param retentionBytes This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the &#39;delete&#39; retention policy. By default there is no size limit only a time limit. Since this limit is enforced at the partition level, multiply it by the number of partitions to compute the topic retention in bytes.
         * 
         * @return builder
         * 
         */
        public Builder retentionBytes(Integer retentionBytes) {
            $.retentionBytes = retentionBytes;
            return this;
        }

        /**
         * @param retentionHours Retention period (hours).
         * 
         * @return builder
         * 
         */
        public Builder retentionHours(Integer retentionHours) {
            $.retentionHours = retentionHours;
            return this;
        }

        /**
         * @param state Topic state. The possible values are `ACTIVE`, `CONFIGURING` and `DELETING`.
         * 
         * @return builder
         * 
         */
        public Builder state(String state) {
            $.state = state;
            return this;
        }

        /**
         * @param tags Topic tags.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable List<GetKafkaTopicListTopicTag> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags Topic tags.
         * 
         * @return builder
         * 
         */
        public Builder tags(GetKafkaTopicListTopicTag... tags) {
            return tags(List.of(tags));
        }

        /**
         * @param topicDescription Topic description.
         * 
         * @return builder
         * 
         */
        public Builder topicDescription(String topicDescription) {
            $.topicDescription = topicDescription;
            return this;
        }

        /**
         * @param topicName Topic name.
         * 
         * @return builder
         * 
         */
        public Builder topicName(String topicName) {
            $.topicName = topicName;
            return this;
        }

        public GetKafkaTopicListTopic build() {
            if ($.cleanupPolicy == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "cleanupPolicy");
            }
            if ($.disklessEnable == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "disklessEnable");
            }
            if ($.minInsyncReplicas == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "minInsyncReplicas");
            }
            if ($.ownerUserGroupId == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "ownerUserGroupId");
            }
            if ($.partitions == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "partitions");
            }
            if ($.remoteStorageEnable == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "remoteStorageEnable");
            }
            if ($.replication == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "replication");
            }
            if ($.retentionBytes == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "retentionBytes");
            }
            if ($.retentionHours == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "retentionHours");
            }
            if ($.state == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "state");
            }
            if ($.topicDescription == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "topicDescription");
            }
            if ($.topicName == null) {
                throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "topicName");
            }
            return $;
        }
    }

}
