// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aiven.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetKafkaKafkaUserConfigKafkaRestConfig {
    /**
     * @return If true the consumer&#39;s offset will be periodically committed to Kafka in the background. Default: `true`.
     * 
     */
    private @Nullable Boolean consumerEnableAutoCommit;
    /**
     * @return Specifies the maximum duration (in seconds) a client can remain idle before it is deleted. If a consumer is inactive, it will exit the consumer group, and its state will be discarded. A value of 0 (default) indicates that the consumer will not be disconnected automatically due to inactivity. Default: `0`.
     * 
     */
    private @Nullable Integer consumerIdleDisconnectTimeout;
    /**
     * @return Maximum number of bytes in unencoded message keys and values by a single request. Default: `67108864`.
     * 
     */
    private @Nullable Integer consumerRequestMaxBytes;
    /**
     * @return Enum: `1000`, `15000`, `30000`. The maximum total time to wait for messages for a request if the maximum number of messages has not yet been reached. Default: `1000`.
     * 
     */
    private @Nullable Integer consumerRequestTimeoutMs;
    /**
     * @return Enum: `record_name`, `topic_name`, `topic_record_name`. Name strategy to use when selecting subject for storing schemas. Default: `topic_name`.
     * 
     */
    private @Nullable String nameStrategy;
    /**
     * @return If true, validate that given schema is registered under expected subject name by the used name strategy when producing messages. Default: `true`.
     * 
     */
    private @Nullable Boolean nameStrategyValidation;
    /**
     * @return Enum: `-1`, `0`, `1`, `all`. The number of acknowledgments the producer requires the leader to have received before considering a request complete. If set to `all` or `-1`, the leader will wait for the full set of in-sync replicas to acknowledge the record. Default: `1`.
     * 
     */
    private @Nullable String producerAcks;
    /**
     * @return Enum: `gzip`, `lz4`, `none`, `snappy`, `zstd`. Specify the default compression type for producers. This configuration accepts the standard compression codecs (`gzip`, `snappy`, `lz4`, `zstd`). It additionally accepts `none` which is the default and equivalent to no compression.
     * 
     */
    private @Nullable String producerCompressionType;
    /**
     * @return Wait for up to the given delay to allow batching records together. Default: `0`.
     * 
     */
    private @Nullable Integer producerLingerMs;
    /**
     * @return The maximum size of a request in bytes. Note that Kafka broker can also cap the record batch size. Default: `1048576`.
     * 
     */
    private @Nullable Integer producerMaxRequestSize;
    /**
     * @return Maximum number of SimpleConsumers that can be instantiated per broker. Default: `25`.
     * 
     */
    private @Nullable Integer simpleconsumerPoolSizeMax;

    private GetKafkaKafkaUserConfigKafkaRestConfig() {}
    /**
     * @return If true the consumer&#39;s offset will be periodically committed to Kafka in the background. Default: `true`.
     * 
     */
    public Optional<Boolean> consumerEnableAutoCommit() {
        return Optional.ofNullable(this.consumerEnableAutoCommit);
    }
    /**
     * @return Specifies the maximum duration (in seconds) a client can remain idle before it is deleted. If a consumer is inactive, it will exit the consumer group, and its state will be discarded. A value of 0 (default) indicates that the consumer will not be disconnected automatically due to inactivity. Default: `0`.
     * 
     */
    public Optional<Integer> consumerIdleDisconnectTimeout() {
        return Optional.ofNullable(this.consumerIdleDisconnectTimeout);
    }
    /**
     * @return Maximum number of bytes in unencoded message keys and values by a single request. Default: `67108864`.
     * 
     */
    public Optional<Integer> consumerRequestMaxBytes() {
        return Optional.ofNullable(this.consumerRequestMaxBytes);
    }
    /**
     * @return Enum: `1000`, `15000`, `30000`. The maximum total time to wait for messages for a request if the maximum number of messages has not yet been reached. Default: `1000`.
     * 
     */
    public Optional<Integer> consumerRequestTimeoutMs() {
        return Optional.ofNullable(this.consumerRequestTimeoutMs);
    }
    /**
     * @return Enum: `record_name`, `topic_name`, `topic_record_name`. Name strategy to use when selecting subject for storing schemas. Default: `topic_name`.
     * 
     */
    public Optional<String> nameStrategy() {
        return Optional.ofNullable(this.nameStrategy);
    }
    /**
     * @return If true, validate that given schema is registered under expected subject name by the used name strategy when producing messages. Default: `true`.
     * 
     */
    public Optional<Boolean> nameStrategyValidation() {
        return Optional.ofNullable(this.nameStrategyValidation);
    }
    /**
     * @return Enum: `-1`, `0`, `1`, `all`. The number of acknowledgments the producer requires the leader to have received before considering a request complete. If set to `all` or `-1`, the leader will wait for the full set of in-sync replicas to acknowledge the record. Default: `1`.
     * 
     */
    public Optional<String> producerAcks() {
        return Optional.ofNullable(this.producerAcks);
    }
    /**
     * @return Enum: `gzip`, `lz4`, `none`, `snappy`, `zstd`. Specify the default compression type for producers. This configuration accepts the standard compression codecs (`gzip`, `snappy`, `lz4`, `zstd`). It additionally accepts `none` which is the default and equivalent to no compression.
     * 
     */
    public Optional<String> producerCompressionType() {
        return Optional.ofNullable(this.producerCompressionType);
    }
    /**
     * @return Wait for up to the given delay to allow batching records together. Default: `0`.
     * 
     */
    public Optional<Integer> producerLingerMs() {
        return Optional.ofNullable(this.producerLingerMs);
    }
    /**
     * @return The maximum size of a request in bytes. Note that Kafka broker can also cap the record batch size. Default: `1048576`.
     * 
     */
    public Optional<Integer> producerMaxRequestSize() {
        return Optional.ofNullable(this.producerMaxRequestSize);
    }
    /**
     * @return Maximum number of SimpleConsumers that can be instantiated per broker. Default: `25`.
     * 
     */
    public Optional<Integer> simpleconsumerPoolSizeMax() {
        return Optional.ofNullable(this.simpleconsumerPoolSizeMax);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetKafkaKafkaUserConfigKafkaRestConfig defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable Boolean consumerEnableAutoCommit;
        private @Nullable Integer consumerIdleDisconnectTimeout;
        private @Nullable Integer consumerRequestMaxBytes;
        private @Nullable Integer consumerRequestTimeoutMs;
        private @Nullable String nameStrategy;
        private @Nullable Boolean nameStrategyValidation;
        private @Nullable String producerAcks;
        private @Nullable String producerCompressionType;
        private @Nullable Integer producerLingerMs;
        private @Nullable Integer producerMaxRequestSize;
        private @Nullable Integer simpleconsumerPoolSizeMax;
        public Builder() {}
        public Builder(GetKafkaKafkaUserConfigKafkaRestConfig defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.consumerEnableAutoCommit = defaults.consumerEnableAutoCommit;
    	      this.consumerIdleDisconnectTimeout = defaults.consumerIdleDisconnectTimeout;
    	      this.consumerRequestMaxBytes = defaults.consumerRequestMaxBytes;
    	      this.consumerRequestTimeoutMs = defaults.consumerRequestTimeoutMs;
    	      this.nameStrategy = defaults.nameStrategy;
    	      this.nameStrategyValidation = defaults.nameStrategyValidation;
    	      this.producerAcks = defaults.producerAcks;
    	      this.producerCompressionType = defaults.producerCompressionType;
    	      this.producerLingerMs = defaults.producerLingerMs;
    	      this.producerMaxRequestSize = defaults.producerMaxRequestSize;
    	      this.simpleconsumerPoolSizeMax = defaults.simpleconsumerPoolSizeMax;
        }

        @CustomType.Setter
        public Builder consumerEnableAutoCommit(@Nullable Boolean consumerEnableAutoCommit) {

            this.consumerEnableAutoCommit = consumerEnableAutoCommit;
            return this;
        }
        @CustomType.Setter
        public Builder consumerIdleDisconnectTimeout(@Nullable Integer consumerIdleDisconnectTimeout) {

            this.consumerIdleDisconnectTimeout = consumerIdleDisconnectTimeout;
            return this;
        }
        @CustomType.Setter
        public Builder consumerRequestMaxBytes(@Nullable Integer consumerRequestMaxBytes) {

            this.consumerRequestMaxBytes = consumerRequestMaxBytes;
            return this;
        }
        @CustomType.Setter
        public Builder consumerRequestTimeoutMs(@Nullable Integer consumerRequestTimeoutMs) {

            this.consumerRequestTimeoutMs = consumerRequestTimeoutMs;
            return this;
        }
        @CustomType.Setter
        public Builder nameStrategy(@Nullable String nameStrategy) {

            this.nameStrategy = nameStrategy;
            return this;
        }
        @CustomType.Setter
        public Builder nameStrategyValidation(@Nullable Boolean nameStrategyValidation) {

            this.nameStrategyValidation = nameStrategyValidation;
            return this;
        }
        @CustomType.Setter
        public Builder producerAcks(@Nullable String producerAcks) {

            this.producerAcks = producerAcks;
            return this;
        }
        @CustomType.Setter
        public Builder producerCompressionType(@Nullable String producerCompressionType) {

            this.producerCompressionType = producerCompressionType;
            return this;
        }
        @CustomType.Setter
        public Builder producerLingerMs(@Nullable Integer producerLingerMs) {

            this.producerLingerMs = producerLingerMs;
            return this;
        }
        @CustomType.Setter
        public Builder producerMaxRequestSize(@Nullable Integer producerMaxRequestSize) {

            this.producerMaxRequestSize = producerMaxRequestSize;
            return this;
        }
        @CustomType.Setter
        public Builder simpleconsumerPoolSizeMax(@Nullable Integer simpleconsumerPoolSizeMax) {

            this.simpleconsumerPoolSizeMax = simpleconsumerPoolSizeMax;
            return this;
        }
        public GetKafkaKafkaUserConfigKafkaRestConfig build() {
            final var _resultValue = new GetKafkaKafkaUserConfigKafkaRestConfig();
            _resultValue.consumerEnableAutoCommit = consumerEnableAutoCommit;
            _resultValue.consumerIdleDisconnectTimeout = consumerIdleDisconnectTimeout;
            _resultValue.consumerRequestMaxBytes = consumerRequestMaxBytes;
            _resultValue.consumerRequestTimeoutMs = consumerRequestTimeoutMs;
            _resultValue.nameStrategy = nameStrategy;
            _resultValue.nameStrategyValidation = nameStrategyValidation;
            _resultValue.producerAcks = producerAcks;
            _resultValue.producerCompressionType = producerCompressionType;
            _resultValue.producerLingerMs = producerLingerMs;
            _resultValue.producerMaxRequestSize = producerMaxRequestSize;
            _resultValue.simpleconsumerPoolSizeMax = simpleconsumerPoolSizeMax;
            return _resultValue;
        }
    }
}
