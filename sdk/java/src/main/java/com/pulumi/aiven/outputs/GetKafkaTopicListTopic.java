// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aiven.outputs;

import com.pulumi.aiven.outputs.GetKafkaTopicListTopicTag;
import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import javax.annotation.Nullable;

@CustomType
public final class GetKafkaTopicListTopic {
    /**
     * @return The retention policy to use on old segments. Possible values include &#39;delete&#39;, &#39;compact&#39;, or a comma-separated list of them. The default policy (&#39;delete&#39;) will discard old segments when their retention time or size limit has been reached. The &#39;compact&#39; setting will enable log compaction on the topic.
     * 
     */
    private String cleanupPolicy;
    /**
     * @return Indicates whether diskless should be enabled. This is only available for BYOC services with Diskless feature enabled.
     * 
     */
    private Boolean disklessEnable;
    /**
     * @return When a producer sets acks to &#39;all&#39; (or &#39;-1&#39;), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. If this minimum cannot be met, then the producer will raise an exception (either NotEnoughReplicas or NotEnoughReplicasAfterAppend). When used together, min.insync.replicas and acks allow you to enforce greater durability guarantees. A typical scenario would be to create a topic with a replication factor of 3, set min.insync.replicas to 2, and produce with acks of &#39;all&#39;. This will ensure that the producer raises an exception if a majority of replicas do not receive a write.
     * 
     */
    private Integer minInsyncReplicas;
    /**
     * @return The user group that owns this topic.
     * 
     */
    private String ownerUserGroupId;
    /**
     * @return Number of partitions.
     * 
     */
    private Integer partitions;
    /**
     * @return Indicates whether tiered storage should be enabled. This is only available for services with Tiered Storage feature enabled.
     * 
     */
    private Boolean remoteStorageEnable;
    /**
     * @return Number of replicas.
     * 
     */
    private Integer replication;
    /**
     * @return This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the &#39;delete&#39; retention policy. By default there is no size limit only a time limit. Since this limit is enforced at the partition level, multiply it by the number of partitions to compute the topic retention in bytes.
     * 
     */
    private Integer retentionBytes;
    /**
     * @return Retention period (hours).
     * 
     */
    private Integer retentionHours;
    /**
     * @return Topic state. The possible values are `ACTIVE`, `CONFIGURING` and `DELETING`.
     * 
     */
    private String state;
    /**
     * @return Topic tags.
     * 
     */
    private @Nullable List<GetKafkaTopicListTopicTag> tags;
    /**
     * @return Topic description.
     * 
     */
    private String topicDescription;
    /**
     * @return Topic name.
     * 
     */
    private String topicName;

    private GetKafkaTopicListTopic() {}
    /**
     * @return The retention policy to use on old segments. Possible values include &#39;delete&#39;, &#39;compact&#39;, or a comma-separated list of them. The default policy (&#39;delete&#39;) will discard old segments when their retention time or size limit has been reached. The &#39;compact&#39; setting will enable log compaction on the topic.
     * 
     */
    public String cleanupPolicy() {
        return this.cleanupPolicy;
    }
    /**
     * @return Indicates whether diskless should be enabled. This is only available for BYOC services with Diskless feature enabled.
     * 
     */
    public Boolean disklessEnable() {
        return this.disklessEnable;
    }
    /**
     * @return When a producer sets acks to &#39;all&#39; (or &#39;-1&#39;), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. If this minimum cannot be met, then the producer will raise an exception (either NotEnoughReplicas or NotEnoughReplicasAfterAppend). When used together, min.insync.replicas and acks allow you to enforce greater durability guarantees. A typical scenario would be to create a topic with a replication factor of 3, set min.insync.replicas to 2, and produce with acks of &#39;all&#39;. This will ensure that the producer raises an exception if a majority of replicas do not receive a write.
     * 
     */
    public Integer minInsyncReplicas() {
        return this.minInsyncReplicas;
    }
    /**
     * @return The user group that owns this topic.
     * 
     */
    public String ownerUserGroupId() {
        return this.ownerUserGroupId;
    }
    /**
     * @return Number of partitions.
     * 
     */
    public Integer partitions() {
        return this.partitions;
    }
    /**
     * @return Indicates whether tiered storage should be enabled. This is only available for services with Tiered Storage feature enabled.
     * 
     */
    public Boolean remoteStorageEnable() {
        return this.remoteStorageEnable;
    }
    /**
     * @return Number of replicas.
     * 
     */
    public Integer replication() {
        return this.replication;
    }
    /**
     * @return This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the &#39;delete&#39; retention policy. By default there is no size limit only a time limit. Since this limit is enforced at the partition level, multiply it by the number of partitions to compute the topic retention in bytes.
     * 
     */
    public Integer retentionBytes() {
        return this.retentionBytes;
    }
    /**
     * @return Retention period (hours).
     * 
     */
    public Integer retentionHours() {
        return this.retentionHours;
    }
    /**
     * @return Topic state. The possible values are `ACTIVE`, `CONFIGURING` and `DELETING`.
     * 
     */
    public String state() {
        return this.state;
    }
    /**
     * @return Topic tags.
     * 
     */
    public List<GetKafkaTopicListTopicTag> tags() {
        return this.tags == null ? List.of() : this.tags;
    }
    /**
     * @return Topic description.
     * 
     */
    public String topicDescription() {
        return this.topicDescription;
    }
    /**
     * @return Topic name.
     * 
     */
    public String topicName() {
        return this.topicName;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetKafkaTopicListTopic defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String cleanupPolicy;
        private Boolean disklessEnable;
        private Integer minInsyncReplicas;
        private String ownerUserGroupId;
        private Integer partitions;
        private Boolean remoteStorageEnable;
        private Integer replication;
        private Integer retentionBytes;
        private Integer retentionHours;
        private String state;
        private @Nullable List<GetKafkaTopicListTopicTag> tags;
        private String topicDescription;
        private String topicName;
        public Builder() {}
        public Builder(GetKafkaTopicListTopic defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.cleanupPolicy = defaults.cleanupPolicy;
    	      this.disklessEnable = defaults.disklessEnable;
    	      this.minInsyncReplicas = defaults.minInsyncReplicas;
    	      this.ownerUserGroupId = defaults.ownerUserGroupId;
    	      this.partitions = defaults.partitions;
    	      this.remoteStorageEnable = defaults.remoteStorageEnable;
    	      this.replication = defaults.replication;
    	      this.retentionBytes = defaults.retentionBytes;
    	      this.retentionHours = defaults.retentionHours;
    	      this.state = defaults.state;
    	      this.tags = defaults.tags;
    	      this.topicDescription = defaults.topicDescription;
    	      this.topicName = defaults.topicName;
        }

        @CustomType.Setter
        public Builder cleanupPolicy(String cleanupPolicy) {
            if (cleanupPolicy == null) {
              throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "cleanupPolicy");
            }
            this.cleanupPolicy = cleanupPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder disklessEnable(Boolean disklessEnable) {
            if (disklessEnable == null) {
              throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "disklessEnable");
            }
            this.disklessEnable = disklessEnable;
            return this;
        }
        @CustomType.Setter
        public Builder minInsyncReplicas(Integer minInsyncReplicas) {
            if (minInsyncReplicas == null) {
              throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "minInsyncReplicas");
            }
            this.minInsyncReplicas = minInsyncReplicas;
            return this;
        }
        @CustomType.Setter
        public Builder ownerUserGroupId(String ownerUserGroupId) {
            if (ownerUserGroupId == null) {
              throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "ownerUserGroupId");
            }
            this.ownerUserGroupId = ownerUserGroupId;
            return this;
        }
        @CustomType.Setter
        public Builder partitions(Integer partitions) {
            if (partitions == null) {
              throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "partitions");
            }
            this.partitions = partitions;
            return this;
        }
        @CustomType.Setter
        public Builder remoteStorageEnable(Boolean remoteStorageEnable) {
            if (remoteStorageEnable == null) {
              throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "remoteStorageEnable");
            }
            this.remoteStorageEnable = remoteStorageEnable;
            return this;
        }
        @CustomType.Setter
        public Builder replication(Integer replication) {
            if (replication == null) {
              throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "replication");
            }
            this.replication = replication;
            return this;
        }
        @CustomType.Setter
        public Builder retentionBytes(Integer retentionBytes) {
            if (retentionBytes == null) {
              throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "retentionBytes");
            }
            this.retentionBytes = retentionBytes;
            return this;
        }
        @CustomType.Setter
        public Builder retentionHours(Integer retentionHours) {
            if (retentionHours == null) {
              throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "retentionHours");
            }
            this.retentionHours = retentionHours;
            return this;
        }
        @CustomType.Setter
        public Builder state(String state) {
            if (state == null) {
              throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "state");
            }
            this.state = state;
            return this;
        }
        @CustomType.Setter
        public Builder tags(@Nullable List<GetKafkaTopicListTopicTag> tags) {

            this.tags = tags;
            return this;
        }
        public Builder tags(GetKafkaTopicListTopicTag... tags) {
            return tags(List.of(tags));
        }
        @CustomType.Setter
        public Builder topicDescription(String topicDescription) {
            if (topicDescription == null) {
              throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "topicDescription");
            }
            this.topicDescription = topicDescription;
            return this;
        }
        @CustomType.Setter
        public Builder topicName(String topicName) {
            if (topicName == null) {
              throw new MissingRequiredPropertyException("GetKafkaTopicListTopic", "topicName");
            }
            this.topicName = topicName;
            return this;
        }
        public GetKafkaTopicListTopic build() {
            final var _resultValue = new GetKafkaTopicListTopic();
            _resultValue.cleanupPolicy = cleanupPolicy;
            _resultValue.disklessEnable = disklessEnable;
            _resultValue.minInsyncReplicas = minInsyncReplicas;
            _resultValue.ownerUserGroupId = ownerUserGroupId;
            _resultValue.partitions = partitions;
            _resultValue.remoteStorageEnable = remoteStorageEnable;
            _resultValue.replication = replication;
            _resultValue.retentionBytes = retentionBytes;
            _resultValue.retentionHours = retentionHours;
            _resultValue.state = state;
            _resultValue.tags = tags;
            _resultValue.topicDescription = topicDescription;
            _resultValue.topicName = topicName;
            return _resultValue;
        }
    }
}
