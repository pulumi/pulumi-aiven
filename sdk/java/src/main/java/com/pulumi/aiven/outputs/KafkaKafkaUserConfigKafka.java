// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aiven.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class KafkaKafkaUserConfigKafka {
    private @Nullable String autoCreateTopicsEnable;
    private @Nullable String compressionType;
    private @Nullable String connectionsMaxIdleMs;
    private @Nullable String defaultReplicationFactor;
    private @Nullable String groupInitialRebalanceDelayMs;
    private @Nullable String groupMaxSessionTimeoutMs;
    private @Nullable String groupMinSessionTimeoutMs;
    private @Nullable String logCleanerDeleteRetentionMs;
    private @Nullable String logCleanerMaxCompactionLagMs;
    private @Nullable String logCleanerMinCleanableRatio;
    private @Nullable String logCleanerMinCompactionLagMs;
    private @Nullable String logCleanupPolicy;
    private @Nullable String logFlushIntervalMessages;
    private @Nullable String logFlushIntervalMs;
    private @Nullable String logIndexIntervalBytes;
    private @Nullable String logIndexSizeMaxBytes;
    private @Nullable String logMessageDownconversionEnable;
    private @Nullable String logMessageTimestampDifferenceMaxMs;
    private @Nullable String logMessageTimestampType;
    private @Nullable String logPreallocate;
    private @Nullable String logRetentionBytes;
    private @Nullable String logRetentionHours;
    private @Nullable String logRetentionMs;
    private @Nullable String logRollJitterMs;
    private @Nullable String logRollMs;
    private @Nullable String logSegmentBytes;
    private @Nullable String logSegmentDeleteDelayMs;
    private @Nullable String maxConnectionsPerIp;
    private @Nullable String maxIncrementalFetchSessionCacheSlots;
    private @Nullable String messageMaxBytes;
    private @Nullable String minInsyncReplicas;
    private @Nullable String numPartitions;
    private @Nullable String offsetsRetentionMinutes;
    private @Nullable String producerPurgatoryPurgeIntervalRequests;
    private @Nullable String replicaFetchMaxBytes;
    private @Nullable String replicaFetchResponseMaxBytes;
    private @Nullable String socketRequestMaxBytes;
    private @Nullable String transactionRemoveExpiredTransactionCleanupIntervalMs;
    private @Nullable String transactionStateLogSegmentBytes;

    private KafkaKafkaUserConfigKafka() {}
    public Optional<String> autoCreateTopicsEnable() {
        return Optional.ofNullable(this.autoCreateTopicsEnable);
    }
    public Optional<String> compressionType() {
        return Optional.ofNullable(this.compressionType);
    }
    public Optional<String> connectionsMaxIdleMs() {
        return Optional.ofNullable(this.connectionsMaxIdleMs);
    }
    public Optional<String> defaultReplicationFactor() {
        return Optional.ofNullable(this.defaultReplicationFactor);
    }
    public Optional<String> groupInitialRebalanceDelayMs() {
        return Optional.ofNullable(this.groupInitialRebalanceDelayMs);
    }
    public Optional<String> groupMaxSessionTimeoutMs() {
        return Optional.ofNullable(this.groupMaxSessionTimeoutMs);
    }
    public Optional<String> groupMinSessionTimeoutMs() {
        return Optional.ofNullable(this.groupMinSessionTimeoutMs);
    }
    public Optional<String> logCleanerDeleteRetentionMs() {
        return Optional.ofNullable(this.logCleanerDeleteRetentionMs);
    }
    public Optional<String> logCleanerMaxCompactionLagMs() {
        return Optional.ofNullable(this.logCleanerMaxCompactionLagMs);
    }
    public Optional<String> logCleanerMinCleanableRatio() {
        return Optional.ofNullable(this.logCleanerMinCleanableRatio);
    }
    public Optional<String> logCleanerMinCompactionLagMs() {
        return Optional.ofNullable(this.logCleanerMinCompactionLagMs);
    }
    public Optional<String> logCleanupPolicy() {
        return Optional.ofNullable(this.logCleanupPolicy);
    }
    public Optional<String> logFlushIntervalMessages() {
        return Optional.ofNullable(this.logFlushIntervalMessages);
    }
    public Optional<String> logFlushIntervalMs() {
        return Optional.ofNullable(this.logFlushIntervalMs);
    }
    public Optional<String> logIndexIntervalBytes() {
        return Optional.ofNullable(this.logIndexIntervalBytes);
    }
    public Optional<String> logIndexSizeMaxBytes() {
        return Optional.ofNullable(this.logIndexSizeMaxBytes);
    }
    public Optional<String> logMessageDownconversionEnable() {
        return Optional.ofNullable(this.logMessageDownconversionEnable);
    }
    public Optional<String> logMessageTimestampDifferenceMaxMs() {
        return Optional.ofNullable(this.logMessageTimestampDifferenceMaxMs);
    }
    public Optional<String> logMessageTimestampType() {
        return Optional.ofNullable(this.logMessageTimestampType);
    }
    public Optional<String> logPreallocate() {
        return Optional.ofNullable(this.logPreallocate);
    }
    public Optional<String> logRetentionBytes() {
        return Optional.ofNullable(this.logRetentionBytes);
    }
    public Optional<String> logRetentionHours() {
        return Optional.ofNullable(this.logRetentionHours);
    }
    public Optional<String> logRetentionMs() {
        return Optional.ofNullable(this.logRetentionMs);
    }
    public Optional<String> logRollJitterMs() {
        return Optional.ofNullable(this.logRollJitterMs);
    }
    public Optional<String> logRollMs() {
        return Optional.ofNullable(this.logRollMs);
    }
    public Optional<String> logSegmentBytes() {
        return Optional.ofNullable(this.logSegmentBytes);
    }
    public Optional<String> logSegmentDeleteDelayMs() {
        return Optional.ofNullable(this.logSegmentDeleteDelayMs);
    }
    public Optional<String> maxConnectionsPerIp() {
        return Optional.ofNullable(this.maxConnectionsPerIp);
    }
    public Optional<String> maxIncrementalFetchSessionCacheSlots() {
        return Optional.ofNullable(this.maxIncrementalFetchSessionCacheSlots);
    }
    public Optional<String> messageMaxBytes() {
        return Optional.ofNullable(this.messageMaxBytes);
    }
    public Optional<String> minInsyncReplicas() {
        return Optional.ofNullable(this.minInsyncReplicas);
    }
    public Optional<String> numPartitions() {
        return Optional.ofNullable(this.numPartitions);
    }
    public Optional<String> offsetsRetentionMinutes() {
        return Optional.ofNullable(this.offsetsRetentionMinutes);
    }
    public Optional<String> producerPurgatoryPurgeIntervalRequests() {
        return Optional.ofNullable(this.producerPurgatoryPurgeIntervalRequests);
    }
    public Optional<String> replicaFetchMaxBytes() {
        return Optional.ofNullable(this.replicaFetchMaxBytes);
    }
    public Optional<String> replicaFetchResponseMaxBytes() {
        return Optional.ofNullable(this.replicaFetchResponseMaxBytes);
    }
    public Optional<String> socketRequestMaxBytes() {
        return Optional.ofNullable(this.socketRequestMaxBytes);
    }
    public Optional<String> transactionRemoveExpiredTransactionCleanupIntervalMs() {
        return Optional.ofNullable(this.transactionRemoveExpiredTransactionCleanupIntervalMs);
    }
    public Optional<String> transactionStateLogSegmentBytes() {
        return Optional.ofNullable(this.transactionStateLogSegmentBytes);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(KafkaKafkaUserConfigKafka defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable String autoCreateTopicsEnable;
        private @Nullable String compressionType;
        private @Nullable String connectionsMaxIdleMs;
        private @Nullable String defaultReplicationFactor;
        private @Nullable String groupInitialRebalanceDelayMs;
        private @Nullable String groupMaxSessionTimeoutMs;
        private @Nullable String groupMinSessionTimeoutMs;
        private @Nullable String logCleanerDeleteRetentionMs;
        private @Nullable String logCleanerMaxCompactionLagMs;
        private @Nullable String logCleanerMinCleanableRatio;
        private @Nullable String logCleanerMinCompactionLagMs;
        private @Nullable String logCleanupPolicy;
        private @Nullable String logFlushIntervalMessages;
        private @Nullable String logFlushIntervalMs;
        private @Nullable String logIndexIntervalBytes;
        private @Nullable String logIndexSizeMaxBytes;
        private @Nullable String logMessageDownconversionEnable;
        private @Nullable String logMessageTimestampDifferenceMaxMs;
        private @Nullable String logMessageTimestampType;
        private @Nullable String logPreallocate;
        private @Nullable String logRetentionBytes;
        private @Nullable String logRetentionHours;
        private @Nullable String logRetentionMs;
        private @Nullable String logRollJitterMs;
        private @Nullable String logRollMs;
        private @Nullable String logSegmentBytes;
        private @Nullable String logSegmentDeleteDelayMs;
        private @Nullable String maxConnectionsPerIp;
        private @Nullable String maxIncrementalFetchSessionCacheSlots;
        private @Nullable String messageMaxBytes;
        private @Nullable String minInsyncReplicas;
        private @Nullable String numPartitions;
        private @Nullable String offsetsRetentionMinutes;
        private @Nullable String producerPurgatoryPurgeIntervalRequests;
        private @Nullable String replicaFetchMaxBytes;
        private @Nullable String replicaFetchResponseMaxBytes;
        private @Nullable String socketRequestMaxBytes;
        private @Nullable String transactionRemoveExpiredTransactionCleanupIntervalMs;
        private @Nullable String transactionStateLogSegmentBytes;
        public Builder() {}
        public Builder(KafkaKafkaUserConfigKafka defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.autoCreateTopicsEnable = defaults.autoCreateTopicsEnable;
    	      this.compressionType = defaults.compressionType;
    	      this.connectionsMaxIdleMs = defaults.connectionsMaxIdleMs;
    	      this.defaultReplicationFactor = defaults.defaultReplicationFactor;
    	      this.groupInitialRebalanceDelayMs = defaults.groupInitialRebalanceDelayMs;
    	      this.groupMaxSessionTimeoutMs = defaults.groupMaxSessionTimeoutMs;
    	      this.groupMinSessionTimeoutMs = defaults.groupMinSessionTimeoutMs;
    	      this.logCleanerDeleteRetentionMs = defaults.logCleanerDeleteRetentionMs;
    	      this.logCleanerMaxCompactionLagMs = defaults.logCleanerMaxCompactionLagMs;
    	      this.logCleanerMinCleanableRatio = defaults.logCleanerMinCleanableRatio;
    	      this.logCleanerMinCompactionLagMs = defaults.logCleanerMinCompactionLagMs;
    	      this.logCleanupPolicy = defaults.logCleanupPolicy;
    	      this.logFlushIntervalMessages = defaults.logFlushIntervalMessages;
    	      this.logFlushIntervalMs = defaults.logFlushIntervalMs;
    	      this.logIndexIntervalBytes = defaults.logIndexIntervalBytes;
    	      this.logIndexSizeMaxBytes = defaults.logIndexSizeMaxBytes;
    	      this.logMessageDownconversionEnable = defaults.logMessageDownconversionEnable;
    	      this.logMessageTimestampDifferenceMaxMs = defaults.logMessageTimestampDifferenceMaxMs;
    	      this.logMessageTimestampType = defaults.logMessageTimestampType;
    	      this.logPreallocate = defaults.logPreallocate;
    	      this.logRetentionBytes = defaults.logRetentionBytes;
    	      this.logRetentionHours = defaults.logRetentionHours;
    	      this.logRetentionMs = defaults.logRetentionMs;
    	      this.logRollJitterMs = defaults.logRollJitterMs;
    	      this.logRollMs = defaults.logRollMs;
    	      this.logSegmentBytes = defaults.logSegmentBytes;
    	      this.logSegmentDeleteDelayMs = defaults.logSegmentDeleteDelayMs;
    	      this.maxConnectionsPerIp = defaults.maxConnectionsPerIp;
    	      this.maxIncrementalFetchSessionCacheSlots = defaults.maxIncrementalFetchSessionCacheSlots;
    	      this.messageMaxBytes = defaults.messageMaxBytes;
    	      this.minInsyncReplicas = defaults.minInsyncReplicas;
    	      this.numPartitions = defaults.numPartitions;
    	      this.offsetsRetentionMinutes = defaults.offsetsRetentionMinutes;
    	      this.producerPurgatoryPurgeIntervalRequests = defaults.producerPurgatoryPurgeIntervalRequests;
    	      this.replicaFetchMaxBytes = defaults.replicaFetchMaxBytes;
    	      this.replicaFetchResponseMaxBytes = defaults.replicaFetchResponseMaxBytes;
    	      this.socketRequestMaxBytes = defaults.socketRequestMaxBytes;
    	      this.transactionRemoveExpiredTransactionCleanupIntervalMs = defaults.transactionRemoveExpiredTransactionCleanupIntervalMs;
    	      this.transactionStateLogSegmentBytes = defaults.transactionStateLogSegmentBytes;
        }

        @CustomType.Setter
        public Builder autoCreateTopicsEnable(@Nullable String autoCreateTopicsEnable) {
            this.autoCreateTopicsEnable = autoCreateTopicsEnable;
            return this;
        }
        @CustomType.Setter
        public Builder compressionType(@Nullable String compressionType) {
            this.compressionType = compressionType;
            return this;
        }
        @CustomType.Setter
        public Builder connectionsMaxIdleMs(@Nullable String connectionsMaxIdleMs) {
            this.connectionsMaxIdleMs = connectionsMaxIdleMs;
            return this;
        }
        @CustomType.Setter
        public Builder defaultReplicationFactor(@Nullable String defaultReplicationFactor) {
            this.defaultReplicationFactor = defaultReplicationFactor;
            return this;
        }
        @CustomType.Setter
        public Builder groupInitialRebalanceDelayMs(@Nullable String groupInitialRebalanceDelayMs) {
            this.groupInitialRebalanceDelayMs = groupInitialRebalanceDelayMs;
            return this;
        }
        @CustomType.Setter
        public Builder groupMaxSessionTimeoutMs(@Nullable String groupMaxSessionTimeoutMs) {
            this.groupMaxSessionTimeoutMs = groupMaxSessionTimeoutMs;
            return this;
        }
        @CustomType.Setter
        public Builder groupMinSessionTimeoutMs(@Nullable String groupMinSessionTimeoutMs) {
            this.groupMinSessionTimeoutMs = groupMinSessionTimeoutMs;
            return this;
        }
        @CustomType.Setter
        public Builder logCleanerDeleteRetentionMs(@Nullable String logCleanerDeleteRetentionMs) {
            this.logCleanerDeleteRetentionMs = logCleanerDeleteRetentionMs;
            return this;
        }
        @CustomType.Setter
        public Builder logCleanerMaxCompactionLagMs(@Nullable String logCleanerMaxCompactionLagMs) {
            this.logCleanerMaxCompactionLagMs = logCleanerMaxCompactionLagMs;
            return this;
        }
        @CustomType.Setter
        public Builder logCleanerMinCleanableRatio(@Nullable String logCleanerMinCleanableRatio) {
            this.logCleanerMinCleanableRatio = logCleanerMinCleanableRatio;
            return this;
        }
        @CustomType.Setter
        public Builder logCleanerMinCompactionLagMs(@Nullable String logCleanerMinCompactionLagMs) {
            this.logCleanerMinCompactionLagMs = logCleanerMinCompactionLagMs;
            return this;
        }
        @CustomType.Setter
        public Builder logCleanupPolicy(@Nullable String logCleanupPolicy) {
            this.logCleanupPolicy = logCleanupPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder logFlushIntervalMessages(@Nullable String logFlushIntervalMessages) {
            this.logFlushIntervalMessages = logFlushIntervalMessages;
            return this;
        }
        @CustomType.Setter
        public Builder logFlushIntervalMs(@Nullable String logFlushIntervalMs) {
            this.logFlushIntervalMs = logFlushIntervalMs;
            return this;
        }
        @CustomType.Setter
        public Builder logIndexIntervalBytes(@Nullable String logIndexIntervalBytes) {
            this.logIndexIntervalBytes = logIndexIntervalBytes;
            return this;
        }
        @CustomType.Setter
        public Builder logIndexSizeMaxBytes(@Nullable String logIndexSizeMaxBytes) {
            this.logIndexSizeMaxBytes = logIndexSizeMaxBytes;
            return this;
        }
        @CustomType.Setter
        public Builder logMessageDownconversionEnable(@Nullable String logMessageDownconversionEnable) {
            this.logMessageDownconversionEnable = logMessageDownconversionEnable;
            return this;
        }
        @CustomType.Setter
        public Builder logMessageTimestampDifferenceMaxMs(@Nullable String logMessageTimestampDifferenceMaxMs) {
            this.logMessageTimestampDifferenceMaxMs = logMessageTimestampDifferenceMaxMs;
            return this;
        }
        @CustomType.Setter
        public Builder logMessageTimestampType(@Nullable String logMessageTimestampType) {
            this.logMessageTimestampType = logMessageTimestampType;
            return this;
        }
        @CustomType.Setter
        public Builder logPreallocate(@Nullable String logPreallocate) {
            this.logPreallocate = logPreallocate;
            return this;
        }
        @CustomType.Setter
        public Builder logRetentionBytes(@Nullable String logRetentionBytes) {
            this.logRetentionBytes = logRetentionBytes;
            return this;
        }
        @CustomType.Setter
        public Builder logRetentionHours(@Nullable String logRetentionHours) {
            this.logRetentionHours = logRetentionHours;
            return this;
        }
        @CustomType.Setter
        public Builder logRetentionMs(@Nullable String logRetentionMs) {
            this.logRetentionMs = logRetentionMs;
            return this;
        }
        @CustomType.Setter
        public Builder logRollJitterMs(@Nullable String logRollJitterMs) {
            this.logRollJitterMs = logRollJitterMs;
            return this;
        }
        @CustomType.Setter
        public Builder logRollMs(@Nullable String logRollMs) {
            this.logRollMs = logRollMs;
            return this;
        }
        @CustomType.Setter
        public Builder logSegmentBytes(@Nullable String logSegmentBytes) {
            this.logSegmentBytes = logSegmentBytes;
            return this;
        }
        @CustomType.Setter
        public Builder logSegmentDeleteDelayMs(@Nullable String logSegmentDeleteDelayMs) {
            this.logSegmentDeleteDelayMs = logSegmentDeleteDelayMs;
            return this;
        }
        @CustomType.Setter
        public Builder maxConnectionsPerIp(@Nullable String maxConnectionsPerIp) {
            this.maxConnectionsPerIp = maxConnectionsPerIp;
            return this;
        }
        @CustomType.Setter
        public Builder maxIncrementalFetchSessionCacheSlots(@Nullable String maxIncrementalFetchSessionCacheSlots) {
            this.maxIncrementalFetchSessionCacheSlots = maxIncrementalFetchSessionCacheSlots;
            return this;
        }
        @CustomType.Setter
        public Builder messageMaxBytes(@Nullable String messageMaxBytes) {
            this.messageMaxBytes = messageMaxBytes;
            return this;
        }
        @CustomType.Setter
        public Builder minInsyncReplicas(@Nullable String minInsyncReplicas) {
            this.minInsyncReplicas = minInsyncReplicas;
            return this;
        }
        @CustomType.Setter
        public Builder numPartitions(@Nullable String numPartitions) {
            this.numPartitions = numPartitions;
            return this;
        }
        @CustomType.Setter
        public Builder offsetsRetentionMinutes(@Nullable String offsetsRetentionMinutes) {
            this.offsetsRetentionMinutes = offsetsRetentionMinutes;
            return this;
        }
        @CustomType.Setter
        public Builder producerPurgatoryPurgeIntervalRequests(@Nullable String producerPurgatoryPurgeIntervalRequests) {
            this.producerPurgatoryPurgeIntervalRequests = producerPurgatoryPurgeIntervalRequests;
            return this;
        }
        @CustomType.Setter
        public Builder replicaFetchMaxBytes(@Nullable String replicaFetchMaxBytes) {
            this.replicaFetchMaxBytes = replicaFetchMaxBytes;
            return this;
        }
        @CustomType.Setter
        public Builder replicaFetchResponseMaxBytes(@Nullable String replicaFetchResponseMaxBytes) {
            this.replicaFetchResponseMaxBytes = replicaFetchResponseMaxBytes;
            return this;
        }
        @CustomType.Setter
        public Builder socketRequestMaxBytes(@Nullable String socketRequestMaxBytes) {
            this.socketRequestMaxBytes = socketRequestMaxBytes;
            return this;
        }
        @CustomType.Setter
        public Builder transactionRemoveExpiredTransactionCleanupIntervalMs(@Nullable String transactionRemoveExpiredTransactionCleanupIntervalMs) {
            this.transactionRemoveExpiredTransactionCleanupIntervalMs = transactionRemoveExpiredTransactionCleanupIntervalMs;
            return this;
        }
        @CustomType.Setter
        public Builder transactionStateLogSegmentBytes(@Nullable String transactionStateLogSegmentBytes) {
            this.transactionStateLogSegmentBytes = transactionStateLogSegmentBytes;
            return this;
        }
        public KafkaKafkaUserConfigKafka build() {
            final var o = new KafkaKafkaUserConfigKafka();
            o.autoCreateTopicsEnable = autoCreateTopicsEnable;
            o.compressionType = compressionType;
            o.connectionsMaxIdleMs = connectionsMaxIdleMs;
            o.defaultReplicationFactor = defaultReplicationFactor;
            o.groupInitialRebalanceDelayMs = groupInitialRebalanceDelayMs;
            o.groupMaxSessionTimeoutMs = groupMaxSessionTimeoutMs;
            o.groupMinSessionTimeoutMs = groupMinSessionTimeoutMs;
            o.logCleanerDeleteRetentionMs = logCleanerDeleteRetentionMs;
            o.logCleanerMaxCompactionLagMs = logCleanerMaxCompactionLagMs;
            o.logCleanerMinCleanableRatio = logCleanerMinCleanableRatio;
            o.logCleanerMinCompactionLagMs = logCleanerMinCompactionLagMs;
            o.logCleanupPolicy = logCleanupPolicy;
            o.logFlushIntervalMessages = logFlushIntervalMessages;
            o.logFlushIntervalMs = logFlushIntervalMs;
            o.logIndexIntervalBytes = logIndexIntervalBytes;
            o.logIndexSizeMaxBytes = logIndexSizeMaxBytes;
            o.logMessageDownconversionEnable = logMessageDownconversionEnable;
            o.logMessageTimestampDifferenceMaxMs = logMessageTimestampDifferenceMaxMs;
            o.logMessageTimestampType = logMessageTimestampType;
            o.logPreallocate = logPreallocate;
            o.logRetentionBytes = logRetentionBytes;
            o.logRetentionHours = logRetentionHours;
            o.logRetentionMs = logRetentionMs;
            o.logRollJitterMs = logRollJitterMs;
            o.logRollMs = logRollMs;
            o.logSegmentBytes = logSegmentBytes;
            o.logSegmentDeleteDelayMs = logSegmentDeleteDelayMs;
            o.maxConnectionsPerIp = maxConnectionsPerIp;
            o.maxIncrementalFetchSessionCacheSlots = maxIncrementalFetchSessionCacheSlots;
            o.messageMaxBytes = messageMaxBytes;
            o.minInsyncReplicas = minInsyncReplicas;
            o.numPartitions = numPartitions;
            o.offsetsRetentionMinutes = offsetsRetentionMinutes;
            o.producerPurgatoryPurgeIntervalRequests = producerPurgatoryPurgeIntervalRequests;
            o.replicaFetchMaxBytes = replicaFetchMaxBytes;
            o.replicaFetchResponseMaxBytes = replicaFetchResponseMaxBytes;
            o.socketRequestMaxBytes = socketRequestMaxBytes;
            o.transactionRemoveExpiredTransactionCleanupIntervalMs = transactionRemoveExpiredTransactionCleanupIntervalMs;
            o.transactionStateLogSegmentBytes = transactionStateLogSegmentBytes;
            return o;
        }
    }
}
