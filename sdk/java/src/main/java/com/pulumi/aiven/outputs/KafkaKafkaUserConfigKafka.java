// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aiven.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class KafkaKafkaUserConfigKafka {
    /**
     * @return Enable auto-creation of topics. (Default: true).
     * 
     */
    private @Nullable Boolean autoCreateTopicsEnable;
    /**
     * @return Enum: `gzip`, `snappy`, `lz4`, `zstd`, `uncompressed`, `producer`. Specify the final compression type for a given topic. This configuration accepts the standard compression codecs (`gzip`, `snappy`, `lz4`, `zstd`). It additionally accepts `uncompressed` which is equivalent to no compression; and `producer` which means retain the original compression codec set by the producer.(Default: producer).
     * 
     */
    private @Nullable String compressionType;
    /**
     * @return Idle connections timeout: the server socket processor threads close the connections that idle for longer than this. (Default: 600000 ms (10 minutes)). Example: `540000`.
     * 
     */
    private @Nullable Integer connectionsMaxIdleMs;
    /**
     * @return Replication factor for auto-created topics (Default: 3).
     * 
     */
    private @Nullable Integer defaultReplicationFactor;
    /**
     * @return The amount of time, in milliseconds, the group coordinator will wait for more consumers to join a new group before performing the first rebalance. A longer delay means potentially fewer rebalances, but increases the time until processing begins. The default value for this is 3 seconds. During development and testing it might be desirable to set this to 0 in order to not delay test execution time. (Default: 3000 ms (3 seconds)). Example: `3000`.
     * 
     */
    private @Nullable Integer groupInitialRebalanceDelayMs;
    /**
     * @return The maximum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures. Default: 1800000 ms (30 minutes). Example: `1800000`.
     * 
     */
    private @Nullable Integer groupMaxSessionTimeoutMs;
    /**
     * @return The minimum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures. (Default: 6000 ms (6 seconds)). Example: `6000`.
     * 
     */
    private @Nullable Integer groupMinSessionTimeoutMs;
    /**
     * @return How long are delete records retained? (Default: 86400000 (1 day)). Example: `86400000`.
     * 
     */
    private @Nullable Integer logCleanerDeleteRetentionMs;
    /**
     * @return The maximum amount of time message will remain uncompacted. Only applicable for logs that are being compacted. (Default: 9223372036854775807 ms (Long.MAX_VALUE)).
     * 
     */
    private @Nullable Integer logCleanerMaxCompactionLagMs;
    /**
     * @return Controls log compactor frequency. Larger value means more frequent compactions but also more space wasted for logs. Consider setting log.cleaner.max.compaction.lag.ms to enforce compactions sooner, instead of setting a very high value for this option. (Default: 0.5). Example: `0.5`.
     * 
     */
    private @Nullable Double logCleanerMinCleanableRatio;
    /**
     * @return The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted. (Default: 0 ms).
     * 
     */
    private @Nullable Integer logCleanerMinCompactionLagMs;
    /**
     * @return Enum: `delete`, `compact`, `compact,delete`. The default cleanup policy for segments beyond the retention window (Default: delete).
     * 
     */
    private @Nullable String logCleanupPolicy;
    /**
     * @return The number of messages accumulated on a log partition before messages are flushed to disk (Default: 9223372036854775807 (Long.MAX_VALUE)). Example: `9223372036854775807`.
     * 
     */
    private @Nullable Integer logFlushIntervalMessages;
    /**
     * @return The maximum time in ms that a message in any topic is kept in memory (page-cache) before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used (Default: null).
     * 
     */
    private @Nullable Integer logFlushIntervalMs;
    /**
     * @return The interval with which Kafka adds an entry to the offset index (Default: 4096 bytes (4 kibibytes)). Example: `4096`.
     * 
     */
    private @Nullable Integer logIndexIntervalBytes;
    /**
     * @return The maximum size in bytes of the offset index (Default: 10485760 (10 mebibytes)). Example: `10485760`.
     * 
     */
    private @Nullable Integer logIndexSizeMaxBytes;
    /**
     * @return The maximum size of local log segments that can grow for a partition before it gets eligible for deletion. If set to -2, the value of log.retention.bytes is used. The effective value should always be less than or equal to log.retention.bytes value. (Default: -2).
     * 
     */
    private @Nullable Integer logLocalRetentionBytes;
    /**
     * @return The number of milliseconds to keep the local log segments before it gets eligible for deletion. If set to -2, the value of log.retention.ms is used. The effective value should always be less than or equal to log.retention.ms value. (Default: -2).
     * 
     */
    private @Nullable Integer logLocalRetentionMs;
    /**
     * @return This configuration controls whether down-conversion of message formats is enabled to satisfy consume requests. (Default: true).
     * 
     */
    private @Nullable Boolean logMessageDownconversionEnable;
    /**
     * @return The maximum difference allowed between the timestamp when a broker receives a message and the timestamp specified in the message (Default: 9223372036854775807 (Long.MAX_VALUE)).
     * 
     */
    private @Nullable Integer logMessageTimestampDifferenceMaxMs;
    /**
     * @return Enum: `CreateTime`, `LogAppendTime`. Define whether the timestamp in the message is message create time or log append time. (Default: CreateTime).
     * 
     */
    private @Nullable String logMessageTimestampType;
    /**
     * @return Should pre allocate file when create new segment? (Default: false).
     * 
     */
    private @Nullable Boolean logPreallocate;
    /**
     * @return The maximum size of the log before deleting messages (Default: -1).
     * 
     */
    private @Nullable Integer logRetentionBytes;
    /**
     * @return The number of hours to keep a log file before deleting it (Default: 168 hours (1 week)).
     * 
     */
    private @Nullable Integer logRetentionHours;
    /**
     * @return The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied. (Default: null, log.retention.hours applies).
     * 
     */
    private @Nullable Integer logRetentionMs;
    /**
     * @return The maximum jitter to subtract from logRollTimeMillis (in milliseconds). If not set, the value in log.roll.jitter.hours is used (Default: null).
     * 
     */
    private @Nullable Integer logRollJitterMs;
    /**
     * @return The maximum time before a new log segment is rolled out (in milliseconds). (Default: null, log.roll.hours applies (Default: 168, 7 days)).
     * 
     */
    private @Nullable Integer logRollMs;
    /**
     * @return The maximum size of a single log file (Default: 1073741824 bytes (1 gibibyte)).
     * 
     */
    private @Nullable Integer logSegmentBytes;
    /**
     * @return The amount of time to wait before deleting a file from the filesystem (Default: 60000 ms (1 minute)). Example: `60000`.
     * 
     */
    private @Nullable Integer logSegmentDeleteDelayMs;
    /**
     * @return The maximum number of connections allowed from each ip address (Default: 2147483647).
     * 
     */
    private @Nullable Integer maxConnectionsPerIp;
    /**
     * @return The maximum number of incremental fetch sessions that the broker will maintain. (Default: 1000). Example: `1000`.
     * 
     */
    private @Nullable Integer maxIncrementalFetchSessionCacheSlots;
    /**
     * @return The maximum size of message that the server can receive. (Default: 1048588 bytes (1 mebibyte + 12 bytes)). Example: `1048588`.
     * 
     */
    private @Nullable Integer messageMaxBytes;
    /**
     * @return When a producer sets acks to `all` (or `-1`), min.insync.replicas specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. (Default: 1). Example: `1`.
     * 
     */
    private @Nullable Integer minInsyncReplicas;
    /**
     * @return Number of partitions for auto-created topics (Default: 1).
     * 
     */
    private @Nullable Integer numPartitions;
    /**
     * @return Log retention window in minutes for offsets topic (Default: 10080 minutes (7 days)). Example: `10080`.
     * 
     */
    private @Nullable Integer offsetsRetentionMinutes;
    /**
     * @return The purge interval (in number of requests) of the producer request purgatory (Default: 1000).
     * 
     */
    private @Nullable Integer producerPurgatoryPurgeIntervalRequests;
    /**
     * @return The number of bytes of messages to attempt to fetch for each partition . This is not an absolute maximum, if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that progress can be made. (Default: 1048576 bytes (1 mebibytes)).
     * 
     */
    private @Nullable Integer replicaFetchMaxBytes;
    /**
     * @return Maximum bytes expected for the entire fetch response. Records are fetched in batches, and if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that progress can be made. As such, this is not an absolute maximum. (Default: 10485760 bytes (10 mebibytes)).
     * 
     */
    private @Nullable Integer replicaFetchResponseMaxBytes;
    /**
     * @return The (optional) comma-delimited setting for the broker to use to verify that the JWT was issued for one of the expected audiences. (Default: null).
     * 
     */
    private @Nullable String saslOauthbearerExpectedAudience;
    /**
     * @return Optional setting for the broker to use to verify that the JWT was created by the expected issuer.(Default: null).
     * 
     */
    private @Nullable String saslOauthbearerExpectedIssuer;
    /**
     * @return OIDC JWKS endpoint URL. By setting this the SASL SSL OAuth2/OIDC authentication is enabled. See also other options for SASL OAuth2/OIDC. (Default: null).
     * 
     */
    private @Nullable String saslOauthbearerJwksEndpointUrl;
    /**
     * @return Name of the scope from which to extract the subject claim from the JWT.(Default: sub).
     * 
     */
    private @Nullable String saslOauthbearerSubClaimName;
    /**
     * @return The maximum number of bytes in a socket request (Default: 104857600 bytes).
     * 
     */
    private @Nullable Integer socketRequestMaxBytes;
    /**
     * @return Enable verification that checks that the partition has been added to the transaction before writing transactional records to the partition. (Default: false).
     * 
     */
    private @Nullable Boolean transactionPartitionVerificationEnable;
    /**
     * @return The interval at which to remove transactions that have expired due to transactional.id.expiration.ms passing (Default: 3600000 ms (1 hour)). Example: `3600000`.
     * 
     */
    private @Nullable Integer transactionRemoveExpiredTransactionCleanupIntervalMs;
    /**
     * @return The transaction topic segment bytes should be kept relatively small in order to facilitate faster log compaction and cache loads (Default: 104857600 bytes (100 mebibytes)). Example: `104857600`.
     * 
     */
    private @Nullable Integer transactionStateLogSegmentBytes;

    private KafkaKafkaUserConfigKafka() {}
    /**
     * @return Enable auto-creation of topics. (Default: true).
     * 
     */
    public Optional<Boolean> autoCreateTopicsEnable() {
        return Optional.ofNullable(this.autoCreateTopicsEnable);
    }
    /**
     * @return Enum: `gzip`, `snappy`, `lz4`, `zstd`, `uncompressed`, `producer`. Specify the final compression type for a given topic. This configuration accepts the standard compression codecs (`gzip`, `snappy`, `lz4`, `zstd`). It additionally accepts `uncompressed` which is equivalent to no compression; and `producer` which means retain the original compression codec set by the producer.(Default: producer).
     * 
     */
    public Optional<String> compressionType() {
        return Optional.ofNullable(this.compressionType);
    }
    /**
     * @return Idle connections timeout: the server socket processor threads close the connections that idle for longer than this. (Default: 600000 ms (10 minutes)). Example: `540000`.
     * 
     */
    public Optional<Integer> connectionsMaxIdleMs() {
        return Optional.ofNullable(this.connectionsMaxIdleMs);
    }
    /**
     * @return Replication factor for auto-created topics (Default: 3).
     * 
     */
    public Optional<Integer> defaultReplicationFactor() {
        return Optional.ofNullable(this.defaultReplicationFactor);
    }
    /**
     * @return The amount of time, in milliseconds, the group coordinator will wait for more consumers to join a new group before performing the first rebalance. A longer delay means potentially fewer rebalances, but increases the time until processing begins. The default value for this is 3 seconds. During development and testing it might be desirable to set this to 0 in order to not delay test execution time. (Default: 3000 ms (3 seconds)). Example: `3000`.
     * 
     */
    public Optional<Integer> groupInitialRebalanceDelayMs() {
        return Optional.ofNullable(this.groupInitialRebalanceDelayMs);
    }
    /**
     * @return The maximum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures. Default: 1800000 ms (30 minutes). Example: `1800000`.
     * 
     */
    public Optional<Integer> groupMaxSessionTimeoutMs() {
        return Optional.ofNullable(this.groupMaxSessionTimeoutMs);
    }
    /**
     * @return The minimum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures. (Default: 6000 ms (6 seconds)). Example: `6000`.
     * 
     */
    public Optional<Integer> groupMinSessionTimeoutMs() {
        return Optional.ofNullable(this.groupMinSessionTimeoutMs);
    }
    /**
     * @return How long are delete records retained? (Default: 86400000 (1 day)). Example: `86400000`.
     * 
     */
    public Optional<Integer> logCleanerDeleteRetentionMs() {
        return Optional.ofNullable(this.logCleanerDeleteRetentionMs);
    }
    /**
     * @return The maximum amount of time message will remain uncompacted. Only applicable for logs that are being compacted. (Default: 9223372036854775807 ms (Long.MAX_VALUE)).
     * 
     */
    public Optional<Integer> logCleanerMaxCompactionLagMs() {
        return Optional.ofNullable(this.logCleanerMaxCompactionLagMs);
    }
    /**
     * @return Controls log compactor frequency. Larger value means more frequent compactions but also more space wasted for logs. Consider setting log.cleaner.max.compaction.lag.ms to enforce compactions sooner, instead of setting a very high value for this option. (Default: 0.5). Example: `0.5`.
     * 
     */
    public Optional<Double> logCleanerMinCleanableRatio() {
        return Optional.ofNullable(this.logCleanerMinCleanableRatio);
    }
    /**
     * @return The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted. (Default: 0 ms).
     * 
     */
    public Optional<Integer> logCleanerMinCompactionLagMs() {
        return Optional.ofNullable(this.logCleanerMinCompactionLagMs);
    }
    /**
     * @return Enum: `delete`, `compact`, `compact,delete`. The default cleanup policy for segments beyond the retention window (Default: delete).
     * 
     */
    public Optional<String> logCleanupPolicy() {
        return Optional.ofNullable(this.logCleanupPolicy);
    }
    /**
     * @return The number of messages accumulated on a log partition before messages are flushed to disk (Default: 9223372036854775807 (Long.MAX_VALUE)). Example: `9223372036854775807`.
     * 
     */
    public Optional<Integer> logFlushIntervalMessages() {
        return Optional.ofNullable(this.logFlushIntervalMessages);
    }
    /**
     * @return The maximum time in ms that a message in any topic is kept in memory (page-cache) before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used (Default: null).
     * 
     */
    public Optional<Integer> logFlushIntervalMs() {
        return Optional.ofNullable(this.logFlushIntervalMs);
    }
    /**
     * @return The interval with which Kafka adds an entry to the offset index (Default: 4096 bytes (4 kibibytes)). Example: `4096`.
     * 
     */
    public Optional<Integer> logIndexIntervalBytes() {
        return Optional.ofNullable(this.logIndexIntervalBytes);
    }
    /**
     * @return The maximum size in bytes of the offset index (Default: 10485760 (10 mebibytes)). Example: `10485760`.
     * 
     */
    public Optional<Integer> logIndexSizeMaxBytes() {
        return Optional.ofNullable(this.logIndexSizeMaxBytes);
    }
    /**
     * @return The maximum size of local log segments that can grow for a partition before it gets eligible for deletion. If set to -2, the value of log.retention.bytes is used. The effective value should always be less than or equal to log.retention.bytes value. (Default: -2).
     * 
     */
    public Optional<Integer> logLocalRetentionBytes() {
        return Optional.ofNullable(this.logLocalRetentionBytes);
    }
    /**
     * @return The number of milliseconds to keep the local log segments before it gets eligible for deletion. If set to -2, the value of log.retention.ms is used. The effective value should always be less than or equal to log.retention.ms value. (Default: -2).
     * 
     */
    public Optional<Integer> logLocalRetentionMs() {
        return Optional.ofNullable(this.logLocalRetentionMs);
    }
    /**
     * @return This configuration controls whether down-conversion of message formats is enabled to satisfy consume requests. (Default: true).
     * 
     */
    public Optional<Boolean> logMessageDownconversionEnable() {
        return Optional.ofNullable(this.logMessageDownconversionEnable);
    }
    /**
     * @return The maximum difference allowed between the timestamp when a broker receives a message and the timestamp specified in the message (Default: 9223372036854775807 (Long.MAX_VALUE)).
     * 
     */
    public Optional<Integer> logMessageTimestampDifferenceMaxMs() {
        return Optional.ofNullable(this.logMessageTimestampDifferenceMaxMs);
    }
    /**
     * @return Enum: `CreateTime`, `LogAppendTime`. Define whether the timestamp in the message is message create time or log append time. (Default: CreateTime).
     * 
     */
    public Optional<String> logMessageTimestampType() {
        return Optional.ofNullable(this.logMessageTimestampType);
    }
    /**
     * @return Should pre allocate file when create new segment? (Default: false).
     * 
     */
    public Optional<Boolean> logPreallocate() {
        return Optional.ofNullable(this.logPreallocate);
    }
    /**
     * @return The maximum size of the log before deleting messages (Default: -1).
     * 
     */
    public Optional<Integer> logRetentionBytes() {
        return Optional.ofNullable(this.logRetentionBytes);
    }
    /**
     * @return The number of hours to keep a log file before deleting it (Default: 168 hours (1 week)).
     * 
     */
    public Optional<Integer> logRetentionHours() {
        return Optional.ofNullable(this.logRetentionHours);
    }
    /**
     * @return The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied. (Default: null, log.retention.hours applies).
     * 
     */
    public Optional<Integer> logRetentionMs() {
        return Optional.ofNullable(this.logRetentionMs);
    }
    /**
     * @return The maximum jitter to subtract from logRollTimeMillis (in milliseconds). If not set, the value in log.roll.jitter.hours is used (Default: null).
     * 
     */
    public Optional<Integer> logRollJitterMs() {
        return Optional.ofNullable(this.logRollJitterMs);
    }
    /**
     * @return The maximum time before a new log segment is rolled out (in milliseconds). (Default: null, log.roll.hours applies (Default: 168, 7 days)).
     * 
     */
    public Optional<Integer> logRollMs() {
        return Optional.ofNullable(this.logRollMs);
    }
    /**
     * @return The maximum size of a single log file (Default: 1073741824 bytes (1 gibibyte)).
     * 
     */
    public Optional<Integer> logSegmentBytes() {
        return Optional.ofNullable(this.logSegmentBytes);
    }
    /**
     * @return The amount of time to wait before deleting a file from the filesystem (Default: 60000 ms (1 minute)). Example: `60000`.
     * 
     */
    public Optional<Integer> logSegmentDeleteDelayMs() {
        return Optional.ofNullable(this.logSegmentDeleteDelayMs);
    }
    /**
     * @return The maximum number of connections allowed from each ip address (Default: 2147483647).
     * 
     */
    public Optional<Integer> maxConnectionsPerIp() {
        return Optional.ofNullable(this.maxConnectionsPerIp);
    }
    /**
     * @return The maximum number of incremental fetch sessions that the broker will maintain. (Default: 1000). Example: `1000`.
     * 
     */
    public Optional<Integer> maxIncrementalFetchSessionCacheSlots() {
        return Optional.ofNullable(this.maxIncrementalFetchSessionCacheSlots);
    }
    /**
     * @return The maximum size of message that the server can receive. (Default: 1048588 bytes (1 mebibyte + 12 bytes)). Example: `1048588`.
     * 
     */
    public Optional<Integer> messageMaxBytes() {
        return Optional.ofNullable(this.messageMaxBytes);
    }
    /**
     * @return When a producer sets acks to `all` (or `-1`), min.insync.replicas specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. (Default: 1). Example: `1`.
     * 
     */
    public Optional<Integer> minInsyncReplicas() {
        return Optional.ofNullable(this.minInsyncReplicas);
    }
    /**
     * @return Number of partitions for auto-created topics (Default: 1).
     * 
     */
    public Optional<Integer> numPartitions() {
        return Optional.ofNullable(this.numPartitions);
    }
    /**
     * @return Log retention window in minutes for offsets topic (Default: 10080 minutes (7 days)). Example: `10080`.
     * 
     */
    public Optional<Integer> offsetsRetentionMinutes() {
        return Optional.ofNullable(this.offsetsRetentionMinutes);
    }
    /**
     * @return The purge interval (in number of requests) of the producer request purgatory (Default: 1000).
     * 
     */
    public Optional<Integer> producerPurgatoryPurgeIntervalRequests() {
        return Optional.ofNullable(this.producerPurgatoryPurgeIntervalRequests);
    }
    /**
     * @return The number of bytes of messages to attempt to fetch for each partition . This is not an absolute maximum, if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that progress can be made. (Default: 1048576 bytes (1 mebibytes)).
     * 
     */
    public Optional<Integer> replicaFetchMaxBytes() {
        return Optional.ofNullable(this.replicaFetchMaxBytes);
    }
    /**
     * @return Maximum bytes expected for the entire fetch response. Records are fetched in batches, and if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that progress can be made. As such, this is not an absolute maximum. (Default: 10485760 bytes (10 mebibytes)).
     * 
     */
    public Optional<Integer> replicaFetchResponseMaxBytes() {
        return Optional.ofNullable(this.replicaFetchResponseMaxBytes);
    }
    /**
     * @return The (optional) comma-delimited setting for the broker to use to verify that the JWT was issued for one of the expected audiences. (Default: null).
     * 
     */
    public Optional<String> saslOauthbearerExpectedAudience() {
        return Optional.ofNullable(this.saslOauthbearerExpectedAudience);
    }
    /**
     * @return Optional setting for the broker to use to verify that the JWT was created by the expected issuer.(Default: null).
     * 
     */
    public Optional<String> saslOauthbearerExpectedIssuer() {
        return Optional.ofNullable(this.saslOauthbearerExpectedIssuer);
    }
    /**
     * @return OIDC JWKS endpoint URL. By setting this the SASL SSL OAuth2/OIDC authentication is enabled. See also other options for SASL OAuth2/OIDC. (Default: null).
     * 
     */
    public Optional<String> saslOauthbearerJwksEndpointUrl() {
        return Optional.ofNullable(this.saslOauthbearerJwksEndpointUrl);
    }
    /**
     * @return Name of the scope from which to extract the subject claim from the JWT.(Default: sub).
     * 
     */
    public Optional<String> saslOauthbearerSubClaimName() {
        return Optional.ofNullable(this.saslOauthbearerSubClaimName);
    }
    /**
     * @return The maximum number of bytes in a socket request (Default: 104857600 bytes).
     * 
     */
    public Optional<Integer> socketRequestMaxBytes() {
        return Optional.ofNullable(this.socketRequestMaxBytes);
    }
    /**
     * @return Enable verification that checks that the partition has been added to the transaction before writing transactional records to the partition. (Default: false).
     * 
     */
    public Optional<Boolean> transactionPartitionVerificationEnable() {
        return Optional.ofNullable(this.transactionPartitionVerificationEnable);
    }
    /**
     * @return The interval at which to remove transactions that have expired due to transactional.id.expiration.ms passing (Default: 3600000 ms (1 hour)). Example: `3600000`.
     * 
     */
    public Optional<Integer> transactionRemoveExpiredTransactionCleanupIntervalMs() {
        return Optional.ofNullable(this.transactionRemoveExpiredTransactionCleanupIntervalMs);
    }
    /**
     * @return The transaction topic segment bytes should be kept relatively small in order to facilitate faster log compaction and cache loads (Default: 104857600 bytes (100 mebibytes)). Example: `104857600`.
     * 
     */
    public Optional<Integer> transactionStateLogSegmentBytes() {
        return Optional.ofNullable(this.transactionStateLogSegmentBytes);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(KafkaKafkaUserConfigKafka defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable Boolean autoCreateTopicsEnable;
        private @Nullable String compressionType;
        private @Nullable Integer connectionsMaxIdleMs;
        private @Nullable Integer defaultReplicationFactor;
        private @Nullable Integer groupInitialRebalanceDelayMs;
        private @Nullable Integer groupMaxSessionTimeoutMs;
        private @Nullable Integer groupMinSessionTimeoutMs;
        private @Nullable Integer logCleanerDeleteRetentionMs;
        private @Nullable Integer logCleanerMaxCompactionLagMs;
        private @Nullable Double logCleanerMinCleanableRatio;
        private @Nullable Integer logCleanerMinCompactionLagMs;
        private @Nullable String logCleanupPolicy;
        private @Nullable Integer logFlushIntervalMessages;
        private @Nullable Integer logFlushIntervalMs;
        private @Nullable Integer logIndexIntervalBytes;
        private @Nullable Integer logIndexSizeMaxBytes;
        private @Nullable Integer logLocalRetentionBytes;
        private @Nullable Integer logLocalRetentionMs;
        private @Nullable Boolean logMessageDownconversionEnable;
        private @Nullable Integer logMessageTimestampDifferenceMaxMs;
        private @Nullable String logMessageTimestampType;
        private @Nullable Boolean logPreallocate;
        private @Nullable Integer logRetentionBytes;
        private @Nullable Integer logRetentionHours;
        private @Nullable Integer logRetentionMs;
        private @Nullable Integer logRollJitterMs;
        private @Nullable Integer logRollMs;
        private @Nullable Integer logSegmentBytes;
        private @Nullable Integer logSegmentDeleteDelayMs;
        private @Nullable Integer maxConnectionsPerIp;
        private @Nullable Integer maxIncrementalFetchSessionCacheSlots;
        private @Nullable Integer messageMaxBytes;
        private @Nullable Integer minInsyncReplicas;
        private @Nullable Integer numPartitions;
        private @Nullable Integer offsetsRetentionMinutes;
        private @Nullable Integer producerPurgatoryPurgeIntervalRequests;
        private @Nullable Integer replicaFetchMaxBytes;
        private @Nullable Integer replicaFetchResponseMaxBytes;
        private @Nullable String saslOauthbearerExpectedAudience;
        private @Nullable String saslOauthbearerExpectedIssuer;
        private @Nullable String saslOauthbearerJwksEndpointUrl;
        private @Nullable String saslOauthbearerSubClaimName;
        private @Nullable Integer socketRequestMaxBytes;
        private @Nullable Boolean transactionPartitionVerificationEnable;
        private @Nullable Integer transactionRemoveExpiredTransactionCleanupIntervalMs;
        private @Nullable Integer transactionStateLogSegmentBytes;
        public Builder() {}
        public Builder(KafkaKafkaUserConfigKafka defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.autoCreateTopicsEnable = defaults.autoCreateTopicsEnable;
    	      this.compressionType = defaults.compressionType;
    	      this.connectionsMaxIdleMs = defaults.connectionsMaxIdleMs;
    	      this.defaultReplicationFactor = defaults.defaultReplicationFactor;
    	      this.groupInitialRebalanceDelayMs = defaults.groupInitialRebalanceDelayMs;
    	      this.groupMaxSessionTimeoutMs = defaults.groupMaxSessionTimeoutMs;
    	      this.groupMinSessionTimeoutMs = defaults.groupMinSessionTimeoutMs;
    	      this.logCleanerDeleteRetentionMs = defaults.logCleanerDeleteRetentionMs;
    	      this.logCleanerMaxCompactionLagMs = defaults.logCleanerMaxCompactionLagMs;
    	      this.logCleanerMinCleanableRatio = defaults.logCleanerMinCleanableRatio;
    	      this.logCleanerMinCompactionLagMs = defaults.logCleanerMinCompactionLagMs;
    	      this.logCleanupPolicy = defaults.logCleanupPolicy;
    	      this.logFlushIntervalMessages = defaults.logFlushIntervalMessages;
    	      this.logFlushIntervalMs = defaults.logFlushIntervalMs;
    	      this.logIndexIntervalBytes = defaults.logIndexIntervalBytes;
    	      this.logIndexSizeMaxBytes = defaults.logIndexSizeMaxBytes;
    	      this.logLocalRetentionBytes = defaults.logLocalRetentionBytes;
    	      this.logLocalRetentionMs = defaults.logLocalRetentionMs;
    	      this.logMessageDownconversionEnable = defaults.logMessageDownconversionEnable;
    	      this.logMessageTimestampDifferenceMaxMs = defaults.logMessageTimestampDifferenceMaxMs;
    	      this.logMessageTimestampType = defaults.logMessageTimestampType;
    	      this.logPreallocate = defaults.logPreallocate;
    	      this.logRetentionBytes = defaults.logRetentionBytes;
    	      this.logRetentionHours = defaults.logRetentionHours;
    	      this.logRetentionMs = defaults.logRetentionMs;
    	      this.logRollJitterMs = defaults.logRollJitterMs;
    	      this.logRollMs = defaults.logRollMs;
    	      this.logSegmentBytes = defaults.logSegmentBytes;
    	      this.logSegmentDeleteDelayMs = defaults.logSegmentDeleteDelayMs;
    	      this.maxConnectionsPerIp = defaults.maxConnectionsPerIp;
    	      this.maxIncrementalFetchSessionCacheSlots = defaults.maxIncrementalFetchSessionCacheSlots;
    	      this.messageMaxBytes = defaults.messageMaxBytes;
    	      this.minInsyncReplicas = defaults.minInsyncReplicas;
    	      this.numPartitions = defaults.numPartitions;
    	      this.offsetsRetentionMinutes = defaults.offsetsRetentionMinutes;
    	      this.producerPurgatoryPurgeIntervalRequests = defaults.producerPurgatoryPurgeIntervalRequests;
    	      this.replicaFetchMaxBytes = defaults.replicaFetchMaxBytes;
    	      this.replicaFetchResponseMaxBytes = defaults.replicaFetchResponseMaxBytes;
    	      this.saslOauthbearerExpectedAudience = defaults.saslOauthbearerExpectedAudience;
    	      this.saslOauthbearerExpectedIssuer = defaults.saslOauthbearerExpectedIssuer;
    	      this.saslOauthbearerJwksEndpointUrl = defaults.saslOauthbearerJwksEndpointUrl;
    	      this.saslOauthbearerSubClaimName = defaults.saslOauthbearerSubClaimName;
    	      this.socketRequestMaxBytes = defaults.socketRequestMaxBytes;
    	      this.transactionPartitionVerificationEnable = defaults.transactionPartitionVerificationEnable;
    	      this.transactionRemoveExpiredTransactionCleanupIntervalMs = defaults.transactionRemoveExpiredTransactionCleanupIntervalMs;
    	      this.transactionStateLogSegmentBytes = defaults.transactionStateLogSegmentBytes;
        }

        @CustomType.Setter
        public Builder autoCreateTopicsEnable(@Nullable Boolean autoCreateTopicsEnable) {

            this.autoCreateTopicsEnable = autoCreateTopicsEnable;
            return this;
        }
        @CustomType.Setter
        public Builder compressionType(@Nullable String compressionType) {

            this.compressionType = compressionType;
            return this;
        }
        @CustomType.Setter
        public Builder connectionsMaxIdleMs(@Nullable Integer connectionsMaxIdleMs) {

            this.connectionsMaxIdleMs = connectionsMaxIdleMs;
            return this;
        }
        @CustomType.Setter
        public Builder defaultReplicationFactor(@Nullable Integer defaultReplicationFactor) {

            this.defaultReplicationFactor = defaultReplicationFactor;
            return this;
        }
        @CustomType.Setter
        public Builder groupInitialRebalanceDelayMs(@Nullable Integer groupInitialRebalanceDelayMs) {

            this.groupInitialRebalanceDelayMs = groupInitialRebalanceDelayMs;
            return this;
        }
        @CustomType.Setter
        public Builder groupMaxSessionTimeoutMs(@Nullable Integer groupMaxSessionTimeoutMs) {

            this.groupMaxSessionTimeoutMs = groupMaxSessionTimeoutMs;
            return this;
        }
        @CustomType.Setter
        public Builder groupMinSessionTimeoutMs(@Nullable Integer groupMinSessionTimeoutMs) {

            this.groupMinSessionTimeoutMs = groupMinSessionTimeoutMs;
            return this;
        }
        @CustomType.Setter
        public Builder logCleanerDeleteRetentionMs(@Nullable Integer logCleanerDeleteRetentionMs) {

            this.logCleanerDeleteRetentionMs = logCleanerDeleteRetentionMs;
            return this;
        }
        @CustomType.Setter
        public Builder logCleanerMaxCompactionLagMs(@Nullable Integer logCleanerMaxCompactionLagMs) {

            this.logCleanerMaxCompactionLagMs = logCleanerMaxCompactionLagMs;
            return this;
        }
        @CustomType.Setter
        public Builder logCleanerMinCleanableRatio(@Nullable Double logCleanerMinCleanableRatio) {

            this.logCleanerMinCleanableRatio = logCleanerMinCleanableRatio;
            return this;
        }
        @CustomType.Setter
        public Builder logCleanerMinCompactionLagMs(@Nullable Integer logCleanerMinCompactionLagMs) {

            this.logCleanerMinCompactionLagMs = logCleanerMinCompactionLagMs;
            return this;
        }
        @CustomType.Setter
        public Builder logCleanupPolicy(@Nullable String logCleanupPolicy) {

            this.logCleanupPolicy = logCleanupPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder logFlushIntervalMessages(@Nullable Integer logFlushIntervalMessages) {

            this.logFlushIntervalMessages = logFlushIntervalMessages;
            return this;
        }
        @CustomType.Setter
        public Builder logFlushIntervalMs(@Nullable Integer logFlushIntervalMs) {

            this.logFlushIntervalMs = logFlushIntervalMs;
            return this;
        }
        @CustomType.Setter
        public Builder logIndexIntervalBytes(@Nullable Integer logIndexIntervalBytes) {

            this.logIndexIntervalBytes = logIndexIntervalBytes;
            return this;
        }
        @CustomType.Setter
        public Builder logIndexSizeMaxBytes(@Nullable Integer logIndexSizeMaxBytes) {

            this.logIndexSizeMaxBytes = logIndexSizeMaxBytes;
            return this;
        }
        @CustomType.Setter
        public Builder logLocalRetentionBytes(@Nullable Integer logLocalRetentionBytes) {

            this.logLocalRetentionBytes = logLocalRetentionBytes;
            return this;
        }
        @CustomType.Setter
        public Builder logLocalRetentionMs(@Nullable Integer logLocalRetentionMs) {

            this.logLocalRetentionMs = logLocalRetentionMs;
            return this;
        }
        @CustomType.Setter
        public Builder logMessageDownconversionEnable(@Nullable Boolean logMessageDownconversionEnable) {

            this.logMessageDownconversionEnable = logMessageDownconversionEnable;
            return this;
        }
        @CustomType.Setter
        public Builder logMessageTimestampDifferenceMaxMs(@Nullable Integer logMessageTimestampDifferenceMaxMs) {

            this.logMessageTimestampDifferenceMaxMs = logMessageTimestampDifferenceMaxMs;
            return this;
        }
        @CustomType.Setter
        public Builder logMessageTimestampType(@Nullable String logMessageTimestampType) {

            this.logMessageTimestampType = logMessageTimestampType;
            return this;
        }
        @CustomType.Setter
        public Builder logPreallocate(@Nullable Boolean logPreallocate) {

            this.logPreallocate = logPreallocate;
            return this;
        }
        @CustomType.Setter
        public Builder logRetentionBytes(@Nullable Integer logRetentionBytes) {

            this.logRetentionBytes = logRetentionBytes;
            return this;
        }
        @CustomType.Setter
        public Builder logRetentionHours(@Nullable Integer logRetentionHours) {

            this.logRetentionHours = logRetentionHours;
            return this;
        }
        @CustomType.Setter
        public Builder logRetentionMs(@Nullable Integer logRetentionMs) {

            this.logRetentionMs = logRetentionMs;
            return this;
        }
        @CustomType.Setter
        public Builder logRollJitterMs(@Nullable Integer logRollJitterMs) {

            this.logRollJitterMs = logRollJitterMs;
            return this;
        }
        @CustomType.Setter
        public Builder logRollMs(@Nullable Integer logRollMs) {

            this.logRollMs = logRollMs;
            return this;
        }
        @CustomType.Setter
        public Builder logSegmentBytes(@Nullable Integer logSegmentBytes) {

            this.logSegmentBytes = logSegmentBytes;
            return this;
        }
        @CustomType.Setter
        public Builder logSegmentDeleteDelayMs(@Nullable Integer logSegmentDeleteDelayMs) {

            this.logSegmentDeleteDelayMs = logSegmentDeleteDelayMs;
            return this;
        }
        @CustomType.Setter
        public Builder maxConnectionsPerIp(@Nullable Integer maxConnectionsPerIp) {

            this.maxConnectionsPerIp = maxConnectionsPerIp;
            return this;
        }
        @CustomType.Setter
        public Builder maxIncrementalFetchSessionCacheSlots(@Nullable Integer maxIncrementalFetchSessionCacheSlots) {

            this.maxIncrementalFetchSessionCacheSlots = maxIncrementalFetchSessionCacheSlots;
            return this;
        }
        @CustomType.Setter
        public Builder messageMaxBytes(@Nullable Integer messageMaxBytes) {

            this.messageMaxBytes = messageMaxBytes;
            return this;
        }
        @CustomType.Setter
        public Builder minInsyncReplicas(@Nullable Integer minInsyncReplicas) {

            this.minInsyncReplicas = minInsyncReplicas;
            return this;
        }
        @CustomType.Setter
        public Builder numPartitions(@Nullable Integer numPartitions) {

            this.numPartitions = numPartitions;
            return this;
        }
        @CustomType.Setter
        public Builder offsetsRetentionMinutes(@Nullable Integer offsetsRetentionMinutes) {

            this.offsetsRetentionMinutes = offsetsRetentionMinutes;
            return this;
        }
        @CustomType.Setter
        public Builder producerPurgatoryPurgeIntervalRequests(@Nullable Integer producerPurgatoryPurgeIntervalRequests) {

            this.producerPurgatoryPurgeIntervalRequests = producerPurgatoryPurgeIntervalRequests;
            return this;
        }
        @CustomType.Setter
        public Builder replicaFetchMaxBytes(@Nullable Integer replicaFetchMaxBytes) {

            this.replicaFetchMaxBytes = replicaFetchMaxBytes;
            return this;
        }
        @CustomType.Setter
        public Builder replicaFetchResponseMaxBytes(@Nullable Integer replicaFetchResponseMaxBytes) {

            this.replicaFetchResponseMaxBytes = replicaFetchResponseMaxBytes;
            return this;
        }
        @CustomType.Setter
        public Builder saslOauthbearerExpectedAudience(@Nullable String saslOauthbearerExpectedAudience) {

            this.saslOauthbearerExpectedAudience = saslOauthbearerExpectedAudience;
            return this;
        }
        @CustomType.Setter
        public Builder saslOauthbearerExpectedIssuer(@Nullable String saslOauthbearerExpectedIssuer) {

            this.saslOauthbearerExpectedIssuer = saslOauthbearerExpectedIssuer;
            return this;
        }
        @CustomType.Setter
        public Builder saslOauthbearerJwksEndpointUrl(@Nullable String saslOauthbearerJwksEndpointUrl) {

            this.saslOauthbearerJwksEndpointUrl = saslOauthbearerJwksEndpointUrl;
            return this;
        }
        @CustomType.Setter
        public Builder saslOauthbearerSubClaimName(@Nullable String saslOauthbearerSubClaimName) {

            this.saslOauthbearerSubClaimName = saslOauthbearerSubClaimName;
            return this;
        }
        @CustomType.Setter
        public Builder socketRequestMaxBytes(@Nullable Integer socketRequestMaxBytes) {

            this.socketRequestMaxBytes = socketRequestMaxBytes;
            return this;
        }
        @CustomType.Setter
        public Builder transactionPartitionVerificationEnable(@Nullable Boolean transactionPartitionVerificationEnable) {

            this.transactionPartitionVerificationEnable = transactionPartitionVerificationEnable;
            return this;
        }
        @CustomType.Setter
        public Builder transactionRemoveExpiredTransactionCleanupIntervalMs(@Nullable Integer transactionRemoveExpiredTransactionCleanupIntervalMs) {

            this.transactionRemoveExpiredTransactionCleanupIntervalMs = transactionRemoveExpiredTransactionCleanupIntervalMs;
            return this;
        }
        @CustomType.Setter
        public Builder transactionStateLogSegmentBytes(@Nullable Integer transactionStateLogSegmentBytes) {

            this.transactionStateLogSegmentBytes = transactionStateLogSegmentBytes;
            return this;
        }
        public KafkaKafkaUserConfigKafka build() {
            final var _resultValue = new KafkaKafkaUserConfigKafka();
            _resultValue.autoCreateTopicsEnable = autoCreateTopicsEnable;
            _resultValue.compressionType = compressionType;
            _resultValue.connectionsMaxIdleMs = connectionsMaxIdleMs;
            _resultValue.defaultReplicationFactor = defaultReplicationFactor;
            _resultValue.groupInitialRebalanceDelayMs = groupInitialRebalanceDelayMs;
            _resultValue.groupMaxSessionTimeoutMs = groupMaxSessionTimeoutMs;
            _resultValue.groupMinSessionTimeoutMs = groupMinSessionTimeoutMs;
            _resultValue.logCleanerDeleteRetentionMs = logCleanerDeleteRetentionMs;
            _resultValue.logCleanerMaxCompactionLagMs = logCleanerMaxCompactionLagMs;
            _resultValue.logCleanerMinCleanableRatio = logCleanerMinCleanableRatio;
            _resultValue.logCleanerMinCompactionLagMs = logCleanerMinCompactionLagMs;
            _resultValue.logCleanupPolicy = logCleanupPolicy;
            _resultValue.logFlushIntervalMessages = logFlushIntervalMessages;
            _resultValue.logFlushIntervalMs = logFlushIntervalMs;
            _resultValue.logIndexIntervalBytes = logIndexIntervalBytes;
            _resultValue.logIndexSizeMaxBytes = logIndexSizeMaxBytes;
            _resultValue.logLocalRetentionBytes = logLocalRetentionBytes;
            _resultValue.logLocalRetentionMs = logLocalRetentionMs;
            _resultValue.logMessageDownconversionEnable = logMessageDownconversionEnable;
            _resultValue.logMessageTimestampDifferenceMaxMs = logMessageTimestampDifferenceMaxMs;
            _resultValue.logMessageTimestampType = logMessageTimestampType;
            _resultValue.logPreallocate = logPreallocate;
            _resultValue.logRetentionBytes = logRetentionBytes;
            _resultValue.logRetentionHours = logRetentionHours;
            _resultValue.logRetentionMs = logRetentionMs;
            _resultValue.logRollJitterMs = logRollJitterMs;
            _resultValue.logRollMs = logRollMs;
            _resultValue.logSegmentBytes = logSegmentBytes;
            _resultValue.logSegmentDeleteDelayMs = logSegmentDeleteDelayMs;
            _resultValue.maxConnectionsPerIp = maxConnectionsPerIp;
            _resultValue.maxIncrementalFetchSessionCacheSlots = maxIncrementalFetchSessionCacheSlots;
            _resultValue.messageMaxBytes = messageMaxBytes;
            _resultValue.minInsyncReplicas = minInsyncReplicas;
            _resultValue.numPartitions = numPartitions;
            _resultValue.offsetsRetentionMinutes = offsetsRetentionMinutes;
            _resultValue.producerPurgatoryPurgeIntervalRequests = producerPurgatoryPurgeIntervalRequests;
            _resultValue.replicaFetchMaxBytes = replicaFetchMaxBytes;
            _resultValue.replicaFetchResponseMaxBytes = replicaFetchResponseMaxBytes;
            _resultValue.saslOauthbearerExpectedAudience = saslOauthbearerExpectedAudience;
            _resultValue.saslOauthbearerExpectedIssuer = saslOauthbearerExpectedIssuer;
            _resultValue.saslOauthbearerJwksEndpointUrl = saslOauthbearerJwksEndpointUrl;
            _resultValue.saslOauthbearerSubClaimName = saslOauthbearerSubClaimName;
            _resultValue.socketRequestMaxBytes = socketRequestMaxBytes;
            _resultValue.transactionPartitionVerificationEnable = transactionPartitionVerificationEnable;
            _resultValue.transactionRemoveExpiredTransactionCleanupIntervalMs = transactionRemoveExpiredTransactionCleanupIntervalMs;
            _resultValue.transactionStateLogSegmentBytes = transactionStateLogSegmentBytes;
            return _resultValue;
        }
    }
}
