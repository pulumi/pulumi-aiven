// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aiven.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class KafkaKafkaUserConfigKafkaArgs extends com.pulumi.resources.ResourceArgs {

    public static final KafkaKafkaUserConfigKafkaArgs Empty = new KafkaKafkaUserConfigKafkaArgs();

    /**
     * Enable auto-creation of topics. (Default: true).
     * 
     */
    @Import(name="autoCreateTopicsEnable")
    private @Nullable Output<Boolean> autoCreateTopicsEnable;

    /**
     * @return Enable auto-creation of topics. (Default: true).
     * 
     */
    public Optional<Output<Boolean>> autoCreateTopicsEnable() {
        return Optional.ofNullable(this.autoCreateTopicsEnable);
    }

    /**
     * Enum: `gzip`, `snappy`, `lz4`, `zstd`, `uncompressed`, `producer`. Specify the final compression type for a given topic. This configuration accepts the standard compression codecs (`gzip`, `snappy`, `lz4`, `zstd`). It additionally accepts `uncompressed` which is equivalent to no compression; and `producer` which means retain the original compression codec set by the producer.(Default: producer).
     * 
     */
    @Import(name="compressionType")
    private @Nullable Output<String> compressionType;

    /**
     * @return Enum: `gzip`, `snappy`, `lz4`, `zstd`, `uncompressed`, `producer`. Specify the final compression type for a given topic. This configuration accepts the standard compression codecs (`gzip`, `snappy`, `lz4`, `zstd`). It additionally accepts `uncompressed` which is equivalent to no compression; and `producer` which means retain the original compression codec set by the producer.(Default: producer).
     * 
     */
    public Optional<Output<String>> compressionType() {
        return Optional.ofNullable(this.compressionType);
    }

    /**
     * Idle connections timeout: the server socket processor threads close the connections that idle for longer than this. (Default: 600000 ms (10 minutes)). Example: `540000`.
     * 
     */
    @Import(name="connectionsMaxIdleMs")
    private @Nullable Output<Integer> connectionsMaxIdleMs;

    /**
     * @return Idle connections timeout: the server socket processor threads close the connections that idle for longer than this. (Default: 600000 ms (10 minutes)). Example: `540000`.
     * 
     */
    public Optional<Output<Integer>> connectionsMaxIdleMs() {
        return Optional.ofNullable(this.connectionsMaxIdleMs);
    }

    /**
     * Replication factor for auto-created topics (Default: 3).
     * 
     */
    @Import(name="defaultReplicationFactor")
    private @Nullable Output<Integer> defaultReplicationFactor;

    /**
     * @return Replication factor for auto-created topics (Default: 3).
     * 
     */
    public Optional<Output<Integer>> defaultReplicationFactor() {
        return Optional.ofNullable(this.defaultReplicationFactor);
    }

    /**
     * The amount of time, in milliseconds, the group coordinator will wait for more consumers to join a new group before performing the first rebalance. A longer delay means potentially fewer rebalances, but increases the time until processing begins. The default value for this is 3 seconds. During development and testing it might be desirable to set this to 0 in order to not delay test execution time. (Default: 3000 ms (3 seconds)). Example: `3000`.
     * 
     */
    @Import(name="groupInitialRebalanceDelayMs")
    private @Nullable Output<Integer> groupInitialRebalanceDelayMs;

    /**
     * @return The amount of time, in milliseconds, the group coordinator will wait for more consumers to join a new group before performing the first rebalance. A longer delay means potentially fewer rebalances, but increases the time until processing begins. The default value for this is 3 seconds. During development and testing it might be desirable to set this to 0 in order to not delay test execution time. (Default: 3000 ms (3 seconds)). Example: `3000`.
     * 
     */
    public Optional<Output<Integer>> groupInitialRebalanceDelayMs() {
        return Optional.ofNullable(this.groupInitialRebalanceDelayMs);
    }

    /**
     * The maximum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures. Default: 1800000 ms (30 minutes). Example: `1800000`.
     * 
     */
    @Import(name="groupMaxSessionTimeoutMs")
    private @Nullable Output<Integer> groupMaxSessionTimeoutMs;

    /**
     * @return The maximum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures. Default: 1800000 ms (30 minutes). Example: `1800000`.
     * 
     */
    public Optional<Output<Integer>> groupMaxSessionTimeoutMs() {
        return Optional.ofNullable(this.groupMaxSessionTimeoutMs);
    }

    /**
     * The minimum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures. (Default: 6000 ms (6 seconds)). Example: `6000`.
     * 
     */
    @Import(name="groupMinSessionTimeoutMs")
    private @Nullable Output<Integer> groupMinSessionTimeoutMs;

    /**
     * @return The minimum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures. (Default: 6000 ms (6 seconds)). Example: `6000`.
     * 
     */
    public Optional<Output<Integer>> groupMinSessionTimeoutMs() {
        return Optional.ofNullable(this.groupMinSessionTimeoutMs);
    }

    /**
     * How long are delete records retained? (Default: 86400000 (1 day)). Example: `86400000`.
     * 
     */
    @Import(name="logCleanerDeleteRetentionMs")
    private @Nullable Output<Integer> logCleanerDeleteRetentionMs;

    /**
     * @return How long are delete records retained? (Default: 86400000 (1 day)). Example: `86400000`.
     * 
     */
    public Optional<Output<Integer>> logCleanerDeleteRetentionMs() {
        return Optional.ofNullable(this.logCleanerDeleteRetentionMs);
    }

    /**
     * The maximum amount of time message will remain uncompacted. Only applicable for logs that are being compacted. (Default: 9223372036854775807 ms (Long.MAX_VALUE)).
     * 
     */
    @Import(name="logCleanerMaxCompactionLagMs")
    private @Nullable Output<Integer> logCleanerMaxCompactionLagMs;

    /**
     * @return The maximum amount of time message will remain uncompacted. Only applicable for logs that are being compacted. (Default: 9223372036854775807 ms (Long.MAX_VALUE)).
     * 
     */
    public Optional<Output<Integer>> logCleanerMaxCompactionLagMs() {
        return Optional.ofNullable(this.logCleanerMaxCompactionLagMs);
    }

    /**
     * Controls log compactor frequency. Larger value means more frequent compactions but also more space wasted for logs. Consider setting log.cleaner.max.compaction.lag.ms to enforce compactions sooner, instead of setting a very high value for this option. (Default: 0.5). Example: `0.5`.
     * 
     */
    @Import(name="logCleanerMinCleanableRatio")
    private @Nullable Output<Double> logCleanerMinCleanableRatio;

    /**
     * @return Controls log compactor frequency. Larger value means more frequent compactions but also more space wasted for logs. Consider setting log.cleaner.max.compaction.lag.ms to enforce compactions sooner, instead of setting a very high value for this option. (Default: 0.5). Example: `0.5`.
     * 
     */
    public Optional<Output<Double>> logCleanerMinCleanableRatio() {
        return Optional.ofNullable(this.logCleanerMinCleanableRatio);
    }

    /**
     * The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted. (Default: 0 ms).
     * 
     */
    @Import(name="logCleanerMinCompactionLagMs")
    private @Nullable Output<Integer> logCleanerMinCompactionLagMs;

    /**
     * @return The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted. (Default: 0 ms).
     * 
     */
    public Optional<Output<Integer>> logCleanerMinCompactionLagMs() {
        return Optional.ofNullable(this.logCleanerMinCompactionLagMs);
    }

    /**
     * Enum: `delete`, `compact`, `compact,delete`. The default cleanup policy for segments beyond the retention window (Default: delete).
     * 
     */
    @Import(name="logCleanupPolicy")
    private @Nullable Output<String> logCleanupPolicy;

    /**
     * @return Enum: `delete`, `compact`, `compact,delete`. The default cleanup policy for segments beyond the retention window (Default: delete).
     * 
     */
    public Optional<Output<String>> logCleanupPolicy() {
        return Optional.ofNullable(this.logCleanupPolicy);
    }

    /**
     * The number of messages accumulated on a log partition before messages are flushed to disk (Default: 9223372036854775807 (Long.MAX_VALUE)). Example: `9223372036854775807`.
     * 
     */
    @Import(name="logFlushIntervalMessages")
    private @Nullable Output<Integer> logFlushIntervalMessages;

    /**
     * @return The number of messages accumulated on a log partition before messages are flushed to disk (Default: 9223372036854775807 (Long.MAX_VALUE)). Example: `9223372036854775807`.
     * 
     */
    public Optional<Output<Integer>> logFlushIntervalMessages() {
        return Optional.ofNullable(this.logFlushIntervalMessages);
    }

    /**
     * The maximum time in ms that a message in any topic is kept in memory (page-cache) before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used (Default: null).
     * 
     */
    @Import(name="logFlushIntervalMs")
    private @Nullable Output<Integer> logFlushIntervalMs;

    /**
     * @return The maximum time in ms that a message in any topic is kept in memory (page-cache) before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used (Default: null).
     * 
     */
    public Optional<Output<Integer>> logFlushIntervalMs() {
        return Optional.ofNullable(this.logFlushIntervalMs);
    }

    /**
     * The interval with which Kafka adds an entry to the offset index (Default: 4096 bytes (4 kibibytes)). Example: `4096`.
     * 
     */
    @Import(name="logIndexIntervalBytes")
    private @Nullable Output<Integer> logIndexIntervalBytes;

    /**
     * @return The interval with which Kafka adds an entry to the offset index (Default: 4096 bytes (4 kibibytes)). Example: `4096`.
     * 
     */
    public Optional<Output<Integer>> logIndexIntervalBytes() {
        return Optional.ofNullable(this.logIndexIntervalBytes);
    }

    /**
     * The maximum size in bytes of the offset index (Default: 10485760 (10 mebibytes)). Example: `10485760`.
     * 
     */
    @Import(name="logIndexSizeMaxBytes")
    private @Nullable Output<Integer> logIndexSizeMaxBytes;

    /**
     * @return The maximum size in bytes of the offset index (Default: 10485760 (10 mebibytes)). Example: `10485760`.
     * 
     */
    public Optional<Output<Integer>> logIndexSizeMaxBytes() {
        return Optional.ofNullable(this.logIndexSizeMaxBytes);
    }

    /**
     * The maximum size of local log segments that can grow for a partition before it gets eligible for deletion. If set to -2, the value of log.retention.bytes is used. The effective value should always be less than or equal to log.retention.bytes value. (Default: -2).
     * 
     */
    @Import(name="logLocalRetentionBytes")
    private @Nullable Output<Integer> logLocalRetentionBytes;

    /**
     * @return The maximum size of local log segments that can grow for a partition before it gets eligible for deletion. If set to -2, the value of log.retention.bytes is used. The effective value should always be less than or equal to log.retention.bytes value. (Default: -2).
     * 
     */
    public Optional<Output<Integer>> logLocalRetentionBytes() {
        return Optional.ofNullable(this.logLocalRetentionBytes);
    }

    /**
     * The number of milliseconds to keep the local log segments before it gets eligible for deletion. If set to -2, the value of log.retention.ms is used. The effective value should always be less than or equal to log.retention.ms value. (Default: -2).
     * 
     */
    @Import(name="logLocalRetentionMs")
    private @Nullable Output<Integer> logLocalRetentionMs;

    /**
     * @return The number of milliseconds to keep the local log segments before it gets eligible for deletion. If set to -2, the value of log.retention.ms is used. The effective value should always be less than or equal to log.retention.ms value. (Default: -2).
     * 
     */
    public Optional<Output<Integer>> logLocalRetentionMs() {
        return Optional.ofNullable(this.logLocalRetentionMs);
    }

    /**
     * This configuration controls whether down-conversion of message formats is enabled to satisfy consume requests. (Default: true).
     * 
     */
    @Import(name="logMessageDownconversionEnable")
    private @Nullable Output<Boolean> logMessageDownconversionEnable;

    /**
     * @return This configuration controls whether down-conversion of message formats is enabled to satisfy consume requests. (Default: true).
     * 
     */
    public Optional<Output<Boolean>> logMessageDownconversionEnable() {
        return Optional.ofNullable(this.logMessageDownconversionEnable);
    }

    /**
     * The maximum difference allowed between the timestamp when a broker receives a message and the timestamp specified in the message (Default: 9223372036854775807 (Long.MAX_VALUE)).
     * 
     */
    @Import(name="logMessageTimestampDifferenceMaxMs")
    private @Nullable Output<Integer> logMessageTimestampDifferenceMaxMs;

    /**
     * @return The maximum difference allowed between the timestamp when a broker receives a message and the timestamp specified in the message (Default: 9223372036854775807 (Long.MAX_VALUE)).
     * 
     */
    public Optional<Output<Integer>> logMessageTimestampDifferenceMaxMs() {
        return Optional.ofNullable(this.logMessageTimestampDifferenceMaxMs);
    }

    /**
     * Enum: `CreateTime`, `LogAppendTime`. Define whether the timestamp in the message is message create time or log append time. (Default: CreateTime).
     * 
     */
    @Import(name="logMessageTimestampType")
    private @Nullable Output<String> logMessageTimestampType;

    /**
     * @return Enum: `CreateTime`, `LogAppendTime`. Define whether the timestamp in the message is message create time or log append time. (Default: CreateTime).
     * 
     */
    public Optional<Output<String>> logMessageTimestampType() {
        return Optional.ofNullable(this.logMessageTimestampType);
    }

    /**
     * Should pre allocate file when create new segment? (Default: false).
     * 
     */
    @Import(name="logPreallocate")
    private @Nullable Output<Boolean> logPreallocate;

    /**
     * @return Should pre allocate file when create new segment? (Default: false).
     * 
     */
    public Optional<Output<Boolean>> logPreallocate() {
        return Optional.ofNullable(this.logPreallocate);
    }

    /**
     * The maximum size of the log before deleting messages (Default: -1).
     * 
     */
    @Import(name="logRetentionBytes")
    private @Nullable Output<Integer> logRetentionBytes;

    /**
     * @return The maximum size of the log before deleting messages (Default: -1).
     * 
     */
    public Optional<Output<Integer>> logRetentionBytes() {
        return Optional.ofNullable(this.logRetentionBytes);
    }

    /**
     * The number of hours to keep a log file before deleting it (Default: 168 hours (1 week)).
     * 
     */
    @Import(name="logRetentionHours")
    private @Nullable Output<Integer> logRetentionHours;

    /**
     * @return The number of hours to keep a log file before deleting it (Default: 168 hours (1 week)).
     * 
     */
    public Optional<Output<Integer>> logRetentionHours() {
        return Optional.ofNullable(this.logRetentionHours);
    }

    /**
     * The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied. (Default: null, log.retention.hours applies).
     * 
     */
    @Import(name="logRetentionMs")
    private @Nullable Output<Integer> logRetentionMs;

    /**
     * @return The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied. (Default: null, log.retention.hours applies).
     * 
     */
    public Optional<Output<Integer>> logRetentionMs() {
        return Optional.ofNullable(this.logRetentionMs);
    }

    /**
     * The maximum jitter to subtract from logRollTimeMillis (in milliseconds). If not set, the value in log.roll.jitter.hours is used (Default: null).
     * 
     */
    @Import(name="logRollJitterMs")
    private @Nullable Output<Integer> logRollJitterMs;

    /**
     * @return The maximum jitter to subtract from logRollTimeMillis (in milliseconds). If not set, the value in log.roll.jitter.hours is used (Default: null).
     * 
     */
    public Optional<Output<Integer>> logRollJitterMs() {
        return Optional.ofNullable(this.logRollJitterMs);
    }

    /**
     * The maximum time before a new log segment is rolled out (in milliseconds). (Default: null, log.roll.hours applies (Default: 168, 7 days)).
     * 
     */
    @Import(name="logRollMs")
    private @Nullable Output<Integer> logRollMs;

    /**
     * @return The maximum time before a new log segment is rolled out (in milliseconds). (Default: null, log.roll.hours applies (Default: 168, 7 days)).
     * 
     */
    public Optional<Output<Integer>> logRollMs() {
        return Optional.ofNullable(this.logRollMs);
    }

    /**
     * The maximum size of a single log file (Default: 1073741824 bytes (1 gibibyte)).
     * 
     */
    @Import(name="logSegmentBytes")
    private @Nullable Output<Integer> logSegmentBytes;

    /**
     * @return The maximum size of a single log file (Default: 1073741824 bytes (1 gibibyte)).
     * 
     */
    public Optional<Output<Integer>> logSegmentBytes() {
        return Optional.ofNullable(this.logSegmentBytes);
    }

    /**
     * The amount of time to wait before deleting a file from the filesystem (Default: 60000 ms (1 minute)). Example: `60000`.
     * 
     */
    @Import(name="logSegmentDeleteDelayMs")
    private @Nullable Output<Integer> logSegmentDeleteDelayMs;

    /**
     * @return The amount of time to wait before deleting a file from the filesystem (Default: 60000 ms (1 minute)). Example: `60000`.
     * 
     */
    public Optional<Output<Integer>> logSegmentDeleteDelayMs() {
        return Optional.ofNullable(this.logSegmentDeleteDelayMs);
    }

    /**
     * The maximum number of connections allowed from each ip address (Default: 2147483647).
     * 
     */
    @Import(name="maxConnectionsPerIp")
    private @Nullable Output<Integer> maxConnectionsPerIp;

    /**
     * @return The maximum number of connections allowed from each ip address (Default: 2147483647).
     * 
     */
    public Optional<Output<Integer>> maxConnectionsPerIp() {
        return Optional.ofNullable(this.maxConnectionsPerIp);
    }

    /**
     * The maximum number of incremental fetch sessions that the broker will maintain. (Default: 1000). Example: `1000`.
     * 
     */
    @Import(name="maxIncrementalFetchSessionCacheSlots")
    private @Nullable Output<Integer> maxIncrementalFetchSessionCacheSlots;

    /**
     * @return The maximum number of incremental fetch sessions that the broker will maintain. (Default: 1000). Example: `1000`.
     * 
     */
    public Optional<Output<Integer>> maxIncrementalFetchSessionCacheSlots() {
        return Optional.ofNullable(this.maxIncrementalFetchSessionCacheSlots);
    }

    /**
     * The maximum size of message that the server can receive. (Default: 1048588 bytes (1 mebibyte + 12 bytes)). Example: `1048588`.
     * 
     */
    @Import(name="messageMaxBytes")
    private @Nullable Output<Integer> messageMaxBytes;

    /**
     * @return The maximum size of message that the server can receive. (Default: 1048588 bytes (1 mebibyte + 12 bytes)). Example: `1048588`.
     * 
     */
    public Optional<Output<Integer>> messageMaxBytes() {
        return Optional.ofNullable(this.messageMaxBytes);
    }

    /**
     * When a producer sets acks to `all` (or `-1`), min.insync.replicas specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. (Default: 1). Example: `1`.
     * 
     */
    @Import(name="minInsyncReplicas")
    private @Nullable Output<Integer> minInsyncReplicas;

    /**
     * @return When a producer sets acks to `all` (or `-1`), min.insync.replicas specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. (Default: 1). Example: `1`.
     * 
     */
    public Optional<Output<Integer>> minInsyncReplicas() {
        return Optional.ofNullable(this.minInsyncReplicas);
    }

    /**
     * Number of partitions for auto-created topics (Default: 1).
     * 
     */
    @Import(name="numPartitions")
    private @Nullable Output<Integer> numPartitions;

    /**
     * @return Number of partitions for auto-created topics (Default: 1).
     * 
     */
    public Optional<Output<Integer>> numPartitions() {
        return Optional.ofNullable(this.numPartitions);
    }

    /**
     * Log retention window in minutes for offsets topic (Default: 10080 minutes (7 days)). Example: `10080`.
     * 
     */
    @Import(name="offsetsRetentionMinutes")
    private @Nullable Output<Integer> offsetsRetentionMinutes;

    /**
     * @return Log retention window in minutes for offsets topic (Default: 10080 minutes (7 days)). Example: `10080`.
     * 
     */
    public Optional<Output<Integer>> offsetsRetentionMinutes() {
        return Optional.ofNullable(this.offsetsRetentionMinutes);
    }

    /**
     * The purge interval (in number of requests) of the producer request purgatory (Default: 1000).
     * 
     */
    @Import(name="producerPurgatoryPurgeIntervalRequests")
    private @Nullable Output<Integer> producerPurgatoryPurgeIntervalRequests;

    /**
     * @return The purge interval (in number of requests) of the producer request purgatory (Default: 1000).
     * 
     */
    public Optional<Output<Integer>> producerPurgatoryPurgeIntervalRequests() {
        return Optional.ofNullable(this.producerPurgatoryPurgeIntervalRequests);
    }

    /**
     * The number of bytes of messages to attempt to fetch for each partition . This is not an absolute maximum, if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that progress can be made. (Default: 1048576 bytes (1 mebibytes)).
     * 
     */
    @Import(name="replicaFetchMaxBytes")
    private @Nullable Output<Integer> replicaFetchMaxBytes;

    /**
     * @return The number of bytes of messages to attempt to fetch for each partition . This is not an absolute maximum, if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that progress can be made. (Default: 1048576 bytes (1 mebibytes)).
     * 
     */
    public Optional<Output<Integer>> replicaFetchMaxBytes() {
        return Optional.ofNullable(this.replicaFetchMaxBytes);
    }

    /**
     * Maximum bytes expected for the entire fetch response. Records are fetched in batches, and if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that progress can be made. As such, this is not an absolute maximum. (Default: 10485760 bytes (10 mebibytes)).
     * 
     */
    @Import(name="replicaFetchResponseMaxBytes")
    private @Nullable Output<Integer> replicaFetchResponseMaxBytes;

    /**
     * @return Maximum bytes expected for the entire fetch response. Records are fetched in batches, and if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that progress can be made. As such, this is not an absolute maximum. (Default: 10485760 bytes (10 mebibytes)).
     * 
     */
    public Optional<Output<Integer>> replicaFetchResponseMaxBytes() {
        return Optional.ofNullable(this.replicaFetchResponseMaxBytes);
    }

    /**
     * The (optional) comma-delimited setting for the broker to use to verify that the JWT was issued for one of the expected audiences. (Default: null).
     * 
     */
    @Import(name="saslOauthbearerExpectedAudience")
    private @Nullable Output<String> saslOauthbearerExpectedAudience;

    /**
     * @return The (optional) comma-delimited setting for the broker to use to verify that the JWT was issued for one of the expected audiences. (Default: null).
     * 
     */
    public Optional<Output<String>> saslOauthbearerExpectedAudience() {
        return Optional.ofNullable(this.saslOauthbearerExpectedAudience);
    }

    /**
     * Optional setting for the broker to use to verify that the JWT was created by the expected issuer.(Default: null).
     * 
     */
    @Import(name="saslOauthbearerExpectedIssuer")
    private @Nullable Output<String> saslOauthbearerExpectedIssuer;

    /**
     * @return Optional setting for the broker to use to verify that the JWT was created by the expected issuer.(Default: null).
     * 
     */
    public Optional<Output<String>> saslOauthbearerExpectedIssuer() {
        return Optional.ofNullable(this.saslOauthbearerExpectedIssuer);
    }

    /**
     * OIDC JWKS endpoint URL. By setting this the SASL SSL OAuth2/OIDC authentication is enabled. See also other options for SASL OAuth2/OIDC. (Default: null).
     * 
     */
    @Import(name="saslOauthbearerJwksEndpointUrl")
    private @Nullable Output<String> saslOauthbearerJwksEndpointUrl;

    /**
     * @return OIDC JWKS endpoint URL. By setting this the SASL SSL OAuth2/OIDC authentication is enabled. See also other options for SASL OAuth2/OIDC. (Default: null).
     * 
     */
    public Optional<Output<String>> saslOauthbearerJwksEndpointUrl() {
        return Optional.ofNullable(this.saslOauthbearerJwksEndpointUrl);
    }

    /**
     * Name of the scope from which to extract the subject claim from the JWT.(Default: sub).
     * 
     */
    @Import(name="saslOauthbearerSubClaimName")
    private @Nullable Output<String> saslOauthbearerSubClaimName;

    /**
     * @return Name of the scope from which to extract the subject claim from the JWT.(Default: sub).
     * 
     */
    public Optional<Output<String>> saslOauthbearerSubClaimName() {
        return Optional.ofNullable(this.saslOauthbearerSubClaimName);
    }

    /**
     * The maximum number of bytes in a socket request (Default: 104857600 bytes).
     * 
     */
    @Import(name="socketRequestMaxBytes")
    private @Nullable Output<Integer> socketRequestMaxBytes;

    /**
     * @return The maximum number of bytes in a socket request (Default: 104857600 bytes).
     * 
     */
    public Optional<Output<Integer>> socketRequestMaxBytes() {
        return Optional.ofNullable(this.socketRequestMaxBytes);
    }

    /**
     * Enable verification that checks that the partition has been added to the transaction before writing transactional records to the partition. (Default: false).
     * 
     */
    @Import(name="transactionPartitionVerificationEnable")
    private @Nullable Output<Boolean> transactionPartitionVerificationEnable;

    /**
     * @return Enable verification that checks that the partition has been added to the transaction before writing transactional records to the partition. (Default: false).
     * 
     */
    public Optional<Output<Boolean>> transactionPartitionVerificationEnable() {
        return Optional.ofNullable(this.transactionPartitionVerificationEnable);
    }

    /**
     * The interval at which to remove transactions that have expired due to transactional.id.expiration.ms passing (Default: 3600000 ms (1 hour)). Example: `3600000`.
     * 
     */
    @Import(name="transactionRemoveExpiredTransactionCleanupIntervalMs")
    private @Nullable Output<Integer> transactionRemoveExpiredTransactionCleanupIntervalMs;

    /**
     * @return The interval at which to remove transactions that have expired due to transactional.id.expiration.ms passing (Default: 3600000 ms (1 hour)). Example: `3600000`.
     * 
     */
    public Optional<Output<Integer>> transactionRemoveExpiredTransactionCleanupIntervalMs() {
        return Optional.ofNullable(this.transactionRemoveExpiredTransactionCleanupIntervalMs);
    }

    /**
     * The transaction topic segment bytes should be kept relatively small in order to facilitate faster log compaction and cache loads (Default: 104857600 bytes (100 mebibytes)). Example: `104857600`.
     * 
     */
    @Import(name="transactionStateLogSegmentBytes")
    private @Nullable Output<Integer> transactionStateLogSegmentBytes;

    /**
     * @return The transaction topic segment bytes should be kept relatively small in order to facilitate faster log compaction and cache loads (Default: 104857600 bytes (100 mebibytes)). Example: `104857600`.
     * 
     */
    public Optional<Output<Integer>> transactionStateLogSegmentBytes() {
        return Optional.ofNullable(this.transactionStateLogSegmentBytes);
    }

    private KafkaKafkaUserConfigKafkaArgs() {}

    private KafkaKafkaUserConfigKafkaArgs(KafkaKafkaUserConfigKafkaArgs $) {
        this.autoCreateTopicsEnable = $.autoCreateTopicsEnable;
        this.compressionType = $.compressionType;
        this.connectionsMaxIdleMs = $.connectionsMaxIdleMs;
        this.defaultReplicationFactor = $.defaultReplicationFactor;
        this.groupInitialRebalanceDelayMs = $.groupInitialRebalanceDelayMs;
        this.groupMaxSessionTimeoutMs = $.groupMaxSessionTimeoutMs;
        this.groupMinSessionTimeoutMs = $.groupMinSessionTimeoutMs;
        this.logCleanerDeleteRetentionMs = $.logCleanerDeleteRetentionMs;
        this.logCleanerMaxCompactionLagMs = $.logCleanerMaxCompactionLagMs;
        this.logCleanerMinCleanableRatio = $.logCleanerMinCleanableRatio;
        this.logCleanerMinCompactionLagMs = $.logCleanerMinCompactionLagMs;
        this.logCleanupPolicy = $.logCleanupPolicy;
        this.logFlushIntervalMessages = $.logFlushIntervalMessages;
        this.logFlushIntervalMs = $.logFlushIntervalMs;
        this.logIndexIntervalBytes = $.logIndexIntervalBytes;
        this.logIndexSizeMaxBytes = $.logIndexSizeMaxBytes;
        this.logLocalRetentionBytes = $.logLocalRetentionBytes;
        this.logLocalRetentionMs = $.logLocalRetentionMs;
        this.logMessageDownconversionEnable = $.logMessageDownconversionEnable;
        this.logMessageTimestampDifferenceMaxMs = $.logMessageTimestampDifferenceMaxMs;
        this.logMessageTimestampType = $.logMessageTimestampType;
        this.logPreallocate = $.logPreallocate;
        this.logRetentionBytes = $.logRetentionBytes;
        this.logRetentionHours = $.logRetentionHours;
        this.logRetentionMs = $.logRetentionMs;
        this.logRollJitterMs = $.logRollJitterMs;
        this.logRollMs = $.logRollMs;
        this.logSegmentBytes = $.logSegmentBytes;
        this.logSegmentDeleteDelayMs = $.logSegmentDeleteDelayMs;
        this.maxConnectionsPerIp = $.maxConnectionsPerIp;
        this.maxIncrementalFetchSessionCacheSlots = $.maxIncrementalFetchSessionCacheSlots;
        this.messageMaxBytes = $.messageMaxBytes;
        this.minInsyncReplicas = $.minInsyncReplicas;
        this.numPartitions = $.numPartitions;
        this.offsetsRetentionMinutes = $.offsetsRetentionMinutes;
        this.producerPurgatoryPurgeIntervalRequests = $.producerPurgatoryPurgeIntervalRequests;
        this.replicaFetchMaxBytes = $.replicaFetchMaxBytes;
        this.replicaFetchResponseMaxBytes = $.replicaFetchResponseMaxBytes;
        this.saslOauthbearerExpectedAudience = $.saslOauthbearerExpectedAudience;
        this.saslOauthbearerExpectedIssuer = $.saslOauthbearerExpectedIssuer;
        this.saslOauthbearerJwksEndpointUrl = $.saslOauthbearerJwksEndpointUrl;
        this.saslOauthbearerSubClaimName = $.saslOauthbearerSubClaimName;
        this.socketRequestMaxBytes = $.socketRequestMaxBytes;
        this.transactionPartitionVerificationEnable = $.transactionPartitionVerificationEnable;
        this.transactionRemoveExpiredTransactionCleanupIntervalMs = $.transactionRemoveExpiredTransactionCleanupIntervalMs;
        this.transactionStateLogSegmentBytes = $.transactionStateLogSegmentBytes;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(KafkaKafkaUserConfigKafkaArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private KafkaKafkaUserConfigKafkaArgs $;

        public Builder() {
            $ = new KafkaKafkaUserConfigKafkaArgs();
        }

        public Builder(KafkaKafkaUserConfigKafkaArgs defaults) {
            $ = new KafkaKafkaUserConfigKafkaArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param autoCreateTopicsEnable Enable auto-creation of topics. (Default: true).
         * 
         * @return builder
         * 
         */
        public Builder autoCreateTopicsEnable(@Nullable Output<Boolean> autoCreateTopicsEnable) {
            $.autoCreateTopicsEnable = autoCreateTopicsEnable;
            return this;
        }

        /**
         * @param autoCreateTopicsEnable Enable auto-creation of topics. (Default: true).
         * 
         * @return builder
         * 
         */
        public Builder autoCreateTopicsEnable(Boolean autoCreateTopicsEnable) {
            return autoCreateTopicsEnable(Output.of(autoCreateTopicsEnable));
        }

        /**
         * @param compressionType Enum: `gzip`, `snappy`, `lz4`, `zstd`, `uncompressed`, `producer`. Specify the final compression type for a given topic. This configuration accepts the standard compression codecs (`gzip`, `snappy`, `lz4`, `zstd`). It additionally accepts `uncompressed` which is equivalent to no compression; and `producer` which means retain the original compression codec set by the producer.(Default: producer).
         * 
         * @return builder
         * 
         */
        public Builder compressionType(@Nullable Output<String> compressionType) {
            $.compressionType = compressionType;
            return this;
        }

        /**
         * @param compressionType Enum: `gzip`, `snappy`, `lz4`, `zstd`, `uncompressed`, `producer`. Specify the final compression type for a given topic. This configuration accepts the standard compression codecs (`gzip`, `snappy`, `lz4`, `zstd`). It additionally accepts `uncompressed` which is equivalent to no compression; and `producer` which means retain the original compression codec set by the producer.(Default: producer).
         * 
         * @return builder
         * 
         */
        public Builder compressionType(String compressionType) {
            return compressionType(Output.of(compressionType));
        }

        /**
         * @param connectionsMaxIdleMs Idle connections timeout: the server socket processor threads close the connections that idle for longer than this. (Default: 600000 ms (10 minutes)). Example: `540000`.
         * 
         * @return builder
         * 
         */
        public Builder connectionsMaxIdleMs(@Nullable Output<Integer> connectionsMaxIdleMs) {
            $.connectionsMaxIdleMs = connectionsMaxIdleMs;
            return this;
        }

        /**
         * @param connectionsMaxIdleMs Idle connections timeout: the server socket processor threads close the connections that idle for longer than this. (Default: 600000 ms (10 minutes)). Example: `540000`.
         * 
         * @return builder
         * 
         */
        public Builder connectionsMaxIdleMs(Integer connectionsMaxIdleMs) {
            return connectionsMaxIdleMs(Output.of(connectionsMaxIdleMs));
        }

        /**
         * @param defaultReplicationFactor Replication factor for auto-created topics (Default: 3).
         * 
         * @return builder
         * 
         */
        public Builder defaultReplicationFactor(@Nullable Output<Integer> defaultReplicationFactor) {
            $.defaultReplicationFactor = defaultReplicationFactor;
            return this;
        }

        /**
         * @param defaultReplicationFactor Replication factor for auto-created topics (Default: 3).
         * 
         * @return builder
         * 
         */
        public Builder defaultReplicationFactor(Integer defaultReplicationFactor) {
            return defaultReplicationFactor(Output.of(defaultReplicationFactor));
        }

        /**
         * @param groupInitialRebalanceDelayMs The amount of time, in milliseconds, the group coordinator will wait for more consumers to join a new group before performing the first rebalance. A longer delay means potentially fewer rebalances, but increases the time until processing begins. The default value for this is 3 seconds. During development and testing it might be desirable to set this to 0 in order to not delay test execution time. (Default: 3000 ms (3 seconds)). Example: `3000`.
         * 
         * @return builder
         * 
         */
        public Builder groupInitialRebalanceDelayMs(@Nullable Output<Integer> groupInitialRebalanceDelayMs) {
            $.groupInitialRebalanceDelayMs = groupInitialRebalanceDelayMs;
            return this;
        }

        /**
         * @param groupInitialRebalanceDelayMs The amount of time, in milliseconds, the group coordinator will wait for more consumers to join a new group before performing the first rebalance. A longer delay means potentially fewer rebalances, but increases the time until processing begins. The default value for this is 3 seconds. During development and testing it might be desirable to set this to 0 in order to not delay test execution time. (Default: 3000 ms (3 seconds)). Example: `3000`.
         * 
         * @return builder
         * 
         */
        public Builder groupInitialRebalanceDelayMs(Integer groupInitialRebalanceDelayMs) {
            return groupInitialRebalanceDelayMs(Output.of(groupInitialRebalanceDelayMs));
        }

        /**
         * @param groupMaxSessionTimeoutMs The maximum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures. Default: 1800000 ms (30 minutes). Example: `1800000`.
         * 
         * @return builder
         * 
         */
        public Builder groupMaxSessionTimeoutMs(@Nullable Output<Integer> groupMaxSessionTimeoutMs) {
            $.groupMaxSessionTimeoutMs = groupMaxSessionTimeoutMs;
            return this;
        }

        /**
         * @param groupMaxSessionTimeoutMs The maximum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures. Default: 1800000 ms (30 minutes). Example: `1800000`.
         * 
         * @return builder
         * 
         */
        public Builder groupMaxSessionTimeoutMs(Integer groupMaxSessionTimeoutMs) {
            return groupMaxSessionTimeoutMs(Output.of(groupMaxSessionTimeoutMs));
        }

        /**
         * @param groupMinSessionTimeoutMs The minimum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures. (Default: 6000 ms (6 seconds)). Example: `6000`.
         * 
         * @return builder
         * 
         */
        public Builder groupMinSessionTimeoutMs(@Nullable Output<Integer> groupMinSessionTimeoutMs) {
            $.groupMinSessionTimeoutMs = groupMinSessionTimeoutMs;
            return this;
        }

        /**
         * @param groupMinSessionTimeoutMs The minimum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures. (Default: 6000 ms (6 seconds)). Example: `6000`.
         * 
         * @return builder
         * 
         */
        public Builder groupMinSessionTimeoutMs(Integer groupMinSessionTimeoutMs) {
            return groupMinSessionTimeoutMs(Output.of(groupMinSessionTimeoutMs));
        }

        /**
         * @param logCleanerDeleteRetentionMs How long are delete records retained? (Default: 86400000 (1 day)). Example: `86400000`.
         * 
         * @return builder
         * 
         */
        public Builder logCleanerDeleteRetentionMs(@Nullable Output<Integer> logCleanerDeleteRetentionMs) {
            $.logCleanerDeleteRetentionMs = logCleanerDeleteRetentionMs;
            return this;
        }

        /**
         * @param logCleanerDeleteRetentionMs How long are delete records retained? (Default: 86400000 (1 day)). Example: `86400000`.
         * 
         * @return builder
         * 
         */
        public Builder logCleanerDeleteRetentionMs(Integer logCleanerDeleteRetentionMs) {
            return logCleanerDeleteRetentionMs(Output.of(logCleanerDeleteRetentionMs));
        }

        /**
         * @param logCleanerMaxCompactionLagMs The maximum amount of time message will remain uncompacted. Only applicable for logs that are being compacted. (Default: 9223372036854775807 ms (Long.MAX_VALUE)).
         * 
         * @return builder
         * 
         */
        public Builder logCleanerMaxCompactionLagMs(@Nullable Output<Integer> logCleanerMaxCompactionLagMs) {
            $.logCleanerMaxCompactionLagMs = logCleanerMaxCompactionLagMs;
            return this;
        }

        /**
         * @param logCleanerMaxCompactionLagMs The maximum amount of time message will remain uncompacted. Only applicable for logs that are being compacted. (Default: 9223372036854775807 ms (Long.MAX_VALUE)).
         * 
         * @return builder
         * 
         */
        public Builder logCleanerMaxCompactionLagMs(Integer logCleanerMaxCompactionLagMs) {
            return logCleanerMaxCompactionLagMs(Output.of(logCleanerMaxCompactionLagMs));
        }

        /**
         * @param logCleanerMinCleanableRatio Controls log compactor frequency. Larger value means more frequent compactions but also more space wasted for logs. Consider setting log.cleaner.max.compaction.lag.ms to enforce compactions sooner, instead of setting a very high value for this option. (Default: 0.5). Example: `0.5`.
         * 
         * @return builder
         * 
         */
        public Builder logCleanerMinCleanableRatio(@Nullable Output<Double> logCleanerMinCleanableRatio) {
            $.logCleanerMinCleanableRatio = logCleanerMinCleanableRatio;
            return this;
        }

        /**
         * @param logCleanerMinCleanableRatio Controls log compactor frequency. Larger value means more frequent compactions but also more space wasted for logs. Consider setting log.cleaner.max.compaction.lag.ms to enforce compactions sooner, instead of setting a very high value for this option. (Default: 0.5). Example: `0.5`.
         * 
         * @return builder
         * 
         */
        public Builder logCleanerMinCleanableRatio(Double logCleanerMinCleanableRatio) {
            return logCleanerMinCleanableRatio(Output.of(logCleanerMinCleanableRatio));
        }

        /**
         * @param logCleanerMinCompactionLagMs The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted. (Default: 0 ms).
         * 
         * @return builder
         * 
         */
        public Builder logCleanerMinCompactionLagMs(@Nullable Output<Integer> logCleanerMinCompactionLagMs) {
            $.logCleanerMinCompactionLagMs = logCleanerMinCompactionLagMs;
            return this;
        }

        /**
         * @param logCleanerMinCompactionLagMs The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted. (Default: 0 ms).
         * 
         * @return builder
         * 
         */
        public Builder logCleanerMinCompactionLagMs(Integer logCleanerMinCompactionLagMs) {
            return logCleanerMinCompactionLagMs(Output.of(logCleanerMinCompactionLagMs));
        }

        /**
         * @param logCleanupPolicy Enum: `delete`, `compact`, `compact,delete`. The default cleanup policy for segments beyond the retention window (Default: delete).
         * 
         * @return builder
         * 
         */
        public Builder logCleanupPolicy(@Nullable Output<String> logCleanupPolicy) {
            $.logCleanupPolicy = logCleanupPolicy;
            return this;
        }

        /**
         * @param logCleanupPolicy Enum: `delete`, `compact`, `compact,delete`. The default cleanup policy for segments beyond the retention window (Default: delete).
         * 
         * @return builder
         * 
         */
        public Builder logCleanupPolicy(String logCleanupPolicy) {
            return logCleanupPolicy(Output.of(logCleanupPolicy));
        }

        /**
         * @param logFlushIntervalMessages The number of messages accumulated on a log partition before messages are flushed to disk (Default: 9223372036854775807 (Long.MAX_VALUE)). Example: `9223372036854775807`.
         * 
         * @return builder
         * 
         */
        public Builder logFlushIntervalMessages(@Nullable Output<Integer> logFlushIntervalMessages) {
            $.logFlushIntervalMessages = logFlushIntervalMessages;
            return this;
        }

        /**
         * @param logFlushIntervalMessages The number of messages accumulated on a log partition before messages are flushed to disk (Default: 9223372036854775807 (Long.MAX_VALUE)). Example: `9223372036854775807`.
         * 
         * @return builder
         * 
         */
        public Builder logFlushIntervalMessages(Integer logFlushIntervalMessages) {
            return logFlushIntervalMessages(Output.of(logFlushIntervalMessages));
        }

        /**
         * @param logFlushIntervalMs The maximum time in ms that a message in any topic is kept in memory (page-cache) before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used (Default: null).
         * 
         * @return builder
         * 
         */
        public Builder logFlushIntervalMs(@Nullable Output<Integer> logFlushIntervalMs) {
            $.logFlushIntervalMs = logFlushIntervalMs;
            return this;
        }

        /**
         * @param logFlushIntervalMs The maximum time in ms that a message in any topic is kept in memory (page-cache) before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used (Default: null).
         * 
         * @return builder
         * 
         */
        public Builder logFlushIntervalMs(Integer logFlushIntervalMs) {
            return logFlushIntervalMs(Output.of(logFlushIntervalMs));
        }

        /**
         * @param logIndexIntervalBytes The interval with which Kafka adds an entry to the offset index (Default: 4096 bytes (4 kibibytes)). Example: `4096`.
         * 
         * @return builder
         * 
         */
        public Builder logIndexIntervalBytes(@Nullable Output<Integer> logIndexIntervalBytes) {
            $.logIndexIntervalBytes = logIndexIntervalBytes;
            return this;
        }

        /**
         * @param logIndexIntervalBytes The interval with which Kafka adds an entry to the offset index (Default: 4096 bytes (4 kibibytes)). Example: `4096`.
         * 
         * @return builder
         * 
         */
        public Builder logIndexIntervalBytes(Integer logIndexIntervalBytes) {
            return logIndexIntervalBytes(Output.of(logIndexIntervalBytes));
        }

        /**
         * @param logIndexSizeMaxBytes The maximum size in bytes of the offset index (Default: 10485760 (10 mebibytes)). Example: `10485760`.
         * 
         * @return builder
         * 
         */
        public Builder logIndexSizeMaxBytes(@Nullable Output<Integer> logIndexSizeMaxBytes) {
            $.logIndexSizeMaxBytes = logIndexSizeMaxBytes;
            return this;
        }

        /**
         * @param logIndexSizeMaxBytes The maximum size in bytes of the offset index (Default: 10485760 (10 mebibytes)). Example: `10485760`.
         * 
         * @return builder
         * 
         */
        public Builder logIndexSizeMaxBytes(Integer logIndexSizeMaxBytes) {
            return logIndexSizeMaxBytes(Output.of(logIndexSizeMaxBytes));
        }

        /**
         * @param logLocalRetentionBytes The maximum size of local log segments that can grow for a partition before it gets eligible for deletion. If set to -2, the value of log.retention.bytes is used. The effective value should always be less than or equal to log.retention.bytes value. (Default: -2).
         * 
         * @return builder
         * 
         */
        public Builder logLocalRetentionBytes(@Nullable Output<Integer> logLocalRetentionBytes) {
            $.logLocalRetentionBytes = logLocalRetentionBytes;
            return this;
        }

        /**
         * @param logLocalRetentionBytes The maximum size of local log segments that can grow for a partition before it gets eligible for deletion. If set to -2, the value of log.retention.bytes is used. The effective value should always be less than or equal to log.retention.bytes value. (Default: -2).
         * 
         * @return builder
         * 
         */
        public Builder logLocalRetentionBytes(Integer logLocalRetentionBytes) {
            return logLocalRetentionBytes(Output.of(logLocalRetentionBytes));
        }

        /**
         * @param logLocalRetentionMs The number of milliseconds to keep the local log segments before it gets eligible for deletion. If set to -2, the value of log.retention.ms is used. The effective value should always be less than or equal to log.retention.ms value. (Default: -2).
         * 
         * @return builder
         * 
         */
        public Builder logLocalRetentionMs(@Nullable Output<Integer> logLocalRetentionMs) {
            $.logLocalRetentionMs = logLocalRetentionMs;
            return this;
        }

        /**
         * @param logLocalRetentionMs The number of milliseconds to keep the local log segments before it gets eligible for deletion. If set to -2, the value of log.retention.ms is used. The effective value should always be less than or equal to log.retention.ms value. (Default: -2).
         * 
         * @return builder
         * 
         */
        public Builder logLocalRetentionMs(Integer logLocalRetentionMs) {
            return logLocalRetentionMs(Output.of(logLocalRetentionMs));
        }

        /**
         * @param logMessageDownconversionEnable This configuration controls whether down-conversion of message formats is enabled to satisfy consume requests. (Default: true).
         * 
         * @return builder
         * 
         */
        public Builder logMessageDownconversionEnable(@Nullable Output<Boolean> logMessageDownconversionEnable) {
            $.logMessageDownconversionEnable = logMessageDownconversionEnable;
            return this;
        }

        /**
         * @param logMessageDownconversionEnable This configuration controls whether down-conversion of message formats is enabled to satisfy consume requests. (Default: true).
         * 
         * @return builder
         * 
         */
        public Builder logMessageDownconversionEnable(Boolean logMessageDownconversionEnable) {
            return logMessageDownconversionEnable(Output.of(logMessageDownconversionEnable));
        }

        /**
         * @param logMessageTimestampDifferenceMaxMs The maximum difference allowed between the timestamp when a broker receives a message and the timestamp specified in the message (Default: 9223372036854775807 (Long.MAX_VALUE)).
         * 
         * @return builder
         * 
         */
        public Builder logMessageTimestampDifferenceMaxMs(@Nullable Output<Integer> logMessageTimestampDifferenceMaxMs) {
            $.logMessageTimestampDifferenceMaxMs = logMessageTimestampDifferenceMaxMs;
            return this;
        }

        /**
         * @param logMessageTimestampDifferenceMaxMs The maximum difference allowed between the timestamp when a broker receives a message and the timestamp specified in the message (Default: 9223372036854775807 (Long.MAX_VALUE)).
         * 
         * @return builder
         * 
         */
        public Builder logMessageTimestampDifferenceMaxMs(Integer logMessageTimestampDifferenceMaxMs) {
            return logMessageTimestampDifferenceMaxMs(Output.of(logMessageTimestampDifferenceMaxMs));
        }

        /**
         * @param logMessageTimestampType Enum: `CreateTime`, `LogAppendTime`. Define whether the timestamp in the message is message create time or log append time. (Default: CreateTime).
         * 
         * @return builder
         * 
         */
        public Builder logMessageTimestampType(@Nullable Output<String> logMessageTimestampType) {
            $.logMessageTimestampType = logMessageTimestampType;
            return this;
        }

        /**
         * @param logMessageTimestampType Enum: `CreateTime`, `LogAppendTime`. Define whether the timestamp in the message is message create time or log append time. (Default: CreateTime).
         * 
         * @return builder
         * 
         */
        public Builder logMessageTimestampType(String logMessageTimestampType) {
            return logMessageTimestampType(Output.of(logMessageTimestampType));
        }

        /**
         * @param logPreallocate Should pre allocate file when create new segment? (Default: false).
         * 
         * @return builder
         * 
         */
        public Builder logPreallocate(@Nullable Output<Boolean> logPreallocate) {
            $.logPreallocate = logPreallocate;
            return this;
        }

        /**
         * @param logPreallocate Should pre allocate file when create new segment? (Default: false).
         * 
         * @return builder
         * 
         */
        public Builder logPreallocate(Boolean logPreallocate) {
            return logPreallocate(Output.of(logPreallocate));
        }

        /**
         * @param logRetentionBytes The maximum size of the log before deleting messages (Default: -1).
         * 
         * @return builder
         * 
         */
        public Builder logRetentionBytes(@Nullable Output<Integer> logRetentionBytes) {
            $.logRetentionBytes = logRetentionBytes;
            return this;
        }

        /**
         * @param logRetentionBytes The maximum size of the log before deleting messages (Default: -1).
         * 
         * @return builder
         * 
         */
        public Builder logRetentionBytes(Integer logRetentionBytes) {
            return logRetentionBytes(Output.of(logRetentionBytes));
        }

        /**
         * @param logRetentionHours The number of hours to keep a log file before deleting it (Default: 168 hours (1 week)).
         * 
         * @return builder
         * 
         */
        public Builder logRetentionHours(@Nullable Output<Integer> logRetentionHours) {
            $.logRetentionHours = logRetentionHours;
            return this;
        }

        /**
         * @param logRetentionHours The number of hours to keep a log file before deleting it (Default: 168 hours (1 week)).
         * 
         * @return builder
         * 
         */
        public Builder logRetentionHours(Integer logRetentionHours) {
            return logRetentionHours(Output.of(logRetentionHours));
        }

        /**
         * @param logRetentionMs The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied. (Default: null, log.retention.hours applies).
         * 
         * @return builder
         * 
         */
        public Builder logRetentionMs(@Nullable Output<Integer> logRetentionMs) {
            $.logRetentionMs = logRetentionMs;
            return this;
        }

        /**
         * @param logRetentionMs The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied. (Default: null, log.retention.hours applies).
         * 
         * @return builder
         * 
         */
        public Builder logRetentionMs(Integer logRetentionMs) {
            return logRetentionMs(Output.of(logRetentionMs));
        }

        /**
         * @param logRollJitterMs The maximum jitter to subtract from logRollTimeMillis (in milliseconds). If not set, the value in log.roll.jitter.hours is used (Default: null).
         * 
         * @return builder
         * 
         */
        public Builder logRollJitterMs(@Nullable Output<Integer> logRollJitterMs) {
            $.logRollJitterMs = logRollJitterMs;
            return this;
        }

        /**
         * @param logRollJitterMs The maximum jitter to subtract from logRollTimeMillis (in milliseconds). If not set, the value in log.roll.jitter.hours is used (Default: null).
         * 
         * @return builder
         * 
         */
        public Builder logRollJitterMs(Integer logRollJitterMs) {
            return logRollJitterMs(Output.of(logRollJitterMs));
        }

        /**
         * @param logRollMs The maximum time before a new log segment is rolled out (in milliseconds). (Default: null, log.roll.hours applies (Default: 168, 7 days)).
         * 
         * @return builder
         * 
         */
        public Builder logRollMs(@Nullable Output<Integer> logRollMs) {
            $.logRollMs = logRollMs;
            return this;
        }

        /**
         * @param logRollMs The maximum time before a new log segment is rolled out (in milliseconds). (Default: null, log.roll.hours applies (Default: 168, 7 days)).
         * 
         * @return builder
         * 
         */
        public Builder logRollMs(Integer logRollMs) {
            return logRollMs(Output.of(logRollMs));
        }

        /**
         * @param logSegmentBytes The maximum size of a single log file (Default: 1073741824 bytes (1 gibibyte)).
         * 
         * @return builder
         * 
         */
        public Builder logSegmentBytes(@Nullable Output<Integer> logSegmentBytes) {
            $.logSegmentBytes = logSegmentBytes;
            return this;
        }

        /**
         * @param logSegmentBytes The maximum size of a single log file (Default: 1073741824 bytes (1 gibibyte)).
         * 
         * @return builder
         * 
         */
        public Builder logSegmentBytes(Integer logSegmentBytes) {
            return logSegmentBytes(Output.of(logSegmentBytes));
        }

        /**
         * @param logSegmentDeleteDelayMs The amount of time to wait before deleting a file from the filesystem (Default: 60000 ms (1 minute)). Example: `60000`.
         * 
         * @return builder
         * 
         */
        public Builder logSegmentDeleteDelayMs(@Nullable Output<Integer> logSegmentDeleteDelayMs) {
            $.logSegmentDeleteDelayMs = logSegmentDeleteDelayMs;
            return this;
        }

        /**
         * @param logSegmentDeleteDelayMs The amount of time to wait before deleting a file from the filesystem (Default: 60000 ms (1 minute)). Example: `60000`.
         * 
         * @return builder
         * 
         */
        public Builder logSegmentDeleteDelayMs(Integer logSegmentDeleteDelayMs) {
            return logSegmentDeleteDelayMs(Output.of(logSegmentDeleteDelayMs));
        }

        /**
         * @param maxConnectionsPerIp The maximum number of connections allowed from each ip address (Default: 2147483647).
         * 
         * @return builder
         * 
         */
        public Builder maxConnectionsPerIp(@Nullable Output<Integer> maxConnectionsPerIp) {
            $.maxConnectionsPerIp = maxConnectionsPerIp;
            return this;
        }

        /**
         * @param maxConnectionsPerIp The maximum number of connections allowed from each ip address (Default: 2147483647).
         * 
         * @return builder
         * 
         */
        public Builder maxConnectionsPerIp(Integer maxConnectionsPerIp) {
            return maxConnectionsPerIp(Output.of(maxConnectionsPerIp));
        }

        /**
         * @param maxIncrementalFetchSessionCacheSlots The maximum number of incremental fetch sessions that the broker will maintain. (Default: 1000). Example: `1000`.
         * 
         * @return builder
         * 
         */
        public Builder maxIncrementalFetchSessionCacheSlots(@Nullable Output<Integer> maxIncrementalFetchSessionCacheSlots) {
            $.maxIncrementalFetchSessionCacheSlots = maxIncrementalFetchSessionCacheSlots;
            return this;
        }

        /**
         * @param maxIncrementalFetchSessionCacheSlots The maximum number of incremental fetch sessions that the broker will maintain. (Default: 1000). Example: `1000`.
         * 
         * @return builder
         * 
         */
        public Builder maxIncrementalFetchSessionCacheSlots(Integer maxIncrementalFetchSessionCacheSlots) {
            return maxIncrementalFetchSessionCacheSlots(Output.of(maxIncrementalFetchSessionCacheSlots));
        }

        /**
         * @param messageMaxBytes The maximum size of message that the server can receive. (Default: 1048588 bytes (1 mebibyte + 12 bytes)). Example: `1048588`.
         * 
         * @return builder
         * 
         */
        public Builder messageMaxBytes(@Nullable Output<Integer> messageMaxBytes) {
            $.messageMaxBytes = messageMaxBytes;
            return this;
        }

        /**
         * @param messageMaxBytes The maximum size of message that the server can receive. (Default: 1048588 bytes (1 mebibyte + 12 bytes)). Example: `1048588`.
         * 
         * @return builder
         * 
         */
        public Builder messageMaxBytes(Integer messageMaxBytes) {
            return messageMaxBytes(Output.of(messageMaxBytes));
        }

        /**
         * @param minInsyncReplicas When a producer sets acks to `all` (or `-1`), min.insync.replicas specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. (Default: 1). Example: `1`.
         * 
         * @return builder
         * 
         */
        public Builder minInsyncReplicas(@Nullable Output<Integer> minInsyncReplicas) {
            $.minInsyncReplicas = minInsyncReplicas;
            return this;
        }

        /**
         * @param minInsyncReplicas When a producer sets acks to `all` (or `-1`), min.insync.replicas specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. (Default: 1). Example: `1`.
         * 
         * @return builder
         * 
         */
        public Builder minInsyncReplicas(Integer minInsyncReplicas) {
            return minInsyncReplicas(Output.of(minInsyncReplicas));
        }

        /**
         * @param numPartitions Number of partitions for auto-created topics (Default: 1).
         * 
         * @return builder
         * 
         */
        public Builder numPartitions(@Nullable Output<Integer> numPartitions) {
            $.numPartitions = numPartitions;
            return this;
        }

        /**
         * @param numPartitions Number of partitions for auto-created topics (Default: 1).
         * 
         * @return builder
         * 
         */
        public Builder numPartitions(Integer numPartitions) {
            return numPartitions(Output.of(numPartitions));
        }

        /**
         * @param offsetsRetentionMinutes Log retention window in minutes for offsets topic (Default: 10080 minutes (7 days)). Example: `10080`.
         * 
         * @return builder
         * 
         */
        public Builder offsetsRetentionMinutes(@Nullable Output<Integer> offsetsRetentionMinutes) {
            $.offsetsRetentionMinutes = offsetsRetentionMinutes;
            return this;
        }

        /**
         * @param offsetsRetentionMinutes Log retention window in minutes for offsets topic (Default: 10080 minutes (7 days)). Example: `10080`.
         * 
         * @return builder
         * 
         */
        public Builder offsetsRetentionMinutes(Integer offsetsRetentionMinutes) {
            return offsetsRetentionMinutes(Output.of(offsetsRetentionMinutes));
        }

        /**
         * @param producerPurgatoryPurgeIntervalRequests The purge interval (in number of requests) of the producer request purgatory (Default: 1000).
         * 
         * @return builder
         * 
         */
        public Builder producerPurgatoryPurgeIntervalRequests(@Nullable Output<Integer> producerPurgatoryPurgeIntervalRequests) {
            $.producerPurgatoryPurgeIntervalRequests = producerPurgatoryPurgeIntervalRequests;
            return this;
        }

        /**
         * @param producerPurgatoryPurgeIntervalRequests The purge interval (in number of requests) of the producer request purgatory (Default: 1000).
         * 
         * @return builder
         * 
         */
        public Builder producerPurgatoryPurgeIntervalRequests(Integer producerPurgatoryPurgeIntervalRequests) {
            return producerPurgatoryPurgeIntervalRequests(Output.of(producerPurgatoryPurgeIntervalRequests));
        }

        /**
         * @param replicaFetchMaxBytes The number of bytes of messages to attempt to fetch for each partition . This is not an absolute maximum, if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that progress can be made. (Default: 1048576 bytes (1 mebibytes)).
         * 
         * @return builder
         * 
         */
        public Builder replicaFetchMaxBytes(@Nullable Output<Integer> replicaFetchMaxBytes) {
            $.replicaFetchMaxBytes = replicaFetchMaxBytes;
            return this;
        }

        /**
         * @param replicaFetchMaxBytes The number of bytes of messages to attempt to fetch for each partition . This is not an absolute maximum, if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that progress can be made. (Default: 1048576 bytes (1 mebibytes)).
         * 
         * @return builder
         * 
         */
        public Builder replicaFetchMaxBytes(Integer replicaFetchMaxBytes) {
            return replicaFetchMaxBytes(Output.of(replicaFetchMaxBytes));
        }

        /**
         * @param replicaFetchResponseMaxBytes Maximum bytes expected for the entire fetch response. Records are fetched in batches, and if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that progress can be made. As such, this is not an absolute maximum. (Default: 10485760 bytes (10 mebibytes)).
         * 
         * @return builder
         * 
         */
        public Builder replicaFetchResponseMaxBytes(@Nullable Output<Integer> replicaFetchResponseMaxBytes) {
            $.replicaFetchResponseMaxBytes = replicaFetchResponseMaxBytes;
            return this;
        }

        /**
         * @param replicaFetchResponseMaxBytes Maximum bytes expected for the entire fetch response. Records are fetched in batches, and if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that progress can be made. As such, this is not an absolute maximum. (Default: 10485760 bytes (10 mebibytes)).
         * 
         * @return builder
         * 
         */
        public Builder replicaFetchResponseMaxBytes(Integer replicaFetchResponseMaxBytes) {
            return replicaFetchResponseMaxBytes(Output.of(replicaFetchResponseMaxBytes));
        }

        /**
         * @param saslOauthbearerExpectedAudience The (optional) comma-delimited setting for the broker to use to verify that the JWT was issued for one of the expected audiences. (Default: null).
         * 
         * @return builder
         * 
         */
        public Builder saslOauthbearerExpectedAudience(@Nullable Output<String> saslOauthbearerExpectedAudience) {
            $.saslOauthbearerExpectedAudience = saslOauthbearerExpectedAudience;
            return this;
        }

        /**
         * @param saslOauthbearerExpectedAudience The (optional) comma-delimited setting for the broker to use to verify that the JWT was issued for one of the expected audiences. (Default: null).
         * 
         * @return builder
         * 
         */
        public Builder saslOauthbearerExpectedAudience(String saslOauthbearerExpectedAudience) {
            return saslOauthbearerExpectedAudience(Output.of(saslOauthbearerExpectedAudience));
        }

        /**
         * @param saslOauthbearerExpectedIssuer Optional setting for the broker to use to verify that the JWT was created by the expected issuer.(Default: null).
         * 
         * @return builder
         * 
         */
        public Builder saslOauthbearerExpectedIssuer(@Nullable Output<String> saslOauthbearerExpectedIssuer) {
            $.saslOauthbearerExpectedIssuer = saslOauthbearerExpectedIssuer;
            return this;
        }

        /**
         * @param saslOauthbearerExpectedIssuer Optional setting for the broker to use to verify that the JWT was created by the expected issuer.(Default: null).
         * 
         * @return builder
         * 
         */
        public Builder saslOauthbearerExpectedIssuer(String saslOauthbearerExpectedIssuer) {
            return saslOauthbearerExpectedIssuer(Output.of(saslOauthbearerExpectedIssuer));
        }

        /**
         * @param saslOauthbearerJwksEndpointUrl OIDC JWKS endpoint URL. By setting this the SASL SSL OAuth2/OIDC authentication is enabled. See also other options for SASL OAuth2/OIDC. (Default: null).
         * 
         * @return builder
         * 
         */
        public Builder saslOauthbearerJwksEndpointUrl(@Nullable Output<String> saslOauthbearerJwksEndpointUrl) {
            $.saslOauthbearerJwksEndpointUrl = saslOauthbearerJwksEndpointUrl;
            return this;
        }

        /**
         * @param saslOauthbearerJwksEndpointUrl OIDC JWKS endpoint URL. By setting this the SASL SSL OAuth2/OIDC authentication is enabled. See also other options for SASL OAuth2/OIDC. (Default: null).
         * 
         * @return builder
         * 
         */
        public Builder saslOauthbearerJwksEndpointUrl(String saslOauthbearerJwksEndpointUrl) {
            return saslOauthbearerJwksEndpointUrl(Output.of(saslOauthbearerJwksEndpointUrl));
        }

        /**
         * @param saslOauthbearerSubClaimName Name of the scope from which to extract the subject claim from the JWT.(Default: sub).
         * 
         * @return builder
         * 
         */
        public Builder saslOauthbearerSubClaimName(@Nullable Output<String> saslOauthbearerSubClaimName) {
            $.saslOauthbearerSubClaimName = saslOauthbearerSubClaimName;
            return this;
        }

        /**
         * @param saslOauthbearerSubClaimName Name of the scope from which to extract the subject claim from the JWT.(Default: sub).
         * 
         * @return builder
         * 
         */
        public Builder saslOauthbearerSubClaimName(String saslOauthbearerSubClaimName) {
            return saslOauthbearerSubClaimName(Output.of(saslOauthbearerSubClaimName));
        }

        /**
         * @param socketRequestMaxBytes The maximum number of bytes in a socket request (Default: 104857600 bytes).
         * 
         * @return builder
         * 
         */
        public Builder socketRequestMaxBytes(@Nullable Output<Integer> socketRequestMaxBytes) {
            $.socketRequestMaxBytes = socketRequestMaxBytes;
            return this;
        }

        /**
         * @param socketRequestMaxBytes The maximum number of bytes in a socket request (Default: 104857600 bytes).
         * 
         * @return builder
         * 
         */
        public Builder socketRequestMaxBytes(Integer socketRequestMaxBytes) {
            return socketRequestMaxBytes(Output.of(socketRequestMaxBytes));
        }

        /**
         * @param transactionPartitionVerificationEnable Enable verification that checks that the partition has been added to the transaction before writing transactional records to the partition. (Default: false).
         * 
         * @return builder
         * 
         */
        public Builder transactionPartitionVerificationEnable(@Nullable Output<Boolean> transactionPartitionVerificationEnable) {
            $.transactionPartitionVerificationEnable = transactionPartitionVerificationEnable;
            return this;
        }

        /**
         * @param transactionPartitionVerificationEnable Enable verification that checks that the partition has been added to the transaction before writing transactional records to the partition. (Default: false).
         * 
         * @return builder
         * 
         */
        public Builder transactionPartitionVerificationEnable(Boolean transactionPartitionVerificationEnable) {
            return transactionPartitionVerificationEnable(Output.of(transactionPartitionVerificationEnable));
        }

        /**
         * @param transactionRemoveExpiredTransactionCleanupIntervalMs The interval at which to remove transactions that have expired due to transactional.id.expiration.ms passing (Default: 3600000 ms (1 hour)). Example: `3600000`.
         * 
         * @return builder
         * 
         */
        public Builder transactionRemoveExpiredTransactionCleanupIntervalMs(@Nullable Output<Integer> transactionRemoveExpiredTransactionCleanupIntervalMs) {
            $.transactionRemoveExpiredTransactionCleanupIntervalMs = transactionRemoveExpiredTransactionCleanupIntervalMs;
            return this;
        }

        /**
         * @param transactionRemoveExpiredTransactionCleanupIntervalMs The interval at which to remove transactions that have expired due to transactional.id.expiration.ms passing (Default: 3600000 ms (1 hour)). Example: `3600000`.
         * 
         * @return builder
         * 
         */
        public Builder transactionRemoveExpiredTransactionCleanupIntervalMs(Integer transactionRemoveExpiredTransactionCleanupIntervalMs) {
            return transactionRemoveExpiredTransactionCleanupIntervalMs(Output.of(transactionRemoveExpiredTransactionCleanupIntervalMs));
        }

        /**
         * @param transactionStateLogSegmentBytes The transaction topic segment bytes should be kept relatively small in order to facilitate faster log compaction and cache loads (Default: 104857600 bytes (100 mebibytes)). Example: `104857600`.
         * 
         * @return builder
         * 
         */
        public Builder transactionStateLogSegmentBytes(@Nullable Output<Integer> transactionStateLogSegmentBytes) {
            $.transactionStateLogSegmentBytes = transactionStateLogSegmentBytes;
            return this;
        }

        /**
         * @param transactionStateLogSegmentBytes The transaction topic segment bytes should be kept relatively small in order to facilitate faster log compaction and cache loads (Default: 104857600 bytes (100 mebibytes)). Example: `104857600`.
         * 
         * @return builder
         * 
         */
        public Builder transactionStateLogSegmentBytes(Integer transactionStateLogSegmentBytes) {
            return transactionStateLogSegmentBytes(Output.of(transactionStateLogSegmentBytes));
        }

        public KafkaKafkaUserConfigKafkaArgs build() {
            return $;
        }
    }

}
