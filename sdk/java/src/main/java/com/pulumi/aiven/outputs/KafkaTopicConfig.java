// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aiven.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class KafkaTopicConfig {
    /**
     * @return cleanup.policy value
     * 
     */
    private @Nullable String cleanupPolicy;
    /**
     * @return compression.type value
     * 
     */
    private @Nullable String compressionType;
    /**
     * @return delete.retention.ms value
     * 
     */
    private @Nullable String deleteRetentionMs;
    /**
     * @return file.delete.delay.ms value
     * 
     */
    private @Nullable String fileDeleteDelayMs;
    /**
     * @return flush.messages value
     * 
     */
    private @Nullable String flushMessages;
    /**
     * @return flush.ms value
     * 
     */
    private @Nullable String flushMs;
    /**
     * @return index.interval.bytes value
     * 
     */
    private @Nullable String indexIntervalBytes;
    /**
     * @return max.compaction.lag.ms value
     * 
     */
    private @Nullable String maxCompactionLagMs;
    /**
     * @return max.message.bytes value
     * 
     */
    private @Nullable String maxMessageBytes;
    /**
     * @return message.downconversion.enable value
     * 
     */
    private @Nullable Boolean messageDownconversionEnable;
    /**
     * @return message.format.version value
     * 
     */
    private @Nullable String messageFormatVersion;
    /**
     * @return message.timestamp.difference.max.ms value
     * 
     */
    private @Nullable String messageTimestampDifferenceMaxMs;
    /**
     * @return message.timestamp.type value
     * 
     */
    private @Nullable String messageTimestampType;
    /**
     * @return min.cleanable.dirty.ratio value
     * 
     */
    private @Nullable Double minCleanableDirtyRatio;
    /**
     * @return min.compaction.lag.ms value
     * 
     */
    private @Nullable String minCompactionLagMs;
    /**
     * @return min.insync.replicas value
     * 
     */
    private @Nullable String minInsyncReplicas;
    /**
     * @return preallocate value
     * 
     */
    private @Nullable Boolean preallocate;
    /**
     * @return retention.bytes value
     * 
     */
    private @Nullable String retentionBytes;
    /**
     * @return retention.ms value
     * 
     */
    private @Nullable String retentionMs;
    /**
     * @return segment.bytes value
     * 
     */
    private @Nullable String segmentBytes;
    /**
     * @return segment.index.bytes value
     * 
     */
    private @Nullable String segmentIndexBytes;
    /**
     * @return segment.jitter.ms value
     * 
     */
    private @Nullable String segmentJitterMs;
    /**
     * @return segment.ms value
     * 
     */
    private @Nullable String segmentMs;
    /**
     * @return unclean.leader.election.enable value; This field is deprecated and no longer functional.
     * 
     * @deprecated
     * This field is deprecated and no longer functional.
     * 
     */
    @Deprecated /* This field is deprecated and no longer functional. */
    private @Nullable Boolean uncleanLeaderElectionEnable;

    private KafkaTopicConfig() {}
    /**
     * @return cleanup.policy value
     * 
     */
    public Optional<String> cleanupPolicy() {
        return Optional.ofNullable(this.cleanupPolicy);
    }
    /**
     * @return compression.type value
     * 
     */
    public Optional<String> compressionType() {
        return Optional.ofNullable(this.compressionType);
    }
    /**
     * @return delete.retention.ms value
     * 
     */
    public Optional<String> deleteRetentionMs() {
        return Optional.ofNullable(this.deleteRetentionMs);
    }
    /**
     * @return file.delete.delay.ms value
     * 
     */
    public Optional<String> fileDeleteDelayMs() {
        return Optional.ofNullable(this.fileDeleteDelayMs);
    }
    /**
     * @return flush.messages value
     * 
     */
    public Optional<String> flushMessages() {
        return Optional.ofNullable(this.flushMessages);
    }
    /**
     * @return flush.ms value
     * 
     */
    public Optional<String> flushMs() {
        return Optional.ofNullable(this.flushMs);
    }
    /**
     * @return index.interval.bytes value
     * 
     */
    public Optional<String> indexIntervalBytes() {
        return Optional.ofNullable(this.indexIntervalBytes);
    }
    /**
     * @return max.compaction.lag.ms value
     * 
     */
    public Optional<String> maxCompactionLagMs() {
        return Optional.ofNullable(this.maxCompactionLagMs);
    }
    /**
     * @return max.message.bytes value
     * 
     */
    public Optional<String> maxMessageBytes() {
        return Optional.ofNullable(this.maxMessageBytes);
    }
    /**
     * @return message.downconversion.enable value
     * 
     */
    public Optional<Boolean> messageDownconversionEnable() {
        return Optional.ofNullable(this.messageDownconversionEnable);
    }
    /**
     * @return message.format.version value
     * 
     */
    public Optional<String> messageFormatVersion() {
        return Optional.ofNullable(this.messageFormatVersion);
    }
    /**
     * @return message.timestamp.difference.max.ms value
     * 
     */
    public Optional<String> messageTimestampDifferenceMaxMs() {
        return Optional.ofNullable(this.messageTimestampDifferenceMaxMs);
    }
    /**
     * @return message.timestamp.type value
     * 
     */
    public Optional<String> messageTimestampType() {
        return Optional.ofNullable(this.messageTimestampType);
    }
    /**
     * @return min.cleanable.dirty.ratio value
     * 
     */
    public Optional<Double> minCleanableDirtyRatio() {
        return Optional.ofNullable(this.minCleanableDirtyRatio);
    }
    /**
     * @return min.compaction.lag.ms value
     * 
     */
    public Optional<String> minCompactionLagMs() {
        return Optional.ofNullable(this.minCompactionLagMs);
    }
    /**
     * @return min.insync.replicas value
     * 
     */
    public Optional<String> minInsyncReplicas() {
        return Optional.ofNullable(this.minInsyncReplicas);
    }
    /**
     * @return preallocate value
     * 
     */
    public Optional<Boolean> preallocate() {
        return Optional.ofNullable(this.preallocate);
    }
    /**
     * @return retention.bytes value
     * 
     */
    public Optional<String> retentionBytes() {
        return Optional.ofNullable(this.retentionBytes);
    }
    /**
     * @return retention.ms value
     * 
     */
    public Optional<String> retentionMs() {
        return Optional.ofNullable(this.retentionMs);
    }
    /**
     * @return segment.bytes value
     * 
     */
    public Optional<String> segmentBytes() {
        return Optional.ofNullable(this.segmentBytes);
    }
    /**
     * @return segment.index.bytes value
     * 
     */
    public Optional<String> segmentIndexBytes() {
        return Optional.ofNullable(this.segmentIndexBytes);
    }
    /**
     * @return segment.jitter.ms value
     * 
     */
    public Optional<String> segmentJitterMs() {
        return Optional.ofNullable(this.segmentJitterMs);
    }
    /**
     * @return segment.ms value
     * 
     */
    public Optional<String> segmentMs() {
        return Optional.ofNullable(this.segmentMs);
    }
    /**
     * @return unclean.leader.election.enable value; This field is deprecated and no longer functional.
     * 
     * @deprecated
     * This field is deprecated and no longer functional.
     * 
     */
    @Deprecated /* This field is deprecated and no longer functional. */
    public Optional<Boolean> uncleanLeaderElectionEnable() {
        return Optional.ofNullable(this.uncleanLeaderElectionEnable);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(KafkaTopicConfig defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable String cleanupPolicy;
        private @Nullable String compressionType;
        private @Nullable String deleteRetentionMs;
        private @Nullable String fileDeleteDelayMs;
        private @Nullable String flushMessages;
        private @Nullable String flushMs;
        private @Nullable String indexIntervalBytes;
        private @Nullable String maxCompactionLagMs;
        private @Nullable String maxMessageBytes;
        private @Nullable Boolean messageDownconversionEnable;
        private @Nullable String messageFormatVersion;
        private @Nullable String messageTimestampDifferenceMaxMs;
        private @Nullable String messageTimestampType;
        private @Nullable Double minCleanableDirtyRatio;
        private @Nullable String minCompactionLagMs;
        private @Nullable String minInsyncReplicas;
        private @Nullable Boolean preallocate;
        private @Nullable String retentionBytes;
        private @Nullable String retentionMs;
        private @Nullable String segmentBytes;
        private @Nullable String segmentIndexBytes;
        private @Nullable String segmentJitterMs;
        private @Nullable String segmentMs;
        private @Nullable Boolean uncleanLeaderElectionEnable;
        public Builder() {}
        public Builder(KafkaTopicConfig defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.cleanupPolicy = defaults.cleanupPolicy;
    	      this.compressionType = defaults.compressionType;
    	      this.deleteRetentionMs = defaults.deleteRetentionMs;
    	      this.fileDeleteDelayMs = defaults.fileDeleteDelayMs;
    	      this.flushMessages = defaults.flushMessages;
    	      this.flushMs = defaults.flushMs;
    	      this.indexIntervalBytes = defaults.indexIntervalBytes;
    	      this.maxCompactionLagMs = defaults.maxCompactionLagMs;
    	      this.maxMessageBytes = defaults.maxMessageBytes;
    	      this.messageDownconversionEnable = defaults.messageDownconversionEnable;
    	      this.messageFormatVersion = defaults.messageFormatVersion;
    	      this.messageTimestampDifferenceMaxMs = defaults.messageTimestampDifferenceMaxMs;
    	      this.messageTimestampType = defaults.messageTimestampType;
    	      this.minCleanableDirtyRatio = defaults.minCleanableDirtyRatio;
    	      this.minCompactionLagMs = defaults.minCompactionLagMs;
    	      this.minInsyncReplicas = defaults.minInsyncReplicas;
    	      this.preallocate = defaults.preallocate;
    	      this.retentionBytes = defaults.retentionBytes;
    	      this.retentionMs = defaults.retentionMs;
    	      this.segmentBytes = defaults.segmentBytes;
    	      this.segmentIndexBytes = defaults.segmentIndexBytes;
    	      this.segmentJitterMs = defaults.segmentJitterMs;
    	      this.segmentMs = defaults.segmentMs;
    	      this.uncleanLeaderElectionEnable = defaults.uncleanLeaderElectionEnable;
        }

        @CustomType.Setter
        public Builder cleanupPolicy(@Nullable String cleanupPolicy) {
            this.cleanupPolicy = cleanupPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder compressionType(@Nullable String compressionType) {
            this.compressionType = compressionType;
            return this;
        }
        @CustomType.Setter
        public Builder deleteRetentionMs(@Nullable String deleteRetentionMs) {
            this.deleteRetentionMs = deleteRetentionMs;
            return this;
        }
        @CustomType.Setter
        public Builder fileDeleteDelayMs(@Nullable String fileDeleteDelayMs) {
            this.fileDeleteDelayMs = fileDeleteDelayMs;
            return this;
        }
        @CustomType.Setter
        public Builder flushMessages(@Nullable String flushMessages) {
            this.flushMessages = flushMessages;
            return this;
        }
        @CustomType.Setter
        public Builder flushMs(@Nullable String flushMs) {
            this.flushMs = flushMs;
            return this;
        }
        @CustomType.Setter
        public Builder indexIntervalBytes(@Nullable String indexIntervalBytes) {
            this.indexIntervalBytes = indexIntervalBytes;
            return this;
        }
        @CustomType.Setter
        public Builder maxCompactionLagMs(@Nullable String maxCompactionLagMs) {
            this.maxCompactionLagMs = maxCompactionLagMs;
            return this;
        }
        @CustomType.Setter
        public Builder maxMessageBytes(@Nullable String maxMessageBytes) {
            this.maxMessageBytes = maxMessageBytes;
            return this;
        }
        @CustomType.Setter
        public Builder messageDownconversionEnable(@Nullable Boolean messageDownconversionEnable) {
            this.messageDownconversionEnable = messageDownconversionEnable;
            return this;
        }
        @CustomType.Setter
        public Builder messageFormatVersion(@Nullable String messageFormatVersion) {
            this.messageFormatVersion = messageFormatVersion;
            return this;
        }
        @CustomType.Setter
        public Builder messageTimestampDifferenceMaxMs(@Nullable String messageTimestampDifferenceMaxMs) {
            this.messageTimestampDifferenceMaxMs = messageTimestampDifferenceMaxMs;
            return this;
        }
        @CustomType.Setter
        public Builder messageTimestampType(@Nullable String messageTimestampType) {
            this.messageTimestampType = messageTimestampType;
            return this;
        }
        @CustomType.Setter
        public Builder minCleanableDirtyRatio(@Nullable Double minCleanableDirtyRatio) {
            this.minCleanableDirtyRatio = minCleanableDirtyRatio;
            return this;
        }
        @CustomType.Setter
        public Builder minCompactionLagMs(@Nullable String minCompactionLagMs) {
            this.minCompactionLagMs = minCompactionLagMs;
            return this;
        }
        @CustomType.Setter
        public Builder minInsyncReplicas(@Nullable String minInsyncReplicas) {
            this.minInsyncReplicas = minInsyncReplicas;
            return this;
        }
        @CustomType.Setter
        public Builder preallocate(@Nullable Boolean preallocate) {
            this.preallocate = preallocate;
            return this;
        }
        @CustomType.Setter
        public Builder retentionBytes(@Nullable String retentionBytes) {
            this.retentionBytes = retentionBytes;
            return this;
        }
        @CustomType.Setter
        public Builder retentionMs(@Nullable String retentionMs) {
            this.retentionMs = retentionMs;
            return this;
        }
        @CustomType.Setter
        public Builder segmentBytes(@Nullable String segmentBytes) {
            this.segmentBytes = segmentBytes;
            return this;
        }
        @CustomType.Setter
        public Builder segmentIndexBytes(@Nullable String segmentIndexBytes) {
            this.segmentIndexBytes = segmentIndexBytes;
            return this;
        }
        @CustomType.Setter
        public Builder segmentJitterMs(@Nullable String segmentJitterMs) {
            this.segmentJitterMs = segmentJitterMs;
            return this;
        }
        @CustomType.Setter
        public Builder segmentMs(@Nullable String segmentMs) {
            this.segmentMs = segmentMs;
            return this;
        }
        @CustomType.Setter
        public Builder uncleanLeaderElectionEnable(@Nullable Boolean uncleanLeaderElectionEnable) {
            this.uncleanLeaderElectionEnable = uncleanLeaderElectionEnable;
            return this;
        }
        public KafkaTopicConfig build() {
            final var o = new KafkaTopicConfig();
            o.cleanupPolicy = cleanupPolicy;
            o.compressionType = compressionType;
            o.deleteRetentionMs = deleteRetentionMs;
            o.fileDeleteDelayMs = fileDeleteDelayMs;
            o.flushMessages = flushMessages;
            o.flushMs = flushMs;
            o.indexIntervalBytes = indexIntervalBytes;
            o.maxCompactionLagMs = maxCompactionLagMs;
            o.maxMessageBytes = maxMessageBytes;
            o.messageDownconversionEnable = messageDownconversionEnable;
            o.messageFormatVersion = messageFormatVersion;
            o.messageTimestampDifferenceMaxMs = messageTimestampDifferenceMaxMs;
            o.messageTimestampType = messageTimestampType;
            o.minCleanableDirtyRatio = minCleanableDirtyRatio;
            o.minCompactionLagMs = minCompactionLagMs;
            o.minInsyncReplicas = minInsyncReplicas;
            o.preallocate = preallocate;
            o.retentionBytes = retentionBytes;
            o.retentionMs = retentionMs;
            o.segmentBytes = segmentBytes;
            o.segmentIndexBytes = segmentIndexBytes;
            o.segmentJitterMs = segmentJitterMs;
            o.segmentMs = segmentMs;
            o.uncleanLeaderElectionEnable = uncleanLeaderElectionEnable;
            return o;
        }
    }
}
