// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aiven.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class KafkaTopicConfig {
    private final @Nullable String cleanupPolicy;
    private final @Nullable String compressionType;
    private final @Nullable String deleteRetentionMs;
    private final @Nullable String fileDeleteDelayMs;
    private final @Nullable String flushMessages;
    private final @Nullable String flushMs;
    private final @Nullable String indexIntervalBytes;
    private final @Nullable String maxCompactionLagMs;
    private final @Nullable String maxMessageBytes;
    private final @Nullable String messageDownconversionEnable;
    private final @Nullable String messageFormatVersion;
    private final @Nullable String messageTimestampDifferenceMaxMs;
    private final @Nullable String messageTimestampType;
    private final @Nullable String minCleanableDirtyRatio;
    private final @Nullable String minCompactionLagMs;
    private final @Nullable String minInsyncReplicas;
    private final @Nullable String preallocate;
    private final @Nullable String retentionBytes;
    private final @Nullable String retentionMs;
    private final @Nullable String segmentBytes;
    private final @Nullable String segmentIndexBytes;
    private final @Nullable String segmentJitterMs;
    private final @Nullable String segmentMs;
    private final @Nullable String uncleanLeaderElectionEnable;

    @CustomType.Constructor
    private KafkaTopicConfig(
        @CustomType.Parameter("cleanupPolicy") @Nullable String cleanupPolicy,
        @CustomType.Parameter("compressionType") @Nullable String compressionType,
        @CustomType.Parameter("deleteRetentionMs") @Nullable String deleteRetentionMs,
        @CustomType.Parameter("fileDeleteDelayMs") @Nullable String fileDeleteDelayMs,
        @CustomType.Parameter("flushMessages") @Nullable String flushMessages,
        @CustomType.Parameter("flushMs") @Nullable String flushMs,
        @CustomType.Parameter("indexIntervalBytes") @Nullable String indexIntervalBytes,
        @CustomType.Parameter("maxCompactionLagMs") @Nullable String maxCompactionLagMs,
        @CustomType.Parameter("maxMessageBytes") @Nullable String maxMessageBytes,
        @CustomType.Parameter("messageDownconversionEnable") @Nullable String messageDownconversionEnable,
        @CustomType.Parameter("messageFormatVersion") @Nullable String messageFormatVersion,
        @CustomType.Parameter("messageTimestampDifferenceMaxMs") @Nullable String messageTimestampDifferenceMaxMs,
        @CustomType.Parameter("messageTimestampType") @Nullable String messageTimestampType,
        @CustomType.Parameter("minCleanableDirtyRatio") @Nullable String minCleanableDirtyRatio,
        @CustomType.Parameter("minCompactionLagMs") @Nullable String minCompactionLagMs,
        @CustomType.Parameter("minInsyncReplicas") @Nullable String minInsyncReplicas,
        @CustomType.Parameter("preallocate") @Nullable String preallocate,
        @CustomType.Parameter("retentionBytes") @Nullable String retentionBytes,
        @CustomType.Parameter("retentionMs") @Nullable String retentionMs,
        @CustomType.Parameter("segmentBytes") @Nullable String segmentBytes,
        @CustomType.Parameter("segmentIndexBytes") @Nullable String segmentIndexBytes,
        @CustomType.Parameter("segmentJitterMs") @Nullable String segmentJitterMs,
        @CustomType.Parameter("segmentMs") @Nullable String segmentMs,
        @CustomType.Parameter("uncleanLeaderElectionEnable") @Nullable String uncleanLeaderElectionEnable) {
        this.cleanupPolicy = cleanupPolicy;
        this.compressionType = compressionType;
        this.deleteRetentionMs = deleteRetentionMs;
        this.fileDeleteDelayMs = fileDeleteDelayMs;
        this.flushMessages = flushMessages;
        this.flushMs = flushMs;
        this.indexIntervalBytes = indexIntervalBytes;
        this.maxCompactionLagMs = maxCompactionLagMs;
        this.maxMessageBytes = maxMessageBytes;
        this.messageDownconversionEnable = messageDownconversionEnable;
        this.messageFormatVersion = messageFormatVersion;
        this.messageTimestampDifferenceMaxMs = messageTimestampDifferenceMaxMs;
        this.messageTimestampType = messageTimestampType;
        this.minCleanableDirtyRatio = minCleanableDirtyRatio;
        this.minCompactionLagMs = minCompactionLagMs;
        this.minInsyncReplicas = minInsyncReplicas;
        this.preallocate = preallocate;
        this.retentionBytes = retentionBytes;
        this.retentionMs = retentionMs;
        this.segmentBytes = segmentBytes;
        this.segmentIndexBytes = segmentIndexBytes;
        this.segmentJitterMs = segmentJitterMs;
        this.segmentMs = segmentMs;
        this.uncleanLeaderElectionEnable = uncleanLeaderElectionEnable;
    }

    public Optional<String> cleanupPolicy() {
        return Optional.ofNullable(this.cleanupPolicy);
    }
    public Optional<String> compressionType() {
        return Optional.ofNullable(this.compressionType);
    }
    public Optional<String> deleteRetentionMs() {
        return Optional.ofNullable(this.deleteRetentionMs);
    }
    public Optional<String> fileDeleteDelayMs() {
        return Optional.ofNullable(this.fileDeleteDelayMs);
    }
    public Optional<String> flushMessages() {
        return Optional.ofNullable(this.flushMessages);
    }
    public Optional<String> flushMs() {
        return Optional.ofNullable(this.flushMs);
    }
    public Optional<String> indexIntervalBytes() {
        return Optional.ofNullable(this.indexIntervalBytes);
    }
    public Optional<String> maxCompactionLagMs() {
        return Optional.ofNullable(this.maxCompactionLagMs);
    }
    public Optional<String> maxMessageBytes() {
        return Optional.ofNullable(this.maxMessageBytes);
    }
    public Optional<String> messageDownconversionEnable() {
        return Optional.ofNullable(this.messageDownconversionEnable);
    }
    public Optional<String> messageFormatVersion() {
        return Optional.ofNullable(this.messageFormatVersion);
    }
    public Optional<String> messageTimestampDifferenceMaxMs() {
        return Optional.ofNullable(this.messageTimestampDifferenceMaxMs);
    }
    public Optional<String> messageTimestampType() {
        return Optional.ofNullable(this.messageTimestampType);
    }
    public Optional<String> minCleanableDirtyRatio() {
        return Optional.ofNullable(this.minCleanableDirtyRatio);
    }
    public Optional<String> minCompactionLagMs() {
        return Optional.ofNullable(this.minCompactionLagMs);
    }
    public Optional<String> minInsyncReplicas() {
        return Optional.ofNullable(this.minInsyncReplicas);
    }
    public Optional<String> preallocate() {
        return Optional.ofNullable(this.preallocate);
    }
    public Optional<String> retentionBytes() {
        return Optional.ofNullable(this.retentionBytes);
    }
    public Optional<String> retentionMs() {
        return Optional.ofNullable(this.retentionMs);
    }
    public Optional<String> segmentBytes() {
        return Optional.ofNullable(this.segmentBytes);
    }
    public Optional<String> segmentIndexBytes() {
        return Optional.ofNullable(this.segmentIndexBytes);
    }
    public Optional<String> segmentJitterMs() {
        return Optional.ofNullable(this.segmentJitterMs);
    }
    public Optional<String> segmentMs() {
        return Optional.ofNullable(this.segmentMs);
    }
    public Optional<String> uncleanLeaderElectionEnable() {
        return Optional.ofNullable(this.uncleanLeaderElectionEnable);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(KafkaTopicConfig defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable String cleanupPolicy;
        private @Nullable String compressionType;
        private @Nullable String deleteRetentionMs;
        private @Nullable String fileDeleteDelayMs;
        private @Nullable String flushMessages;
        private @Nullable String flushMs;
        private @Nullable String indexIntervalBytes;
        private @Nullable String maxCompactionLagMs;
        private @Nullable String maxMessageBytes;
        private @Nullable String messageDownconversionEnable;
        private @Nullable String messageFormatVersion;
        private @Nullable String messageTimestampDifferenceMaxMs;
        private @Nullable String messageTimestampType;
        private @Nullable String minCleanableDirtyRatio;
        private @Nullable String minCompactionLagMs;
        private @Nullable String minInsyncReplicas;
        private @Nullable String preallocate;
        private @Nullable String retentionBytes;
        private @Nullable String retentionMs;
        private @Nullable String segmentBytes;
        private @Nullable String segmentIndexBytes;
        private @Nullable String segmentJitterMs;
        private @Nullable String segmentMs;
        private @Nullable String uncleanLeaderElectionEnable;

        public Builder() {
    	      // Empty
        }

        public Builder(KafkaTopicConfig defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.cleanupPolicy = defaults.cleanupPolicy;
    	      this.compressionType = defaults.compressionType;
    	      this.deleteRetentionMs = defaults.deleteRetentionMs;
    	      this.fileDeleteDelayMs = defaults.fileDeleteDelayMs;
    	      this.flushMessages = defaults.flushMessages;
    	      this.flushMs = defaults.flushMs;
    	      this.indexIntervalBytes = defaults.indexIntervalBytes;
    	      this.maxCompactionLagMs = defaults.maxCompactionLagMs;
    	      this.maxMessageBytes = defaults.maxMessageBytes;
    	      this.messageDownconversionEnable = defaults.messageDownconversionEnable;
    	      this.messageFormatVersion = defaults.messageFormatVersion;
    	      this.messageTimestampDifferenceMaxMs = defaults.messageTimestampDifferenceMaxMs;
    	      this.messageTimestampType = defaults.messageTimestampType;
    	      this.minCleanableDirtyRatio = defaults.minCleanableDirtyRatio;
    	      this.minCompactionLagMs = defaults.minCompactionLagMs;
    	      this.minInsyncReplicas = defaults.minInsyncReplicas;
    	      this.preallocate = defaults.preallocate;
    	      this.retentionBytes = defaults.retentionBytes;
    	      this.retentionMs = defaults.retentionMs;
    	      this.segmentBytes = defaults.segmentBytes;
    	      this.segmentIndexBytes = defaults.segmentIndexBytes;
    	      this.segmentJitterMs = defaults.segmentJitterMs;
    	      this.segmentMs = defaults.segmentMs;
    	      this.uncleanLeaderElectionEnable = defaults.uncleanLeaderElectionEnable;
        }

        public Builder cleanupPolicy(@Nullable String cleanupPolicy) {
            this.cleanupPolicy = cleanupPolicy;
            return this;
        }
        public Builder compressionType(@Nullable String compressionType) {
            this.compressionType = compressionType;
            return this;
        }
        public Builder deleteRetentionMs(@Nullable String deleteRetentionMs) {
            this.deleteRetentionMs = deleteRetentionMs;
            return this;
        }
        public Builder fileDeleteDelayMs(@Nullable String fileDeleteDelayMs) {
            this.fileDeleteDelayMs = fileDeleteDelayMs;
            return this;
        }
        public Builder flushMessages(@Nullable String flushMessages) {
            this.flushMessages = flushMessages;
            return this;
        }
        public Builder flushMs(@Nullable String flushMs) {
            this.flushMs = flushMs;
            return this;
        }
        public Builder indexIntervalBytes(@Nullable String indexIntervalBytes) {
            this.indexIntervalBytes = indexIntervalBytes;
            return this;
        }
        public Builder maxCompactionLagMs(@Nullable String maxCompactionLagMs) {
            this.maxCompactionLagMs = maxCompactionLagMs;
            return this;
        }
        public Builder maxMessageBytes(@Nullable String maxMessageBytes) {
            this.maxMessageBytes = maxMessageBytes;
            return this;
        }
        public Builder messageDownconversionEnable(@Nullable String messageDownconversionEnable) {
            this.messageDownconversionEnable = messageDownconversionEnable;
            return this;
        }
        public Builder messageFormatVersion(@Nullable String messageFormatVersion) {
            this.messageFormatVersion = messageFormatVersion;
            return this;
        }
        public Builder messageTimestampDifferenceMaxMs(@Nullable String messageTimestampDifferenceMaxMs) {
            this.messageTimestampDifferenceMaxMs = messageTimestampDifferenceMaxMs;
            return this;
        }
        public Builder messageTimestampType(@Nullable String messageTimestampType) {
            this.messageTimestampType = messageTimestampType;
            return this;
        }
        public Builder minCleanableDirtyRatio(@Nullable String minCleanableDirtyRatio) {
            this.minCleanableDirtyRatio = minCleanableDirtyRatio;
            return this;
        }
        public Builder minCompactionLagMs(@Nullable String minCompactionLagMs) {
            this.minCompactionLagMs = minCompactionLagMs;
            return this;
        }
        public Builder minInsyncReplicas(@Nullable String minInsyncReplicas) {
            this.minInsyncReplicas = minInsyncReplicas;
            return this;
        }
        public Builder preallocate(@Nullable String preallocate) {
            this.preallocate = preallocate;
            return this;
        }
        public Builder retentionBytes(@Nullable String retentionBytes) {
            this.retentionBytes = retentionBytes;
            return this;
        }
        public Builder retentionMs(@Nullable String retentionMs) {
            this.retentionMs = retentionMs;
            return this;
        }
        public Builder segmentBytes(@Nullable String segmentBytes) {
            this.segmentBytes = segmentBytes;
            return this;
        }
        public Builder segmentIndexBytes(@Nullable String segmentIndexBytes) {
            this.segmentIndexBytes = segmentIndexBytes;
            return this;
        }
        public Builder segmentJitterMs(@Nullable String segmentJitterMs) {
            this.segmentJitterMs = segmentJitterMs;
            return this;
        }
        public Builder segmentMs(@Nullable String segmentMs) {
            this.segmentMs = segmentMs;
            return this;
        }
        public Builder uncleanLeaderElectionEnable(@Nullable String uncleanLeaderElectionEnable) {
            this.uncleanLeaderElectionEnable = uncleanLeaderElectionEnable;
            return this;
        }        public KafkaTopicConfig build() {
            return new KafkaTopicConfig(cleanupPolicy, compressionType, deleteRetentionMs, fileDeleteDelayMs, flushMessages, flushMs, indexIntervalBytes, maxCompactionLagMs, maxMessageBytes, messageDownconversionEnable, messageFormatVersion, messageTimestampDifferenceMaxMs, messageTimestampType, minCleanableDirtyRatio, minCompactionLagMs, minInsyncReplicas, preallocate, retentionBytes, retentionMs, segmentBytes, segmentIndexBytes, segmentJitterMs, segmentMs, uncleanLeaderElectionEnable);
        }
    }
}
