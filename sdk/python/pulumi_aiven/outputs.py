# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AccountAuthenticationSamlFieldMapping',
    'CassandraCassandra',
    'CassandraCassandraUserConfig',
    'CassandraCassandraUserConfigCassandra',
    'CassandraCassandraUserConfigPrivateAccess',
    'CassandraCassandraUserConfigPublicAccess',
    'CassandraComponent',
    'CassandraServiceIntegration',
    'CassandraTag',
    'ClickhouseClickhouse',
    'ClickhouseClickhouseUserConfig',
    'ClickhouseComponent',
    'ClickhouseGrantPrivilegeGrant',
    'ClickhouseGrantRoleGrant',
    'ClickhouseServiceIntegration',
    'ClickhouseTag',
    'FlinkComponent',
    'FlinkFlink',
    'FlinkFlinkUserConfig',
    'FlinkFlinkUserConfigPrivatelinkAccess',
    'FlinkJobTableUpsertKafka',
    'FlinkServiceIntegration',
    'FlinkTag',
    'GrafanaComponent',
    'GrafanaGrafana',
    'GrafanaGrafanaUserConfig',
    'GrafanaGrafanaUserConfigAuthAzuread',
    'GrafanaGrafanaUserConfigAuthGenericOauth',
    'GrafanaGrafanaUserConfigAuthGithub',
    'GrafanaGrafanaUserConfigAuthGitlab',
    'GrafanaGrafanaUserConfigAuthGoogle',
    'GrafanaGrafanaUserConfigDateFormats',
    'GrafanaGrafanaUserConfigExternalImageStorage',
    'GrafanaGrafanaUserConfigPrivateAccess',
    'GrafanaGrafanaUserConfigPrivatelinkAccess',
    'GrafanaGrafanaUserConfigPublicAccess',
    'GrafanaGrafanaUserConfigSmtpServer',
    'GrafanaServiceIntegration',
    'GrafanaTag',
    'InfluxDbComponent',
    'InfluxDbInfluxdb',
    'InfluxDbInfluxdbUserConfig',
    'InfluxDbInfluxdbUserConfigInfluxdb',
    'InfluxDbInfluxdbUserConfigPrivateAccess',
    'InfluxDbInfluxdbUserConfigPrivatelinkAccess',
    'InfluxDbInfluxdbUserConfigPublicAccess',
    'InfluxDbServiceIntegration',
    'InfluxDbTag',
    'KafkaComponent',
    'KafkaConnectComponent',
    'KafkaConnectKafkaConnect',
    'KafkaConnectKafkaConnectUserConfig',
    'KafkaConnectKafkaConnectUserConfigKafkaConnect',
    'KafkaConnectKafkaConnectUserConfigPrivateAccess',
    'KafkaConnectKafkaConnectUserConfigPrivatelinkAccess',
    'KafkaConnectKafkaConnectUserConfigPublicAccess',
    'KafkaConnectServiceIntegration',
    'KafkaConnectTag',
    'KafkaConnectorTask',
    'KafkaKafka',
    'KafkaKafkaUserConfig',
    'KafkaKafkaUserConfigKafka',
    'KafkaKafkaUserConfigKafkaAuthenticationMethods',
    'KafkaKafkaUserConfigKafkaConnectConfig',
    'KafkaKafkaUserConfigKafkaRestConfig',
    'KafkaKafkaUserConfigPrivateAccess',
    'KafkaKafkaUserConfigPrivatelinkAccess',
    'KafkaKafkaUserConfigPublicAccess',
    'KafkaKafkaUserConfigSchemaRegistryConfig',
    'KafkaMirrorMakerComponent',
    'KafkaMirrorMakerKafkaMirrormaker',
    'KafkaMirrorMakerKafkaMirrormakerUserConfig',
    'KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker',
    'KafkaMirrorMakerServiceIntegration',
    'KafkaMirrorMakerTag',
    'KafkaServiceIntegration',
    'KafkaTag',
    'KafkaTopicConfig',
    'KafkaTopicTag',
    'M3AggregatorComponent',
    'M3AggregatorM3aggregator',
    'M3AggregatorM3aggregatorUserConfig',
    'M3AggregatorServiceIntegration',
    'M3AggregatorTag',
    'M3DbComponent',
    'M3DbM3db',
    'M3DbM3dbUserConfig',
    'M3DbM3dbUserConfigLimits',
    'M3DbM3dbUserConfigNamespace',
    'M3DbM3dbUserConfigNamespaceOptions',
    'M3DbM3dbUserConfigNamespaceOptionsRetentionOptions',
    'M3DbM3dbUserConfigPrivateAccess',
    'M3DbM3dbUserConfigPublicAccess',
    'M3DbM3dbUserConfigRules',
    'M3DbM3dbUserConfigRulesMapping',
    'M3DbM3dbUserConfigRulesMappingTag',
    'M3DbServiceIntegration',
    'M3DbTag',
    'MySqlComponent',
    'MySqlMysql',
    'MySqlMysqlUserConfig',
    'MySqlMysqlUserConfigMigration',
    'MySqlMysqlUserConfigMysql',
    'MySqlMysqlUserConfigPrivateAccess',
    'MySqlMysqlUserConfigPrivatelinkAccess',
    'MySqlMysqlUserConfigPublicAccess',
    'MySqlServiceIntegration',
    'MySqlTag',
    'OpenSearchComponent',
    'OpenSearchOpensearch',
    'OpenSearchOpensearchUserConfig',
    'OpenSearchOpensearchUserConfigIndexPattern',
    'OpenSearchOpensearchUserConfigIndexTemplate',
    'OpenSearchOpensearchUserConfigOpensearch',
    'OpenSearchOpensearchUserConfigOpensearchDashboards',
    'OpenSearchOpensearchUserConfigPrivateAccess',
    'OpenSearchOpensearchUserConfigPrivatelinkAccess',
    'OpenSearchOpensearchUserConfigPublicAccess',
    'OpenSearchServiceIntegration',
    'OpenSearchTag',
    'PgComponent',
    'PgPg',
    'PgPgUserConfig',
    'PgPgUserConfigMigration',
    'PgPgUserConfigPg',
    'PgPgUserConfigPgbouncer',
    'PgPgUserConfigPglookout',
    'PgPgUserConfigPrivateAccess',
    'PgPgUserConfigPrivatelinkAccess',
    'PgPgUserConfigPublicAccess',
    'PgPgUserConfigTimescaledb',
    'PgServiceIntegration',
    'PgTag',
    'ProjectTag',
    'RedisComponent',
    'RedisRedi',
    'RedisRedisUserConfig',
    'RedisRedisUserConfigMigration',
    'RedisRedisUserConfigPrivateAccess',
    'RedisRedisUserConfigPrivatelinkAccess',
    'RedisRedisUserConfigPublicAccess',
    'RedisServiceIntegration',
    'RedisTag',
    'ServiceIntegrationEndpointDatadogUserConfig',
    'ServiceIntegrationEndpointDatadogUserConfigDatadogTag',
    'ServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig',
    'ServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig',
    'ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig',
    'ServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig',
    'ServiceIntegrationEndpointExternalKafkaUserConfig',
    'ServiceIntegrationEndpointExternalSchemaRegistryUserConfig',
    'ServiceIntegrationEndpointJolokiaUserConfig',
    'ServiceIntegrationEndpointPrometheusUserConfig',
    'ServiceIntegrationEndpointRsyslogUserConfig',
    'ServiceIntegrationEndpointSignalfxUserConfig',
    'ServiceIntegrationKafkaConnectUserConfig',
    'ServiceIntegrationKafkaConnectUserConfigKafkaConnect',
    'ServiceIntegrationKafkaLogsUserConfig',
    'ServiceIntegrationKafkaMirrormakerUserConfig',
    'ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker',
    'ServiceIntegrationLogsUserConfig',
    'ServiceIntegrationMetricsUserConfig',
    'ServiceIntegrationMetricsUserConfigSourceMysql',
    'ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf',
    'ServiceIntegrationMirrormakerUserConfig',
    'GetAccountAuthenticationSamlFieldMappingResult',
    'GetCassandaCassandraResult',
    'GetCassandaCassandraUserConfigResult',
    'GetCassandaCassandraUserConfigCassandraResult',
    'GetCassandaCassandraUserConfigPrivateAccessResult',
    'GetCassandaCassandraUserConfigPublicAccessResult',
    'GetCassandaComponentResult',
    'GetCassandaServiceIntegrationResult',
    'GetCassandaTagResult',
    'GetCassandraCassandraResult',
    'GetCassandraCassandraUserConfigResult',
    'GetCassandraCassandraUserConfigCassandraResult',
    'GetCassandraCassandraUserConfigPrivateAccessResult',
    'GetCassandraCassandraUserConfigPublicAccessResult',
    'GetCassandraComponentResult',
    'GetCassandraServiceIntegrationResult',
    'GetCassandraTagResult',
    'GetClickhouseClickhouseResult',
    'GetClickhouseClickhouseUserConfigResult',
    'GetClickhouseComponentResult',
    'GetClickhouseServiceIntegrationResult',
    'GetClickhouseTagResult',
    'GetFlinkComponentResult',
    'GetFlinkFlinkResult',
    'GetFlinkFlinkUserConfigResult',
    'GetFlinkFlinkUserConfigPrivatelinkAccessResult',
    'GetFlinkServiceIntegrationResult',
    'GetFlinkTagResult',
    'GetGrafanaComponentResult',
    'GetGrafanaGrafanaResult',
    'GetGrafanaGrafanaUserConfigResult',
    'GetGrafanaGrafanaUserConfigAuthAzureadResult',
    'GetGrafanaGrafanaUserConfigAuthGenericOauthResult',
    'GetGrafanaGrafanaUserConfigAuthGithubResult',
    'GetGrafanaGrafanaUserConfigAuthGitlabResult',
    'GetGrafanaGrafanaUserConfigAuthGoogleResult',
    'GetGrafanaGrafanaUserConfigDateFormatsResult',
    'GetGrafanaGrafanaUserConfigExternalImageStorageResult',
    'GetGrafanaGrafanaUserConfigPrivateAccessResult',
    'GetGrafanaGrafanaUserConfigPrivatelinkAccessResult',
    'GetGrafanaGrafanaUserConfigPublicAccessResult',
    'GetGrafanaGrafanaUserConfigSmtpServerResult',
    'GetGrafanaServiceIntegrationResult',
    'GetGrafanaTagResult',
    'GetInfluxDbComponentResult',
    'GetInfluxDbInfluxdbResult',
    'GetInfluxDbInfluxdbUserConfigResult',
    'GetInfluxDbInfluxdbUserConfigInfluxdbResult',
    'GetInfluxDbInfluxdbUserConfigPrivateAccessResult',
    'GetInfluxDbInfluxdbUserConfigPrivatelinkAccessResult',
    'GetInfluxDbInfluxdbUserConfigPublicAccessResult',
    'GetInfluxDbServiceIntegrationResult',
    'GetInfluxDbTagResult',
    'GetKafkaComponentResult',
    'GetKafkaConnectComponentResult',
    'GetKafkaConnectKafkaConnectResult',
    'GetKafkaConnectKafkaConnectUserConfigResult',
    'GetKafkaConnectKafkaConnectUserConfigKafkaConnectResult',
    'GetKafkaConnectKafkaConnectUserConfigPrivateAccessResult',
    'GetKafkaConnectKafkaConnectUserConfigPrivatelinkAccessResult',
    'GetKafkaConnectKafkaConnectUserConfigPublicAccessResult',
    'GetKafkaConnectServiceIntegrationResult',
    'GetKafkaConnectTagResult',
    'GetKafkaConnectorTaskResult',
    'GetKafkaKafkaResult',
    'GetKafkaKafkaUserConfigResult',
    'GetKafkaKafkaUserConfigKafkaResult',
    'GetKafkaKafkaUserConfigKafkaAuthenticationMethodsResult',
    'GetKafkaKafkaUserConfigKafkaConnectConfigResult',
    'GetKafkaKafkaUserConfigKafkaRestConfigResult',
    'GetKafkaKafkaUserConfigPrivateAccessResult',
    'GetKafkaKafkaUserConfigPrivatelinkAccessResult',
    'GetKafkaKafkaUserConfigPublicAccessResult',
    'GetKafkaKafkaUserConfigSchemaRegistryConfigResult',
    'GetKafkaMirrorMakerComponentResult',
    'GetKafkaMirrorMakerKafkaMirrormakerResult',
    'GetKafkaMirrorMakerKafkaMirrormakerUserConfigResult',
    'GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormakerResult',
    'GetKafkaMirrorMakerServiceIntegrationResult',
    'GetKafkaMirrorMakerTagResult',
    'GetKafkaServiceIntegrationResult',
    'GetKafkaTagResult',
    'GetKafkaTopicConfigResult',
    'GetKafkaTopicTagResult',
    'GetM3AggregatorComponentResult',
    'GetM3AggregatorM3aggregatorResult',
    'GetM3AggregatorM3aggregatorUserConfigResult',
    'GetM3AggregatorServiceIntegrationResult',
    'GetM3AggregatorTagResult',
    'GetM3DbComponentResult',
    'GetM3DbM3dbResult',
    'GetM3DbM3dbUserConfigResult',
    'GetM3DbM3dbUserConfigLimitsResult',
    'GetM3DbM3dbUserConfigNamespaceResult',
    'GetM3DbM3dbUserConfigNamespaceOptionsResult',
    'GetM3DbM3dbUserConfigNamespaceOptionsRetentionOptionsResult',
    'GetM3DbM3dbUserConfigPrivateAccessResult',
    'GetM3DbM3dbUserConfigPublicAccessResult',
    'GetM3DbM3dbUserConfigRulesResult',
    'GetM3DbM3dbUserConfigRulesMappingResult',
    'GetM3DbM3dbUserConfigRulesMappingTagResult',
    'GetM3DbServiceIntegrationResult',
    'GetM3DbTagResult',
    'GetMySqlComponentResult',
    'GetMySqlMysqlResult',
    'GetMySqlMysqlUserConfigResult',
    'GetMySqlMysqlUserConfigMigrationResult',
    'GetMySqlMysqlUserConfigMysqlResult',
    'GetMySqlMysqlUserConfigPrivateAccessResult',
    'GetMySqlMysqlUserConfigPrivatelinkAccessResult',
    'GetMySqlMysqlUserConfigPublicAccessResult',
    'GetMySqlServiceIntegrationResult',
    'GetMySqlTagResult',
    'GetOpenSearchComponentResult',
    'GetOpenSearchOpensearchResult',
    'GetOpenSearchOpensearchUserConfigResult',
    'GetOpenSearchOpensearchUserConfigIndexPatternResult',
    'GetOpenSearchOpensearchUserConfigIndexTemplateResult',
    'GetOpenSearchOpensearchUserConfigOpensearchResult',
    'GetOpenSearchOpensearchUserConfigOpensearchDashboardsResult',
    'GetOpenSearchOpensearchUserConfigPrivateAccessResult',
    'GetOpenSearchOpensearchUserConfigPrivatelinkAccessResult',
    'GetOpenSearchOpensearchUserConfigPublicAccessResult',
    'GetOpenSearchServiceIntegrationResult',
    'GetOpenSearchTagResult',
    'GetPgComponentResult',
    'GetPgPgResult',
    'GetPgPgUserConfigResult',
    'GetPgPgUserConfigMigrationResult',
    'GetPgPgUserConfigPgResult',
    'GetPgPgUserConfigPgbouncerResult',
    'GetPgPgUserConfigPglookoutResult',
    'GetPgPgUserConfigPrivateAccessResult',
    'GetPgPgUserConfigPrivatelinkAccessResult',
    'GetPgPgUserConfigPublicAccessResult',
    'GetPgPgUserConfigTimescaledbResult',
    'GetPgServiceIntegrationResult',
    'GetPgTagResult',
    'GetProjectTagResult',
    'GetRedisComponentResult',
    'GetRedisRediResult',
    'GetRedisRedisUserConfigResult',
    'GetRedisRedisUserConfigMigrationResult',
    'GetRedisRedisUserConfigPrivateAccessResult',
    'GetRedisRedisUserConfigPrivatelinkAccessResult',
    'GetRedisRedisUserConfigPublicAccessResult',
    'GetRedisServiceIntegrationResult',
    'GetRedisTagResult',
    'GetServiceIntegrationEndpointDatadogUserConfigResult',
    'GetServiceIntegrationEndpointDatadogUserConfigDatadogTagResult',
    'GetServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfigResult',
    'GetServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfigResult',
    'GetServiceIntegrationEndpointExternalElasticsearchLogsUserConfigResult',
    'GetServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfigResult',
    'GetServiceIntegrationEndpointExternalKafkaUserConfigResult',
    'GetServiceIntegrationEndpointExternalSchemaRegistryUserConfigResult',
    'GetServiceIntegrationEndpointJolokiaUserConfigResult',
    'GetServiceIntegrationEndpointPrometheusUserConfigResult',
    'GetServiceIntegrationEndpointRsyslogUserConfigResult',
    'GetServiceIntegrationEndpointSignalfxUserConfigResult',
    'GetServiceIntegrationKafkaConnectUserConfigResult',
    'GetServiceIntegrationKafkaConnectUserConfigKafkaConnectResult',
    'GetServiceIntegrationKafkaLogsUserConfigResult',
    'GetServiceIntegrationKafkaMirrormakerUserConfigResult',
    'GetServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormakerResult',
    'GetServiceIntegrationLogsUserConfigResult',
    'GetServiceIntegrationMetricsUserConfigResult',
    'GetServiceIntegrationMetricsUserConfigSourceMysqlResult',
    'GetServiceIntegrationMetricsUserConfigSourceMysqlTelegrafResult',
    'GetServiceIntegrationMirrormakerUserConfigResult',
]

@pulumi.output_type
class AccountAuthenticationSamlFieldMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstName":
            suggest = "first_name"
        elif key == "lastName":
            suggest = "last_name"
        elif key == "realName":
            suggest = "real_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountAuthenticationSamlFieldMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountAuthenticationSamlFieldMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountAuthenticationSamlFieldMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: Optional[str] = None,
                 first_name: Optional[str] = None,
                 identity: Optional[str] = None,
                 last_name: Optional[str] = None,
                 real_name: Optional[str] = None):
        """
        :param str email: Field name for user email
        :param str first_name: Field name for user's first name
        :param str identity: Field name for user's identity. This field must always exist in responses, and must be immutable and unique. Contents of this field are used to identify the user. Using user ID (such as unix user id) is highly recommended, as email address may change, requiring relinking user to Aiven user.
        :param str last_name: Field name for user's last name
        :param str real_name: Field name for user's full name. If specified, first*name and last*name mappings are ignored
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if real_name is not None:
            pulumi.set(__self__, "real_name", real_name)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        Field name for user email
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[str]:
        """
        Field name for user's first name
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter
    def identity(self) -> Optional[str]:
        """
        Field name for user's identity. This field must always exist in responses, and must be immutable and unique. Contents of this field are used to identify the user. Using user ID (such as unix user id) is highly recommended, as email address may change, requiring relinking user to Aiven user.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[str]:
        """
        Field name for user's last name
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="realName")
    def real_name(self) -> Optional[str]:
        """
        Field name for user's full name. If specified, first*name and last*name mappings are ignored
        """
        return pulumi.get(self, "real_name")


@pulumi.output_type
class CassandraCassandra(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class CassandraCassandraUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cassandraVersion":
            suggest = "cassandra_version"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "migrateSstableloader":
            suggest = "migrate_sstableloader"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CassandraCassandraUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CassandraCassandraUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CassandraCassandraUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cassandra: Optional['outputs.CassandraCassandraUserConfigCassandra'] = None,
                 cassandra_version: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 migrate_sstableloader: Optional[str] = None,
                 private_access: Optional['outputs.CassandraCassandraUserConfigPrivateAccess'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.CassandraCassandraUserConfigPublicAccess'] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        """
        :param 'CassandraCassandraUserConfigCassandraArgs' cassandra: cassandra configuration values
        :param str cassandra_version: Cassandra major version
        :param Sequence[str] ip_filters: IP filter
        :param str migrate_sstableloader: Migration mode for the sstableloader utility
        :param 'CassandraCassandraUserConfigPrivateAccessArgs' private_access: Allow access to selected service ports from private networks
        :param str project_to_fork_from: Name of another project to fork a service from. This has effect only when a new service is being created.
        :param 'CassandraCassandraUserConfigPublicAccessArgs' public_access: Allow access to selected service ports from the public Internet
        :param str service_to_fork_from: Name of another service to fork from. This has effect only when a new service is being created.
        :param str static_ips: Static IP addresses
        """
        if cassandra is not None:
            pulumi.set(__self__, "cassandra", cassandra)
        if cassandra_version is not None:
            pulumi.set(__self__, "cassandra_version", cassandra_version)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migrate_sstableloader is not None:
            pulumi.set(__self__, "migrate_sstableloader", migrate_sstableloader)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter
    def cassandra(self) -> Optional['outputs.CassandraCassandraUserConfigCassandra']:
        """
        cassandra configuration values
        """
        return pulumi.get(self, "cassandra")

    @property
    @pulumi.getter(name="cassandraVersion")
    def cassandra_version(self) -> Optional[str]:
        """
        Cassandra major version
        """
        return pulumi.get(self, "cassandra_version")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="migrateSstableloader")
    def migrate_sstableloader(self) -> Optional[str]:
        """
        Migration mode for the sstableloader utility
        """
        return pulumi.get(self, "migrate_sstableloader")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.CassandraCassandraUserConfigPrivateAccess']:
        """
        Allow access to selected service ports from private networks
        """
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        """
        Name of another project to fork a service from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.CassandraCassandraUserConfigPublicAccess']:
        """
        Allow access to selected service ports from the public Internet
        """
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        """
        Name of another service to fork from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IP addresses
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class CassandraCassandraUserConfigCassandra(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchSizeFailThresholdInKb":
            suggest = "batch_size_fail_threshold_in_kb"
        elif key == "batchSizeWarnThresholdInKb":
            suggest = "batch_size_warn_threshold_in_kb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CassandraCassandraUserConfigCassandra. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CassandraCassandraUserConfigCassandra.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CassandraCassandraUserConfigCassandra.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_size_fail_threshold_in_kb: Optional[str] = None,
                 batch_size_warn_threshold_in_kb: Optional[str] = None):
        if batch_size_fail_threshold_in_kb is not None:
            pulumi.set(__self__, "batch_size_fail_threshold_in_kb", batch_size_fail_threshold_in_kb)
        if batch_size_warn_threshold_in_kb is not None:
            pulumi.set(__self__, "batch_size_warn_threshold_in_kb", batch_size_warn_threshold_in_kb)

    @property
    @pulumi.getter(name="batchSizeFailThresholdInKb")
    def batch_size_fail_threshold_in_kb(self) -> Optional[str]:
        return pulumi.get(self, "batch_size_fail_threshold_in_kb")

    @property
    @pulumi.getter(name="batchSizeWarnThresholdInKb")
    def batch_size_warn_threshold_in_kb(self) -> Optional[str]:
        return pulumi.get(self, "batch_size_warn_threshold_in_kb")


@pulumi.output_type
class CassandraCassandraUserConfigPrivateAccess(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class CassandraCassandraUserConfigPublicAccess(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class CassandraComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CassandraComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CassandraComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CassandraComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class CassandraServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CassandraServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CassandraServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CassandraServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        """
        :param str integration_type: Type of the service integration. The only supported value at the moment is `read_replica`
        :param str source_service_name: Name of the source service
        """
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Type of the service integration. The only supported value at the moment is `read_replica`
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        """
        Name of the source service
        """
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class CassandraTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Service tag key
        :param str value: Service tag value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Service tag key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Service tag value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClickhouseClickhouse(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClickhouseClickhouseUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClickhouseClickhouseUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClickhouseClickhouseUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClickhouseClickhouseUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 project_to_fork_from: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None):
        """
        :param Sequence[str] ip_filters: IP filter
        :param str project_to_fork_from: Name of another project to fork a service from. This has effect only when a new service is being created.
        :param str service_to_fork_from: Name of another service to fork from. This has effect only when a new service is being created.
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        """
        Name of another project to fork a service from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        """
        Name of another service to fork from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "service_to_fork_from")


@pulumi.output_type
class ClickhouseComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClickhouseComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClickhouseComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClickhouseComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class ClickhouseGrantPrivilegeGrant(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "withGrant":
            suggest = "with_grant"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClickhouseGrantPrivilegeGrant. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClickhouseGrantPrivilegeGrant.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClickhouseGrantPrivilegeGrant.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 column: Optional[str] = None,
                 privilege: Optional[str] = None,
                 table: Optional[str] = None,
                 with_grant: Optional[bool] = None):
        """
        :param str database: The database that the grant refers to. To set up proper dependencies please refer to this variable as a reference. This property cannot be changed, doing so forces recreation of the resource.
        :param str column: The column that the grant refers to. This property cannot be changed, doing so forces recreation of the resource.
        :param str privilege: The privilege to grant, i.e. 'INSERT', 'SELECT', etc. This property cannot be changed, doing so forces recreation of the resource.
        :param str table: The table that the grant refers to. This property cannot be changed, doing so forces recreation of the resource.
        :param bool with_grant: If true then the grantee gets the ability to grant the privileges he received too This property cannot be changed, doing so forces recreation of the resource.
        """
        pulumi.set(__self__, "database", database)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if privilege is not None:
            pulumi.set(__self__, "privilege", privilege)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if with_grant is not None:
            pulumi.set(__self__, "with_grant", with_grant)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database that the grant refers to. To set up proper dependencies please refer to this variable as a reference. This property cannot be changed, doing so forces recreation of the resource.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        """
        The column that the grant refers to. This property cannot be changed, doing so forces recreation of the resource.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def privilege(self) -> Optional[str]:
        """
        The privilege to grant, i.e. 'INSERT', 'SELECT', etc. This property cannot be changed, doing so forces recreation of the resource.
        """
        return pulumi.get(self, "privilege")

    @property
    @pulumi.getter
    def table(self) -> Optional[str]:
        """
        The table that the grant refers to. This property cannot be changed, doing so forces recreation of the resource.
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="withGrant")
    def with_grant(self) -> Optional[bool]:
        """
        If true then the grantee gets the ability to grant the privileges he received too This property cannot be changed, doing so forces recreation of the resource.
        """
        return pulumi.get(self, "with_grant")


@pulumi.output_type
class ClickhouseGrantRoleGrant(dict):
    def __init__(__self__, *,
                 role: Optional[str] = None):
        """
        :param str role: The role that is to be granted. To set up proper dependencies please refer to this variable as a reference. This property cannot be changed, doing so forces recreation of the resource.
        """
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        The role that is to be granted. To set up proper dependencies please refer to this variable as a reference. This property cannot be changed, doing so forces recreation of the resource.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class ClickhouseServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClickhouseServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClickhouseServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClickhouseServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        """
        :param str integration_type: Type of the service integration. The only supported value at the moment is `read_replica`
        :param str source_service_name: Name of the source service
        """
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Type of the service integration. The only supported value at the moment is `read_replica`
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        """
        Name of the source service
        """
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class ClickhouseTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Service tag key
        :param str value: Service tag value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Service tag key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Service tag value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FlinkComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class FlinkFlink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostPorts":
            suggest = "host_ports"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkFlink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkFlink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkFlink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_ports: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] host_ports: Host and Port of a Flink server
        """
        if host_ports is not None:
            pulumi.set(__self__, "host_ports", host_ports)

    @property
    @pulumi.getter(name="hostPorts")
    def host_ports(self) -> Optional[Sequence[str]]:
        """
        Host and Port of a Flink server
        """
        return pulumi.get(self, "host_ports")


@pulumi.output_type
class FlinkFlinkUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionCheckpointingIntervalMs":
            suggest = "execution_checkpointing_interval_ms"
        elif key == "executionCheckpointingTimeoutMs":
            suggest = "execution_checkpointing_timeout_ms"
        elif key == "flinkVersion":
            suggest = "flink_version"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "numberOfTaskSlots":
            suggest = "number_of_task_slots"
        elif key == "parallelismDefault":
            suggest = "parallelism_default"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "restartStrategy":
            suggest = "restart_strategy"
        elif key == "restartStrategyDelaySec":
            suggest = "restart_strategy_delay_sec"
        elif key == "restartStrategyFailureRateIntervalMin":
            suggest = "restart_strategy_failure_rate_interval_min"
        elif key == "restartStrategyMaxFailures":
            suggest = "restart_strategy_max_failures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkFlinkUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkFlinkUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkFlinkUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_checkpointing_interval_ms: Optional[str] = None,
                 execution_checkpointing_timeout_ms: Optional[str] = None,
                 flink_version: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 number_of_task_slots: Optional[str] = None,
                 parallelism_default: Optional[str] = None,
                 privatelink_access: Optional['outputs.FlinkFlinkUserConfigPrivatelinkAccess'] = None,
                 restart_strategy: Optional[str] = None,
                 restart_strategy_delay_sec: Optional[str] = None,
                 restart_strategy_failure_rate_interval_min: Optional[str] = None,
                 restart_strategy_max_failures: Optional[str] = None):
        """
        :param str execution_checkpointing_interval_ms: Flink execution.checkpointing.interval in milliseconds
        :param str execution_checkpointing_timeout_ms: Flink execution.checkpointing.timeout in milliseconds
        :param str flink_version: Flink major version
        :param Sequence[str] ip_filters: IP filter
        :param str number_of_task_slots: Flink taskmanager.numberOfTaskSlots
        :param str parallelism_default: Flink parallelism.default
        :param 'FlinkFlinkUserConfigPrivatelinkAccessArgs' privatelink_access: Allow access to selected service components through Privatelink
        :param str restart_strategy: Flink restart-strategy
        :param str restart_strategy_delay_sec: Flink restart-strategy.failure-rate.delay in seconds
        :param str restart_strategy_failure_rate_interval_min: Flink restart-strategy.failure-rate.failure-rate-interval in minutes
        :param str restart_strategy_max_failures: Flink restart-strategy.failure-rate.max-failures-per-interval
        """
        if execution_checkpointing_interval_ms is not None:
            pulumi.set(__self__, "execution_checkpointing_interval_ms", execution_checkpointing_interval_ms)
        if execution_checkpointing_timeout_ms is not None:
            pulumi.set(__self__, "execution_checkpointing_timeout_ms", execution_checkpointing_timeout_ms)
        if flink_version is not None:
            pulumi.set(__self__, "flink_version", flink_version)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if number_of_task_slots is not None:
            pulumi.set(__self__, "number_of_task_slots", number_of_task_slots)
        if parallelism_default is not None:
            pulumi.set(__self__, "parallelism_default", parallelism_default)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if restart_strategy is not None:
            pulumi.set(__self__, "restart_strategy", restart_strategy)
        if restart_strategy_delay_sec is not None:
            pulumi.set(__self__, "restart_strategy_delay_sec", restart_strategy_delay_sec)
        if restart_strategy_failure_rate_interval_min is not None:
            pulumi.set(__self__, "restart_strategy_failure_rate_interval_min", restart_strategy_failure_rate_interval_min)
        if restart_strategy_max_failures is not None:
            pulumi.set(__self__, "restart_strategy_max_failures", restart_strategy_max_failures)

    @property
    @pulumi.getter(name="executionCheckpointingIntervalMs")
    def execution_checkpointing_interval_ms(self) -> Optional[str]:
        """
        Flink execution.checkpointing.interval in milliseconds
        """
        return pulumi.get(self, "execution_checkpointing_interval_ms")

    @property
    @pulumi.getter(name="executionCheckpointingTimeoutMs")
    def execution_checkpointing_timeout_ms(self) -> Optional[str]:
        """
        Flink execution.checkpointing.timeout in milliseconds
        """
        return pulumi.get(self, "execution_checkpointing_timeout_ms")

    @property
    @pulumi.getter(name="flinkVersion")
    def flink_version(self) -> Optional[str]:
        """
        Flink major version
        """
        return pulumi.get(self, "flink_version")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="numberOfTaskSlots")
    def number_of_task_slots(self) -> Optional[str]:
        """
        Flink taskmanager.numberOfTaskSlots
        """
        return pulumi.get(self, "number_of_task_slots")

    @property
    @pulumi.getter(name="parallelismDefault")
    def parallelism_default(self) -> Optional[str]:
        """
        Flink parallelism.default
        """
        return pulumi.get(self, "parallelism_default")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.FlinkFlinkUserConfigPrivatelinkAccess']:
        """
        Allow access to selected service components through Privatelink
        """
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="restartStrategy")
    def restart_strategy(self) -> Optional[str]:
        """
        Flink restart-strategy
        """
        return pulumi.get(self, "restart_strategy")

    @property
    @pulumi.getter(name="restartStrategyDelaySec")
    def restart_strategy_delay_sec(self) -> Optional[str]:
        """
        Flink restart-strategy.failure-rate.delay in seconds
        """
        return pulumi.get(self, "restart_strategy_delay_sec")

    @property
    @pulumi.getter(name="restartStrategyFailureRateIntervalMin")
    def restart_strategy_failure_rate_interval_min(self) -> Optional[str]:
        """
        Flink restart-strategy.failure-rate.failure-rate-interval in minutes
        """
        return pulumi.get(self, "restart_strategy_failure_rate_interval_min")

    @property
    @pulumi.getter(name="restartStrategyMaxFailures")
    def restart_strategy_max_failures(self) -> Optional[str]:
        """
        Flink restart-strategy.failure-rate.max-failures-per-interval
        """
        return pulumi.get(self, "restart_strategy_max_failures")


@pulumi.output_type
class FlinkFlinkUserConfigPrivatelinkAccess(dict):
    def __init__(__self__, *,
                 flink: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str flink: Flink server provided values
        """
        if flink is not None:
            pulumi.set(__self__, "flink", flink)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def flink(self) -> Optional[str]:
        """
        Flink server provided values
        """
        return pulumi.get(self, "flink")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class FlinkJobTableUpsertKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyFields":
            suggest = "key_fields"
        elif key == "keyFormat":
            suggest = "key_format"
        elif key == "scanStartupMode":
            suggest = "scan_startup_mode"
        elif key == "valueFieldsInclude":
            suggest = "value_fields_include"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkJobTableUpsertKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkJobTableUpsertKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkJobTableUpsertKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_fields: Optional[Sequence[str]] = None,
                 key_format: Optional[str] = None,
                 scan_startup_mode: Optional[str] = None,
                 topic: Optional[str] = None,
                 value_fields_include: Optional[str] = None,
                 value_format: Optional[str] = None):
        """
        :param Sequence[str] key_fields: Defines the columns from the SQL schema of the data table that are considered keys in the Kafka messages. This property cannot be changed, doing so forces recreation of the resource.
        :param str key_format: Sets the format that is used to convert the key part of Kafka messages. The possible values are `avro`, `avro-confluent`, `debezium-avro-confluent`, `debezium-json` and `json`. This property cannot be changed, doing so forces recreation of the resource.
        :param str scan_startup_mode: Controls the startup method for the Kafka consumer that Aiven for Apache Flink is using. The possible values are `earliest-offset`, `latest-offset`, `group-offsets` and `timestamp`. This property cannot be changed, doing so forces recreation of the resource.
        :param str topic: Topic name This property cannot be changed, doing so forces recreation of the resource.
        :param str value_fields_include: Controls how key columns are handled in the message value. Select ALL to include the physical columns of the table schema in the message value. Select EXCEPT_KEY to exclude the physical columns of the table schema from the message value. This is the default for upsert Kafka connectors. The possible values are `[ALL EXCEPT_KEY]`. This property cannot be changed, doing so forces recreation of the resource.
        :param str value_format: Sets the format that is used to convert the value part of Kafka messages. The possible values are `avro`, `avro-confluent`, `debezium-avro-confluent`, `debezium-json` and `json`. This property cannot be changed, doing so forces recreation of the resource.
        """
        if key_fields is not None:
            pulumi.set(__self__, "key_fields", key_fields)
        if key_format is not None:
            pulumi.set(__self__, "key_format", key_format)
        if scan_startup_mode is not None:
            pulumi.set(__self__, "scan_startup_mode", scan_startup_mode)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)
        if value_fields_include is not None:
            pulumi.set(__self__, "value_fields_include", value_fields_include)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter(name="keyFields")
    def key_fields(self) -> Optional[Sequence[str]]:
        """
        Defines the columns from the SQL schema of the data table that are considered keys in the Kafka messages. This property cannot be changed, doing so forces recreation of the resource.
        """
        return pulumi.get(self, "key_fields")

    @property
    @pulumi.getter(name="keyFormat")
    def key_format(self) -> Optional[str]:
        """
        Sets the format that is used to convert the key part of Kafka messages. The possible values are `avro`, `avro-confluent`, `debezium-avro-confluent`, `debezium-json` and `json`. This property cannot be changed, doing so forces recreation of the resource.
        """
        return pulumi.get(self, "key_format")

    @property
    @pulumi.getter(name="scanStartupMode")
    def scan_startup_mode(self) -> Optional[str]:
        """
        Controls the startup method for the Kafka consumer that Aiven for Apache Flink is using. The possible values are `earliest-offset`, `latest-offset`, `group-offsets` and `timestamp`. This property cannot be changed, doing so forces recreation of the resource.
        """
        return pulumi.get(self, "scan_startup_mode")

    @property
    @pulumi.getter
    def topic(self) -> Optional[str]:
        """
        Topic name This property cannot be changed, doing so forces recreation of the resource.
        """
        return pulumi.get(self, "topic")

    @property
    @pulumi.getter(name="valueFieldsInclude")
    def value_fields_include(self) -> Optional[str]:
        """
        Controls how key columns are handled in the message value. Select ALL to include the physical columns of the table schema in the message value. Select EXCEPT_KEY to exclude the physical columns of the table schema from the message value. This is the default for upsert Kafka connectors. The possible values are `[ALL EXCEPT_KEY]`. This property cannot be changed, doing so forces recreation of the resource.
        """
        return pulumi.get(self, "value_fields_include")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[str]:
        """
        Sets the format that is used to convert the value part of Kafka messages. The possible values are `avro`, `avro-confluent`, `debezium-avro-confluent`, `debezium-json` and `json`. This property cannot be changed, doing so forces recreation of the resource.
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class FlinkServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        """
        :param str integration_type: Type of the service integration. The only supported value at the moment is `read_replica`
        :param str source_service_name: Name of the source service
        """
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Type of the service integration. The only supported value at the moment is `read_replica`
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        """
        Name of the source service
        """
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class FlinkTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Service tag key
        :param str value: Service tag value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Service tag key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Service tag value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GrafanaComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GrafanaGrafana(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GrafanaGrafanaUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingEnabled":
            suggest = "alerting_enabled"
        elif key == "alertingErrorOrTimeout":
            suggest = "alerting_error_or_timeout"
        elif key == "alertingMaxAnnotationsToKeep":
            suggest = "alerting_max_annotations_to_keep"
        elif key == "alertingNodataOrNullvalues":
            suggest = "alerting_nodata_or_nullvalues"
        elif key == "allowEmbedding":
            suggest = "allow_embedding"
        elif key == "authAzuread":
            suggest = "auth_azuread"
        elif key == "authBasicEnabled":
            suggest = "auth_basic_enabled"
        elif key == "authGenericOauth":
            suggest = "auth_generic_oauth"
        elif key == "authGithub":
            suggest = "auth_github"
        elif key == "authGitlab":
            suggest = "auth_gitlab"
        elif key == "authGoogle":
            suggest = "auth_google"
        elif key == "cookieSamesite":
            suggest = "cookie_samesite"
        elif key == "customDomain":
            suggest = "custom_domain"
        elif key == "dashboardsMinRefreshInterval":
            suggest = "dashboards_min_refresh_interval"
        elif key == "dashboardsVersionsToKeep":
            suggest = "dashboards_versions_to_keep"
        elif key == "dataproxySendUserHeader":
            suggest = "dataproxy_send_user_header"
        elif key == "dataproxyTimeout":
            suggest = "dataproxy_timeout"
        elif key == "dateFormats":
            suggest = "date_formats"
        elif key == "disableGravatar":
            suggest = "disable_gravatar"
        elif key == "editorsCanAdmin":
            suggest = "editors_can_admin"
        elif key == "externalImageStorage":
            suggest = "external_image_storage"
        elif key == "googleAnalyticsUaId":
            suggest = "google_analytics_ua_id"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "metricsEnabled":
            suggest = "metrics_enabled"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "recoveryBasebackupName":
            suggest = "recovery_basebackup_name"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"
        elif key == "smtpServer":
            suggest = "smtp_server"
        elif key == "staticIps":
            suggest = "static_ips"
        elif key == "userAutoAssignOrg":
            suggest = "user_auto_assign_org"
        elif key == "userAutoAssignOrgRole":
            suggest = "user_auto_assign_org_role"
        elif key == "viewersCanEdit":
            suggest = "viewers_can_edit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alerting_enabled: Optional[str] = None,
                 alerting_error_or_timeout: Optional[str] = None,
                 alerting_max_annotations_to_keep: Optional[str] = None,
                 alerting_nodata_or_nullvalues: Optional[str] = None,
                 allow_embedding: Optional[str] = None,
                 auth_azuread: Optional['outputs.GrafanaGrafanaUserConfigAuthAzuread'] = None,
                 auth_basic_enabled: Optional[str] = None,
                 auth_generic_oauth: Optional['outputs.GrafanaGrafanaUserConfigAuthGenericOauth'] = None,
                 auth_github: Optional['outputs.GrafanaGrafanaUserConfigAuthGithub'] = None,
                 auth_gitlab: Optional['outputs.GrafanaGrafanaUserConfigAuthGitlab'] = None,
                 auth_google: Optional['outputs.GrafanaGrafanaUserConfigAuthGoogle'] = None,
                 cookie_samesite: Optional[str] = None,
                 custom_domain: Optional[str] = None,
                 dashboards_min_refresh_interval: Optional[str] = None,
                 dashboards_versions_to_keep: Optional[str] = None,
                 dataproxy_send_user_header: Optional[str] = None,
                 dataproxy_timeout: Optional[str] = None,
                 date_formats: Optional['outputs.GrafanaGrafanaUserConfigDateFormats'] = None,
                 disable_gravatar: Optional[str] = None,
                 editors_can_admin: Optional[str] = None,
                 external_image_storage: Optional['outputs.GrafanaGrafanaUserConfigExternalImageStorage'] = None,
                 google_analytics_ua_id: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 metrics_enabled: Optional[str] = None,
                 private_access: Optional['outputs.GrafanaGrafanaUserConfigPrivateAccess'] = None,
                 privatelink_access: Optional['outputs.GrafanaGrafanaUserConfigPrivatelinkAccess'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GrafanaGrafanaUserConfigPublicAccess'] = None,
                 recovery_basebackup_name: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 smtp_server: Optional['outputs.GrafanaGrafanaUserConfigSmtpServer'] = None,
                 static_ips: Optional[str] = None,
                 user_auto_assign_org: Optional[str] = None,
                 user_auto_assign_org_role: Optional[str] = None,
                 viewers_can_edit: Optional[str] = None):
        """
        :param str alerting_enabled: Enable or disable Grafana alerting functionality
        :param str alerting_error_or_timeout: Default error or timeout setting for new alerting rules
        :param str alerting_max_annotations_to_keep: Max number of alert annotations that Grafana stores. 0 (default) keeps all alert annotations.
        :param str alerting_nodata_or_nullvalues: Default value for 'no data or null values' for new alerting rules
        :param str allow_embedding: Allow embedding Grafana dashboards with iframe/frame/object/embed tags. Disabled by default to limit impact of clickjacking
        :param 'GrafanaGrafanaUserConfigAuthAzureadArgs' auth_azuread: Azure AD OAuth integration
        :param str auth_basic_enabled: Enable or disable basic authentication form, used by Grafana built-in login
        :param 'GrafanaGrafanaUserConfigAuthGenericOauthArgs' auth_generic_oauth: Generic OAuth integration
        :param 'GrafanaGrafanaUserConfigAuthGithubArgs' auth_github: Github Auth integration
        :param 'GrafanaGrafanaUserConfigAuthGitlabArgs' auth_gitlab: GitLab Auth integration
        :param 'GrafanaGrafanaUserConfigAuthGoogleArgs' auth_google: Google Auth integration
        :param str cookie_samesite: Cookie SameSite attribute: 'strict' prevents sending cookie for cross-site requests, effectively disabling direct linking from other sites to Grafana. 'lax' is the default value.
        :param str custom_domain: Custom domain
        :param str dashboards_min_refresh_interval: Minimum refresh interval
        :param str dashboards_versions_to_keep: Dashboard versions to keep per dashboard
        :param str dataproxy_send_user_header: Send 'X-Grafana-User' header to data source
        :param str dataproxy_timeout: Timeout for data proxy requests in seconds
        :param 'GrafanaGrafanaUserConfigDateFormatsArgs' date_formats: Grafana date format specifications
        :param str disable_gravatar: Set to true to disable gravatar. Defaults to false (gravatar is enabled)
        :param str editors_can_admin: Editors can manage folders, teams and dashboards created by them
        :param 'GrafanaGrafanaUserConfigExternalImageStorageArgs' external_image_storage: External image store settings
        :param str google_analytics_ua_id: Google Analytics ID
        :param Sequence[str] ip_filters: IP filter
        :param str metrics_enabled: Enable Grafana /metrics endpoint
        :param 'GrafanaGrafanaUserConfigPrivateAccessArgs' private_access: Allow access to selected service ports from private networks
        :param 'GrafanaGrafanaUserConfigPrivatelinkAccessArgs' privatelink_access: Allow access to selected service components through Privatelink
        :param str project_to_fork_from: Name of another project to fork a service from. This has effect only when a new service is being created.
        :param 'GrafanaGrafanaUserConfigPublicAccessArgs' public_access: Allow access to selected service ports from the public Internet
        :param str recovery_basebackup_name: Name of the basebackup to restore in forked service
        :param str service_to_fork_from: Name of another service to fork from. This has effect only when a new service is being created.
        :param 'GrafanaGrafanaUserConfigSmtpServerArgs' smtp_server: SMTP server settings
        :param str static_ips: Static IP addresses
        :param str user_auto_assign_org: Auto-assign new users on signup to main organization. Defaults to false
        :param str user_auto_assign_org_role: Set role for new signups. Defaults to Viewer
        :param str viewers_can_edit: Users with view-only permission can edit but not save dashboards
        """
        if alerting_enabled is not None:
            pulumi.set(__self__, "alerting_enabled", alerting_enabled)
        if alerting_error_or_timeout is not None:
            pulumi.set(__self__, "alerting_error_or_timeout", alerting_error_or_timeout)
        if alerting_max_annotations_to_keep is not None:
            pulumi.set(__self__, "alerting_max_annotations_to_keep", alerting_max_annotations_to_keep)
        if alerting_nodata_or_nullvalues is not None:
            pulumi.set(__self__, "alerting_nodata_or_nullvalues", alerting_nodata_or_nullvalues)
        if allow_embedding is not None:
            pulumi.set(__self__, "allow_embedding", allow_embedding)
        if auth_azuread is not None:
            pulumi.set(__self__, "auth_azuread", auth_azuread)
        if auth_basic_enabled is not None:
            pulumi.set(__self__, "auth_basic_enabled", auth_basic_enabled)
        if auth_generic_oauth is not None:
            pulumi.set(__self__, "auth_generic_oauth", auth_generic_oauth)
        if auth_github is not None:
            pulumi.set(__self__, "auth_github", auth_github)
        if auth_gitlab is not None:
            pulumi.set(__self__, "auth_gitlab", auth_gitlab)
        if auth_google is not None:
            pulumi.set(__self__, "auth_google", auth_google)
        if cookie_samesite is not None:
            pulumi.set(__self__, "cookie_samesite", cookie_samesite)
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if dashboards_min_refresh_interval is not None:
            pulumi.set(__self__, "dashboards_min_refresh_interval", dashboards_min_refresh_interval)
        if dashboards_versions_to_keep is not None:
            pulumi.set(__self__, "dashboards_versions_to_keep", dashboards_versions_to_keep)
        if dataproxy_send_user_header is not None:
            pulumi.set(__self__, "dataproxy_send_user_header", dataproxy_send_user_header)
        if dataproxy_timeout is not None:
            pulumi.set(__self__, "dataproxy_timeout", dataproxy_timeout)
        if date_formats is not None:
            pulumi.set(__self__, "date_formats", date_formats)
        if disable_gravatar is not None:
            pulumi.set(__self__, "disable_gravatar", disable_gravatar)
        if editors_can_admin is not None:
            pulumi.set(__self__, "editors_can_admin", editors_can_admin)
        if external_image_storage is not None:
            pulumi.set(__self__, "external_image_storage", external_image_storage)
        if google_analytics_ua_id is not None:
            pulumi.set(__self__, "google_analytics_ua_id", google_analytics_ua_id)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if metrics_enabled is not None:
            pulumi.set(__self__, "metrics_enabled", metrics_enabled)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_basebackup_name is not None:
            pulumi.set(__self__, "recovery_basebackup_name", recovery_basebackup_name)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if smtp_server is not None:
            pulumi.set(__self__, "smtp_server", smtp_server)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)
        if user_auto_assign_org is not None:
            pulumi.set(__self__, "user_auto_assign_org", user_auto_assign_org)
        if user_auto_assign_org_role is not None:
            pulumi.set(__self__, "user_auto_assign_org_role", user_auto_assign_org_role)
        if viewers_can_edit is not None:
            pulumi.set(__self__, "viewers_can_edit", viewers_can_edit)

    @property
    @pulumi.getter(name="alertingEnabled")
    def alerting_enabled(self) -> Optional[str]:
        """
        Enable or disable Grafana alerting functionality
        """
        return pulumi.get(self, "alerting_enabled")

    @property
    @pulumi.getter(name="alertingErrorOrTimeout")
    def alerting_error_or_timeout(self) -> Optional[str]:
        """
        Default error or timeout setting for new alerting rules
        """
        return pulumi.get(self, "alerting_error_or_timeout")

    @property
    @pulumi.getter(name="alertingMaxAnnotationsToKeep")
    def alerting_max_annotations_to_keep(self) -> Optional[str]:
        """
        Max number of alert annotations that Grafana stores. 0 (default) keeps all alert annotations.
        """
        return pulumi.get(self, "alerting_max_annotations_to_keep")

    @property
    @pulumi.getter(name="alertingNodataOrNullvalues")
    def alerting_nodata_or_nullvalues(self) -> Optional[str]:
        """
        Default value for 'no data or null values' for new alerting rules
        """
        return pulumi.get(self, "alerting_nodata_or_nullvalues")

    @property
    @pulumi.getter(name="allowEmbedding")
    def allow_embedding(self) -> Optional[str]:
        """
        Allow embedding Grafana dashboards with iframe/frame/object/embed tags. Disabled by default to limit impact of clickjacking
        """
        return pulumi.get(self, "allow_embedding")

    @property
    @pulumi.getter(name="authAzuread")
    def auth_azuread(self) -> Optional['outputs.GrafanaGrafanaUserConfigAuthAzuread']:
        """
        Azure AD OAuth integration
        """
        return pulumi.get(self, "auth_azuread")

    @property
    @pulumi.getter(name="authBasicEnabled")
    def auth_basic_enabled(self) -> Optional[str]:
        """
        Enable or disable basic authentication form, used by Grafana built-in login
        """
        return pulumi.get(self, "auth_basic_enabled")

    @property
    @pulumi.getter(name="authGenericOauth")
    def auth_generic_oauth(self) -> Optional['outputs.GrafanaGrafanaUserConfigAuthGenericOauth']:
        """
        Generic OAuth integration
        """
        return pulumi.get(self, "auth_generic_oauth")

    @property
    @pulumi.getter(name="authGithub")
    def auth_github(self) -> Optional['outputs.GrafanaGrafanaUserConfigAuthGithub']:
        """
        Github Auth integration
        """
        return pulumi.get(self, "auth_github")

    @property
    @pulumi.getter(name="authGitlab")
    def auth_gitlab(self) -> Optional['outputs.GrafanaGrafanaUserConfigAuthGitlab']:
        """
        GitLab Auth integration
        """
        return pulumi.get(self, "auth_gitlab")

    @property
    @pulumi.getter(name="authGoogle")
    def auth_google(self) -> Optional['outputs.GrafanaGrafanaUserConfigAuthGoogle']:
        """
        Google Auth integration
        """
        return pulumi.get(self, "auth_google")

    @property
    @pulumi.getter(name="cookieSamesite")
    def cookie_samesite(self) -> Optional[str]:
        """
        Cookie SameSite attribute: 'strict' prevents sending cookie for cross-site requests, effectively disabling direct linking from other sites to Grafana. 'lax' is the default value.
        """
        return pulumi.get(self, "cookie_samesite")

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        """
        Custom domain
        """
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="dashboardsMinRefreshInterval")
    def dashboards_min_refresh_interval(self) -> Optional[str]:
        """
        Minimum refresh interval
        """
        return pulumi.get(self, "dashboards_min_refresh_interval")

    @property
    @pulumi.getter(name="dashboardsVersionsToKeep")
    def dashboards_versions_to_keep(self) -> Optional[str]:
        """
        Dashboard versions to keep per dashboard
        """
        return pulumi.get(self, "dashboards_versions_to_keep")

    @property
    @pulumi.getter(name="dataproxySendUserHeader")
    def dataproxy_send_user_header(self) -> Optional[str]:
        """
        Send 'X-Grafana-User' header to data source
        """
        return pulumi.get(self, "dataproxy_send_user_header")

    @property
    @pulumi.getter(name="dataproxyTimeout")
    def dataproxy_timeout(self) -> Optional[str]:
        """
        Timeout for data proxy requests in seconds
        """
        return pulumi.get(self, "dataproxy_timeout")

    @property
    @pulumi.getter(name="dateFormats")
    def date_formats(self) -> Optional['outputs.GrafanaGrafanaUserConfigDateFormats']:
        """
        Grafana date format specifications
        """
        return pulumi.get(self, "date_formats")

    @property
    @pulumi.getter(name="disableGravatar")
    def disable_gravatar(self) -> Optional[str]:
        """
        Set to true to disable gravatar. Defaults to false (gravatar is enabled)
        """
        return pulumi.get(self, "disable_gravatar")

    @property
    @pulumi.getter(name="editorsCanAdmin")
    def editors_can_admin(self) -> Optional[str]:
        """
        Editors can manage folders, teams and dashboards created by them
        """
        return pulumi.get(self, "editors_can_admin")

    @property
    @pulumi.getter(name="externalImageStorage")
    def external_image_storage(self) -> Optional['outputs.GrafanaGrafanaUserConfigExternalImageStorage']:
        """
        External image store settings
        """
        return pulumi.get(self, "external_image_storage")

    @property
    @pulumi.getter(name="googleAnalyticsUaId")
    def google_analytics_ua_id(self) -> Optional[str]:
        """
        Google Analytics ID
        """
        return pulumi.get(self, "google_analytics_ua_id")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="metricsEnabled")
    def metrics_enabled(self) -> Optional[str]:
        """
        Enable Grafana /metrics endpoint
        """
        return pulumi.get(self, "metrics_enabled")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GrafanaGrafanaUserConfigPrivateAccess']:
        """
        Allow access to selected service ports from private networks
        """
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GrafanaGrafanaUserConfigPrivatelinkAccess']:
        """
        Allow access to selected service components through Privatelink
        """
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        """
        Name of another project to fork a service from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GrafanaGrafanaUserConfigPublicAccess']:
        """
        Allow access to selected service ports from the public Internet
        """
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryBasebackupName")
    def recovery_basebackup_name(self) -> Optional[str]:
        """
        Name of the basebackup to restore in forked service
        """
        return pulumi.get(self, "recovery_basebackup_name")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        """
        Name of another service to fork from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="smtpServer")
    def smtp_server(self) -> Optional['outputs.GrafanaGrafanaUserConfigSmtpServer']:
        """
        SMTP server settings
        """
        return pulumi.get(self, "smtp_server")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IP addresses
        """
        return pulumi.get(self, "static_ips")

    @property
    @pulumi.getter(name="userAutoAssignOrg")
    def user_auto_assign_org(self) -> Optional[str]:
        """
        Auto-assign new users on signup to main organization. Defaults to false
        """
        return pulumi.get(self, "user_auto_assign_org")

    @property
    @pulumi.getter(name="userAutoAssignOrgRole")
    def user_auto_assign_org_role(self) -> Optional[str]:
        """
        Set role for new signups. Defaults to Viewer
        """
        return pulumi.get(self, "user_auto_assign_org_role")

    @property
    @pulumi.getter(name="viewersCanEdit")
    def viewers_can_edit(self) -> Optional[str]:
        """
        Users with view-only permission can edit but not save dashboards
        """
        return pulumi.get(self, "viewers_can_edit")


@pulumi.output_type
class GrafanaGrafanaUserConfigAuthAzuread(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSignUp":
            suggest = "allow_sign_up"
        elif key == "allowedDomains":
            suggest = "allowed_domains"
        elif key == "allowedGroups":
            suggest = "allowed_groups"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfigAuthAzuread. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfigAuthAzuread.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfigAuthAzuread.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_domains: Optional[Sequence[str]] = None,
                 allowed_groups: Optional[Sequence[str]] = None,
                 auth_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 token_url: Optional[str] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_domains")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        return pulumi.get(self, "token_url")


@pulumi.output_type
class GrafanaGrafanaUserConfigAuthGenericOauth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSignUp":
            suggest = "allow_sign_up"
        elif key == "allowedDomains":
            suggest = "allowed_domains"
        elif key == "allowedOrganizations":
            suggest = "allowed_organizations"
        elif key == "apiUrl":
            suggest = "api_url"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfigAuthGenericOauth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfigAuthGenericOauth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfigAuthGenericOauth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_domains: Optional[Sequence[str]] = None,
                 allowed_organizations: Optional[Sequence[str]] = None,
                 api_url: Optional[str] = None,
                 auth_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 name: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 token_url: Optional[str] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if allowed_organizations is not None:
            pulumi.set(__self__, "allowed_organizations", allowed_organizations)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_domains")

    @property
    @pulumi.getter(name="allowedOrganizations")
    def allowed_organizations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_organizations")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        return pulumi.get(self, "token_url")


@pulumi.output_type
class GrafanaGrafanaUserConfigAuthGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSignUp":
            suggest = "allow_sign_up"
        elif key == "allowedOrganizations":
            suggest = "allowed_organizations"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "teamIds":
            suggest = "team_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfigAuthGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfigAuthGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfigAuthGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_organizations: Optional[Sequence[str]] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 team_ids: Optional[Sequence[str]] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_organizations is not None:
            pulumi.set(__self__, "allowed_organizations", allowed_organizations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if team_ids is not None:
            pulumi.set(__self__, "team_ids", team_ids)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedOrganizations")
    def allowed_organizations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_organizations")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="teamIds")
    def team_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "team_ids")


@pulumi.output_type
class GrafanaGrafanaUserConfigAuthGitlab(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSignUp":
            suggest = "allow_sign_up"
        elif key == "allowedGroups":
            suggest = "allowed_groups"
        elif key == "apiUrl":
            suggest = "api_url"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfigAuthGitlab. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfigAuthGitlab.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfigAuthGitlab.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_groups: Optional[Sequence[str]] = None,
                 api_url: Optional[str] = None,
                 auth_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 token_url: Optional[str] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        return pulumi.get(self, "token_url")


@pulumi.output_type
class GrafanaGrafanaUserConfigAuthGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSignUp":
            suggest = "allow_sign_up"
        elif key == "allowedDomains":
            suggest = "allowed_domains"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfigAuthGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfigAuthGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfigAuthGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_domains: Optional[Sequence[str]] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_domains")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class GrafanaGrafanaUserConfigDateFormats(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultTimezone":
            suggest = "default_timezone"
        elif key == "fullDate":
            suggest = "full_date"
        elif key == "intervalDay":
            suggest = "interval_day"
        elif key == "intervalHour":
            suggest = "interval_hour"
        elif key == "intervalMinute":
            suggest = "interval_minute"
        elif key == "intervalMonth":
            suggest = "interval_month"
        elif key == "intervalSecond":
            suggest = "interval_second"
        elif key == "intervalYear":
            suggest = "interval_year"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfigDateFormats. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfigDateFormats.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfigDateFormats.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_timezone: Optional[str] = None,
                 full_date: Optional[str] = None,
                 interval_day: Optional[str] = None,
                 interval_hour: Optional[str] = None,
                 interval_minute: Optional[str] = None,
                 interval_month: Optional[str] = None,
                 interval_second: Optional[str] = None,
                 interval_year: Optional[str] = None):
        if default_timezone is not None:
            pulumi.set(__self__, "default_timezone", default_timezone)
        if full_date is not None:
            pulumi.set(__self__, "full_date", full_date)
        if interval_day is not None:
            pulumi.set(__self__, "interval_day", interval_day)
        if interval_hour is not None:
            pulumi.set(__self__, "interval_hour", interval_hour)
        if interval_minute is not None:
            pulumi.set(__self__, "interval_minute", interval_minute)
        if interval_month is not None:
            pulumi.set(__self__, "interval_month", interval_month)
        if interval_second is not None:
            pulumi.set(__self__, "interval_second", interval_second)
        if interval_year is not None:
            pulumi.set(__self__, "interval_year", interval_year)

    @property
    @pulumi.getter(name="defaultTimezone")
    def default_timezone(self) -> Optional[str]:
        return pulumi.get(self, "default_timezone")

    @property
    @pulumi.getter(name="fullDate")
    def full_date(self) -> Optional[str]:
        return pulumi.get(self, "full_date")

    @property
    @pulumi.getter(name="intervalDay")
    def interval_day(self) -> Optional[str]:
        return pulumi.get(self, "interval_day")

    @property
    @pulumi.getter(name="intervalHour")
    def interval_hour(self) -> Optional[str]:
        return pulumi.get(self, "interval_hour")

    @property
    @pulumi.getter(name="intervalMinute")
    def interval_minute(self) -> Optional[str]:
        return pulumi.get(self, "interval_minute")

    @property
    @pulumi.getter(name="intervalMonth")
    def interval_month(self) -> Optional[str]:
        return pulumi.get(self, "interval_month")

    @property
    @pulumi.getter(name="intervalSecond")
    def interval_second(self) -> Optional[str]:
        return pulumi.get(self, "interval_second")

    @property
    @pulumi.getter(name="intervalYear")
    def interval_year(self) -> Optional[str]:
        return pulumi.get(self, "interval_year")


@pulumi.output_type
class GrafanaGrafanaUserConfigExternalImageStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "bucketUrl":
            suggest = "bucket_url"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfigExternalImageStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfigExternalImageStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfigExternalImageStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 bucket_url: Optional[str] = None,
                 provider: Optional[str] = None,
                 secret_key: Optional[str] = None):
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bucket_url is not None:
            pulumi.set(__self__, "bucket_url", bucket_url)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bucketUrl")
    def bucket_url(self) -> Optional[str]:
        return pulumi.get(self, "bucket_url")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class GrafanaGrafanaUserConfigPrivateAccess(dict):
    def __init__(__self__, *,
                 grafana: Optional[str] = None):
        """
        :param str grafana: Grafana server provided values
        """
        if grafana is not None:
            pulumi.set(__self__, "grafana", grafana)

    @property
    @pulumi.getter
    def grafana(self) -> Optional[str]:
        """
        Grafana server provided values
        """
        return pulumi.get(self, "grafana")


@pulumi.output_type
class GrafanaGrafanaUserConfigPrivatelinkAccess(dict):
    def __init__(__self__, *,
                 grafana: Optional[str] = None):
        """
        :param str grafana: Grafana server provided values
        """
        if grafana is not None:
            pulumi.set(__self__, "grafana", grafana)

    @property
    @pulumi.getter
    def grafana(self) -> Optional[str]:
        """
        Grafana server provided values
        """
        return pulumi.get(self, "grafana")


@pulumi.output_type
class GrafanaGrafanaUserConfigPublicAccess(dict):
    def __init__(__self__, *,
                 grafana: Optional[str] = None):
        """
        :param str grafana: Grafana server provided values
        """
        if grafana is not None:
            pulumi.set(__self__, "grafana", grafana)

    @property
    @pulumi.getter
    def grafana(self) -> Optional[str]:
        """
        Grafana server provided values
        """
        return pulumi.get(self, "grafana")


@pulumi.output_type
class GrafanaGrafanaUserConfigSmtpServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromAddress":
            suggest = "from_address"
        elif key == "fromName":
            suggest = "from_name"
        elif key == "skipVerify":
            suggest = "skip_verify"
        elif key == "starttlsPolicy":
            suggest = "starttls_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfigSmtpServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfigSmtpServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfigSmtpServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_address: Optional[str] = None,
                 from_name: Optional[str] = None,
                 host: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 skip_verify: Optional[str] = None,
                 starttls_policy: Optional[str] = None,
                 username: Optional[str] = None):
        if from_address is not None:
            pulumi.set(__self__, "from_address", from_address)
        if from_name is not None:
            pulumi.set(__self__, "from_name", from_name)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if skip_verify is not None:
            pulumi.set(__self__, "skip_verify", skip_verify)
        if starttls_policy is not None:
            pulumi.set(__self__, "starttls_policy", starttls_policy)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="fromAddress")
    def from_address(self) -> Optional[str]:
        return pulumi.get(self, "from_address")

    @property
    @pulumi.getter(name="fromName")
    def from_name(self) -> Optional[str]:
        return pulumi.get(self, "from_name")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="skipVerify")
    def skip_verify(self) -> Optional[str]:
        return pulumi.get(self, "skip_verify")

    @property
    @pulumi.getter(name="starttlsPolicy")
    def starttls_policy(self) -> Optional[str]:
        return pulumi.get(self, "starttls_policy")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class GrafanaServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        """
        :param str integration_type: Type of the service integration. The only supported value at the moment is `read_replica`
        :param str source_service_name: Name of the source service
        """
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Type of the service integration. The only supported value at the moment is `read_replica`
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        """
        Name of the source service
        """
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GrafanaTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Service tag key
        :param str value: Service tag value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Service tag key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Service tag value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InfluxDbComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfluxDbComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfluxDbComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfluxDbComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class InfluxDbInfluxdb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfluxDbInfluxdb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfluxDbInfluxdb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfluxDbInfluxdb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: Optional[str] = None):
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        return pulumi.get(self, "database_name")


@pulumi.output_type
class InfluxDbInfluxdbUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDomain":
            suggest = "custom_domain"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "recoveryBasebackupName":
            suggest = "recovery_basebackup_name"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfluxDbInfluxdbUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfluxDbInfluxdbUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfluxDbInfluxdbUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 influxdb: Optional['outputs.InfluxDbInfluxdbUserConfigInfluxdb'] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 private_access: Optional['outputs.InfluxDbInfluxdbUserConfigPrivateAccess'] = None,
                 privatelink_access: Optional['outputs.InfluxDbInfluxdbUserConfigPrivatelinkAccess'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.InfluxDbInfluxdbUserConfigPublicAccess'] = None,
                 recovery_basebackup_name: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        """
        :param str custom_domain: Custom domain
        :param 'InfluxDbInfluxdbUserConfigInfluxdbArgs' influxdb: influxdb.conf configuration values
        :param Sequence[str] ip_filters: IP filter
        :param 'InfluxDbInfluxdbUserConfigPrivateAccessArgs' private_access: Allow access to selected service ports from private networks
        :param 'InfluxDbInfluxdbUserConfigPrivatelinkAccessArgs' privatelink_access: Allow access to selected service components through Privatelink
        :param str project_to_fork_from: Name of another project to fork a service from. This has effect only when a new service is being created.
        :param 'InfluxDbInfluxdbUserConfigPublicAccessArgs' public_access: Allow access to selected service ports from the public Internet
        :param str recovery_basebackup_name: Name of the basebackup to restore in forked service
        :param str service_to_fork_from: Name of another service to fork from. This has effect only when a new service is being created.
        :param str static_ips: Static IP addresses
        """
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if influxdb is not None:
            pulumi.set(__self__, "influxdb", influxdb)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_basebackup_name is not None:
            pulumi.set(__self__, "recovery_basebackup_name", recovery_basebackup_name)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        """
        Custom domain
        """
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter
    def influxdb(self) -> Optional['outputs.InfluxDbInfluxdbUserConfigInfluxdb']:
        """
        influxdb.conf configuration values
        """
        return pulumi.get(self, "influxdb")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.InfluxDbInfluxdbUserConfigPrivateAccess']:
        """
        Allow access to selected service ports from private networks
        """
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.InfluxDbInfluxdbUserConfigPrivatelinkAccess']:
        """
        Allow access to selected service components through Privatelink
        """
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        """
        Name of another project to fork a service from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.InfluxDbInfluxdbUserConfigPublicAccess']:
        """
        Allow access to selected service ports from the public Internet
        """
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryBasebackupName")
    def recovery_basebackup_name(self) -> Optional[str]:
        """
        Name of the basebackup to restore in forked service
        """
        return pulumi.get(self, "recovery_basebackup_name")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        """
        Name of another service to fork from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IP addresses
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class InfluxDbInfluxdbUserConfigInfluxdb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logQueriesAfter":
            suggest = "log_queries_after"
        elif key == "maxConnectionLimit":
            suggest = "max_connection_limit"
        elif key == "maxRowLimit":
            suggest = "max_row_limit"
        elif key == "maxSelectBuckets":
            suggest = "max_select_buckets"
        elif key == "maxSelectPoint":
            suggest = "max_select_point"
        elif key == "queryTimeout":
            suggest = "query_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfluxDbInfluxdbUserConfigInfluxdb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfluxDbInfluxdbUserConfigInfluxdb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfluxDbInfluxdbUserConfigInfluxdb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_queries_after: Optional[str] = None,
                 max_connection_limit: Optional[str] = None,
                 max_row_limit: Optional[str] = None,
                 max_select_buckets: Optional[str] = None,
                 max_select_point: Optional[str] = None,
                 query_timeout: Optional[str] = None):
        if log_queries_after is not None:
            pulumi.set(__self__, "log_queries_after", log_queries_after)
        if max_connection_limit is not None:
            pulumi.set(__self__, "max_connection_limit", max_connection_limit)
        if max_row_limit is not None:
            pulumi.set(__self__, "max_row_limit", max_row_limit)
        if max_select_buckets is not None:
            pulumi.set(__self__, "max_select_buckets", max_select_buckets)
        if max_select_point is not None:
            pulumi.set(__self__, "max_select_point", max_select_point)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)

    @property
    @pulumi.getter(name="logQueriesAfter")
    def log_queries_after(self) -> Optional[str]:
        return pulumi.get(self, "log_queries_after")

    @property
    @pulumi.getter(name="maxConnectionLimit")
    def max_connection_limit(self) -> Optional[str]:
        return pulumi.get(self, "max_connection_limit")

    @property
    @pulumi.getter(name="maxRowLimit")
    def max_row_limit(self) -> Optional[str]:
        return pulumi.get(self, "max_row_limit")

    @property
    @pulumi.getter(name="maxSelectBuckets")
    def max_select_buckets(self) -> Optional[str]:
        return pulumi.get(self, "max_select_buckets")

    @property
    @pulumi.getter(name="maxSelectPoint")
    def max_select_point(self) -> Optional[str]:
        return pulumi.get(self, "max_select_point")

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[str]:
        return pulumi.get(self, "query_timeout")


@pulumi.output_type
class InfluxDbInfluxdbUserConfigPrivateAccess(dict):
    def __init__(__self__, *,
                 influxdb: Optional[str] = None):
        """
        :param str influxdb: InfluxDB server provided values
        """
        if influxdb is not None:
            pulumi.set(__self__, "influxdb", influxdb)

    @property
    @pulumi.getter
    def influxdb(self) -> Optional[str]:
        """
        InfluxDB server provided values
        """
        return pulumi.get(self, "influxdb")


@pulumi.output_type
class InfluxDbInfluxdbUserConfigPrivatelinkAccess(dict):
    def __init__(__self__, *,
                 influxdb: Optional[str] = None):
        """
        :param str influxdb: InfluxDB server provided values
        """
        if influxdb is not None:
            pulumi.set(__self__, "influxdb", influxdb)

    @property
    @pulumi.getter
    def influxdb(self) -> Optional[str]:
        """
        InfluxDB server provided values
        """
        return pulumi.get(self, "influxdb")


@pulumi.output_type
class InfluxDbInfluxdbUserConfigPublicAccess(dict):
    def __init__(__self__, *,
                 influxdb: Optional[str] = None):
        """
        :param str influxdb: InfluxDB server provided values
        """
        if influxdb is not None:
            pulumi.set(__self__, "influxdb", influxdb)

    @property
    @pulumi.getter
    def influxdb(self) -> Optional[str]:
        """
        InfluxDB server provided values
        """
        return pulumi.get(self, "influxdb")


@pulumi.output_type
class InfluxDbServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfluxDbServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfluxDbServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfluxDbServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        """
        :param str integration_type: Type of the service integration. The only supported value at the moment is `read_replica`
        :param str source_service_name: Name of the source service
        """
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Type of the service integration. The only supported value at the moment is `read_replica`
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        """
        Name of the source service
        """
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class InfluxDbTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Service tag key
        :param str value: Service tag value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Service tag key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Service tag value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class KafkaComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class KafkaConnectComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaConnectComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaConnectComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaConnectComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class KafkaConnectKafkaConnect(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class KafkaConnectKafkaConnectUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "kafkaConnect":
            suggest = "kafka_connect"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaConnectKafkaConnectUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaConnectKafkaConnectUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaConnectKafkaConnectUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka_connect: Optional['outputs.KafkaConnectKafkaConnectUserConfigKafkaConnect'] = None,
                 private_access: Optional['outputs.KafkaConnectKafkaConnectUserConfigPrivateAccess'] = None,
                 privatelink_access: Optional['outputs.KafkaConnectKafkaConnectUserConfigPrivatelinkAccess'] = None,
                 public_access: Optional['outputs.KafkaConnectKafkaConnectUserConfigPublicAccess'] = None,
                 static_ips: Optional[str] = None):
        """
        :param Sequence[str] ip_filters: IP filter
        :param 'KafkaConnectKafkaConnectUserConfigKafkaConnectArgs' kafka_connect: Kafka Connect configuration values
        :param 'KafkaConnectKafkaConnectUserConfigPrivateAccessArgs' private_access: Allow access to selected service ports from private networks
        :param 'KafkaConnectKafkaConnectUserConfigPrivatelinkAccessArgs' privatelink_access: Allow access to selected service components through Privatelink
        :param 'KafkaConnectKafkaConnectUserConfigPublicAccessArgs' public_access: Allow access to selected service ports from the public Internet
        :param str static_ips: Static IP addresses
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional['outputs.KafkaConnectKafkaConnectUserConfigKafkaConnect']:
        """
        Kafka Connect configuration values
        """
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.KafkaConnectKafkaConnectUserConfigPrivateAccess']:
        """
        Allow access to selected service ports from private networks
        """
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.KafkaConnectKafkaConnectUserConfigPrivatelinkAccess']:
        """
        Allow access to selected service components through Privatelink
        """
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.KafkaConnectKafkaConnectUserConfigPublicAccess']:
        """
        Allow access to selected service ports from the public Internet
        """
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IP addresses
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class KafkaConnectKafkaConnectUserConfigKafkaConnect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorClientConfigOverridePolicy":
            suggest = "connector_client_config_override_policy"
        elif key == "consumerAutoOffsetReset":
            suggest = "consumer_auto_offset_reset"
        elif key == "consumerFetchMaxBytes":
            suggest = "consumer_fetch_max_bytes"
        elif key == "consumerIsolationLevel":
            suggest = "consumer_isolation_level"
        elif key == "consumerMaxPartitionFetchBytes":
            suggest = "consumer_max_partition_fetch_bytes"
        elif key == "consumerMaxPollIntervalMs":
            suggest = "consumer_max_poll_interval_ms"
        elif key == "consumerMaxPollRecords":
            suggest = "consumer_max_poll_records"
        elif key == "offsetFlushIntervalMs":
            suggest = "offset_flush_interval_ms"
        elif key == "offsetFlushTimeoutMs":
            suggest = "offset_flush_timeout_ms"
        elif key == "producerCompressionType":
            suggest = "producer_compression_type"
        elif key == "producerMaxRequestSize":
            suggest = "producer_max_request_size"
        elif key == "sessionTimeoutMs":
            suggest = "session_timeout_ms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaConnectKafkaConnectUserConfigKafkaConnect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaConnectKafkaConnectUserConfigKafkaConnect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaConnectKafkaConnectUserConfigKafkaConnect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_client_config_override_policy: Optional[str] = None,
                 consumer_auto_offset_reset: Optional[str] = None,
                 consumer_fetch_max_bytes: Optional[str] = None,
                 consumer_isolation_level: Optional[str] = None,
                 consumer_max_partition_fetch_bytes: Optional[str] = None,
                 consumer_max_poll_interval_ms: Optional[str] = None,
                 consumer_max_poll_records: Optional[str] = None,
                 offset_flush_interval_ms: Optional[str] = None,
                 offset_flush_timeout_ms: Optional[str] = None,
                 producer_compression_type: Optional[str] = None,
                 producer_max_request_size: Optional[str] = None,
                 session_timeout_ms: Optional[str] = None):
        if connector_client_config_override_policy is not None:
            pulumi.set(__self__, "connector_client_config_override_policy", connector_client_config_override_policy)
        if consumer_auto_offset_reset is not None:
            pulumi.set(__self__, "consumer_auto_offset_reset", consumer_auto_offset_reset)
        if consumer_fetch_max_bytes is not None:
            pulumi.set(__self__, "consumer_fetch_max_bytes", consumer_fetch_max_bytes)
        if consumer_isolation_level is not None:
            pulumi.set(__self__, "consumer_isolation_level", consumer_isolation_level)
        if consumer_max_partition_fetch_bytes is not None:
            pulumi.set(__self__, "consumer_max_partition_fetch_bytes", consumer_max_partition_fetch_bytes)
        if consumer_max_poll_interval_ms is not None:
            pulumi.set(__self__, "consumer_max_poll_interval_ms", consumer_max_poll_interval_ms)
        if consumer_max_poll_records is not None:
            pulumi.set(__self__, "consumer_max_poll_records", consumer_max_poll_records)
        if offset_flush_interval_ms is not None:
            pulumi.set(__self__, "offset_flush_interval_ms", offset_flush_interval_ms)
        if offset_flush_timeout_ms is not None:
            pulumi.set(__self__, "offset_flush_timeout_ms", offset_flush_timeout_ms)
        if producer_compression_type is not None:
            pulumi.set(__self__, "producer_compression_type", producer_compression_type)
        if producer_max_request_size is not None:
            pulumi.set(__self__, "producer_max_request_size", producer_max_request_size)
        if session_timeout_ms is not None:
            pulumi.set(__self__, "session_timeout_ms", session_timeout_ms)

    @property
    @pulumi.getter(name="connectorClientConfigOverridePolicy")
    def connector_client_config_override_policy(self) -> Optional[str]:
        return pulumi.get(self, "connector_client_config_override_policy")

    @property
    @pulumi.getter(name="consumerAutoOffsetReset")
    def consumer_auto_offset_reset(self) -> Optional[str]:
        return pulumi.get(self, "consumer_auto_offset_reset")

    @property
    @pulumi.getter(name="consumerFetchMaxBytes")
    def consumer_fetch_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_fetch_max_bytes")

    @property
    @pulumi.getter(name="consumerIsolationLevel")
    def consumer_isolation_level(self) -> Optional[str]:
        return pulumi.get(self, "consumer_isolation_level")

    @property
    @pulumi.getter(name="consumerMaxPartitionFetchBytes")
    def consumer_max_partition_fetch_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_partition_fetch_bytes")

    @property
    @pulumi.getter(name="consumerMaxPollIntervalMs")
    def consumer_max_poll_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_poll_interval_ms")

    @property
    @pulumi.getter(name="consumerMaxPollRecords")
    def consumer_max_poll_records(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_poll_records")

    @property
    @pulumi.getter(name="offsetFlushIntervalMs")
    def offset_flush_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "offset_flush_interval_ms")

    @property
    @pulumi.getter(name="offsetFlushTimeoutMs")
    def offset_flush_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "offset_flush_timeout_ms")

    @property
    @pulumi.getter(name="producerCompressionType")
    def producer_compression_type(self) -> Optional[str]:
        return pulumi.get(self, "producer_compression_type")

    @property
    @pulumi.getter(name="producerMaxRequestSize")
    def producer_max_request_size(self) -> Optional[str]:
        return pulumi.get(self, "producer_max_request_size")

    @property
    @pulumi.getter(name="sessionTimeoutMs")
    def session_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "session_timeout_ms")


@pulumi.output_type
class KafkaConnectKafkaConnectUserConfigPrivateAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaConnect":
            suggest = "kafka_connect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaConnectKafkaConnectUserConfigPrivateAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaConnectKafkaConnectUserConfigPrivateAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaConnectKafkaConnectUserConfigPrivateAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka_connect: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str kafka_connect: Kafka Connect server provided values
        """
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        """
        Kafka Connect server provided values
        """
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class KafkaConnectKafkaConnectUserConfigPrivatelinkAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaConnect":
            suggest = "kafka_connect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaConnectKafkaConnectUserConfigPrivatelinkAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaConnectKafkaConnectUserConfigPrivatelinkAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaConnectKafkaConnectUserConfigPrivatelinkAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 jolokia: Optional[str] = None,
                 kafka_connect: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str kafka_connect: Kafka Connect server provided values
        """
        if jolokia is not None:
            pulumi.set(__self__, "jolokia", jolokia)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def jolokia(self) -> Optional[str]:
        return pulumi.get(self, "jolokia")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        """
        Kafka Connect server provided values
        """
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class KafkaConnectKafkaConnectUserConfigPublicAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaConnect":
            suggest = "kafka_connect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaConnectKafkaConnectUserConfigPublicAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaConnectKafkaConnectUserConfigPublicAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaConnectKafkaConnectUserConfigPublicAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka_connect: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str kafka_connect: Kafka Connect server provided values
        """
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        """
        Kafka Connect server provided values
        """
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class KafkaConnectServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaConnectServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaConnectServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaConnectServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        """
        :param str integration_type: Type of the service integration. The only supported value at the moment is `read_replica`
        :param str source_service_name: Name of the source service
        """
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Type of the service integration. The only supported value at the moment is `read_replica`
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        """
        Name of the source service
        """
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class KafkaConnectTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Service tag key
        :param str value: Service tag value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Service tag key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Service tag value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class KafkaConnectorTask(dict):
    def __init__(__self__, *,
                 connector: Optional[str] = None,
                 task: Optional[int] = None):
        """
        :param int task: List of tasks of a connector.
        """
        if connector is not None:
            pulumi.set(__self__, "connector", connector)
        if task is not None:
            pulumi.set(__self__, "task", task)

    @property
    @pulumi.getter
    def connector(self) -> Optional[str]:
        return pulumi.get(self, "connector")

    @property
    @pulumi.getter
    def task(self) -> Optional[int]:
        """
        List of tasks of a connector.
        """
        return pulumi.get(self, "task")


@pulumi.output_type
class KafkaKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessCert":
            suggest = "access_cert"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "connectUri":
            suggest = "connect_uri"
        elif key == "restUri":
            suggest = "rest_uri"
        elif key == "schemaRegistryUri":
            suggest = "schema_registry_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_cert: Optional[str] = None,
                 access_key: Optional[str] = None,
                 connect_uri: Optional[str] = None,
                 rest_uri: Optional[str] = None,
                 schema_registry_uri: Optional[str] = None):
        """
        :param str access_cert: The Kafka client certificate
        :param str access_key: The Kafka client certificate key
        :param str connect_uri: The Kafka Connect URI, if any
        :param str rest_uri: The Kafka REST URI, if any
        :param str schema_registry_uri: The Schema Registry URI, if any
        """
        if access_cert is not None:
            pulumi.set(__self__, "access_cert", access_cert)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if connect_uri is not None:
            pulumi.set(__self__, "connect_uri", connect_uri)
        if rest_uri is not None:
            pulumi.set(__self__, "rest_uri", rest_uri)
        if schema_registry_uri is not None:
            pulumi.set(__self__, "schema_registry_uri", schema_registry_uri)

    @property
    @pulumi.getter(name="accessCert")
    def access_cert(self) -> Optional[str]:
        """
        The Kafka client certificate
        """
        return pulumi.get(self, "access_cert")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Kafka client certificate key
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="connectUri")
    def connect_uri(self) -> Optional[str]:
        """
        The Kafka Connect URI, if any
        """
        return pulumi.get(self, "connect_uri")

    @property
    @pulumi.getter(name="restUri")
    def rest_uri(self) -> Optional[str]:
        """
        The Kafka REST URI, if any
        """
        return pulumi.get(self, "rest_uri")

    @property
    @pulumi.getter(name="schemaRegistryUri")
    def schema_registry_uri(self) -> Optional[str]:
        """
        The Schema Registry URI, if any
        """
        return pulumi.get(self, "schema_registry_uri")


@pulumi.output_type
class KafkaKafkaUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDomain":
            suggest = "custom_domain"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "kafkaAuthenticationMethods":
            suggest = "kafka_authentication_methods"
        elif key == "kafkaConnect":
            suggest = "kafka_connect"
        elif key == "kafkaConnectConfig":
            suggest = "kafka_connect_config"
        elif key == "kafkaRest":
            suggest = "kafka_rest"
        elif key == "kafkaRestConfig":
            suggest = "kafka_rest_config"
        elif key == "kafkaVersion":
            suggest = "kafka_version"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "schemaRegistry":
            suggest = "schema_registry"
        elif key == "schemaRegistryConfig":
            suggest = "schema_registry_config"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaKafkaUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaKafkaUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaKafkaUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka: Optional['outputs.KafkaKafkaUserConfigKafka'] = None,
                 kafka_authentication_methods: Optional['outputs.KafkaKafkaUserConfigKafkaAuthenticationMethods'] = None,
                 kafka_connect: Optional[str] = None,
                 kafka_connect_config: Optional['outputs.KafkaKafkaUserConfigKafkaConnectConfig'] = None,
                 kafka_rest: Optional[str] = None,
                 kafka_rest_config: Optional['outputs.KafkaKafkaUserConfigKafkaRestConfig'] = None,
                 kafka_version: Optional[str] = None,
                 private_access: Optional['outputs.KafkaKafkaUserConfigPrivateAccess'] = None,
                 privatelink_access: Optional['outputs.KafkaKafkaUserConfigPrivatelinkAccess'] = None,
                 public_access: Optional['outputs.KafkaKafkaUserConfigPublicAccess'] = None,
                 schema_registry: Optional[str] = None,
                 schema_registry_config: Optional['outputs.KafkaKafkaUserConfigSchemaRegistryConfig'] = None,
                 static_ips: Optional[str] = None):
        """
        :param str custom_domain: Custom domain
        :param Sequence[str] ip_filters: IP filter
        :param 'KafkaKafkaUserConfigKafkaArgs' kafka: Kafka broker configuration values
        :param 'KafkaKafkaUserConfigKafkaAuthenticationMethodsArgs' kafka_authentication_methods: Kafka authentication methods
        :param str kafka_connect: Enable Kafka Connect service
        :param 'KafkaKafkaUserConfigKafkaConnectConfigArgs' kafka_connect_config: Kafka Connect configuration values
        :param str kafka_rest: Enable Kafka-REST service
        :param 'KafkaKafkaUserConfigKafkaRestConfigArgs' kafka_rest_config: Kafka REST configuration
        :param str kafka_version: Kafka major version
        :param 'KafkaKafkaUserConfigPrivateAccessArgs' private_access: Allow access to selected service ports from private networks
        :param 'KafkaKafkaUserConfigPrivatelinkAccessArgs' privatelink_access: Allow access to selected service components through Privatelink
        :param 'KafkaKafkaUserConfigPublicAccessArgs' public_access: Allow access to selected service ports from the public Internet
        :param str schema_registry: Enable Schema-Registry service
        :param 'KafkaKafkaUserConfigSchemaRegistryConfigArgs' schema_registry_config: Schema Registry configuration
        :param str static_ips: Static IP addresses
        """
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kafka_authentication_methods is not None:
            pulumi.set(__self__, "kafka_authentication_methods", kafka_authentication_methods)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if kafka_connect_config is not None:
            pulumi.set(__self__, "kafka_connect_config", kafka_connect_config)
        if kafka_rest is not None:
            pulumi.set(__self__, "kafka_rest", kafka_rest)
        if kafka_rest_config is not None:
            pulumi.set(__self__, "kafka_rest_config", kafka_rest_config)
        if kafka_version is not None:
            pulumi.set(__self__, "kafka_version", kafka_version)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)
        if schema_registry_config is not None:
            pulumi.set(__self__, "schema_registry_config", schema_registry_config)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        """
        Custom domain
        """
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def kafka(self) -> Optional['outputs.KafkaKafkaUserConfigKafka']:
        """
        Kafka broker configuration values
        """
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethods")
    def kafka_authentication_methods(self) -> Optional['outputs.KafkaKafkaUserConfigKafkaAuthenticationMethods']:
        """
        Kafka authentication methods
        """
        return pulumi.get(self, "kafka_authentication_methods")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        """
        Enable Kafka Connect service
        """
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter(name="kafkaConnectConfig")
    def kafka_connect_config(self) -> Optional['outputs.KafkaKafkaUserConfigKafkaConnectConfig']:
        """
        Kafka Connect configuration values
        """
        return pulumi.get(self, "kafka_connect_config")

    @property
    @pulumi.getter(name="kafkaRest")
    def kafka_rest(self) -> Optional[str]:
        """
        Enable Kafka-REST service
        """
        return pulumi.get(self, "kafka_rest")

    @property
    @pulumi.getter(name="kafkaRestConfig")
    def kafka_rest_config(self) -> Optional['outputs.KafkaKafkaUserConfigKafkaRestConfig']:
        """
        Kafka REST configuration
        """
        return pulumi.get(self, "kafka_rest_config")

    @property
    @pulumi.getter(name="kafkaVersion")
    def kafka_version(self) -> Optional[str]:
        """
        Kafka major version
        """
        return pulumi.get(self, "kafka_version")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.KafkaKafkaUserConfigPrivateAccess']:
        """
        Allow access to selected service ports from private networks
        """
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.KafkaKafkaUserConfigPrivatelinkAccess']:
        """
        Allow access to selected service components through Privatelink
        """
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.KafkaKafkaUserConfigPublicAccess']:
        """
        Allow access to selected service ports from the public Internet
        """
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[str]:
        """
        Enable Schema-Registry service
        """
        return pulumi.get(self, "schema_registry")

    @property
    @pulumi.getter(name="schemaRegistryConfig")
    def schema_registry_config(self) -> Optional['outputs.KafkaKafkaUserConfigSchemaRegistryConfig']:
        """
        Schema Registry configuration
        """
        return pulumi.get(self, "schema_registry_config")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IP addresses
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class KafkaKafkaUserConfigKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoCreateTopicsEnable":
            suggest = "auto_create_topics_enable"
        elif key == "compressionType":
            suggest = "compression_type"
        elif key == "connectionsMaxIdleMs":
            suggest = "connections_max_idle_ms"
        elif key == "defaultReplicationFactor":
            suggest = "default_replication_factor"
        elif key == "groupInitialRebalanceDelayMs":
            suggest = "group_initial_rebalance_delay_ms"
        elif key == "groupMaxSessionTimeoutMs":
            suggest = "group_max_session_timeout_ms"
        elif key == "groupMinSessionTimeoutMs":
            suggest = "group_min_session_timeout_ms"
        elif key == "logCleanerDeleteRetentionMs":
            suggest = "log_cleaner_delete_retention_ms"
        elif key == "logCleanerMaxCompactionLagMs":
            suggest = "log_cleaner_max_compaction_lag_ms"
        elif key == "logCleanerMinCleanableRatio":
            suggest = "log_cleaner_min_cleanable_ratio"
        elif key == "logCleanerMinCompactionLagMs":
            suggest = "log_cleaner_min_compaction_lag_ms"
        elif key == "logCleanupPolicy":
            suggest = "log_cleanup_policy"
        elif key == "logFlushIntervalMessages":
            suggest = "log_flush_interval_messages"
        elif key == "logFlushIntervalMs":
            suggest = "log_flush_interval_ms"
        elif key == "logIndexIntervalBytes":
            suggest = "log_index_interval_bytes"
        elif key == "logIndexSizeMaxBytes":
            suggest = "log_index_size_max_bytes"
        elif key == "logMessageDownconversionEnable":
            suggest = "log_message_downconversion_enable"
        elif key == "logMessageTimestampDifferenceMaxMs":
            suggest = "log_message_timestamp_difference_max_ms"
        elif key == "logMessageTimestampType":
            suggest = "log_message_timestamp_type"
        elif key == "logPreallocate":
            suggest = "log_preallocate"
        elif key == "logRetentionBytes":
            suggest = "log_retention_bytes"
        elif key == "logRetentionHours":
            suggest = "log_retention_hours"
        elif key == "logRetentionMs":
            suggest = "log_retention_ms"
        elif key == "logRollJitterMs":
            suggest = "log_roll_jitter_ms"
        elif key == "logRollMs":
            suggest = "log_roll_ms"
        elif key == "logSegmentBytes":
            suggest = "log_segment_bytes"
        elif key == "logSegmentDeleteDelayMs":
            suggest = "log_segment_delete_delay_ms"
        elif key == "maxConnectionsPerIp":
            suggest = "max_connections_per_ip"
        elif key == "maxIncrementalFetchSessionCacheSlots":
            suggest = "max_incremental_fetch_session_cache_slots"
        elif key == "messageMaxBytes":
            suggest = "message_max_bytes"
        elif key == "minInsyncReplicas":
            suggest = "min_insync_replicas"
        elif key == "numPartitions":
            suggest = "num_partitions"
        elif key == "offsetsRetentionMinutes":
            suggest = "offsets_retention_minutes"
        elif key == "producerPurgatoryPurgeIntervalRequests":
            suggest = "producer_purgatory_purge_interval_requests"
        elif key == "replicaFetchMaxBytes":
            suggest = "replica_fetch_max_bytes"
        elif key == "replicaFetchResponseMaxBytes":
            suggest = "replica_fetch_response_max_bytes"
        elif key == "socketRequestMaxBytes":
            suggest = "socket_request_max_bytes"
        elif key == "transactionRemoveExpiredTransactionCleanupIntervalMs":
            suggest = "transaction_remove_expired_transaction_cleanup_interval_ms"
        elif key == "transactionStateLogSegmentBytes":
            suggest = "transaction_state_log_segment_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaKafkaUserConfigKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaKafkaUserConfigKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaKafkaUserConfigKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_create_topics_enable: Optional[str] = None,
                 compression_type: Optional[str] = None,
                 connections_max_idle_ms: Optional[str] = None,
                 default_replication_factor: Optional[str] = None,
                 group_initial_rebalance_delay_ms: Optional[str] = None,
                 group_max_session_timeout_ms: Optional[str] = None,
                 group_min_session_timeout_ms: Optional[str] = None,
                 log_cleaner_delete_retention_ms: Optional[str] = None,
                 log_cleaner_max_compaction_lag_ms: Optional[str] = None,
                 log_cleaner_min_cleanable_ratio: Optional[str] = None,
                 log_cleaner_min_compaction_lag_ms: Optional[str] = None,
                 log_cleanup_policy: Optional[str] = None,
                 log_flush_interval_messages: Optional[str] = None,
                 log_flush_interval_ms: Optional[str] = None,
                 log_index_interval_bytes: Optional[str] = None,
                 log_index_size_max_bytes: Optional[str] = None,
                 log_message_downconversion_enable: Optional[str] = None,
                 log_message_timestamp_difference_max_ms: Optional[str] = None,
                 log_message_timestamp_type: Optional[str] = None,
                 log_preallocate: Optional[str] = None,
                 log_retention_bytes: Optional[str] = None,
                 log_retention_hours: Optional[str] = None,
                 log_retention_ms: Optional[str] = None,
                 log_roll_jitter_ms: Optional[str] = None,
                 log_roll_ms: Optional[str] = None,
                 log_segment_bytes: Optional[str] = None,
                 log_segment_delete_delay_ms: Optional[str] = None,
                 max_connections_per_ip: Optional[str] = None,
                 max_incremental_fetch_session_cache_slots: Optional[str] = None,
                 message_max_bytes: Optional[str] = None,
                 min_insync_replicas: Optional[str] = None,
                 num_partitions: Optional[str] = None,
                 offsets_retention_minutes: Optional[str] = None,
                 producer_purgatory_purge_interval_requests: Optional[str] = None,
                 replica_fetch_max_bytes: Optional[str] = None,
                 replica_fetch_response_max_bytes: Optional[str] = None,
                 socket_request_max_bytes: Optional[str] = None,
                 transaction_remove_expired_transaction_cleanup_interval_ms: Optional[str] = None,
                 transaction_state_log_segment_bytes: Optional[str] = None):
        if auto_create_topics_enable is not None:
            pulumi.set(__self__, "auto_create_topics_enable", auto_create_topics_enable)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if connections_max_idle_ms is not None:
            pulumi.set(__self__, "connections_max_idle_ms", connections_max_idle_ms)
        if default_replication_factor is not None:
            pulumi.set(__self__, "default_replication_factor", default_replication_factor)
        if group_initial_rebalance_delay_ms is not None:
            pulumi.set(__self__, "group_initial_rebalance_delay_ms", group_initial_rebalance_delay_ms)
        if group_max_session_timeout_ms is not None:
            pulumi.set(__self__, "group_max_session_timeout_ms", group_max_session_timeout_ms)
        if group_min_session_timeout_ms is not None:
            pulumi.set(__self__, "group_min_session_timeout_ms", group_min_session_timeout_ms)
        if log_cleaner_delete_retention_ms is not None:
            pulumi.set(__self__, "log_cleaner_delete_retention_ms", log_cleaner_delete_retention_ms)
        if log_cleaner_max_compaction_lag_ms is not None:
            pulumi.set(__self__, "log_cleaner_max_compaction_lag_ms", log_cleaner_max_compaction_lag_ms)
        if log_cleaner_min_cleanable_ratio is not None:
            pulumi.set(__self__, "log_cleaner_min_cleanable_ratio", log_cleaner_min_cleanable_ratio)
        if log_cleaner_min_compaction_lag_ms is not None:
            pulumi.set(__self__, "log_cleaner_min_compaction_lag_ms", log_cleaner_min_compaction_lag_ms)
        if log_cleanup_policy is not None:
            pulumi.set(__self__, "log_cleanup_policy", log_cleanup_policy)
        if log_flush_interval_messages is not None:
            pulumi.set(__self__, "log_flush_interval_messages", log_flush_interval_messages)
        if log_flush_interval_ms is not None:
            pulumi.set(__self__, "log_flush_interval_ms", log_flush_interval_ms)
        if log_index_interval_bytes is not None:
            pulumi.set(__self__, "log_index_interval_bytes", log_index_interval_bytes)
        if log_index_size_max_bytes is not None:
            pulumi.set(__self__, "log_index_size_max_bytes", log_index_size_max_bytes)
        if log_message_downconversion_enable is not None:
            pulumi.set(__self__, "log_message_downconversion_enable", log_message_downconversion_enable)
        if log_message_timestamp_difference_max_ms is not None:
            pulumi.set(__self__, "log_message_timestamp_difference_max_ms", log_message_timestamp_difference_max_ms)
        if log_message_timestamp_type is not None:
            pulumi.set(__self__, "log_message_timestamp_type", log_message_timestamp_type)
        if log_preallocate is not None:
            pulumi.set(__self__, "log_preallocate", log_preallocate)
        if log_retention_bytes is not None:
            pulumi.set(__self__, "log_retention_bytes", log_retention_bytes)
        if log_retention_hours is not None:
            pulumi.set(__self__, "log_retention_hours", log_retention_hours)
        if log_retention_ms is not None:
            pulumi.set(__self__, "log_retention_ms", log_retention_ms)
        if log_roll_jitter_ms is not None:
            pulumi.set(__self__, "log_roll_jitter_ms", log_roll_jitter_ms)
        if log_roll_ms is not None:
            pulumi.set(__self__, "log_roll_ms", log_roll_ms)
        if log_segment_bytes is not None:
            pulumi.set(__self__, "log_segment_bytes", log_segment_bytes)
        if log_segment_delete_delay_ms is not None:
            pulumi.set(__self__, "log_segment_delete_delay_ms", log_segment_delete_delay_ms)
        if max_connections_per_ip is not None:
            pulumi.set(__self__, "max_connections_per_ip", max_connections_per_ip)
        if max_incremental_fetch_session_cache_slots is not None:
            pulumi.set(__self__, "max_incremental_fetch_session_cache_slots", max_incremental_fetch_session_cache_slots)
        if message_max_bytes is not None:
            pulumi.set(__self__, "message_max_bytes", message_max_bytes)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if num_partitions is not None:
            pulumi.set(__self__, "num_partitions", num_partitions)
        if offsets_retention_minutes is not None:
            pulumi.set(__self__, "offsets_retention_minutes", offsets_retention_minutes)
        if producer_purgatory_purge_interval_requests is not None:
            pulumi.set(__self__, "producer_purgatory_purge_interval_requests", producer_purgatory_purge_interval_requests)
        if replica_fetch_max_bytes is not None:
            pulumi.set(__self__, "replica_fetch_max_bytes", replica_fetch_max_bytes)
        if replica_fetch_response_max_bytes is not None:
            pulumi.set(__self__, "replica_fetch_response_max_bytes", replica_fetch_response_max_bytes)
        if socket_request_max_bytes is not None:
            pulumi.set(__self__, "socket_request_max_bytes", socket_request_max_bytes)
        if transaction_remove_expired_transaction_cleanup_interval_ms is not None:
            pulumi.set(__self__, "transaction_remove_expired_transaction_cleanup_interval_ms", transaction_remove_expired_transaction_cleanup_interval_ms)
        if transaction_state_log_segment_bytes is not None:
            pulumi.set(__self__, "transaction_state_log_segment_bytes", transaction_state_log_segment_bytes)

    @property
    @pulumi.getter(name="autoCreateTopicsEnable")
    def auto_create_topics_enable(self) -> Optional[str]:
        return pulumi.get(self, "auto_create_topics_enable")

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        return pulumi.get(self, "compression_type")

    @property
    @pulumi.getter(name="connectionsMaxIdleMs")
    def connections_max_idle_ms(self) -> Optional[str]:
        return pulumi.get(self, "connections_max_idle_ms")

    @property
    @pulumi.getter(name="defaultReplicationFactor")
    def default_replication_factor(self) -> Optional[str]:
        return pulumi.get(self, "default_replication_factor")

    @property
    @pulumi.getter(name="groupInitialRebalanceDelayMs")
    def group_initial_rebalance_delay_ms(self) -> Optional[str]:
        return pulumi.get(self, "group_initial_rebalance_delay_ms")

    @property
    @pulumi.getter(name="groupMaxSessionTimeoutMs")
    def group_max_session_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "group_max_session_timeout_ms")

    @property
    @pulumi.getter(name="groupMinSessionTimeoutMs")
    def group_min_session_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "group_min_session_timeout_ms")

    @property
    @pulumi.getter(name="logCleanerDeleteRetentionMs")
    def log_cleaner_delete_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_cleaner_delete_retention_ms")

    @property
    @pulumi.getter(name="logCleanerMaxCompactionLagMs")
    def log_cleaner_max_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_cleaner_max_compaction_lag_ms")

    @property
    @pulumi.getter(name="logCleanerMinCleanableRatio")
    def log_cleaner_min_cleanable_ratio(self) -> Optional[str]:
        return pulumi.get(self, "log_cleaner_min_cleanable_ratio")

    @property
    @pulumi.getter(name="logCleanerMinCompactionLagMs")
    def log_cleaner_min_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_cleaner_min_compaction_lag_ms")

    @property
    @pulumi.getter(name="logCleanupPolicy")
    def log_cleanup_policy(self) -> Optional[str]:
        return pulumi.get(self, "log_cleanup_policy")

    @property
    @pulumi.getter(name="logFlushIntervalMessages")
    def log_flush_interval_messages(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_interval_messages")

    @property
    @pulumi.getter(name="logFlushIntervalMs")
    def log_flush_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_interval_ms")

    @property
    @pulumi.getter(name="logIndexIntervalBytes")
    def log_index_interval_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_index_interval_bytes")

    @property
    @pulumi.getter(name="logIndexSizeMaxBytes")
    def log_index_size_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_index_size_max_bytes")

    @property
    @pulumi.getter(name="logMessageDownconversionEnable")
    def log_message_downconversion_enable(self) -> Optional[str]:
        return pulumi.get(self, "log_message_downconversion_enable")

    @property
    @pulumi.getter(name="logMessageTimestampDifferenceMaxMs")
    def log_message_timestamp_difference_max_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_message_timestamp_difference_max_ms")

    @property
    @pulumi.getter(name="logMessageTimestampType")
    def log_message_timestamp_type(self) -> Optional[str]:
        return pulumi.get(self, "log_message_timestamp_type")

    @property
    @pulumi.getter(name="logPreallocate")
    def log_preallocate(self) -> Optional[str]:
        return pulumi.get(self, "log_preallocate")

    @property
    @pulumi.getter(name="logRetentionBytes")
    def log_retention_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_bytes")

    @property
    @pulumi.getter(name="logRetentionHours")
    def log_retention_hours(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_hours")

    @property
    @pulumi.getter(name="logRetentionMs")
    def log_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_ms")

    @property
    @pulumi.getter(name="logRollJitterMs")
    def log_roll_jitter_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_roll_jitter_ms")

    @property
    @pulumi.getter(name="logRollMs")
    def log_roll_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_roll_ms")

    @property
    @pulumi.getter(name="logSegmentBytes")
    def log_segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_segment_bytes")

    @property
    @pulumi.getter(name="logSegmentDeleteDelayMs")
    def log_segment_delete_delay_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_segment_delete_delay_ms")

    @property
    @pulumi.getter(name="maxConnectionsPerIp")
    def max_connections_per_ip(self) -> Optional[str]:
        return pulumi.get(self, "max_connections_per_ip")

    @property
    @pulumi.getter(name="maxIncrementalFetchSessionCacheSlots")
    def max_incremental_fetch_session_cache_slots(self) -> Optional[str]:
        return pulumi.get(self, "max_incremental_fetch_session_cache_slots")

    @property
    @pulumi.getter(name="messageMaxBytes")
    def message_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "message_max_bytes")

    @property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[str]:
        return pulumi.get(self, "min_insync_replicas")

    @property
    @pulumi.getter(name="numPartitions")
    def num_partitions(self) -> Optional[str]:
        return pulumi.get(self, "num_partitions")

    @property
    @pulumi.getter(name="offsetsRetentionMinutes")
    def offsets_retention_minutes(self) -> Optional[str]:
        return pulumi.get(self, "offsets_retention_minutes")

    @property
    @pulumi.getter(name="producerPurgatoryPurgeIntervalRequests")
    def producer_purgatory_purge_interval_requests(self) -> Optional[str]:
        return pulumi.get(self, "producer_purgatory_purge_interval_requests")

    @property
    @pulumi.getter(name="replicaFetchMaxBytes")
    def replica_fetch_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "replica_fetch_max_bytes")

    @property
    @pulumi.getter(name="replicaFetchResponseMaxBytes")
    def replica_fetch_response_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "replica_fetch_response_max_bytes")

    @property
    @pulumi.getter(name="socketRequestMaxBytes")
    def socket_request_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "socket_request_max_bytes")

    @property
    @pulumi.getter(name="transactionRemoveExpiredTransactionCleanupIntervalMs")
    def transaction_remove_expired_transaction_cleanup_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "transaction_remove_expired_transaction_cleanup_interval_ms")

    @property
    @pulumi.getter(name="transactionStateLogSegmentBytes")
    def transaction_state_log_segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "transaction_state_log_segment_bytes")


@pulumi.output_type
class KafkaKafkaUserConfigKafkaAuthenticationMethods(dict):
    def __init__(__self__, *,
                 certificate: Optional[str] = None,
                 sasl: Optional[str] = None):
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if sasl is not None:
            pulumi.set(__self__, "sasl", sasl)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def sasl(self) -> Optional[str]:
        return pulumi.get(self, "sasl")


@pulumi.output_type
class KafkaKafkaUserConfigKafkaConnectConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorClientConfigOverridePolicy":
            suggest = "connector_client_config_override_policy"
        elif key == "consumerAutoOffsetReset":
            suggest = "consumer_auto_offset_reset"
        elif key == "consumerFetchMaxBytes":
            suggest = "consumer_fetch_max_bytes"
        elif key == "consumerIsolationLevel":
            suggest = "consumer_isolation_level"
        elif key == "consumerMaxPartitionFetchBytes":
            suggest = "consumer_max_partition_fetch_bytes"
        elif key == "consumerMaxPollIntervalMs":
            suggest = "consumer_max_poll_interval_ms"
        elif key == "consumerMaxPollRecords":
            suggest = "consumer_max_poll_records"
        elif key == "offsetFlushIntervalMs":
            suggest = "offset_flush_interval_ms"
        elif key == "offsetFlushTimeoutMs":
            suggest = "offset_flush_timeout_ms"
        elif key == "producerCompressionType":
            suggest = "producer_compression_type"
        elif key == "producerMaxRequestSize":
            suggest = "producer_max_request_size"
        elif key == "sessionTimeoutMs":
            suggest = "session_timeout_ms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaKafkaUserConfigKafkaConnectConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaKafkaUserConfigKafkaConnectConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaKafkaUserConfigKafkaConnectConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_client_config_override_policy: Optional[str] = None,
                 consumer_auto_offset_reset: Optional[str] = None,
                 consumer_fetch_max_bytes: Optional[str] = None,
                 consumer_isolation_level: Optional[str] = None,
                 consumer_max_partition_fetch_bytes: Optional[str] = None,
                 consumer_max_poll_interval_ms: Optional[str] = None,
                 consumer_max_poll_records: Optional[str] = None,
                 offset_flush_interval_ms: Optional[str] = None,
                 offset_flush_timeout_ms: Optional[str] = None,
                 producer_compression_type: Optional[str] = None,
                 producer_max_request_size: Optional[str] = None,
                 session_timeout_ms: Optional[str] = None):
        if connector_client_config_override_policy is not None:
            pulumi.set(__self__, "connector_client_config_override_policy", connector_client_config_override_policy)
        if consumer_auto_offset_reset is not None:
            pulumi.set(__self__, "consumer_auto_offset_reset", consumer_auto_offset_reset)
        if consumer_fetch_max_bytes is not None:
            pulumi.set(__self__, "consumer_fetch_max_bytes", consumer_fetch_max_bytes)
        if consumer_isolation_level is not None:
            pulumi.set(__self__, "consumer_isolation_level", consumer_isolation_level)
        if consumer_max_partition_fetch_bytes is not None:
            pulumi.set(__self__, "consumer_max_partition_fetch_bytes", consumer_max_partition_fetch_bytes)
        if consumer_max_poll_interval_ms is not None:
            pulumi.set(__self__, "consumer_max_poll_interval_ms", consumer_max_poll_interval_ms)
        if consumer_max_poll_records is not None:
            pulumi.set(__self__, "consumer_max_poll_records", consumer_max_poll_records)
        if offset_flush_interval_ms is not None:
            pulumi.set(__self__, "offset_flush_interval_ms", offset_flush_interval_ms)
        if offset_flush_timeout_ms is not None:
            pulumi.set(__self__, "offset_flush_timeout_ms", offset_flush_timeout_ms)
        if producer_compression_type is not None:
            pulumi.set(__self__, "producer_compression_type", producer_compression_type)
        if producer_max_request_size is not None:
            pulumi.set(__self__, "producer_max_request_size", producer_max_request_size)
        if session_timeout_ms is not None:
            pulumi.set(__self__, "session_timeout_ms", session_timeout_ms)

    @property
    @pulumi.getter(name="connectorClientConfigOverridePolicy")
    def connector_client_config_override_policy(self) -> Optional[str]:
        return pulumi.get(self, "connector_client_config_override_policy")

    @property
    @pulumi.getter(name="consumerAutoOffsetReset")
    def consumer_auto_offset_reset(self) -> Optional[str]:
        return pulumi.get(self, "consumer_auto_offset_reset")

    @property
    @pulumi.getter(name="consumerFetchMaxBytes")
    def consumer_fetch_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_fetch_max_bytes")

    @property
    @pulumi.getter(name="consumerIsolationLevel")
    def consumer_isolation_level(self) -> Optional[str]:
        return pulumi.get(self, "consumer_isolation_level")

    @property
    @pulumi.getter(name="consumerMaxPartitionFetchBytes")
    def consumer_max_partition_fetch_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_partition_fetch_bytes")

    @property
    @pulumi.getter(name="consumerMaxPollIntervalMs")
    def consumer_max_poll_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_poll_interval_ms")

    @property
    @pulumi.getter(name="consumerMaxPollRecords")
    def consumer_max_poll_records(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_poll_records")

    @property
    @pulumi.getter(name="offsetFlushIntervalMs")
    def offset_flush_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "offset_flush_interval_ms")

    @property
    @pulumi.getter(name="offsetFlushTimeoutMs")
    def offset_flush_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "offset_flush_timeout_ms")

    @property
    @pulumi.getter(name="producerCompressionType")
    def producer_compression_type(self) -> Optional[str]:
        return pulumi.get(self, "producer_compression_type")

    @property
    @pulumi.getter(name="producerMaxRequestSize")
    def producer_max_request_size(self) -> Optional[str]:
        return pulumi.get(self, "producer_max_request_size")

    @property
    @pulumi.getter(name="sessionTimeoutMs")
    def session_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "session_timeout_ms")


@pulumi.output_type
class KafkaKafkaUserConfigKafkaRestConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerEnableAutoCommit":
            suggest = "consumer_enable_auto_commit"
        elif key == "consumerRequestMaxBytes":
            suggest = "consumer_request_max_bytes"
        elif key == "consumerRequestTimeoutMs":
            suggest = "consumer_request_timeout_ms"
        elif key == "producerAcks":
            suggest = "producer_acks"
        elif key == "producerLingerMs":
            suggest = "producer_linger_ms"
        elif key == "simpleconsumerPoolSizeMax":
            suggest = "simpleconsumer_pool_size_max"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaKafkaUserConfigKafkaRestConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaKafkaUserConfigKafkaRestConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaKafkaUserConfigKafkaRestConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_enable_auto_commit: Optional[str] = None,
                 consumer_request_max_bytes: Optional[str] = None,
                 consumer_request_timeout_ms: Optional[str] = None,
                 producer_acks: Optional[str] = None,
                 producer_linger_ms: Optional[str] = None,
                 simpleconsumer_pool_size_max: Optional[str] = None):
        if consumer_enable_auto_commit is not None:
            pulumi.set(__self__, "consumer_enable_auto_commit", consumer_enable_auto_commit)
        if consumer_request_max_bytes is not None:
            pulumi.set(__self__, "consumer_request_max_bytes", consumer_request_max_bytes)
        if consumer_request_timeout_ms is not None:
            pulumi.set(__self__, "consumer_request_timeout_ms", consumer_request_timeout_ms)
        if producer_acks is not None:
            pulumi.set(__self__, "producer_acks", producer_acks)
        if producer_linger_ms is not None:
            pulumi.set(__self__, "producer_linger_ms", producer_linger_ms)
        if simpleconsumer_pool_size_max is not None:
            pulumi.set(__self__, "simpleconsumer_pool_size_max", simpleconsumer_pool_size_max)

    @property
    @pulumi.getter(name="consumerEnableAutoCommit")
    def consumer_enable_auto_commit(self) -> Optional[str]:
        return pulumi.get(self, "consumer_enable_auto_commit")

    @property
    @pulumi.getter(name="consumerRequestMaxBytes")
    def consumer_request_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_request_max_bytes")

    @property
    @pulumi.getter(name="consumerRequestTimeoutMs")
    def consumer_request_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "consumer_request_timeout_ms")

    @property
    @pulumi.getter(name="producerAcks")
    def producer_acks(self) -> Optional[str]:
        return pulumi.get(self, "producer_acks")

    @property
    @pulumi.getter(name="producerLingerMs")
    def producer_linger_ms(self) -> Optional[str]:
        return pulumi.get(self, "producer_linger_ms")

    @property
    @pulumi.getter(name="simpleconsumerPoolSizeMax")
    def simpleconsumer_pool_size_max(self) -> Optional[str]:
        return pulumi.get(self, "simpleconsumer_pool_size_max")


@pulumi.output_type
class KafkaKafkaUserConfigPrivateAccess(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class KafkaKafkaUserConfigPrivatelinkAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaConnect":
            suggest = "kafka_connect"
        elif key == "kafkaRest":
            suggest = "kafka_rest"
        elif key == "schemaRegistry":
            suggest = "schema_registry"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaKafkaUserConfigPrivatelinkAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaKafkaUserConfigPrivatelinkAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaKafkaUserConfigPrivatelinkAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 jolokia: Optional[str] = None,
                 kafka: Optional[str] = None,
                 kafka_connect: Optional[str] = None,
                 kafka_rest: Optional[str] = None,
                 prometheus: Optional[str] = None,
                 schema_registry: Optional[str] = None):
        """
        :param str kafka: Kafka server provided values
        """
        if jolokia is not None:
            pulumi.set(__self__, "jolokia", jolokia)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if kafka_rest is not None:
            pulumi.set(__self__, "kafka_rest", kafka_rest)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)

    @property
    @pulumi.getter
    def jolokia(self) -> Optional[str]:
        return pulumi.get(self, "jolokia")

    @property
    @pulumi.getter
    def kafka(self) -> Optional[str]:
        """
        Kafka server provided values
        """
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter(name="kafkaRest")
    def kafka_rest(self) -> Optional[str]:
        return pulumi.get(self, "kafka_rest")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[str]:
        return pulumi.get(self, "schema_registry")


@pulumi.output_type
class KafkaKafkaUserConfigPublicAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaConnect":
            suggest = "kafka_connect"
        elif key == "kafkaRest":
            suggest = "kafka_rest"
        elif key == "schemaRegistry":
            suggest = "schema_registry"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaKafkaUserConfigPublicAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaKafkaUserConfigPublicAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaKafkaUserConfigPublicAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka: Optional[str] = None,
                 kafka_connect: Optional[str] = None,
                 kafka_rest: Optional[str] = None,
                 prometheus: Optional[str] = None,
                 schema_registry: Optional[str] = None):
        """
        :param str kafka: Kafka server provided values
        """
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if kafka_rest is not None:
            pulumi.set(__self__, "kafka_rest", kafka_rest)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)

    @property
    @pulumi.getter
    def kafka(self) -> Optional[str]:
        """
        Kafka server provided values
        """
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter(name="kafkaRest")
    def kafka_rest(self) -> Optional[str]:
        return pulumi.get(self, "kafka_rest")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[str]:
        return pulumi.get(self, "schema_registry")


@pulumi.output_type
class KafkaKafkaUserConfigSchemaRegistryConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "leaderEligibility":
            suggest = "leader_eligibility"
        elif key == "topicName":
            suggest = "topic_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaKafkaUserConfigSchemaRegistryConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaKafkaUserConfigSchemaRegistryConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaKafkaUserConfigSchemaRegistryConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 leader_eligibility: Optional[str] = None,
                 topic_name: Optional[str] = None):
        if leader_eligibility is not None:
            pulumi.set(__self__, "leader_eligibility", leader_eligibility)
        if topic_name is not None:
            pulumi.set(__self__, "topic_name", topic_name)

    @property
    @pulumi.getter(name="leaderEligibility")
    def leader_eligibility(self) -> Optional[str]:
        return pulumi.get(self, "leader_eligibility")

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> Optional[str]:
        return pulumi.get(self, "topic_name")


@pulumi.output_type
class KafkaMirrorMakerComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaMirrorMakerComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaMirrorMakerComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaMirrorMakerComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class KafkaMirrorMakerKafkaMirrormaker(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class KafkaMirrorMakerKafkaMirrormakerUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "kafkaMirrormaker":
            suggest = "kafka_mirrormaker"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaMirrorMakerKafkaMirrormakerUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaMirrorMakerKafkaMirrormakerUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaMirrorMakerKafkaMirrormakerUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka_mirrormaker: Optional['outputs.KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker'] = None,
                 static_ips: Optional[str] = None):
        """
        :param Sequence[str] ip_filters: IP filter
        :param 'KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormakerArgs' kafka_mirrormaker: Kafka MirrorMaker configuration values
        :param str static_ips: Static IP addresses
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka_mirrormaker is not None:
            pulumi.set(__self__, "kafka_mirrormaker", kafka_mirrormaker)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="kafkaMirrormaker")
    def kafka_mirrormaker(self) -> Optional['outputs.KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker']:
        """
        Kafka MirrorMaker configuration values
        """
        return pulumi.get(self, "kafka_mirrormaker")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IP addresses
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emitCheckpointsEnabled":
            suggest = "emit_checkpoints_enabled"
        elif key == "emitCheckpointsIntervalSeconds":
            suggest = "emit_checkpoints_interval_seconds"
        elif key == "refreshGroupsEnabled":
            suggest = "refresh_groups_enabled"
        elif key == "refreshGroupsIntervalSeconds":
            suggest = "refresh_groups_interval_seconds"
        elif key == "refreshTopicsEnabled":
            suggest = "refresh_topics_enabled"
        elif key == "refreshTopicsIntervalSeconds":
            suggest = "refresh_topics_interval_seconds"
        elif key == "syncGroupOffsetsEnabled":
            suggest = "sync_group_offsets_enabled"
        elif key == "syncGroupOffsetsIntervalSeconds":
            suggest = "sync_group_offsets_interval_seconds"
        elif key == "syncTopicConfigsEnabled":
            suggest = "sync_topic_configs_enabled"
        elif key == "tasksMaxPerCpu":
            suggest = "tasks_max_per_cpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emit_checkpoints_enabled: Optional[str] = None,
                 emit_checkpoints_interval_seconds: Optional[str] = None,
                 refresh_groups_enabled: Optional[str] = None,
                 refresh_groups_interval_seconds: Optional[str] = None,
                 refresh_topics_enabled: Optional[str] = None,
                 refresh_topics_interval_seconds: Optional[str] = None,
                 sync_group_offsets_enabled: Optional[str] = None,
                 sync_group_offsets_interval_seconds: Optional[str] = None,
                 sync_topic_configs_enabled: Optional[str] = None,
                 tasks_max_per_cpu: Optional[str] = None):
        if emit_checkpoints_enabled is not None:
            pulumi.set(__self__, "emit_checkpoints_enabled", emit_checkpoints_enabled)
        if emit_checkpoints_interval_seconds is not None:
            pulumi.set(__self__, "emit_checkpoints_interval_seconds", emit_checkpoints_interval_seconds)
        if refresh_groups_enabled is not None:
            pulumi.set(__self__, "refresh_groups_enabled", refresh_groups_enabled)
        if refresh_groups_interval_seconds is not None:
            pulumi.set(__self__, "refresh_groups_interval_seconds", refresh_groups_interval_seconds)
        if refresh_topics_enabled is not None:
            pulumi.set(__self__, "refresh_topics_enabled", refresh_topics_enabled)
        if refresh_topics_interval_seconds is not None:
            pulumi.set(__self__, "refresh_topics_interval_seconds", refresh_topics_interval_seconds)
        if sync_group_offsets_enabled is not None:
            pulumi.set(__self__, "sync_group_offsets_enabled", sync_group_offsets_enabled)
        if sync_group_offsets_interval_seconds is not None:
            pulumi.set(__self__, "sync_group_offsets_interval_seconds", sync_group_offsets_interval_seconds)
        if sync_topic_configs_enabled is not None:
            pulumi.set(__self__, "sync_topic_configs_enabled", sync_topic_configs_enabled)
        if tasks_max_per_cpu is not None:
            pulumi.set(__self__, "tasks_max_per_cpu", tasks_max_per_cpu)

    @property
    @pulumi.getter(name="emitCheckpointsEnabled")
    def emit_checkpoints_enabled(self) -> Optional[str]:
        return pulumi.get(self, "emit_checkpoints_enabled")

    @property
    @pulumi.getter(name="emitCheckpointsIntervalSeconds")
    def emit_checkpoints_interval_seconds(self) -> Optional[str]:
        return pulumi.get(self, "emit_checkpoints_interval_seconds")

    @property
    @pulumi.getter(name="refreshGroupsEnabled")
    def refresh_groups_enabled(self) -> Optional[str]:
        return pulumi.get(self, "refresh_groups_enabled")

    @property
    @pulumi.getter(name="refreshGroupsIntervalSeconds")
    def refresh_groups_interval_seconds(self) -> Optional[str]:
        return pulumi.get(self, "refresh_groups_interval_seconds")

    @property
    @pulumi.getter(name="refreshTopicsEnabled")
    def refresh_topics_enabled(self) -> Optional[str]:
        return pulumi.get(self, "refresh_topics_enabled")

    @property
    @pulumi.getter(name="refreshTopicsIntervalSeconds")
    def refresh_topics_interval_seconds(self) -> Optional[str]:
        return pulumi.get(self, "refresh_topics_interval_seconds")

    @property
    @pulumi.getter(name="syncGroupOffsetsEnabled")
    def sync_group_offsets_enabled(self) -> Optional[str]:
        return pulumi.get(self, "sync_group_offsets_enabled")

    @property
    @pulumi.getter(name="syncGroupOffsetsIntervalSeconds")
    def sync_group_offsets_interval_seconds(self) -> Optional[str]:
        return pulumi.get(self, "sync_group_offsets_interval_seconds")

    @property
    @pulumi.getter(name="syncTopicConfigsEnabled")
    def sync_topic_configs_enabled(self) -> Optional[str]:
        return pulumi.get(self, "sync_topic_configs_enabled")

    @property
    @pulumi.getter(name="tasksMaxPerCpu")
    def tasks_max_per_cpu(self) -> Optional[str]:
        return pulumi.get(self, "tasks_max_per_cpu")


@pulumi.output_type
class KafkaMirrorMakerServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaMirrorMakerServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaMirrorMakerServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaMirrorMakerServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        """
        :param str integration_type: Type of the service integration. The only supported value at the moment is `read_replica`
        :param str source_service_name: Name of the source service
        """
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Type of the service integration. The only supported value at the moment is `read_replica`
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        """
        Name of the source service
        """
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class KafkaMirrorMakerTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Service tag key
        :param str value: Service tag value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Service tag key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Service tag value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class KafkaServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        """
        :param str integration_type: Type of the service integration. The only supported value at the moment is `read_replica`
        :param str source_service_name: Name of the source service
        """
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Type of the service integration. The only supported value at the moment is `read_replica`
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        """
        Name of the source service
        """
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class KafkaTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Service tag key
        :param str value: Service tag value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Service tag key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Service tag value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class KafkaTopicConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupPolicy":
            suggest = "cleanup_policy"
        elif key == "compressionType":
            suggest = "compression_type"
        elif key == "deleteRetentionMs":
            suggest = "delete_retention_ms"
        elif key == "fileDeleteDelayMs":
            suggest = "file_delete_delay_ms"
        elif key == "flushMessages":
            suggest = "flush_messages"
        elif key == "flushMs":
            suggest = "flush_ms"
        elif key == "indexIntervalBytes":
            suggest = "index_interval_bytes"
        elif key == "maxCompactionLagMs":
            suggest = "max_compaction_lag_ms"
        elif key == "maxMessageBytes":
            suggest = "max_message_bytes"
        elif key == "messageDownconversionEnable":
            suggest = "message_downconversion_enable"
        elif key == "messageFormatVersion":
            suggest = "message_format_version"
        elif key == "messageTimestampDifferenceMaxMs":
            suggest = "message_timestamp_difference_max_ms"
        elif key == "messageTimestampType":
            suggest = "message_timestamp_type"
        elif key == "minCleanableDirtyRatio":
            suggest = "min_cleanable_dirty_ratio"
        elif key == "minCompactionLagMs":
            suggest = "min_compaction_lag_ms"
        elif key == "minInsyncReplicas":
            suggest = "min_insync_replicas"
        elif key == "retentionBytes":
            suggest = "retention_bytes"
        elif key == "retentionMs":
            suggest = "retention_ms"
        elif key == "segmentBytes":
            suggest = "segment_bytes"
        elif key == "segmentIndexBytes":
            suggest = "segment_index_bytes"
        elif key == "segmentJitterMs":
            suggest = "segment_jitter_ms"
        elif key == "segmentMs":
            suggest = "segment_ms"
        elif key == "uncleanLeaderElectionEnable":
            suggest = "unclean_leader_election_enable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaTopicConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaTopicConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaTopicConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cleanup_policy: Optional[str] = None,
                 compression_type: Optional[str] = None,
                 delete_retention_ms: Optional[str] = None,
                 file_delete_delay_ms: Optional[str] = None,
                 flush_messages: Optional[str] = None,
                 flush_ms: Optional[str] = None,
                 index_interval_bytes: Optional[str] = None,
                 max_compaction_lag_ms: Optional[str] = None,
                 max_message_bytes: Optional[str] = None,
                 message_downconversion_enable: Optional[str] = None,
                 message_format_version: Optional[str] = None,
                 message_timestamp_difference_max_ms: Optional[str] = None,
                 message_timestamp_type: Optional[str] = None,
                 min_cleanable_dirty_ratio: Optional[str] = None,
                 min_compaction_lag_ms: Optional[str] = None,
                 min_insync_replicas: Optional[str] = None,
                 preallocate: Optional[str] = None,
                 retention_bytes: Optional[str] = None,
                 retention_ms: Optional[str] = None,
                 segment_bytes: Optional[str] = None,
                 segment_index_bytes: Optional[str] = None,
                 segment_jitter_ms: Optional[str] = None,
                 segment_ms: Optional[str] = None,
                 unclean_leader_election_enable: Optional[str] = None):
        """
        :param str cleanup_policy: cleanup.policy value
        :param str compression_type: compression.type value
        :param str delete_retention_ms: delete.retention.ms value
        :param str file_delete_delay_ms: file.delete.delay.ms value
        :param str flush_messages: flush.messages value
        :param str flush_ms: flush.ms value
        :param str index_interval_bytes: index.interval.bytes value
        :param str max_compaction_lag_ms: max.compaction.lag.ms value
        :param str max_message_bytes: max.message.bytes value
        :param str message_downconversion_enable: message.downconversion.enable value
        :param str message_format_version: message.format.version value
        :param str message_timestamp_difference_max_ms: message.timestamp.difference.max.ms value
        :param str message_timestamp_type: message.timestamp.type value
        :param str min_cleanable_dirty_ratio: min.cleanable.dirty.ratio value
        :param str min_compaction_lag_ms: min.compaction.lag.ms value
        :param str min_insync_replicas: min.insync.replicas value
        :param str preallocate: preallocate value
        :param str retention_bytes: retention.bytes value
        :param str retention_ms: retention.ms value
        :param str segment_bytes: segment.bytes value
        :param str segment_index_bytes: segment.index.bytes value
        :param str segment_jitter_ms: segment.jitter.ms value
        :param str segment_ms: segment.ms value
        :param str unclean_leader_election_enable: unclean.leader.election.enable value
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if delete_retention_ms is not None:
            pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        if file_delete_delay_ms is not None:
            pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        if flush_messages is not None:
            pulumi.set(__self__, "flush_messages", flush_messages)
        if flush_ms is not None:
            pulumi.set(__self__, "flush_ms", flush_ms)
        if index_interval_bytes is not None:
            pulumi.set(__self__, "index_interval_bytes", index_interval_bytes)
        if max_compaction_lag_ms is not None:
            pulumi.set(__self__, "max_compaction_lag_ms", max_compaction_lag_ms)
        if max_message_bytes is not None:
            pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        if message_downconversion_enable is not None:
            pulumi.set(__self__, "message_downconversion_enable", message_downconversion_enable)
        if message_format_version is not None:
            pulumi.set(__self__, "message_format_version", message_format_version)
        if message_timestamp_difference_max_ms is not None:
            pulumi.set(__self__, "message_timestamp_difference_max_ms", message_timestamp_difference_max_ms)
        if message_timestamp_type is not None:
            pulumi.set(__self__, "message_timestamp_type", message_timestamp_type)
        if min_cleanable_dirty_ratio is not None:
            pulumi.set(__self__, "min_cleanable_dirty_ratio", min_cleanable_dirty_ratio)
        if min_compaction_lag_ms is not None:
            pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if preallocate is not None:
            pulumi.set(__self__, "preallocate", preallocate)
        if retention_bytes is not None:
            pulumi.set(__self__, "retention_bytes", retention_bytes)
        if retention_ms is not None:
            pulumi.set(__self__, "retention_ms", retention_ms)
        if segment_bytes is not None:
            pulumi.set(__self__, "segment_bytes", segment_bytes)
        if segment_index_bytes is not None:
            pulumi.set(__self__, "segment_index_bytes", segment_index_bytes)
        if segment_jitter_ms is not None:
            pulumi.set(__self__, "segment_jitter_ms", segment_jitter_ms)
        if segment_ms is not None:
            pulumi.set(__self__, "segment_ms", segment_ms)
        if unclean_leader_election_enable is not None:
            pulumi.set(__self__, "unclean_leader_election_enable", unclean_leader_election_enable)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[str]:
        """
        cleanup.policy value
        """
        return pulumi.get(self, "cleanup_policy")

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        """
        compression.type value
        """
        return pulumi.get(self, "compression_type")

    @property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> Optional[str]:
        """
        delete.retention.ms value
        """
        return pulumi.get(self, "delete_retention_ms")

    @property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> Optional[str]:
        """
        file.delete.delay.ms value
        """
        return pulumi.get(self, "file_delete_delay_ms")

    @property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> Optional[str]:
        """
        flush.messages value
        """
        return pulumi.get(self, "flush_messages")

    @property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> Optional[str]:
        """
        flush.ms value
        """
        return pulumi.get(self, "flush_ms")

    @property
    @pulumi.getter(name="indexIntervalBytes")
    def index_interval_bytes(self) -> Optional[str]:
        """
        index.interval.bytes value
        """
        return pulumi.get(self, "index_interval_bytes")

    @property
    @pulumi.getter(name="maxCompactionLagMs")
    def max_compaction_lag_ms(self) -> Optional[str]:
        """
        max.compaction.lag.ms value
        """
        return pulumi.get(self, "max_compaction_lag_ms")

    @property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> Optional[str]:
        """
        max.message.bytes value
        """
        return pulumi.get(self, "max_message_bytes")

    @property
    @pulumi.getter(name="messageDownconversionEnable")
    def message_downconversion_enable(self) -> Optional[str]:
        """
        message.downconversion.enable value
        """
        return pulumi.get(self, "message_downconversion_enable")

    @property
    @pulumi.getter(name="messageFormatVersion")
    def message_format_version(self) -> Optional[str]:
        """
        message.format.version value
        """
        return pulumi.get(self, "message_format_version")

    @property
    @pulumi.getter(name="messageTimestampDifferenceMaxMs")
    def message_timestamp_difference_max_ms(self) -> Optional[str]:
        """
        message.timestamp.difference.max.ms value
        """
        return pulumi.get(self, "message_timestamp_difference_max_ms")

    @property
    @pulumi.getter(name="messageTimestampType")
    def message_timestamp_type(self) -> Optional[str]:
        """
        message.timestamp.type value
        """
        return pulumi.get(self, "message_timestamp_type")

    @property
    @pulumi.getter(name="minCleanableDirtyRatio")
    def min_cleanable_dirty_ratio(self) -> Optional[str]:
        """
        min.cleanable.dirty.ratio value
        """
        return pulumi.get(self, "min_cleanable_dirty_ratio")

    @property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> Optional[str]:
        """
        min.compaction.lag.ms value
        """
        return pulumi.get(self, "min_compaction_lag_ms")

    @property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[str]:
        """
        min.insync.replicas value
        """
        return pulumi.get(self, "min_insync_replicas")

    @property
    @pulumi.getter
    def preallocate(self) -> Optional[str]:
        """
        preallocate value
        """
        return pulumi.get(self, "preallocate")

    @property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> Optional[str]:
        """
        retention.bytes value
        """
        return pulumi.get(self, "retention_bytes")

    @property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> Optional[str]:
        """
        retention.ms value
        """
        return pulumi.get(self, "retention_ms")

    @property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> Optional[str]:
        """
        segment.bytes value
        """
        return pulumi.get(self, "segment_bytes")

    @property
    @pulumi.getter(name="segmentIndexBytes")
    def segment_index_bytes(self) -> Optional[str]:
        """
        segment.index.bytes value
        """
        return pulumi.get(self, "segment_index_bytes")

    @property
    @pulumi.getter(name="segmentJitterMs")
    def segment_jitter_ms(self) -> Optional[str]:
        """
        segment.jitter.ms value
        """
        return pulumi.get(self, "segment_jitter_ms")

    @property
    @pulumi.getter(name="segmentMs")
    def segment_ms(self) -> Optional[str]:
        """
        segment.ms value
        """
        return pulumi.get(self, "segment_ms")

    @property
    @pulumi.getter(name="uncleanLeaderElectionEnable")
    def unclean_leader_election_enable(self) -> Optional[str]:
        """
        unclean.leader.election.enable value
        """
        return pulumi.get(self, "unclean_leader_election_enable")


@pulumi.output_type
class KafkaTopicTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str key: Topic tag key. Maximum Length: `64`.
        :param str value: Topic tag value. Maximum Length: `256`.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Topic tag key. Maximum Length: `64`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Topic tag value. Maximum Length: `256`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class M3AggregatorComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3AggregatorComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3AggregatorComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3AggregatorComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class M3AggregatorM3aggregator(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class M3AggregatorM3aggregatorUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDomain":
            suggest = "custom_domain"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "m3Version":
            suggest = "m3_version"
        elif key == "m3aggregatorVersion":
            suggest = "m3aggregator_version"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3AggregatorM3aggregatorUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3AggregatorM3aggregatorUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3AggregatorM3aggregatorUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 m3_version: Optional[str] = None,
                 m3aggregator_version: Optional[str] = None,
                 static_ips: Optional[str] = None):
        """
        :param str custom_domain: Custom domain
        :param Sequence[str] ip_filters: IP filter
        :param str m3_version: M3 major version (deprecated, use m3aggregator_version)
        :param str m3aggregator_version: M3 major version (the minimum compatible version)
        :param str static_ips: Static IP addresses
        """
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if m3_version is not None:
            pulumi.set(__self__, "m3_version", m3_version)
        if m3aggregator_version is not None:
            pulumi.set(__self__, "m3aggregator_version", m3aggregator_version)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        """
        Custom domain
        """
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="m3Version")
    def m3_version(self) -> Optional[str]:
        """
        M3 major version (deprecated, use m3aggregator_version)
        """
        return pulumi.get(self, "m3_version")

    @property
    @pulumi.getter(name="m3aggregatorVersion")
    def m3aggregator_version(self) -> Optional[str]:
        """
        M3 major version (the minimum compatible version)
        """
        return pulumi.get(self, "m3aggregator_version")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IP addresses
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class M3AggregatorServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3AggregatorServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3AggregatorServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3AggregatorServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        """
        :param str integration_type: Type of the service integration. The only supported value at the moment is `read_replica`
        :param str source_service_name: Name of the source service
        """
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Type of the service integration. The only supported value at the moment is `read_replica`
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        """
        Name of the source service
        """
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class M3AggregatorTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Service tag key
        :param str value: Service tag value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Service tag key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Service tag value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class M3DbComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3DbComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3DbComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3DbComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class M3DbM3db(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class M3DbM3dbUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDomain":
            suggest = "custom_domain"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "m3Version":
            suggest = "m3_version"
        elif key == "m3coordinatorEnableGraphiteCarbonIngest":
            suggest = "m3coordinator_enable_graphite_carbon_ingest"
        elif key == "m3dbVersion":
            suggest = "m3db_version"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3DbM3dbUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3DbM3dbUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3DbM3dbUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 limits: Optional['outputs.M3DbM3dbUserConfigLimits'] = None,
                 m3_version: Optional[str] = None,
                 m3coordinator_enable_graphite_carbon_ingest: Optional[str] = None,
                 m3db_version: Optional[str] = None,
                 namespaces: Optional[Sequence['outputs.M3DbM3dbUserConfigNamespace']] = None,
                 private_access: Optional['outputs.M3DbM3dbUserConfigPrivateAccess'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.M3DbM3dbUserConfigPublicAccess'] = None,
                 rules: Optional['outputs.M3DbM3dbUserConfigRules'] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        """
        :param str custom_domain: Custom domain
        :param Sequence[str] ip_filters: IP filter
        :param 'M3DbM3dbUserConfigLimitsArgs' limits: M3 limits
        :param str m3_version: M3 major version (deprecated, use m3db_version)
        :param str m3coordinator_enable_graphite_carbon_ingest: Enable Graphite ingestion using Carbon plaintext protocol
        :param str m3db_version: M3 major version (the minimum compatible version)
        :param Sequence['M3DbM3dbUserConfigNamespaceArgs'] namespaces: List of M3 namespaces
        :param 'M3DbM3dbUserConfigPrivateAccessArgs' private_access: Allow access to selected service ports from private networks
        :param str project_to_fork_from: Name of another project to fork a service from. This has effect only when a new service is being created.
        :param 'M3DbM3dbUserConfigPublicAccessArgs' public_access: Allow access to selected service ports from the public Internet
        :param 'M3DbM3dbUserConfigRulesArgs' rules: M3 rules
        :param str service_to_fork_from: Name of another service to fork from. This has effect only when a new service is being created.
        :param str static_ips: Static IP addresses
        """
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if m3_version is not None:
            pulumi.set(__self__, "m3_version", m3_version)
        if m3coordinator_enable_graphite_carbon_ingest is not None:
            pulumi.set(__self__, "m3coordinator_enable_graphite_carbon_ingest", m3coordinator_enable_graphite_carbon_ingest)
        if m3db_version is not None:
            pulumi.set(__self__, "m3db_version", m3db_version)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        """
        Custom domain
        """
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def limits(self) -> Optional['outputs.M3DbM3dbUserConfigLimits']:
        """
        M3 limits
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter(name="m3Version")
    def m3_version(self) -> Optional[str]:
        """
        M3 major version (deprecated, use m3db_version)
        """
        return pulumi.get(self, "m3_version")

    @property
    @pulumi.getter(name="m3coordinatorEnableGraphiteCarbonIngest")
    def m3coordinator_enable_graphite_carbon_ingest(self) -> Optional[str]:
        """
        Enable Graphite ingestion using Carbon plaintext protocol
        """
        return pulumi.get(self, "m3coordinator_enable_graphite_carbon_ingest")

    @property
    @pulumi.getter(name="m3dbVersion")
    def m3db_version(self) -> Optional[str]:
        """
        M3 major version (the minimum compatible version)
        """
        return pulumi.get(self, "m3db_version")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence['outputs.M3DbM3dbUserConfigNamespace']]:
        """
        List of M3 namespaces
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.M3DbM3dbUserConfigPrivateAccess']:
        """
        Allow access to selected service ports from private networks
        """
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        """
        Name of another project to fork a service from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.M3DbM3dbUserConfigPublicAccess']:
        """
        Allow access to selected service ports from the public Internet
        """
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter
    def rules(self) -> Optional['outputs.M3DbM3dbUserConfigRules']:
        """
        M3 rules
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        """
        Name of another service to fork from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IP addresses
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class M3DbM3dbUserConfigLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryDocs":
            suggest = "query_docs"
        elif key == "queryRequireExhaustive":
            suggest = "query_require_exhaustive"
        elif key == "querySeries":
            suggest = "query_series"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3DbM3dbUserConfigLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3DbM3dbUserConfigLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3DbM3dbUserConfigLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_docs: Optional[str] = None,
                 query_require_exhaustive: Optional[str] = None,
                 query_series: Optional[str] = None):
        if query_docs is not None:
            pulumi.set(__self__, "query_docs", query_docs)
        if query_require_exhaustive is not None:
            pulumi.set(__self__, "query_require_exhaustive", query_require_exhaustive)
        if query_series is not None:
            pulumi.set(__self__, "query_series", query_series)

    @property
    @pulumi.getter(name="queryDocs")
    def query_docs(self) -> Optional[str]:
        return pulumi.get(self, "query_docs")

    @property
    @pulumi.getter(name="queryRequireExhaustive")
    def query_require_exhaustive(self) -> Optional[str]:
        return pulumi.get(self, "query_require_exhaustive")

    @property
    @pulumi.getter(name="querySeries")
    def query_series(self) -> Optional[str]:
        return pulumi.get(self, "query_series")


@pulumi.output_type
class M3DbM3dbUserConfigNamespace(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 options: Optional['outputs.M3DbM3dbUserConfigNamespaceOptions'] = None,
                 resolution: Optional[str] = None,
                 type: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def options(self) -> Optional['outputs.M3DbM3dbUserConfigNamespaceOptions']:
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def resolution(self) -> Optional[str]:
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class M3DbM3dbUserConfigNamespaceOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionOptions":
            suggest = "retention_options"
        elif key == "snapshotEnabled":
            suggest = "snapshot_enabled"
        elif key == "writesToCommitlog":
            suggest = "writes_to_commitlog"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3DbM3dbUserConfigNamespaceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3DbM3dbUserConfigNamespaceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3DbM3dbUserConfigNamespaceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_options: Optional['outputs.M3DbM3dbUserConfigNamespaceOptionsRetentionOptions'] = None,
                 snapshot_enabled: Optional[str] = None,
                 writes_to_commitlog: Optional[str] = None):
        if retention_options is not None:
            pulumi.set(__self__, "retention_options", retention_options)
        if snapshot_enabled is not None:
            pulumi.set(__self__, "snapshot_enabled", snapshot_enabled)
        if writes_to_commitlog is not None:
            pulumi.set(__self__, "writes_to_commitlog", writes_to_commitlog)

    @property
    @pulumi.getter(name="retentionOptions")
    def retention_options(self) -> Optional['outputs.M3DbM3dbUserConfigNamespaceOptionsRetentionOptions']:
        return pulumi.get(self, "retention_options")

    @property
    @pulumi.getter(name="snapshotEnabled")
    def snapshot_enabled(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_enabled")

    @property
    @pulumi.getter(name="writesToCommitlog")
    def writes_to_commitlog(self) -> Optional[str]:
        return pulumi.get(self, "writes_to_commitlog")


@pulumi.output_type
class M3DbM3dbUserConfigNamespaceOptionsRetentionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockDataExpiryDuration":
            suggest = "block_data_expiry_duration"
        elif key == "blocksizeDuration":
            suggest = "blocksize_duration"
        elif key == "bufferFutureDuration":
            suggest = "buffer_future_duration"
        elif key == "bufferPastDuration":
            suggest = "buffer_past_duration"
        elif key == "retentionPeriodDuration":
            suggest = "retention_period_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3DbM3dbUserConfigNamespaceOptionsRetentionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3DbM3dbUserConfigNamespaceOptionsRetentionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3DbM3dbUserConfigNamespaceOptionsRetentionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_data_expiry_duration: Optional[str] = None,
                 blocksize_duration: Optional[str] = None,
                 buffer_future_duration: Optional[str] = None,
                 buffer_past_duration: Optional[str] = None,
                 retention_period_duration: Optional[str] = None):
        if block_data_expiry_duration is not None:
            pulumi.set(__self__, "block_data_expiry_duration", block_data_expiry_duration)
        if blocksize_duration is not None:
            pulumi.set(__self__, "blocksize_duration", blocksize_duration)
        if buffer_future_duration is not None:
            pulumi.set(__self__, "buffer_future_duration", buffer_future_duration)
        if buffer_past_duration is not None:
            pulumi.set(__self__, "buffer_past_duration", buffer_past_duration)
        if retention_period_duration is not None:
            pulumi.set(__self__, "retention_period_duration", retention_period_duration)

    @property
    @pulumi.getter(name="blockDataExpiryDuration")
    def block_data_expiry_duration(self) -> Optional[str]:
        return pulumi.get(self, "block_data_expiry_duration")

    @property
    @pulumi.getter(name="blocksizeDuration")
    def blocksize_duration(self) -> Optional[str]:
        return pulumi.get(self, "blocksize_duration")

    @property
    @pulumi.getter(name="bufferFutureDuration")
    def buffer_future_duration(self) -> Optional[str]:
        return pulumi.get(self, "buffer_future_duration")

    @property
    @pulumi.getter(name="bufferPastDuration")
    def buffer_past_duration(self) -> Optional[str]:
        return pulumi.get(self, "buffer_past_duration")

    @property
    @pulumi.getter(name="retentionPeriodDuration")
    def retention_period_duration(self) -> Optional[str]:
        return pulumi.get(self, "retention_period_duration")


@pulumi.output_type
class M3DbM3dbUserConfigPrivateAccess(dict):
    def __init__(__self__, *,
                 m3coordinator: Optional[str] = None):
        if m3coordinator is not None:
            pulumi.set(__self__, "m3coordinator", m3coordinator)

    @property
    @pulumi.getter
    def m3coordinator(self) -> Optional[str]:
        return pulumi.get(self, "m3coordinator")


@pulumi.output_type
class M3DbM3dbUserConfigPublicAccess(dict):
    def __init__(__self__, *,
                 m3coordinator: Optional[str] = None):
        if m3coordinator is not None:
            pulumi.set(__self__, "m3coordinator", m3coordinator)

    @property
    @pulumi.getter
    def m3coordinator(self) -> Optional[str]:
        return pulumi.get(self, "m3coordinator")


@pulumi.output_type
class M3DbM3dbUserConfigRules(dict):
    def __init__(__self__, *,
                 mappings: Optional[Sequence['outputs.M3DbM3dbUserConfigRulesMapping']] = None):
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter
    def mappings(self) -> Optional[Sequence['outputs.M3DbM3dbUserConfigRulesMapping']]:
        return pulumi.get(self, "mappings")


@pulumi.output_type
class M3DbM3dbUserConfigRulesMapping(dict):
    def __init__(__self__, *,
                 aggregations: Optional[Sequence[str]] = None,
                 drop: Optional[str] = None,
                 filter: Optional[str] = None,
                 name: Optional[str] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence['outputs.M3DbM3dbUserConfigRulesMappingTag']] = None):
        if aggregations is not None:
            pulumi.set(__self__, "aggregations", aggregations)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def aggregations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "aggregations")

    @property
    @pulumi.getter
    def drop(self) -> Optional[str]:
        return pulumi.get(self, "drop")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.M3DbM3dbUserConfigRulesMappingTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class M3DbM3dbUserConfigRulesMappingTag(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class M3DbServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3DbServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3DbServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3DbServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        """
        :param str integration_type: Type of the service integration. The only supported value at the moment is `read_replica`
        :param str source_service_name: Name of the source service
        """
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Type of the service integration. The only supported value at the moment is `read_replica`
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        """
        Name of the source service
        """
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class M3DbTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Service tag key
        :param str value: Service tag value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Service tag key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Service tag value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class MySqlComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MySqlComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MySqlComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MySqlComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class MySqlMysql(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class MySqlMysqlUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupHour":
            suggest = "backup_hour"
        elif key == "backupMinute":
            suggest = "backup_minute"
        elif key == "binlogRetentionPeriod":
            suggest = "binlog_retention_period"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "mysqlVersion":
            suggest = "mysql_version"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "recoveryTargetTime":
            suggest = "recovery_target_time"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MySqlMysqlUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MySqlMysqlUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MySqlMysqlUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_hour: Optional[str] = None,
                 backup_minute: Optional[str] = None,
                 binlog_retention_period: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 migration: Optional['outputs.MySqlMysqlUserConfigMigration'] = None,
                 mysql: Optional['outputs.MySqlMysqlUserConfigMysql'] = None,
                 mysql_version: Optional[str] = None,
                 private_access: Optional['outputs.MySqlMysqlUserConfigPrivateAccess'] = None,
                 privatelink_access: Optional['outputs.MySqlMysqlUserConfigPrivatelinkAccess'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.MySqlMysqlUserConfigPublicAccess'] = None,
                 recovery_target_time: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        """
        :param str admin_password: Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        :param str admin_username: Custom username for admin user. This must be set only when a new service is being created.
        :param str backup_hour: The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        :param str backup_minute: The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        :param str binlog_retention_period: The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
        :param Sequence[str] ip_filters: IP filter
        :param 'MySqlMysqlUserConfigMigrationArgs' migration: Migrate data from existing server
        :param 'MySqlMysqlUserConfigMysqlArgs' mysql: mysql.conf configuration values
        :param str mysql_version: MySQL major version
        :param 'MySqlMysqlUserConfigPrivateAccessArgs' private_access: Allow access to selected service ports from private networks
        :param 'MySqlMysqlUserConfigPrivatelinkAccessArgs' privatelink_access: Allow access to selected service components through Privatelink
        :param str project_to_fork_from: Name of another project to fork a service from. This has effect only when a new service is being created.
        :param 'MySqlMysqlUserConfigPublicAccessArgs' public_access: Allow access to selected service ports from the public Internet
        :param str recovery_target_time: Recovery target time when forking a service. This has effect only when a new service is being created.
        :param str service_to_fork_from: Name of another service to fork from. This has effect only when a new service is being created.
        :param str static_ips: Static IP addresses
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if binlog_retention_period is not None:
            pulumi.set(__self__, "binlog_retention_period", binlog_retention_period)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if mysql_version is not None:
            pulumi.set(__self__, "mysql_version", mysql_version)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_target_time is not None:
            pulumi.set(__self__, "recovery_target_time", recovery_target_time)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        """
        Custom username for admin user. This must be set only when a new service is being created.
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[str]:
        """
        The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_hour")

    @property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[str]:
        """
        The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_minute")

    @property
    @pulumi.getter(name="binlogRetentionPeriod")
    def binlog_retention_period(self) -> Optional[str]:
        """
        The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
        """
        return pulumi.get(self, "binlog_retention_period")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def migration(self) -> Optional['outputs.MySqlMysqlUserConfigMigration']:
        """
        Migrate data from existing server
        """
        return pulumi.get(self, "migration")

    @property
    @pulumi.getter
    def mysql(self) -> Optional['outputs.MySqlMysqlUserConfigMysql']:
        """
        mysql.conf configuration values
        """
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter(name="mysqlVersion")
    def mysql_version(self) -> Optional[str]:
        """
        MySQL major version
        """
        return pulumi.get(self, "mysql_version")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.MySqlMysqlUserConfigPrivateAccess']:
        """
        Allow access to selected service ports from private networks
        """
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.MySqlMysqlUserConfigPrivatelinkAccess']:
        """
        Allow access to selected service components through Privatelink
        """
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        """
        Name of another project to fork a service from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.MySqlMysqlUserConfigPublicAccess']:
        """
        Allow access to selected service ports from the public Internet
        """
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryTargetTime")
    def recovery_target_time(self) -> Optional[str]:
        """
        Recovery target time when forking a service. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "recovery_target_time")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        """
        Name of another service to fork from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IP addresses
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class MySqlMysqlUserConfigMigration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreDbs":
            suggest = "ignore_dbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MySqlMysqlUserConfigMigration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MySqlMysqlUserConfigMigration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MySqlMysqlUserConfigMigration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 ignore_dbs: Optional[str] = None,
                 method: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 ssl: Optional[str] = None,
                 username: Optional[str] = None):
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[str]:
        return pulumi.get(self, "ignore_dbs")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class MySqlMysqlUserConfigMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "defaultTimeZone":
            suggest = "default_time_zone"
        elif key == "groupConcatMaxLen":
            suggest = "group_concat_max_len"
        elif key == "informationSchemaStatsExpiry":
            suggest = "information_schema_stats_expiry"
        elif key == "innodbChangeBufferMaxSize":
            suggest = "innodb_change_buffer_max_size"
        elif key == "innodbFlushNeighbors":
            suggest = "innodb_flush_neighbors"
        elif key == "innodbFtMinTokenSize":
            suggest = "innodb_ft_min_token_size"
        elif key == "innodbFtServerStopwordTable":
            suggest = "innodb_ft_server_stopword_table"
        elif key == "innodbLockWaitTimeout":
            suggest = "innodb_lock_wait_timeout"
        elif key == "innodbLogBufferSize":
            suggest = "innodb_log_buffer_size"
        elif key == "innodbOnlineAlterLogMaxSize":
            suggest = "innodb_online_alter_log_max_size"
        elif key == "innodbPrintAllDeadlocks":
            suggest = "innodb_print_all_deadlocks"
        elif key == "innodbReadIoThreads":
            suggest = "innodb_read_io_threads"
        elif key == "innodbRollbackOnTimeout":
            suggest = "innodb_rollback_on_timeout"
        elif key == "innodbThreadConcurrency":
            suggest = "innodb_thread_concurrency"
        elif key == "innodbWriteIoThreads":
            suggest = "innodb_write_io_threads"
        elif key == "interactiveTimeout":
            suggest = "interactive_timeout"
        elif key == "internalTmpMemStorageEngine":
            suggest = "internal_tmp_mem_storage_engine"
        elif key == "longQueryTime":
            suggest = "long_query_time"
        elif key == "maxAllowedPacket":
            suggest = "max_allowed_packet"
        elif key == "maxHeapTableSize":
            suggest = "max_heap_table_size"
        elif key == "netBufferLength":
            suggest = "net_buffer_length"
        elif key == "netReadTimeout":
            suggest = "net_read_timeout"
        elif key == "netWriteTimeout":
            suggest = "net_write_timeout"
        elif key == "slowQueryLog":
            suggest = "slow_query_log"
        elif key == "sortBufferSize":
            suggest = "sort_buffer_size"
        elif key == "sqlMode":
            suggest = "sql_mode"
        elif key == "sqlRequirePrimaryKey":
            suggest = "sql_require_primary_key"
        elif key == "tmpTableSize":
            suggest = "tmp_table_size"
        elif key == "waitTimeout":
            suggest = "wait_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MySqlMysqlUserConfigMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MySqlMysqlUserConfigMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MySqlMysqlUserConfigMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connect_timeout: Optional[str] = None,
                 default_time_zone: Optional[str] = None,
                 group_concat_max_len: Optional[str] = None,
                 information_schema_stats_expiry: Optional[str] = None,
                 innodb_change_buffer_max_size: Optional[str] = None,
                 innodb_flush_neighbors: Optional[str] = None,
                 innodb_ft_min_token_size: Optional[str] = None,
                 innodb_ft_server_stopword_table: Optional[str] = None,
                 innodb_lock_wait_timeout: Optional[str] = None,
                 innodb_log_buffer_size: Optional[str] = None,
                 innodb_online_alter_log_max_size: Optional[str] = None,
                 innodb_print_all_deadlocks: Optional[str] = None,
                 innodb_read_io_threads: Optional[str] = None,
                 innodb_rollback_on_timeout: Optional[str] = None,
                 innodb_thread_concurrency: Optional[str] = None,
                 innodb_write_io_threads: Optional[str] = None,
                 interactive_timeout: Optional[str] = None,
                 internal_tmp_mem_storage_engine: Optional[str] = None,
                 long_query_time: Optional[str] = None,
                 max_allowed_packet: Optional[str] = None,
                 max_heap_table_size: Optional[str] = None,
                 net_buffer_length: Optional[str] = None,
                 net_read_timeout: Optional[str] = None,
                 net_write_timeout: Optional[str] = None,
                 slow_query_log: Optional[str] = None,
                 sort_buffer_size: Optional[str] = None,
                 sql_mode: Optional[str] = None,
                 sql_require_primary_key: Optional[str] = None,
                 tmp_table_size: Optional[str] = None,
                 wait_timeout: Optional[str] = None):
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if default_time_zone is not None:
            pulumi.set(__self__, "default_time_zone", default_time_zone)
        if group_concat_max_len is not None:
            pulumi.set(__self__, "group_concat_max_len", group_concat_max_len)
        if information_schema_stats_expiry is not None:
            pulumi.set(__self__, "information_schema_stats_expiry", information_schema_stats_expiry)
        if innodb_change_buffer_max_size is not None:
            pulumi.set(__self__, "innodb_change_buffer_max_size", innodb_change_buffer_max_size)
        if innodb_flush_neighbors is not None:
            pulumi.set(__self__, "innodb_flush_neighbors", innodb_flush_neighbors)
        if innodb_ft_min_token_size is not None:
            pulumi.set(__self__, "innodb_ft_min_token_size", innodb_ft_min_token_size)
        if innodb_ft_server_stopword_table is not None:
            pulumi.set(__self__, "innodb_ft_server_stopword_table", innodb_ft_server_stopword_table)
        if innodb_lock_wait_timeout is not None:
            pulumi.set(__self__, "innodb_lock_wait_timeout", innodb_lock_wait_timeout)
        if innodb_log_buffer_size is not None:
            pulumi.set(__self__, "innodb_log_buffer_size", innodb_log_buffer_size)
        if innodb_online_alter_log_max_size is not None:
            pulumi.set(__self__, "innodb_online_alter_log_max_size", innodb_online_alter_log_max_size)
        if innodb_print_all_deadlocks is not None:
            pulumi.set(__self__, "innodb_print_all_deadlocks", innodb_print_all_deadlocks)
        if innodb_read_io_threads is not None:
            pulumi.set(__self__, "innodb_read_io_threads", innodb_read_io_threads)
        if innodb_rollback_on_timeout is not None:
            pulumi.set(__self__, "innodb_rollback_on_timeout", innodb_rollback_on_timeout)
        if innodb_thread_concurrency is not None:
            pulumi.set(__self__, "innodb_thread_concurrency", innodb_thread_concurrency)
        if innodb_write_io_threads is not None:
            pulumi.set(__self__, "innodb_write_io_threads", innodb_write_io_threads)
        if interactive_timeout is not None:
            pulumi.set(__self__, "interactive_timeout", interactive_timeout)
        if internal_tmp_mem_storage_engine is not None:
            pulumi.set(__self__, "internal_tmp_mem_storage_engine", internal_tmp_mem_storage_engine)
        if long_query_time is not None:
            pulumi.set(__self__, "long_query_time", long_query_time)
        if max_allowed_packet is not None:
            pulumi.set(__self__, "max_allowed_packet", max_allowed_packet)
        if max_heap_table_size is not None:
            pulumi.set(__self__, "max_heap_table_size", max_heap_table_size)
        if net_buffer_length is not None:
            pulumi.set(__self__, "net_buffer_length", net_buffer_length)
        if net_read_timeout is not None:
            pulumi.set(__self__, "net_read_timeout", net_read_timeout)
        if net_write_timeout is not None:
            pulumi.set(__self__, "net_write_timeout", net_write_timeout)
        if slow_query_log is not None:
            pulumi.set(__self__, "slow_query_log", slow_query_log)
        if sort_buffer_size is not None:
            pulumi.set(__self__, "sort_buffer_size", sort_buffer_size)
        if sql_mode is not None:
            pulumi.set(__self__, "sql_mode", sql_mode)
        if sql_require_primary_key is not None:
            pulumi.set(__self__, "sql_require_primary_key", sql_require_primary_key)
        if tmp_table_size is not None:
            pulumi.set(__self__, "tmp_table_size", tmp_table_size)
        if wait_timeout is not None:
            pulumi.set(__self__, "wait_timeout", wait_timeout)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[str]:
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="defaultTimeZone")
    def default_time_zone(self) -> Optional[str]:
        return pulumi.get(self, "default_time_zone")

    @property
    @pulumi.getter(name="groupConcatMaxLen")
    def group_concat_max_len(self) -> Optional[str]:
        return pulumi.get(self, "group_concat_max_len")

    @property
    @pulumi.getter(name="informationSchemaStatsExpiry")
    def information_schema_stats_expiry(self) -> Optional[str]:
        return pulumi.get(self, "information_schema_stats_expiry")

    @property
    @pulumi.getter(name="innodbChangeBufferMaxSize")
    def innodb_change_buffer_max_size(self) -> Optional[str]:
        return pulumi.get(self, "innodb_change_buffer_max_size")

    @property
    @pulumi.getter(name="innodbFlushNeighbors")
    def innodb_flush_neighbors(self) -> Optional[str]:
        return pulumi.get(self, "innodb_flush_neighbors")

    @property
    @pulumi.getter(name="innodbFtMinTokenSize")
    def innodb_ft_min_token_size(self) -> Optional[str]:
        return pulumi.get(self, "innodb_ft_min_token_size")

    @property
    @pulumi.getter(name="innodbFtServerStopwordTable")
    def innodb_ft_server_stopword_table(self) -> Optional[str]:
        return pulumi.get(self, "innodb_ft_server_stopword_table")

    @property
    @pulumi.getter(name="innodbLockWaitTimeout")
    def innodb_lock_wait_timeout(self) -> Optional[str]:
        return pulumi.get(self, "innodb_lock_wait_timeout")

    @property
    @pulumi.getter(name="innodbLogBufferSize")
    def innodb_log_buffer_size(self) -> Optional[str]:
        return pulumi.get(self, "innodb_log_buffer_size")

    @property
    @pulumi.getter(name="innodbOnlineAlterLogMaxSize")
    def innodb_online_alter_log_max_size(self) -> Optional[str]:
        return pulumi.get(self, "innodb_online_alter_log_max_size")

    @property
    @pulumi.getter(name="innodbPrintAllDeadlocks")
    def innodb_print_all_deadlocks(self) -> Optional[str]:
        return pulumi.get(self, "innodb_print_all_deadlocks")

    @property
    @pulumi.getter(name="innodbReadIoThreads")
    def innodb_read_io_threads(self) -> Optional[str]:
        return pulumi.get(self, "innodb_read_io_threads")

    @property
    @pulumi.getter(name="innodbRollbackOnTimeout")
    def innodb_rollback_on_timeout(self) -> Optional[str]:
        return pulumi.get(self, "innodb_rollback_on_timeout")

    @property
    @pulumi.getter(name="innodbThreadConcurrency")
    def innodb_thread_concurrency(self) -> Optional[str]:
        return pulumi.get(self, "innodb_thread_concurrency")

    @property
    @pulumi.getter(name="innodbWriteIoThreads")
    def innodb_write_io_threads(self) -> Optional[str]:
        return pulumi.get(self, "innodb_write_io_threads")

    @property
    @pulumi.getter(name="interactiveTimeout")
    def interactive_timeout(self) -> Optional[str]:
        return pulumi.get(self, "interactive_timeout")

    @property
    @pulumi.getter(name="internalTmpMemStorageEngine")
    def internal_tmp_mem_storage_engine(self) -> Optional[str]:
        return pulumi.get(self, "internal_tmp_mem_storage_engine")

    @property
    @pulumi.getter(name="longQueryTime")
    def long_query_time(self) -> Optional[str]:
        return pulumi.get(self, "long_query_time")

    @property
    @pulumi.getter(name="maxAllowedPacket")
    def max_allowed_packet(self) -> Optional[str]:
        return pulumi.get(self, "max_allowed_packet")

    @property
    @pulumi.getter(name="maxHeapTableSize")
    def max_heap_table_size(self) -> Optional[str]:
        return pulumi.get(self, "max_heap_table_size")

    @property
    @pulumi.getter(name="netBufferLength")
    def net_buffer_length(self) -> Optional[str]:
        return pulumi.get(self, "net_buffer_length")

    @property
    @pulumi.getter(name="netReadTimeout")
    def net_read_timeout(self) -> Optional[str]:
        return pulumi.get(self, "net_read_timeout")

    @property
    @pulumi.getter(name="netWriteTimeout")
    def net_write_timeout(self) -> Optional[str]:
        return pulumi.get(self, "net_write_timeout")

    @property
    @pulumi.getter(name="slowQueryLog")
    def slow_query_log(self) -> Optional[str]:
        return pulumi.get(self, "slow_query_log")

    @property
    @pulumi.getter(name="sortBufferSize")
    def sort_buffer_size(self) -> Optional[str]:
        return pulumi.get(self, "sort_buffer_size")

    @property
    @pulumi.getter(name="sqlMode")
    def sql_mode(self) -> Optional[str]:
        return pulumi.get(self, "sql_mode")

    @property
    @pulumi.getter(name="sqlRequirePrimaryKey")
    def sql_require_primary_key(self) -> Optional[str]:
        return pulumi.get(self, "sql_require_primary_key")

    @property
    @pulumi.getter(name="tmpTableSize")
    def tmp_table_size(self) -> Optional[str]:
        return pulumi.get(self, "tmp_table_size")

    @property
    @pulumi.getter(name="waitTimeout")
    def wait_timeout(self) -> Optional[str]:
        return pulumi.get(self, "wait_timeout")


@pulumi.output_type
class MySqlMysqlUserConfigPrivateAccess(dict):
    def __init__(__self__, *,
                 mysql: Optional[str] = None,
                 mysqlx: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str mysql: MySQL specific server provided values
        """
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if mysqlx is not None:
            pulumi.set(__self__, "mysqlx", mysqlx)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def mysql(self) -> Optional[str]:
        """
        MySQL specific server provided values
        """
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter
    def mysqlx(self) -> Optional[str]:
        return pulumi.get(self, "mysqlx")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class MySqlMysqlUserConfigPrivatelinkAccess(dict):
    def __init__(__self__, *,
                 mysql: Optional[str] = None,
                 mysqlx: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str mysql: MySQL specific server provided values
        """
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if mysqlx is not None:
            pulumi.set(__self__, "mysqlx", mysqlx)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def mysql(self) -> Optional[str]:
        """
        MySQL specific server provided values
        """
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter
    def mysqlx(self) -> Optional[str]:
        return pulumi.get(self, "mysqlx")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class MySqlMysqlUserConfigPublicAccess(dict):
    def __init__(__self__, *,
                 mysql: Optional[str] = None,
                 mysqlx: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str mysql: MySQL specific server provided values
        """
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if mysqlx is not None:
            pulumi.set(__self__, "mysqlx", mysqlx)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def mysql(self) -> Optional[str]:
        """
        MySQL specific server provided values
        """
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter
    def mysqlx(self) -> Optional[str]:
        return pulumi.get(self, "mysqlx")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class MySqlServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MySqlServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MySqlServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MySqlServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        """
        :param str integration_type: Type of the service integration. The only supported value at the moment is `read_replica`
        :param str source_service_name: Name of the source service
        """
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Type of the service integration. The only supported value at the moment is `read_replica`
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        """
        Name of the source service
        """
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class MySqlTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Service tag key
        :param str value: Service tag value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Service tag key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Service tag value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OpenSearchComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class OpenSearchOpensearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "opensearchDashboardsUri":
            suggest = "opensearch_dashboards_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 opensearch_dashboards_uri: Optional[str] = None):
        if opensearch_dashboards_uri is not None:
            pulumi.set(__self__, "opensearch_dashboards_uri", opensearch_dashboards_uri)

    @property
    @pulumi.getter(name="opensearchDashboardsUri")
    def opensearch_dashboards_uri(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_dashboards_uri")


@pulumi.output_type
class OpenSearchOpensearchUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDomain":
            suggest = "custom_domain"
        elif key == "disableReplicationFactorAdjustment":
            suggest = "disable_replication_factor_adjustment"
        elif key == "indexPatterns":
            suggest = "index_patterns"
        elif key == "indexTemplate":
            suggest = "index_template"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "keepIndexRefreshInterval":
            suggest = "keep_index_refresh_interval"
        elif key == "maxIndexCount":
            suggest = "max_index_count"
        elif key == "opensearchDashboards":
            suggest = "opensearch_dashboards"
        elif key == "opensearchVersion":
            suggest = "opensearch_version"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "recoveryBasebackupName":
            suggest = "recovery_basebackup_name"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearchUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearchUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearchUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 disable_replication_factor_adjustment: Optional[str] = None,
                 index_patterns: Optional[Sequence['outputs.OpenSearchOpensearchUserConfigIndexPattern']] = None,
                 index_template: Optional['outputs.OpenSearchOpensearchUserConfigIndexTemplate'] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 keep_index_refresh_interval: Optional[str] = None,
                 max_index_count: Optional[str] = None,
                 opensearch: Optional['outputs.OpenSearchOpensearchUserConfigOpensearch'] = None,
                 opensearch_dashboards: Optional['outputs.OpenSearchOpensearchUserConfigOpensearchDashboards'] = None,
                 opensearch_version: Optional[str] = None,
                 private_access: Optional['outputs.OpenSearchOpensearchUserConfigPrivateAccess'] = None,
                 privatelink_access: Optional['outputs.OpenSearchOpensearchUserConfigPrivatelinkAccess'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.OpenSearchOpensearchUserConfigPublicAccess'] = None,
                 recovery_basebackup_name: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        """
        :param str custom_domain: Custom domain
        :param str disable_replication_factor_adjustment: Disable replication factor adjustment
        :param Sequence['OpenSearchOpensearchUserConfigIndexPatternArgs'] index_patterns: Index patterns
        :param 'OpenSearchOpensearchUserConfigIndexTemplateArgs' index_template: Template settings for all new indexes
        :param Sequence[str] ip_filters: IP filter
        :param str keep_index_refresh_interval: Don't reset index.refresh_interval to the default value
        :param str max_index_count: Maximum index count
        :param 'OpenSearchOpensearchUserConfigOpensearchArgs' opensearch: OpenSearch settings
        :param 'OpenSearchOpensearchUserConfigOpensearchDashboardsArgs' opensearch_dashboards: OpenSearch Dashboards settings
        :param str opensearch_version: OpenSearch major version
        :param 'OpenSearchOpensearchUserConfigPrivateAccessArgs' private_access: Allow access to selected service ports from private networks
        :param 'OpenSearchOpensearchUserConfigPrivatelinkAccessArgs' privatelink_access: Allow access to selected service components through Privatelink
        :param str project_to_fork_from: Name of another project to fork a service from. This has effect only when a new service is being created.
        :param 'OpenSearchOpensearchUserConfigPublicAccessArgs' public_access: Allow access to selected service ports from the public Internet
        :param str recovery_basebackup_name: Name of the basebackup to restore in forked service
        :param str service_to_fork_from: Name of another service to fork from. This has effect only when a new service is being created.
        :param str static_ips: Static IP addresses
        """
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if disable_replication_factor_adjustment is not None:
            pulumi.set(__self__, "disable_replication_factor_adjustment", disable_replication_factor_adjustment)
        if index_patterns is not None:
            pulumi.set(__self__, "index_patterns", index_patterns)
        if index_template is not None:
            pulumi.set(__self__, "index_template", index_template)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if keep_index_refresh_interval is not None:
            pulumi.set(__self__, "keep_index_refresh_interval", keep_index_refresh_interval)
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if opensearch is not None:
            pulumi.set(__self__, "opensearch", opensearch)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if opensearch_version is not None:
            pulumi.set(__self__, "opensearch_version", opensearch_version)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_basebackup_name is not None:
            pulumi.set(__self__, "recovery_basebackup_name", recovery_basebackup_name)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        """
        Custom domain
        """
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="disableReplicationFactorAdjustment")
    def disable_replication_factor_adjustment(self) -> Optional[str]:
        """
        Disable replication factor adjustment
        """
        return pulumi.get(self, "disable_replication_factor_adjustment")

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[Sequence['outputs.OpenSearchOpensearchUserConfigIndexPattern']]:
        """
        Index patterns
        """
        return pulumi.get(self, "index_patterns")

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional['outputs.OpenSearchOpensearchUserConfigIndexTemplate']:
        """
        Template settings for all new indexes
        """
        return pulumi.get(self, "index_template")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[str]:
        """
        Don't reset index.refresh_interval to the default value
        """
        return pulumi.get(self, "keep_index_refresh_interval")

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[str]:
        """
        Maximum index count
        """
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter
    def opensearch(self) -> Optional['outputs.OpenSearchOpensearchUserConfigOpensearch']:
        """
        OpenSearch settings
        """
        return pulumi.get(self, "opensearch")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional['outputs.OpenSearchOpensearchUserConfigOpensearchDashboards']:
        """
        OpenSearch Dashboards settings
        """
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter(name="opensearchVersion")
    def opensearch_version(self) -> Optional[str]:
        """
        OpenSearch major version
        """
        return pulumi.get(self, "opensearch_version")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.OpenSearchOpensearchUserConfigPrivateAccess']:
        """
        Allow access to selected service ports from private networks
        """
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.OpenSearchOpensearchUserConfigPrivatelinkAccess']:
        """
        Allow access to selected service components through Privatelink
        """
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        """
        Name of another project to fork a service from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.OpenSearchOpensearchUserConfigPublicAccess']:
        """
        Allow access to selected service ports from the public Internet
        """
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryBasebackupName")
    def recovery_basebackup_name(self) -> Optional[str]:
        """
        Name of the basebackup to restore in forked service
        """
        return pulumi.get(self, "recovery_basebackup_name")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        """
        Name of another service to fork from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IP addresses
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class OpenSearchOpensearchUserConfigIndexPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxIndexCount":
            suggest = "max_index_count"
        elif key == "sortingAlgorithm":
            suggest = "sorting_algorithm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearchUserConfigIndexPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearchUserConfigIndexPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearchUserConfigIndexPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_index_count: Optional[str] = None,
                 pattern: Optional[str] = None,
                 sorting_algorithm: Optional[str] = None):
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if sorting_algorithm is not None:
            pulumi.set(__self__, "sorting_algorithm", sorting_algorithm)

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[str]:
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="sortingAlgorithm")
    def sorting_algorithm(self) -> Optional[str]:
        return pulumi.get(self, "sorting_algorithm")


@pulumi.output_type
class OpenSearchOpensearchUserConfigIndexTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mappingNestedObjectsLimit":
            suggest = "mapping_nested_objects_limit"
        elif key == "numberOfReplicas":
            suggest = "number_of_replicas"
        elif key == "numberOfShards":
            suggest = "number_of_shards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearchUserConfigIndexTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearchUserConfigIndexTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearchUserConfigIndexTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[str] = None,
                 number_of_replicas: Optional[str] = None,
                 number_of_shards: Optional[str] = None):
        if mapping_nested_objects_limit is not None:
            pulumi.set(__self__, "mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[str]:
        return pulumi.get(self, "mapping_nested_objects_limit")

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[str]:
        return pulumi.get(self, "number_of_replicas")

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[str]:
        return pulumi.get(self, "number_of_shards")


@pulumi.output_type
class OpenSearchOpensearchUserConfigOpensearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionAutoCreateIndexEnabled":
            suggest = "action_auto_create_index_enabled"
        elif key == "actionDestructiveRequiresName":
            suggest = "action_destructive_requires_name"
        elif key == "clusterMaxShardsPerNode":
            suggest = "cluster_max_shards_per_node"
        elif key == "clusterRoutingAllocationNodeConcurrentRecoveries":
            suggest = "cluster_routing_allocation_node_concurrent_recoveries"
        elif key == "emailSenderName":
            suggest = "email_sender_name"
        elif key == "emailSenderPassword":
            suggest = "email_sender_password"
        elif key == "emailSenderUsername":
            suggest = "email_sender_username"
        elif key == "httpMaxContentLength":
            suggest = "http_max_content_length"
        elif key == "httpMaxHeaderSize":
            suggest = "http_max_header_size"
        elif key == "httpMaxInitialLineLength":
            suggest = "http_max_initial_line_length"
        elif key == "indicesFielddataCacheSize":
            suggest = "indices_fielddata_cache_size"
        elif key == "indicesMemoryIndexBufferSize":
            suggest = "indices_memory_index_buffer_size"
        elif key == "indicesQueriesCacheSize":
            suggest = "indices_queries_cache_size"
        elif key == "indicesQueryBoolMaxClauseCount":
            suggest = "indices_query_bool_max_clause_count"
        elif key == "indicesRecoveryMaxBytesPerSec":
            suggest = "indices_recovery_max_bytes_per_sec"
        elif key == "indicesRecoveryMaxConcurrentFileChunks":
            suggest = "indices_recovery_max_concurrent_file_chunks"
        elif key == "overrideMainResponseVersion":
            suggest = "override_main_response_version"
        elif key == "reindexRemoteWhitelists":
            suggest = "reindex_remote_whitelists"
        elif key == "scriptMaxCompilationsRate":
            suggest = "script_max_compilations_rate"
        elif key == "searchMaxBuckets":
            suggest = "search_max_buckets"
        elif key == "threadPoolAnalyzeQueueSize":
            suggest = "thread_pool_analyze_queue_size"
        elif key == "threadPoolAnalyzeSize":
            suggest = "thread_pool_analyze_size"
        elif key == "threadPoolForceMergeSize":
            suggest = "thread_pool_force_merge_size"
        elif key == "threadPoolGetQueueSize":
            suggest = "thread_pool_get_queue_size"
        elif key == "threadPoolGetSize":
            suggest = "thread_pool_get_size"
        elif key == "threadPoolSearchQueueSize":
            suggest = "thread_pool_search_queue_size"
        elif key == "threadPoolSearchSize":
            suggest = "thread_pool_search_size"
        elif key == "threadPoolSearchThrottledQueueSize":
            suggest = "thread_pool_search_throttled_queue_size"
        elif key == "threadPoolSearchThrottledSize":
            suggest = "thread_pool_search_throttled_size"
        elif key == "threadPoolWriteQueueSize":
            suggest = "thread_pool_write_queue_size"
        elif key == "threadPoolWriteSize":
            suggest = "thread_pool_write_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearchUserConfigOpensearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearchUserConfigOpensearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearchUserConfigOpensearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_auto_create_index_enabled: Optional[str] = None,
                 action_destructive_requires_name: Optional[str] = None,
                 cluster_max_shards_per_node: Optional[str] = None,
                 cluster_routing_allocation_node_concurrent_recoveries: Optional[str] = None,
                 email_sender_name: Optional[str] = None,
                 email_sender_password: Optional[str] = None,
                 email_sender_username: Optional[str] = None,
                 http_max_content_length: Optional[str] = None,
                 http_max_header_size: Optional[str] = None,
                 http_max_initial_line_length: Optional[str] = None,
                 indices_fielddata_cache_size: Optional[str] = None,
                 indices_memory_index_buffer_size: Optional[str] = None,
                 indices_queries_cache_size: Optional[str] = None,
                 indices_query_bool_max_clause_count: Optional[str] = None,
                 indices_recovery_max_bytes_per_sec: Optional[str] = None,
                 indices_recovery_max_concurrent_file_chunks: Optional[str] = None,
                 override_main_response_version: Optional[str] = None,
                 reindex_remote_whitelists: Optional[Sequence[str]] = None,
                 script_max_compilations_rate: Optional[str] = None,
                 search_max_buckets: Optional[str] = None,
                 thread_pool_analyze_queue_size: Optional[str] = None,
                 thread_pool_analyze_size: Optional[str] = None,
                 thread_pool_force_merge_size: Optional[str] = None,
                 thread_pool_get_queue_size: Optional[str] = None,
                 thread_pool_get_size: Optional[str] = None,
                 thread_pool_search_queue_size: Optional[str] = None,
                 thread_pool_search_size: Optional[str] = None,
                 thread_pool_search_throttled_queue_size: Optional[str] = None,
                 thread_pool_search_throttled_size: Optional[str] = None,
                 thread_pool_write_queue_size: Optional[str] = None,
                 thread_pool_write_size: Optional[str] = None):
        if action_auto_create_index_enabled is not None:
            pulumi.set(__self__, "action_auto_create_index_enabled", action_auto_create_index_enabled)
        if action_destructive_requires_name is not None:
            pulumi.set(__self__, "action_destructive_requires_name", action_destructive_requires_name)
        if cluster_max_shards_per_node is not None:
            pulumi.set(__self__, "cluster_max_shards_per_node", cluster_max_shards_per_node)
        if cluster_routing_allocation_node_concurrent_recoveries is not None:
            pulumi.set(__self__, "cluster_routing_allocation_node_concurrent_recoveries", cluster_routing_allocation_node_concurrent_recoveries)
        if email_sender_name is not None:
            pulumi.set(__self__, "email_sender_name", email_sender_name)
        if email_sender_password is not None:
            pulumi.set(__self__, "email_sender_password", email_sender_password)
        if email_sender_username is not None:
            pulumi.set(__self__, "email_sender_username", email_sender_username)
        if http_max_content_length is not None:
            pulumi.set(__self__, "http_max_content_length", http_max_content_length)
        if http_max_header_size is not None:
            pulumi.set(__self__, "http_max_header_size", http_max_header_size)
        if http_max_initial_line_length is not None:
            pulumi.set(__self__, "http_max_initial_line_length", http_max_initial_line_length)
        if indices_fielddata_cache_size is not None:
            pulumi.set(__self__, "indices_fielddata_cache_size", indices_fielddata_cache_size)
        if indices_memory_index_buffer_size is not None:
            pulumi.set(__self__, "indices_memory_index_buffer_size", indices_memory_index_buffer_size)
        if indices_queries_cache_size is not None:
            pulumi.set(__self__, "indices_queries_cache_size", indices_queries_cache_size)
        if indices_query_bool_max_clause_count is not None:
            pulumi.set(__self__, "indices_query_bool_max_clause_count", indices_query_bool_max_clause_count)
        if indices_recovery_max_bytes_per_sec is not None:
            pulumi.set(__self__, "indices_recovery_max_bytes_per_sec", indices_recovery_max_bytes_per_sec)
        if indices_recovery_max_concurrent_file_chunks is not None:
            pulumi.set(__self__, "indices_recovery_max_concurrent_file_chunks", indices_recovery_max_concurrent_file_chunks)
        if override_main_response_version is not None:
            pulumi.set(__self__, "override_main_response_version", override_main_response_version)
        if reindex_remote_whitelists is not None:
            pulumi.set(__self__, "reindex_remote_whitelists", reindex_remote_whitelists)
        if script_max_compilations_rate is not None:
            pulumi.set(__self__, "script_max_compilations_rate", script_max_compilations_rate)
        if search_max_buckets is not None:
            pulumi.set(__self__, "search_max_buckets", search_max_buckets)
        if thread_pool_analyze_queue_size is not None:
            pulumi.set(__self__, "thread_pool_analyze_queue_size", thread_pool_analyze_queue_size)
        if thread_pool_analyze_size is not None:
            pulumi.set(__self__, "thread_pool_analyze_size", thread_pool_analyze_size)
        if thread_pool_force_merge_size is not None:
            pulumi.set(__self__, "thread_pool_force_merge_size", thread_pool_force_merge_size)
        if thread_pool_get_queue_size is not None:
            pulumi.set(__self__, "thread_pool_get_queue_size", thread_pool_get_queue_size)
        if thread_pool_get_size is not None:
            pulumi.set(__self__, "thread_pool_get_size", thread_pool_get_size)
        if thread_pool_search_queue_size is not None:
            pulumi.set(__self__, "thread_pool_search_queue_size", thread_pool_search_queue_size)
        if thread_pool_search_size is not None:
            pulumi.set(__self__, "thread_pool_search_size", thread_pool_search_size)
        if thread_pool_search_throttled_queue_size is not None:
            pulumi.set(__self__, "thread_pool_search_throttled_queue_size", thread_pool_search_throttled_queue_size)
        if thread_pool_search_throttled_size is not None:
            pulumi.set(__self__, "thread_pool_search_throttled_size", thread_pool_search_throttled_size)
        if thread_pool_write_queue_size is not None:
            pulumi.set(__self__, "thread_pool_write_queue_size", thread_pool_write_queue_size)
        if thread_pool_write_size is not None:
            pulumi.set(__self__, "thread_pool_write_size", thread_pool_write_size)

    @property
    @pulumi.getter(name="actionAutoCreateIndexEnabled")
    def action_auto_create_index_enabled(self) -> Optional[str]:
        return pulumi.get(self, "action_auto_create_index_enabled")

    @property
    @pulumi.getter(name="actionDestructiveRequiresName")
    def action_destructive_requires_name(self) -> Optional[str]:
        return pulumi.get(self, "action_destructive_requires_name")

    @property
    @pulumi.getter(name="clusterMaxShardsPerNode")
    def cluster_max_shards_per_node(self) -> Optional[str]:
        return pulumi.get(self, "cluster_max_shards_per_node")

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeConcurrentRecoveries")
    def cluster_routing_allocation_node_concurrent_recoveries(self) -> Optional[str]:
        return pulumi.get(self, "cluster_routing_allocation_node_concurrent_recoveries")

    @property
    @pulumi.getter(name="emailSenderName")
    def email_sender_name(self) -> Optional[str]:
        return pulumi.get(self, "email_sender_name")

    @property
    @pulumi.getter(name="emailSenderPassword")
    def email_sender_password(self) -> Optional[str]:
        return pulumi.get(self, "email_sender_password")

    @property
    @pulumi.getter(name="emailSenderUsername")
    def email_sender_username(self) -> Optional[str]:
        return pulumi.get(self, "email_sender_username")

    @property
    @pulumi.getter(name="httpMaxContentLength")
    def http_max_content_length(self) -> Optional[str]:
        return pulumi.get(self, "http_max_content_length")

    @property
    @pulumi.getter(name="httpMaxHeaderSize")
    def http_max_header_size(self) -> Optional[str]:
        return pulumi.get(self, "http_max_header_size")

    @property
    @pulumi.getter(name="httpMaxInitialLineLength")
    def http_max_initial_line_length(self) -> Optional[str]:
        return pulumi.get(self, "http_max_initial_line_length")

    @property
    @pulumi.getter(name="indicesFielddataCacheSize")
    def indices_fielddata_cache_size(self) -> Optional[str]:
        return pulumi.get(self, "indices_fielddata_cache_size")

    @property
    @pulumi.getter(name="indicesMemoryIndexBufferSize")
    def indices_memory_index_buffer_size(self) -> Optional[str]:
        return pulumi.get(self, "indices_memory_index_buffer_size")

    @property
    @pulumi.getter(name="indicesQueriesCacheSize")
    def indices_queries_cache_size(self) -> Optional[str]:
        return pulumi.get(self, "indices_queries_cache_size")

    @property
    @pulumi.getter(name="indicesQueryBoolMaxClauseCount")
    def indices_query_bool_max_clause_count(self) -> Optional[str]:
        return pulumi.get(self, "indices_query_bool_max_clause_count")

    @property
    @pulumi.getter(name="indicesRecoveryMaxBytesPerSec")
    def indices_recovery_max_bytes_per_sec(self) -> Optional[str]:
        return pulumi.get(self, "indices_recovery_max_bytes_per_sec")

    @property
    @pulumi.getter(name="indicesRecoveryMaxConcurrentFileChunks")
    def indices_recovery_max_concurrent_file_chunks(self) -> Optional[str]:
        return pulumi.get(self, "indices_recovery_max_concurrent_file_chunks")

    @property
    @pulumi.getter(name="overrideMainResponseVersion")
    def override_main_response_version(self) -> Optional[str]:
        return pulumi.get(self, "override_main_response_version")

    @property
    @pulumi.getter(name="reindexRemoteWhitelists")
    def reindex_remote_whitelists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "reindex_remote_whitelists")

    @property
    @pulumi.getter(name="scriptMaxCompilationsRate")
    def script_max_compilations_rate(self) -> Optional[str]:
        return pulumi.get(self, "script_max_compilations_rate")

    @property
    @pulumi.getter(name="searchMaxBuckets")
    def search_max_buckets(self) -> Optional[str]:
        return pulumi.get(self, "search_max_buckets")

    @property
    @pulumi.getter(name="threadPoolAnalyzeQueueSize")
    def thread_pool_analyze_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_analyze_queue_size")

    @property
    @pulumi.getter(name="threadPoolAnalyzeSize")
    def thread_pool_analyze_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_analyze_size")

    @property
    @pulumi.getter(name="threadPoolForceMergeSize")
    def thread_pool_force_merge_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_force_merge_size")

    @property
    @pulumi.getter(name="threadPoolGetQueueSize")
    def thread_pool_get_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_get_queue_size")

    @property
    @pulumi.getter(name="threadPoolGetSize")
    def thread_pool_get_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_get_size")

    @property
    @pulumi.getter(name="threadPoolSearchQueueSize")
    def thread_pool_search_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_search_queue_size")

    @property
    @pulumi.getter(name="threadPoolSearchSize")
    def thread_pool_search_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_search_size")

    @property
    @pulumi.getter(name="threadPoolSearchThrottledQueueSize")
    def thread_pool_search_throttled_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_search_throttled_queue_size")

    @property
    @pulumi.getter(name="threadPoolSearchThrottledSize")
    def thread_pool_search_throttled_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_search_throttled_size")

    @property
    @pulumi.getter(name="threadPoolWriteQueueSize")
    def thread_pool_write_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_write_queue_size")

    @property
    @pulumi.getter(name="threadPoolWriteSize")
    def thread_pool_write_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_write_size")


@pulumi.output_type
class OpenSearchOpensearchUserConfigOpensearchDashboards(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxOldSpaceSize":
            suggest = "max_old_space_size"
        elif key == "opensearchRequestTimeout":
            suggest = "opensearch_request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearchUserConfigOpensearchDashboards. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearchUserConfigOpensearchDashboards.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearchUserConfigOpensearchDashboards.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[str] = None,
                 max_old_space_size: Optional[str] = None,
                 opensearch_request_timeout: Optional[str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_old_space_size is not None:
            pulumi.set(__self__, "max_old_space_size", max_old_space_size)
        if opensearch_request_timeout is not None:
            pulumi.set(__self__, "opensearch_request_timeout", opensearch_request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[str]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[str]:
        return pulumi.get(self, "max_old_space_size")

    @property
    @pulumi.getter(name="opensearchRequestTimeout")
    def opensearch_request_timeout(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_request_timeout")


@pulumi.output_type
class OpenSearchOpensearchUserConfigPrivateAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "opensearchDashboards":
            suggest = "opensearch_dashboards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearchUserConfigPrivateAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearchUserConfigPrivateAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearchUserConfigPrivateAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 opensearch: Optional[str] = None,
                 opensearch_dashboards: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str opensearch: Opensearch server provided values
        """
        if opensearch is not None:
            pulumi.set(__self__, "opensearch", opensearch)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def opensearch(self) -> Optional[str]:
        """
        Opensearch server provided values
        """
        return pulumi.get(self, "opensearch")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class OpenSearchOpensearchUserConfigPrivatelinkAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "opensearchDashboards":
            suggest = "opensearch_dashboards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearchUserConfigPrivatelinkAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearchUserConfigPrivatelinkAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearchUserConfigPrivatelinkAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 opensearch: Optional[str] = None,
                 opensearch_dashboards: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str opensearch: Opensearch server provided values
        """
        if opensearch is not None:
            pulumi.set(__self__, "opensearch", opensearch)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def opensearch(self) -> Optional[str]:
        """
        Opensearch server provided values
        """
        return pulumi.get(self, "opensearch")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class OpenSearchOpensearchUserConfigPublicAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "opensearchDashboards":
            suggest = "opensearch_dashboards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearchUserConfigPublicAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearchUserConfigPublicAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearchUserConfigPublicAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 opensearch: Optional[str] = None,
                 opensearch_dashboards: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str opensearch: Opensearch server provided values
        """
        if opensearch is not None:
            pulumi.set(__self__, "opensearch", opensearch)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def opensearch(self) -> Optional[str]:
        """
        Opensearch server provided values
        """
        return pulumi.get(self, "opensearch")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class OpenSearchServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        """
        :param str integration_type: Type of the service integration. The only supported value at the moment is `read_replica`
        :param str source_service_name: Name of the source service
        """
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Type of the service integration. The only supported value at the moment is `read_replica`
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        """
        Name of the source service
        """
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class OpenSearchTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Service tag key
        :param str value: Service tag value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Service tag key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Service tag value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PgComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class PgPg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConnections":
            suggest = "max_connections"
        elif key == "replicaUri":
            suggest = "replica_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgPg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgPg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgPg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 max_connections: Optional[int] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 replica_uri: Optional[str] = None,
                 sslmode: Optional[str] = None,
                 uri: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str dbname: Primary PostgreSQL database name
        :param str host: PostgreSQL master node host IP or name
        :param int max_connections: Connection limit
        :param str password: PostgreSQL admin user password
        :param int port: PostgreSQL port
        :param str replica_uri: PostgreSQL replica URI for services with a replica
        :param str sslmode: PostgreSQL sslmode setting (currently always "require")
        :param str uri: PostgreSQL master connection URI
        :param str user: PostgreSQL admin user name
        """
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if replica_uri is not None:
            pulumi.set(__self__, "replica_uri", replica_uri)
        if sslmode is not None:
            pulumi.set(__self__, "sslmode", sslmode)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        """
        Primary PostgreSQL database name
        """
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        PostgreSQL master node host IP or name
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[int]:
        """
        Connection limit
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        PostgreSQL admin user password
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        PostgreSQL port
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="replicaUri")
    def replica_uri(self) -> Optional[str]:
        """
        PostgreSQL replica URI for services with a replica
        """
        return pulumi.get(self, "replica_uri")

    @property
    @pulumi.getter
    def sslmode(self) -> Optional[str]:
        """
        PostgreSQL sslmode setting (currently always "require")
        """
        return pulumi.get(self, "sslmode")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        PostgreSQL master connection URI
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        PostgreSQL admin user name
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class PgPgUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupHour":
            suggest = "backup_hour"
        elif key == "backupMinute":
            suggest = "backup_minute"
        elif key == "enableIpv6":
            suggest = "enable_ipv6"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "pgReadReplica":
            suggest = "pg_read_replica"
        elif key == "pgServiceToForkFrom":
            suggest = "pg_service_to_fork_from"
        elif key == "pgStatMonitorEnable":
            suggest = "pg_stat_monitor_enable"
        elif key == "pgVersion":
            suggest = "pg_version"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "recoveryTargetTime":
            suggest = "recovery_target_time"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"
        elif key == "sharedBuffersPercentage":
            suggest = "shared_buffers_percentage"
        elif key == "staticIps":
            suggest = "static_ips"
        elif key == "synchronousReplication":
            suggest = "synchronous_replication"
        elif key == "workMem":
            suggest = "work_mem"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgPgUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgPgUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgPgUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_hour: Optional[str] = None,
                 backup_minute: Optional[str] = None,
                 enable_ipv6: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 migration: Optional['outputs.PgPgUserConfigMigration'] = None,
                 pg: Optional['outputs.PgPgUserConfigPg'] = None,
                 pg_read_replica: Optional[str] = None,
                 pg_service_to_fork_from: Optional[str] = None,
                 pg_stat_monitor_enable: Optional[str] = None,
                 pg_version: Optional[str] = None,
                 pgbouncer: Optional['outputs.PgPgUserConfigPgbouncer'] = None,
                 pglookout: Optional['outputs.PgPgUserConfigPglookout'] = None,
                 private_access: Optional['outputs.PgPgUserConfigPrivateAccess'] = None,
                 privatelink_access: Optional['outputs.PgPgUserConfigPrivatelinkAccess'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.PgPgUserConfigPublicAccess'] = None,
                 recovery_target_time: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 shared_buffers_percentage: Optional[str] = None,
                 static_ips: Optional[str] = None,
                 synchronous_replication: Optional[str] = None,
                 timescaledb: Optional['outputs.PgPgUserConfigTimescaledb'] = None,
                 variant: Optional[str] = None,
                 work_mem: Optional[str] = None):
        """
        :param str admin_password: Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        :param str admin_username: Custom username for admin user. This must be set only when a new service is being created.
        :param str backup_hour: The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        :param str backup_minute: The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        :param str enable_ipv6: Enable IPv6
        :param Sequence[str] ip_filters: IP filter
        :param 'PgPgUserConfigMigrationArgs' migration: Migrate data from existing server
        :param 'PgPgUserConfigPgArgs' pg: postgresql.conf configuration values
        :param str pg_read_replica: Should the service which is being forked be a read replica (deprecated, use read_replica service integration instead).
        :param str pg_service_to_fork_from: Name of the PG Service from which to fork (deprecated, use service*to*fork_from). This has effect only when a new service is being created.
        :param str pg_stat_monitor_enable: Enable pg*stat*monitor extension if available for the current cluster
        :param str pg_version: PostgreSQL major version
        :param 'PgPgUserConfigPgbouncerArgs' pgbouncer: PGBouncer connection pooling settings
        :param 'PgPgUserConfigPglookoutArgs' pglookout: PGLookout settings
        :param 'PgPgUserConfigPrivateAccessArgs' private_access: Allow access to selected service ports from private networks
        :param 'PgPgUserConfigPrivatelinkAccessArgs' privatelink_access: Allow access to selected service components through Privatelink
        :param str project_to_fork_from: Name of another project to fork a service from. This has effect only when a new service is being created.
        :param 'PgPgUserConfigPublicAccessArgs' public_access: Allow access to selected service ports from the public Internet
        :param str recovery_target_time: Recovery target time when forking a service. This has effect only when a new service is being created.
        :param str service_to_fork_from: Name of another service to fork from. This has effect only when a new service is being created.
        :param str shared_buffers_percentage: shared*buffers*percentage
        :param str static_ips: Static IP addresses
        :param str synchronous_replication: Synchronous replication type. Note that the service plan also needs to support synchronous replication.
        :param 'PgPgUserConfigTimescaledbArgs' timescaledb: TimescaleDB extension configuration values
        :param str variant: Variant of the PostgreSQL service, may affect the features that are exposed by default
        :param str work_mem: work_mem
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if enable_ipv6 is not None:
            pulumi.set(__self__, "enable_ipv6", enable_ipv6)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if pg_read_replica is not None:
            pulumi.set(__self__, "pg_read_replica", pg_read_replica)
        if pg_service_to_fork_from is not None:
            pulumi.set(__self__, "pg_service_to_fork_from", pg_service_to_fork_from)
        if pg_stat_monitor_enable is not None:
            pulumi.set(__self__, "pg_stat_monitor_enable", pg_stat_monitor_enable)
        if pg_version is not None:
            pulumi.set(__self__, "pg_version", pg_version)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if pglookout is not None:
            pulumi.set(__self__, "pglookout", pglookout)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_target_time is not None:
            pulumi.set(__self__, "recovery_target_time", recovery_target_time)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if shared_buffers_percentage is not None:
            pulumi.set(__self__, "shared_buffers_percentage", shared_buffers_percentage)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)
        if synchronous_replication is not None:
            pulumi.set(__self__, "synchronous_replication", synchronous_replication)
        if timescaledb is not None:
            pulumi.set(__self__, "timescaledb", timescaledb)
        if variant is not None:
            pulumi.set(__self__, "variant", variant)
        if work_mem is not None:
            pulumi.set(__self__, "work_mem", work_mem)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        """
        Custom username for admin user. This must be set only when a new service is being created.
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[str]:
        """
        The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_hour")

    @property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[str]:
        """
        The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_minute")

    @property
    @pulumi.getter(name="enableIpv6")
    def enable_ipv6(self) -> Optional[str]:
        """
        Enable IPv6
        """
        return pulumi.get(self, "enable_ipv6")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def migration(self) -> Optional['outputs.PgPgUserConfigMigration']:
        """
        Migrate data from existing server
        """
        return pulumi.get(self, "migration")

    @property
    @pulumi.getter
    def pg(self) -> Optional['outputs.PgPgUserConfigPg']:
        """
        postgresql.conf configuration values
        """
        return pulumi.get(self, "pg")

    @property
    @pulumi.getter(name="pgReadReplica")
    def pg_read_replica(self) -> Optional[str]:
        """
        Should the service which is being forked be a read replica (deprecated, use read_replica service integration instead).
        """
        return pulumi.get(self, "pg_read_replica")

    @property
    @pulumi.getter(name="pgServiceToForkFrom")
    def pg_service_to_fork_from(self) -> Optional[str]:
        """
        Name of the PG Service from which to fork (deprecated, use service*to*fork_from). This has effect only when a new service is being created.
        """
        return pulumi.get(self, "pg_service_to_fork_from")

    @property
    @pulumi.getter(name="pgStatMonitorEnable")
    def pg_stat_monitor_enable(self) -> Optional[str]:
        """
        Enable pg*stat*monitor extension if available for the current cluster
        """
        return pulumi.get(self, "pg_stat_monitor_enable")

    @property
    @pulumi.getter(name="pgVersion")
    def pg_version(self) -> Optional[str]:
        """
        PostgreSQL major version
        """
        return pulumi.get(self, "pg_version")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional['outputs.PgPgUserConfigPgbouncer']:
        """
        PGBouncer connection pooling settings
        """
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def pglookout(self) -> Optional['outputs.PgPgUserConfigPglookout']:
        """
        PGLookout settings
        """
        return pulumi.get(self, "pglookout")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.PgPgUserConfigPrivateAccess']:
        """
        Allow access to selected service ports from private networks
        """
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.PgPgUserConfigPrivatelinkAccess']:
        """
        Allow access to selected service components through Privatelink
        """
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        """
        Name of another project to fork a service from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.PgPgUserConfigPublicAccess']:
        """
        Allow access to selected service ports from the public Internet
        """
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryTargetTime")
    def recovery_target_time(self) -> Optional[str]:
        """
        Recovery target time when forking a service. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "recovery_target_time")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        """
        Name of another service to fork from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="sharedBuffersPercentage")
    def shared_buffers_percentage(self) -> Optional[str]:
        """
        shared*buffers*percentage
        """
        return pulumi.get(self, "shared_buffers_percentage")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IP addresses
        """
        return pulumi.get(self, "static_ips")

    @property
    @pulumi.getter(name="synchronousReplication")
    def synchronous_replication(self) -> Optional[str]:
        """
        Synchronous replication type. Note that the service plan also needs to support synchronous replication.
        """
        return pulumi.get(self, "synchronous_replication")

    @property
    @pulumi.getter
    def timescaledb(self) -> Optional['outputs.PgPgUserConfigTimescaledb']:
        """
        TimescaleDB extension configuration values
        """
        return pulumi.get(self, "timescaledb")

    @property
    @pulumi.getter
    def variant(self) -> Optional[str]:
        """
        Variant of the PostgreSQL service, may affect the features that are exposed by default
        """
        return pulumi.get(self, "variant")

    @property
    @pulumi.getter(name="workMem")
    def work_mem(self) -> Optional[str]:
        """
        work_mem
        """
        return pulumi.get(self, "work_mem")


@pulumi.output_type
class PgPgUserConfigMigration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreDbs":
            suggest = "ignore_dbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgPgUserConfigMigration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgPgUserConfigMigration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgPgUserConfigMigration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 ignore_dbs: Optional[str] = None,
                 method: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 ssl: Optional[str] = None,
                 username: Optional[str] = None):
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[str]:
        return pulumi.get(self, "ignore_dbs")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class PgPgUserConfigPg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autovacuumAnalyzeScaleFactor":
            suggest = "autovacuum_analyze_scale_factor"
        elif key == "autovacuumAnalyzeThreshold":
            suggest = "autovacuum_analyze_threshold"
        elif key == "autovacuumFreezeMaxAge":
            suggest = "autovacuum_freeze_max_age"
        elif key == "autovacuumMaxWorkers":
            suggest = "autovacuum_max_workers"
        elif key == "autovacuumNaptime":
            suggest = "autovacuum_naptime"
        elif key == "autovacuumVacuumCostDelay":
            suggest = "autovacuum_vacuum_cost_delay"
        elif key == "autovacuumVacuumCostLimit":
            suggest = "autovacuum_vacuum_cost_limit"
        elif key == "autovacuumVacuumScaleFactor":
            suggest = "autovacuum_vacuum_scale_factor"
        elif key == "autovacuumVacuumThreshold":
            suggest = "autovacuum_vacuum_threshold"
        elif key == "bgwriterDelay":
            suggest = "bgwriter_delay"
        elif key == "bgwriterFlushAfter":
            suggest = "bgwriter_flush_after"
        elif key == "bgwriterLruMaxpages":
            suggest = "bgwriter_lru_maxpages"
        elif key == "bgwriterLruMultiplier":
            suggest = "bgwriter_lru_multiplier"
        elif key == "deadlockTimeout":
            suggest = "deadlock_timeout"
        elif key == "defaultToastCompression":
            suggest = "default_toast_compression"
        elif key == "idleInTransactionSessionTimeout":
            suggest = "idle_in_transaction_session_timeout"
        elif key == "logAutovacuumMinDuration":
            suggest = "log_autovacuum_min_duration"
        elif key == "logErrorVerbosity":
            suggest = "log_error_verbosity"
        elif key == "logLinePrefix":
            suggest = "log_line_prefix"
        elif key == "logMinDurationStatement":
            suggest = "log_min_duration_statement"
        elif key == "logTempFiles":
            suggest = "log_temp_files"
        elif key == "maxFilesPerProcess":
            suggest = "max_files_per_process"
        elif key == "maxLocksPerTransaction":
            suggest = "max_locks_per_transaction"
        elif key == "maxLogicalReplicationWorkers":
            suggest = "max_logical_replication_workers"
        elif key == "maxParallelWorkers":
            suggest = "max_parallel_workers"
        elif key == "maxParallelWorkersPerGather":
            suggest = "max_parallel_workers_per_gather"
        elif key == "maxPredLocksPerTransaction":
            suggest = "max_pred_locks_per_transaction"
        elif key == "maxPreparedTransactions":
            suggest = "max_prepared_transactions"
        elif key == "maxReplicationSlots":
            suggest = "max_replication_slots"
        elif key == "maxSlotWalKeepSize":
            suggest = "max_slot_wal_keep_size"
        elif key == "maxStackDepth":
            suggest = "max_stack_depth"
        elif key == "maxStandbyArchiveDelay":
            suggest = "max_standby_archive_delay"
        elif key == "maxStandbyStreamingDelay":
            suggest = "max_standby_streaming_delay"
        elif key == "maxWalSenders":
            suggest = "max_wal_senders"
        elif key == "maxWorkerProcesses":
            suggest = "max_worker_processes"
        elif key == "pgPartmanBgwDotInterval":
            suggest = "pg_partman_bgw_dot_interval"
        elif key == "pgPartmanBgwDotRole":
            suggest = "pg_partman_bgw_dot_role"
        elif key == "pgStatStatementsDotTrack":
            suggest = "pg_stat_statements_dot_track"
        elif key == "tempFileLimit":
            suggest = "temp_file_limit"
        elif key == "trackActivityQuerySize":
            suggest = "track_activity_query_size"
        elif key == "trackCommitTimestamp":
            suggest = "track_commit_timestamp"
        elif key == "trackFunctions":
            suggest = "track_functions"
        elif key == "trackIoTiming":
            suggest = "track_io_timing"
        elif key == "walSenderTimeout":
            suggest = "wal_sender_timeout"
        elif key == "walWriterDelay":
            suggest = "wal_writer_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgPgUserConfigPg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgPgUserConfigPg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgPgUserConfigPg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autovacuum_analyze_scale_factor: Optional[str] = None,
                 autovacuum_analyze_threshold: Optional[str] = None,
                 autovacuum_freeze_max_age: Optional[str] = None,
                 autovacuum_max_workers: Optional[str] = None,
                 autovacuum_naptime: Optional[str] = None,
                 autovacuum_vacuum_cost_delay: Optional[str] = None,
                 autovacuum_vacuum_cost_limit: Optional[str] = None,
                 autovacuum_vacuum_scale_factor: Optional[str] = None,
                 autovacuum_vacuum_threshold: Optional[str] = None,
                 bgwriter_delay: Optional[str] = None,
                 bgwriter_flush_after: Optional[str] = None,
                 bgwriter_lru_maxpages: Optional[str] = None,
                 bgwriter_lru_multiplier: Optional[str] = None,
                 deadlock_timeout: Optional[str] = None,
                 default_toast_compression: Optional[str] = None,
                 idle_in_transaction_session_timeout: Optional[str] = None,
                 jit: Optional[str] = None,
                 log_autovacuum_min_duration: Optional[str] = None,
                 log_error_verbosity: Optional[str] = None,
                 log_line_prefix: Optional[str] = None,
                 log_min_duration_statement: Optional[str] = None,
                 log_temp_files: Optional[str] = None,
                 max_files_per_process: Optional[str] = None,
                 max_locks_per_transaction: Optional[str] = None,
                 max_logical_replication_workers: Optional[str] = None,
                 max_parallel_workers: Optional[str] = None,
                 max_parallel_workers_per_gather: Optional[str] = None,
                 max_pred_locks_per_transaction: Optional[str] = None,
                 max_prepared_transactions: Optional[str] = None,
                 max_replication_slots: Optional[str] = None,
                 max_slot_wal_keep_size: Optional[str] = None,
                 max_stack_depth: Optional[str] = None,
                 max_standby_archive_delay: Optional[str] = None,
                 max_standby_streaming_delay: Optional[str] = None,
                 max_wal_senders: Optional[str] = None,
                 max_worker_processes: Optional[str] = None,
                 pg_partman_bgw_dot_interval: Optional[str] = None,
                 pg_partman_bgw_dot_role: Optional[str] = None,
                 pg_stat_statements_dot_track: Optional[str] = None,
                 temp_file_limit: Optional[str] = None,
                 timezone: Optional[str] = None,
                 track_activity_query_size: Optional[str] = None,
                 track_commit_timestamp: Optional[str] = None,
                 track_functions: Optional[str] = None,
                 track_io_timing: Optional[str] = None,
                 wal_sender_timeout: Optional[str] = None,
                 wal_writer_delay: Optional[str] = None):
        if autovacuum_analyze_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_analyze_scale_factor", autovacuum_analyze_scale_factor)
        if autovacuum_analyze_threshold is not None:
            pulumi.set(__self__, "autovacuum_analyze_threshold", autovacuum_analyze_threshold)
        if autovacuum_freeze_max_age is not None:
            pulumi.set(__self__, "autovacuum_freeze_max_age", autovacuum_freeze_max_age)
        if autovacuum_max_workers is not None:
            pulumi.set(__self__, "autovacuum_max_workers", autovacuum_max_workers)
        if autovacuum_naptime is not None:
            pulumi.set(__self__, "autovacuum_naptime", autovacuum_naptime)
        if autovacuum_vacuum_cost_delay is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_delay", autovacuum_vacuum_cost_delay)
        if autovacuum_vacuum_cost_limit is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_limit", autovacuum_vacuum_cost_limit)
        if autovacuum_vacuum_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_vacuum_scale_factor", autovacuum_vacuum_scale_factor)
        if autovacuum_vacuum_threshold is not None:
            pulumi.set(__self__, "autovacuum_vacuum_threshold", autovacuum_vacuum_threshold)
        if bgwriter_delay is not None:
            pulumi.set(__self__, "bgwriter_delay", bgwriter_delay)
        if bgwriter_flush_after is not None:
            pulumi.set(__self__, "bgwriter_flush_after", bgwriter_flush_after)
        if bgwriter_lru_maxpages is not None:
            pulumi.set(__self__, "bgwriter_lru_maxpages", bgwriter_lru_maxpages)
        if bgwriter_lru_multiplier is not None:
            pulumi.set(__self__, "bgwriter_lru_multiplier", bgwriter_lru_multiplier)
        if deadlock_timeout is not None:
            pulumi.set(__self__, "deadlock_timeout", deadlock_timeout)
        if default_toast_compression is not None:
            pulumi.set(__self__, "default_toast_compression", default_toast_compression)
        if idle_in_transaction_session_timeout is not None:
            pulumi.set(__self__, "idle_in_transaction_session_timeout", idle_in_transaction_session_timeout)
        if jit is not None:
            pulumi.set(__self__, "jit", jit)
        if log_autovacuum_min_duration is not None:
            pulumi.set(__self__, "log_autovacuum_min_duration", log_autovacuum_min_duration)
        if log_error_verbosity is not None:
            pulumi.set(__self__, "log_error_verbosity", log_error_verbosity)
        if log_line_prefix is not None:
            pulumi.set(__self__, "log_line_prefix", log_line_prefix)
        if log_min_duration_statement is not None:
            pulumi.set(__self__, "log_min_duration_statement", log_min_duration_statement)
        if log_temp_files is not None:
            pulumi.set(__self__, "log_temp_files", log_temp_files)
        if max_files_per_process is not None:
            pulumi.set(__self__, "max_files_per_process", max_files_per_process)
        if max_locks_per_transaction is not None:
            pulumi.set(__self__, "max_locks_per_transaction", max_locks_per_transaction)
        if max_logical_replication_workers is not None:
            pulumi.set(__self__, "max_logical_replication_workers", max_logical_replication_workers)
        if max_parallel_workers is not None:
            pulumi.set(__self__, "max_parallel_workers", max_parallel_workers)
        if max_parallel_workers_per_gather is not None:
            pulumi.set(__self__, "max_parallel_workers_per_gather", max_parallel_workers_per_gather)
        if max_pred_locks_per_transaction is not None:
            pulumi.set(__self__, "max_pred_locks_per_transaction", max_pred_locks_per_transaction)
        if max_prepared_transactions is not None:
            pulumi.set(__self__, "max_prepared_transactions", max_prepared_transactions)
        if max_replication_slots is not None:
            pulumi.set(__self__, "max_replication_slots", max_replication_slots)
        if max_slot_wal_keep_size is not None:
            pulumi.set(__self__, "max_slot_wal_keep_size", max_slot_wal_keep_size)
        if max_stack_depth is not None:
            pulumi.set(__self__, "max_stack_depth", max_stack_depth)
        if max_standby_archive_delay is not None:
            pulumi.set(__self__, "max_standby_archive_delay", max_standby_archive_delay)
        if max_standby_streaming_delay is not None:
            pulumi.set(__self__, "max_standby_streaming_delay", max_standby_streaming_delay)
        if max_wal_senders is not None:
            pulumi.set(__self__, "max_wal_senders", max_wal_senders)
        if max_worker_processes is not None:
            pulumi.set(__self__, "max_worker_processes", max_worker_processes)
        if pg_partman_bgw_dot_interval is not None:
            pulumi.set(__self__, "pg_partman_bgw_dot_interval", pg_partman_bgw_dot_interval)
        if pg_partman_bgw_dot_role is not None:
            pulumi.set(__self__, "pg_partman_bgw_dot_role", pg_partman_bgw_dot_role)
        if pg_stat_statements_dot_track is not None:
            pulumi.set(__self__, "pg_stat_statements_dot_track", pg_stat_statements_dot_track)
        if temp_file_limit is not None:
            pulumi.set(__self__, "temp_file_limit", temp_file_limit)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if track_activity_query_size is not None:
            pulumi.set(__self__, "track_activity_query_size", track_activity_query_size)
        if track_commit_timestamp is not None:
            pulumi.set(__self__, "track_commit_timestamp", track_commit_timestamp)
        if track_functions is not None:
            pulumi.set(__self__, "track_functions", track_functions)
        if track_io_timing is not None:
            pulumi.set(__self__, "track_io_timing", track_io_timing)
        if wal_sender_timeout is not None:
            pulumi.set(__self__, "wal_sender_timeout", wal_sender_timeout)
        if wal_writer_delay is not None:
            pulumi.set(__self__, "wal_writer_delay", wal_writer_delay)

    @property
    @pulumi.getter(name="autovacuumAnalyzeScaleFactor")
    def autovacuum_analyze_scale_factor(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_analyze_scale_factor")

    @property
    @pulumi.getter(name="autovacuumAnalyzeThreshold")
    def autovacuum_analyze_threshold(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_analyze_threshold")

    @property
    @pulumi.getter(name="autovacuumFreezeMaxAge")
    def autovacuum_freeze_max_age(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_freeze_max_age")

    @property
    @pulumi.getter(name="autovacuumMaxWorkers")
    def autovacuum_max_workers(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_max_workers")

    @property
    @pulumi.getter(name="autovacuumNaptime")
    def autovacuum_naptime(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_naptime")

    @property
    @pulumi.getter(name="autovacuumVacuumCostDelay")
    def autovacuum_vacuum_cost_delay(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_vacuum_cost_delay")

    @property
    @pulumi.getter(name="autovacuumVacuumCostLimit")
    def autovacuum_vacuum_cost_limit(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_vacuum_cost_limit")

    @property
    @pulumi.getter(name="autovacuumVacuumScaleFactor")
    def autovacuum_vacuum_scale_factor(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_vacuum_scale_factor")

    @property
    @pulumi.getter(name="autovacuumVacuumThreshold")
    def autovacuum_vacuum_threshold(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_vacuum_threshold")

    @property
    @pulumi.getter(name="bgwriterDelay")
    def bgwriter_delay(self) -> Optional[str]:
        return pulumi.get(self, "bgwriter_delay")

    @property
    @pulumi.getter(name="bgwriterFlushAfter")
    def bgwriter_flush_after(self) -> Optional[str]:
        return pulumi.get(self, "bgwriter_flush_after")

    @property
    @pulumi.getter(name="bgwriterLruMaxpages")
    def bgwriter_lru_maxpages(self) -> Optional[str]:
        return pulumi.get(self, "bgwriter_lru_maxpages")

    @property
    @pulumi.getter(name="bgwriterLruMultiplier")
    def bgwriter_lru_multiplier(self) -> Optional[str]:
        return pulumi.get(self, "bgwriter_lru_multiplier")

    @property
    @pulumi.getter(name="deadlockTimeout")
    def deadlock_timeout(self) -> Optional[str]:
        return pulumi.get(self, "deadlock_timeout")

    @property
    @pulumi.getter(name="defaultToastCompression")
    def default_toast_compression(self) -> Optional[str]:
        return pulumi.get(self, "default_toast_compression")

    @property
    @pulumi.getter(name="idleInTransactionSessionTimeout")
    def idle_in_transaction_session_timeout(self) -> Optional[str]:
        return pulumi.get(self, "idle_in_transaction_session_timeout")

    @property
    @pulumi.getter
    def jit(self) -> Optional[str]:
        return pulumi.get(self, "jit")

    @property
    @pulumi.getter(name="logAutovacuumMinDuration")
    def log_autovacuum_min_duration(self) -> Optional[str]:
        return pulumi.get(self, "log_autovacuum_min_duration")

    @property
    @pulumi.getter(name="logErrorVerbosity")
    def log_error_verbosity(self) -> Optional[str]:
        return pulumi.get(self, "log_error_verbosity")

    @property
    @pulumi.getter(name="logLinePrefix")
    def log_line_prefix(self) -> Optional[str]:
        return pulumi.get(self, "log_line_prefix")

    @property
    @pulumi.getter(name="logMinDurationStatement")
    def log_min_duration_statement(self) -> Optional[str]:
        return pulumi.get(self, "log_min_duration_statement")

    @property
    @pulumi.getter(name="logTempFiles")
    def log_temp_files(self) -> Optional[str]:
        return pulumi.get(self, "log_temp_files")

    @property
    @pulumi.getter(name="maxFilesPerProcess")
    def max_files_per_process(self) -> Optional[str]:
        return pulumi.get(self, "max_files_per_process")

    @property
    @pulumi.getter(name="maxLocksPerTransaction")
    def max_locks_per_transaction(self) -> Optional[str]:
        return pulumi.get(self, "max_locks_per_transaction")

    @property
    @pulumi.getter(name="maxLogicalReplicationWorkers")
    def max_logical_replication_workers(self) -> Optional[str]:
        return pulumi.get(self, "max_logical_replication_workers")

    @property
    @pulumi.getter(name="maxParallelWorkers")
    def max_parallel_workers(self) -> Optional[str]:
        return pulumi.get(self, "max_parallel_workers")

    @property
    @pulumi.getter(name="maxParallelWorkersPerGather")
    def max_parallel_workers_per_gather(self) -> Optional[str]:
        return pulumi.get(self, "max_parallel_workers_per_gather")

    @property
    @pulumi.getter(name="maxPredLocksPerTransaction")
    def max_pred_locks_per_transaction(self) -> Optional[str]:
        return pulumi.get(self, "max_pred_locks_per_transaction")

    @property
    @pulumi.getter(name="maxPreparedTransactions")
    def max_prepared_transactions(self) -> Optional[str]:
        return pulumi.get(self, "max_prepared_transactions")

    @property
    @pulumi.getter(name="maxReplicationSlots")
    def max_replication_slots(self) -> Optional[str]:
        return pulumi.get(self, "max_replication_slots")

    @property
    @pulumi.getter(name="maxSlotWalKeepSize")
    def max_slot_wal_keep_size(self) -> Optional[str]:
        return pulumi.get(self, "max_slot_wal_keep_size")

    @property
    @pulumi.getter(name="maxStackDepth")
    def max_stack_depth(self) -> Optional[str]:
        return pulumi.get(self, "max_stack_depth")

    @property
    @pulumi.getter(name="maxStandbyArchiveDelay")
    def max_standby_archive_delay(self) -> Optional[str]:
        return pulumi.get(self, "max_standby_archive_delay")

    @property
    @pulumi.getter(name="maxStandbyStreamingDelay")
    def max_standby_streaming_delay(self) -> Optional[str]:
        return pulumi.get(self, "max_standby_streaming_delay")

    @property
    @pulumi.getter(name="maxWalSenders")
    def max_wal_senders(self) -> Optional[str]:
        return pulumi.get(self, "max_wal_senders")

    @property
    @pulumi.getter(name="maxWorkerProcesses")
    def max_worker_processes(self) -> Optional[str]:
        return pulumi.get(self, "max_worker_processes")

    @property
    @pulumi.getter(name="pgPartmanBgwDotInterval")
    def pg_partman_bgw_dot_interval(self) -> Optional[str]:
        return pulumi.get(self, "pg_partman_bgw_dot_interval")

    @property
    @pulumi.getter(name="pgPartmanBgwDotRole")
    def pg_partman_bgw_dot_role(self) -> Optional[str]:
        return pulumi.get(self, "pg_partman_bgw_dot_role")

    @property
    @pulumi.getter(name="pgStatStatementsDotTrack")
    def pg_stat_statements_dot_track(self) -> Optional[str]:
        return pulumi.get(self, "pg_stat_statements_dot_track")

    @property
    @pulumi.getter(name="tempFileLimit")
    def temp_file_limit(self) -> Optional[str]:
        return pulumi.get(self, "temp_file_limit")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter(name="trackActivityQuerySize")
    def track_activity_query_size(self) -> Optional[str]:
        return pulumi.get(self, "track_activity_query_size")

    @property
    @pulumi.getter(name="trackCommitTimestamp")
    def track_commit_timestamp(self) -> Optional[str]:
        return pulumi.get(self, "track_commit_timestamp")

    @property
    @pulumi.getter(name="trackFunctions")
    def track_functions(self) -> Optional[str]:
        return pulumi.get(self, "track_functions")

    @property
    @pulumi.getter(name="trackIoTiming")
    def track_io_timing(self) -> Optional[str]:
        return pulumi.get(self, "track_io_timing")

    @property
    @pulumi.getter(name="walSenderTimeout")
    def wal_sender_timeout(self) -> Optional[str]:
        return pulumi.get(self, "wal_sender_timeout")

    @property
    @pulumi.getter(name="walWriterDelay")
    def wal_writer_delay(self) -> Optional[str]:
        return pulumi.get(self, "wal_writer_delay")


@pulumi.output_type
class PgPgUserConfigPgbouncer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autodbIdleTimeout":
            suggest = "autodb_idle_timeout"
        elif key == "autodbMaxDbConnections":
            suggest = "autodb_max_db_connections"
        elif key == "autodbPoolMode":
            suggest = "autodb_pool_mode"
        elif key == "autodbPoolSize":
            suggest = "autodb_pool_size"
        elif key == "ignoreStartupParameters":
            suggest = "ignore_startup_parameters"
        elif key == "minPoolSize":
            suggest = "min_pool_size"
        elif key == "serverIdleTimeout":
            suggest = "server_idle_timeout"
        elif key == "serverLifetime":
            suggest = "server_lifetime"
        elif key == "serverResetQueryAlways":
            suggest = "server_reset_query_always"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgPgUserConfigPgbouncer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgPgUserConfigPgbouncer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgPgUserConfigPgbouncer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autodb_idle_timeout: Optional[str] = None,
                 autodb_max_db_connections: Optional[str] = None,
                 autodb_pool_mode: Optional[str] = None,
                 autodb_pool_size: Optional[str] = None,
                 ignore_startup_parameters: Optional[Sequence[str]] = None,
                 min_pool_size: Optional[str] = None,
                 server_idle_timeout: Optional[str] = None,
                 server_lifetime: Optional[str] = None,
                 server_reset_query_always: Optional[str] = None):
        if autodb_idle_timeout is not None:
            pulumi.set(__self__, "autodb_idle_timeout", autodb_idle_timeout)
        if autodb_max_db_connections is not None:
            pulumi.set(__self__, "autodb_max_db_connections", autodb_max_db_connections)
        if autodb_pool_mode is not None:
            pulumi.set(__self__, "autodb_pool_mode", autodb_pool_mode)
        if autodb_pool_size is not None:
            pulumi.set(__self__, "autodb_pool_size", autodb_pool_size)
        if ignore_startup_parameters is not None:
            pulumi.set(__self__, "ignore_startup_parameters", ignore_startup_parameters)
        if min_pool_size is not None:
            pulumi.set(__self__, "min_pool_size", min_pool_size)
        if server_idle_timeout is not None:
            pulumi.set(__self__, "server_idle_timeout", server_idle_timeout)
        if server_lifetime is not None:
            pulumi.set(__self__, "server_lifetime", server_lifetime)
        if server_reset_query_always is not None:
            pulumi.set(__self__, "server_reset_query_always", server_reset_query_always)

    @property
    @pulumi.getter(name="autodbIdleTimeout")
    def autodb_idle_timeout(self) -> Optional[str]:
        return pulumi.get(self, "autodb_idle_timeout")

    @property
    @pulumi.getter(name="autodbMaxDbConnections")
    def autodb_max_db_connections(self) -> Optional[str]:
        return pulumi.get(self, "autodb_max_db_connections")

    @property
    @pulumi.getter(name="autodbPoolMode")
    def autodb_pool_mode(self) -> Optional[str]:
        return pulumi.get(self, "autodb_pool_mode")

    @property
    @pulumi.getter(name="autodbPoolSize")
    def autodb_pool_size(self) -> Optional[str]:
        return pulumi.get(self, "autodb_pool_size")

    @property
    @pulumi.getter(name="ignoreStartupParameters")
    def ignore_startup_parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ignore_startup_parameters")

    @property
    @pulumi.getter(name="minPoolSize")
    def min_pool_size(self) -> Optional[str]:
        return pulumi.get(self, "min_pool_size")

    @property
    @pulumi.getter(name="serverIdleTimeout")
    def server_idle_timeout(self) -> Optional[str]:
        return pulumi.get(self, "server_idle_timeout")

    @property
    @pulumi.getter(name="serverLifetime")
    def server_lifetime(self) -> Optional[str]:
        return pulumi.get(self, "server_lifetime")

    @property
    @pulumi.getter(name="serverResetQueryAlways")
    def server_reset_query_always(self) -> Optional[str]:
        return pulumi.get(self, "server_reset_query_always")


@pulumi.output_type
class PgPgUserConfigPglookout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxFailoverReplicationTimeLag":
            suggest = "max_failover_replication_time_lag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgPgUserConfigPglookout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgPgUserConfigPglookout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgPgUserConfigPglookout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_failover_replication_time_lag: Optional[str] = None):
        if max_failover_replication_time_lag is not None:
            pulumi.set(__self__, "max_failover_replication_time_lag", max_failover_replication_time_lag)

    @property
    @pulumi.getter(name="maxFailoverReplicationTimeLag")
    def max_failover_replication_time_lag(self) -> Optional[str]:
        return pulumi.get(self, "max_failover_replication_time_lag")


@pulumi.output_type
class PgPgUserConfigPrivateAccess(dict):
    def __init__(__self__, *,
                 pg: Optional[str] = None,
                 pgbouncer: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str pg: PostgreSQL specific server provided values
        """
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def pg(self) -> Optional[str]:
        """
        PostgreSQL specific server provided values
        """
        return pulumi.get(self, "pg")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional[str]:
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class PgPgUserConfigPrivatelinkAccess(dict):
    def __init__(__self__, *,
                 pg: Optional[str] = None,
                 pgbouncer: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str pg: PostgreSQL specific server provided values
        """
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def pg(self) -> Optional[str]:
        """
        PostgreSQL specific server provided values
        """
        return pulumi.get(self, "pg")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional[str]:
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class PgPgUserConfigPublicAccess(dict):
    def __init__(__self__, *,
                 pg: Optional[str] = None,
                 pgbouncer: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str pg: PostgreSQL specific server provided values
        """
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def pg(self) -> Optional[str]:
        """
        PostgreSQL specific server provided values
        """
        return pulumi.get(self, "pg")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional[str]:
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class PgPgUserConfigTimescaledb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxBackgroundWorkers":
            suggest = "max_background_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgPgUserConfigTimescaledb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgPgUserConfigTimescaledb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgPgUserConfigTimescaledb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_background_workers: Optional[str] = None):
        if max_background_workers is not None:
            pulumi.set(__self__, "max_background_workers", max_background_workers)

    @property
    @pulumi.getter(name="maxBackgroundWorkers")
    def max_background_workers(self) -> Optional[str]:
        return pulumi.get(self, "max_background_workers")


@pulumi.output_type
class PgServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        """
        :param str integration_type: Type of the service integration. The only supported value at the moment is `read_replica`
        :param str source_service_name: Name of the source service
        """
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Type of the service integration. The only supported value at the moment is `read_replica`
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        """
        Name of the source service
        """
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class PgTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Service tag key
        :param str value: Service tag value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Service tag key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Service tag value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProjectTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Project tag key
        :param str value: Project tag value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Project tag key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Project tag value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RedisComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RedisComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RedisComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RedisComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class RedisRedi(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RedisRedisUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "recoveryBasebackupName":
            suggest = "recovery_basebackup_name"
        elif key == "redisAclChannelsDefault":
            suggest = "redis_acl_channels_default"
        elif key == "redisIoThreads":
            suggest = "redis_io_threads"
        elif key == "redisLfuDecayTime":
            suggest = "redis_lfu_decay_time"
        elif key == "redisLfuLogFactor":
            suggest = "redis_lfu_log_factor"
        elif key == "redisMaxmemoryPolicy":
            suggest = "redis_maxmemory_policy"
        elif key == "redisNotifyKeyspaceEvents":
            suggest = "redis_notify_keyspace_events"
        elif key == "redisNumberOfDatabases":
            suggest = "redis_number_of_databases"
        elif key == "redisPersistence":
            suggest = "redis_persistence"
        elif key == "redisPubsubClientOutputBufferLimit":
            suggest = "redis_pubsub_client_output_buffer_limit"
        elif key == "redisSsl":
            suggest = "redis_ssl"
        elif key == "redisTimeout":
            suggest = "redis_timeout"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RedisRedisUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RedisRedisUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RedisRedisUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 migration: Optional['outputs.RedisRedisUserConfigMigration'] = None,
                 private_access: Optional['outputs.RedisRedisUserConfigPrivateAccess'] = None,
                 privatelink_access: Optional['outputs.RedisRedisUserConfigPrivatelinkAccess'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.RedisRedisUserConfigPublicAccess'] = None,
                 recovery_basebackup_name: Optional[str] = None,
                 redis_acl_channels_default: Optional[str] = None,
                 redis_io_threads: Optional[str] = None,
                 redis_lfu_decay_time: Optional[str] = None,
                 redis_lfu_log_factor: Optional[str] = None,
                 redis_maxmemory_policy: Optional[str] = None,
                 redis_notify_keyspace_events: Optional[str] = None,
                 redis_number_of_databases: Optional[str] = None,
                 redis_persistence: Optional[str] = None,
                 redis_pubsub_client_output_buffer_limit: Optional[str] = None,
                 redis_ssl: Optional[str] = None,
                 redis_timeout: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        """
        :param Sequence[str] ip_filters: IP filter
        :param 'RedisRedisUserConfigMigrationArgs' migration: Migrate data from existing server
        :param 'RedisRedisUserConfigPrivateAccessArgs' private_access: Allow access to selected service ports from private networks
        :param 'RedisRedisUserConfigPrivatelinkAccessArgs' privatelink_access: Allow access to selected service components through Privatelink
        :param str project_to_fork_from: Name of another project to fork a service from. This has effect only when a new service is being created.
        :param 'RedisRedisUserConfigPublicAccessArgs' public_access: Allow access to selected service ports from the public Internet
        :param str recovery_basebackup_name: Name of the basebackup to restore in forked service
        :param str redis_acl_channels_default: Default ACL for pub/sub channels used when Redis user is created
        :param str redis_io_threads: Redis IO thread count
        :param str redis_lfu_decay_time: LFU maxmemory-policy counter decay time in minutes
        :param str redis_lfu_log_factor: Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies
        :param str redis_maxmemory_policy: Redis maxmemory-policy
        :param str redis_notify_keyspace_events: Set notify-keyspace-events option
        :param str redis_number_of_databases: Number of redis databases
        :param str redis_persistence: Redis persistence
        :param str redis_pubsub_client_output_buffer_limit: Pub/sub client output buffer hard limit in MB
        :param str redis_ssl: Require SSL to access Redis
        :param str redis_timeout: Redis idle connection timeout in seconds
        :param str service_to_fork_from: Name of another service to fork from. This has effect only when a new service is being created.
        :param str static_ips: Static IP addresses
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_basebackup_name is not None:
            pulumi.set(__self__, "recovery_basebackup_name", recovery_basebackup_name)
        if redis_acl_channels_default is not None:
            pulumi.set(__self__, "redis_acl_channels_default", redis_acl_channels_default)
        if redis_io_threads is not None:
            pulumi.set(__self__, "redis_io_threads", redis_io_threads)
        if redis_lfu_decay_time is not None:
            pulumi.set(__self__, "redis_lfu_decay_time", redis_lfu_decay_time)
        if redis_lfu_log_factor is not None:
            pulumi.set(__self__, "redis_lfu_log_factor", redis_lfu_log_factor)
        if redis_maxmemory_policy is not None:
            pulumi.set(__self__, "redis_maxmemory_policy", redis_maxmemory_policy)
        if redis_notify_keyspace_events is not None:
            pulumi.set(__self__, "redis_notify_keyspace_events", redis_notify_keyspace_events)
        if redis_number_of_databases is not None:
            pulumi.set(__self__, "redis_number_of_databases", redis_number_of_databases)
        if redis_persistence is not None:
            pulumi.set(__self__, "redis_persistence", redis_persistence)
        if redis_pubsub_client_output_buffer_limit is not None:
            pulumi.set(__self__, "redis_pubsub_client_output_buffer_limit", redis_pubsub_client_output_buffer_limit)
        if redis_ssl is not None:
            pulumi.set(__self__, "redis_ssl", redis_ssl)
        if redis_timeout is not None:
            pulumi.set(__self__, "redis_timeout", redis_timeout)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def migration(self) -> Optional['outputs.RedisRedisUserConfigMigration']:
        """
        Migrate data from existing server
        """
        return pulumi.get(self, "migration")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.RedisRedisUserConfigPrivateAccess']:
        """
        Allow access to selected service ports from private networks
        """
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.RedisRedisUserConfigPrivatelinkAccess']:
        """
        Allow access to selected service components through Privatelink
        """
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        """
        Name of another project to fork a service from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.RedisRedisUserConfigPublicAccess']:
        """
        Allow access to selected service ports from the public Internet
        """
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryBasebackupName")
    def recovery_basebackup_name(self) -> Optional[str]:
        """
        Name of the basebackup to restore in forked service
        """
        return pulumi.get(self, "recovery_basebackup_name")

    @property
    @pulumi.getter(name="redisAclChannelsDefault")
    def redis_acl_channels_default(self) -> Optional[str]:
        """
        Default ACL for pub/sub channels used when Redis user is created
        """
        return pulumi.get(self, "redis_acl_channels_default")

    @property
    @pulumi.getter(name="redisIoThreads")
    def redis_io_threads(self) -> Optional[str]:
        """
        Redis IO thread count
        """
        return pulumi.get(self, "redis_io_threads")

    @property
    @pulumi.getter(name="redisLfuDecayTime")
    def redis_lfu_decay_time(self) -> Optional[str]:
        """
        LFU maxmemory-policy counter decay time in minutes
        """
        return pulumi.get(self, "redis_lfu_decay_time")

    @property
    @pulumi.getter(name="redisLfuLogFactor")
    def redis_lfu_log_factor(self) -> Optional[str]:
        """
        Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies
        """
        return pulumi.get(self, "redis_lfu_log_factor")

    @property
    @pulumi.getter(name="redisMaxmemoryPolicy")
    def redis_maxmemory_policy(self) -> Optional[str]:
        """
        Redis maxmemory-policy
        """
        return pulumi.get(self, "redis_maxmemory_policy")

    @property
    @pulumi.getter(name="redisNotifyKeyspaceEvents")
    def redis_notify_keyspace_events(self) -> Optional[str]:
        """
        Set notify-keyspace-events option
        """
        return pulumi.get(self, "redis_notify_keyspace_events")

    @property
    @pulumi.getter(name="redisNumberOfDatabases")
    def redis_number_of_databases(self) -> Optional[str]:
        """
        Number of redis databases
        """
        return pulumi.get(self, "redis_number_of_databases")

    @property
    @pulumi.getter(name="redisPersistence")
    def redis_persistence(self) -> Optional[str]:
        """
        Redis persistence
        """
        return pulumi.get(self, "redis_persistence")

    @property
    @pulumi.getter(name="redisPubsubClientOutputBufferLimit")
    def redis_pubsub_client_output_buffer_limit(self) -> Optional[str]:
        """
        Pub/sub client output buffer hard limit in MB
        """
        return pulumi.get(self, "redis_pubsub_client_output_buffer_limit")

    @property
    @pulumi.getter(name="redisSsl")
    def redis_ssl(self) -> Optional[str]:
        """
        Require SSL to access Redis
        """
        return pulumi.get(self, "redis_ssl")

    @property
    @pulumi.getter(name="redisTimeout")
    def redis_timeout(self) -> Optional[str]:
        """
        Redis idle connection timeout in seconds
        """
        return pulumi.get(self, "redis_timeout")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        """
        Name of another service to fork from. This has effect only when a new service is being created.
        """
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IP addresses
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class RedisRedisUserConfigMigration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreDbs":
            suggest = "ignore_dbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RedisRedisUserConfigMigration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RedisRedisUserConfigMigration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RedisRedisUserConfigMigration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 ignore_dbs: Optional[str] = None,
                 method: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 ssl: Optional[str] = None,
                 username: Optional[str] = None):
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[str]:
        return pulumi.get(self, "ignore_dbs")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class RedisRedisUserConfigPrivateAccess(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None,
                 redis: Optional[str] = None):
        """
        :param str redis: Redis server provided values
        """
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter
    def redis(self) -> Optional[str]:
        """
        Redis server provided values
        """
        return pulumi.get(self, "redis")


@pulumi.output_type
class RedisRedisUserConfigPrivatelinkAccess(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None,
                 redis: Optional[str] = None):
        """
        :param str redis: Redis server provided values
        """
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter
    def redis(self) -> Optional[str]:
        """
        Redis server provided values
        """
        return pulumi.get(self, "redis")


@pulumi.output_type
class RedisRedisUserConfigPublicAccess(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None,
                 redis: Optional[str] = None):
        """
        :param str redis: Redis server provided values
        """
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter
    def redis(self) -> Optional[str]:
        """
        Redis server provided values
        """
        return pulumi.get(self, "redis")


@pulumi.output_type
class RedisServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RedisServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RedisServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RedisServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        """
        :param str integration_type: Type of the service integration. The only supported value at the moment is `read_replica`
        :param str source_service_name: Name of the source service
        """
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Type of the service integration. The only supported value at the moment is `read_replica`
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        """
        Name of the source service
        """
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class RedisTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Service tag key
        :param str value: Service tag value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Service tag key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Service tag value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceIntegrationEndpointDatadogUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datadogApiKey":
            suggest = "datadog_api_key"
        elif key == "datadogTags":
            suggest = "datadog_tags"
        elif key == "disableConsumerStats":
            suggest = "disable_consumer_stats"
        elif key == "kafkaConsumerCheckInstances":
            suggest = "kafka_consumer_check_instances"
        elif key == "kafkaConsumerStatsTimeout":
            suggest = "kafka_consumer_stats_timeout"
        elif key == "maxPartitionContexts":
            suggest = "max_partition_contexts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointDatadogUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointDatadogUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointDatadogUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datadog_api_key: Optional[str] = None,
                 datadog_tags: Optional[Sequence['outputs.ServiceIntegrationEndpointDatadogUserConfigDatadogTag']] = None,
                 disable_consumer_stats: Optional[str] = None,
                 kafka_consumer_check_instances: Optional[str] = None,
                 kafka_consumer_stats_timeout: Optional[str] = None,
                 max_partition_contexts: Optional[str] = None,
                 site: Optional[str] = None):
        """
        :param str datadog_api_key: Datadog API key
        :param Sequence['ServiceIntegrationEndpointDatadogUserConfigDatadogTagArgs'] datadog_tags: Custom tags provided by user
        :param str disable_consumer_stats: Disable consumer group metrics
        :param str kafka_consumer_check_instances: Number of separate instances to fetch kafka consumer statistics with
        :param str kafka_consumer_stats_timeout: Number of seconds that datadog will wait to get consumer statistics from brokers
        :param str max_partition_contexts: Maximum number of partition contexts to send
        :param str site: Datadog intake site. Defaults to datadoghq.com
        """
        if datadog_api_key is not None:
            pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        if datadog_tags is not None:
            pulumi.set(__self__, "datadog_tags", datadog_tags)
        if disable_consumer_stats is not None:
            pulumi.set(__self__, "disable_consumer_stats", disable_consumer_stats)
        if kafka_consumer_check_instances is not None:
            pulumi.set(__self__, "kafka_consumer_check_instances", kafka_consumer_check_instances)
        if kafka_consumer_stats_timeout is not None:
            pulumi.set(__self__, "kafka_consumer_stats_timeout", kafka_consumer_stats_timeout)
        if max_partition_contexts is not None:
            pulumi.set(__self__, "max_partition_contexts", max_partition_contexts)
        if site is not None:
            pulumi.set(__self__, "site", site)

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> Optional[str]:
        """
        Datadog API key
        """
        return pulumi.get(self, "datadog_api_key")

    @property
    @pulumi.getter(name="datadogTags")
    def datadog_tags(self) -> Optional[Sequence['outputs.ServiceIntegrationEndpointDatadogUserConfigDatadogTag']]:
        """
        Custom tags provided by user
        """
        return pulumi.get(self, "datadog_tags")

    @property
    @pulumi.getter(name="disableConsumerStats")
    def disable_consumer_stats(self) -> Optional[str]:
        """
        Disable consumer group metrics
        """
        return pulumi.get(self, "disable_consumer_stats")

    @property
    @pulumi.getter(name="kafkaConsumerCheckInstances")
    def kafka_consumer_check_instances(self) -> Optional[str]:
        """
        Number of separate instances to fetch kafka consumer statistics with
        """
        return pulumi.get(self, "kafka_consumer_check_instances")

    @property
    @pulumi.getter(name="kafkaConsumerStatsTimeout")
    def kafka_consumer_stats_timeout(self) -> Optional[str]:
        """
        Number of seconds that datadog will wait to get consumer statistics from brokers
        """
        return pulumi.get(self, "kafka_consumer_stats_timeout")

    @property
    @pulumi.getter(name="maxPartitionContexts")
    def max_partition_contexts(self) -> Optional[str]:
        """
        Maximum number of partition contexts to send
        """
        return pulumi.get(self, "max_partition_contexts")

    @property
    @pulumi.getter
    def site(self) -> Optional[str]:
        """
        Datadog intake site. Defaults to datadoghq.com
        """
        return pulumi.get(self, "site")


@pulumi.output_type
class ServiceIntegrationEndpointDatadogUserConfigDatadogTag(dict):
    def __init__(__self__, *,
                 comment: Optional[str] = None,
                 tag: Optional[str] = None):
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")


@pulumi.output_type
class ServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "logGroupName":
            suggest = "log_group_name"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 log_group_name: Optional[str] = None,
                 region: Optional[str] = None,
                 secret_key: Optional[str] = None):
        """
        :param str access_key: AWS access key. Required permissions are logs:CreateLogGroup, logs:CreateLogStream, logs:PutLogEvents and logs:DescribeLogStreams
        :param str log_group_name: AWS CloudWatch log group name
        :param str region: AWS region
        :param str secret_key: AWS secret key
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        AWS access key. Required permissions are logs:CreateLogGroup, logs:CreateLogStream, logs:PutLogEvents and logs:DescribeLogStreams
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[str]:
        """
        AWS CloudWatch log group name
        """
        return pulumi.get(self, "log_group_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        AWS region
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        AWS secret key
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class ServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 namespace: Optional[str] = None,
                 region: Optional[str] = None,
                 secret_key: Optional[str] = None):
        """
        :param str access_key: AWS access key. Required permissions are cloudwatch:PutMetricData
        :param str namespace: AWS CloudWatch Metrics Namespace
        :param str region: AWS region
        :param str secret_key: AWS secret key
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        AWS access key. Required permissions are cloudwatch:PutMetricData
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        AWS CloudWatch Metrics Namespace
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        AWS region
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        AWS secret key
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "indexDaysMax":
            suggest = "index_days_max"
        elif key == "indexPrefix":
            suggest = "index_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca: Optional[str] = None,
                 index_days_max: Optional[str] = None,
                 index_prefix: Optional[str] = None,
                 timeout: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str ca: PEM encoded CA certificate
        :param str index_days_max: Maximum number of days of logs to keep
        :param str index_prefix: Elasticsearch index prefix
        :param str timeout: Elasticsearch request timeout limit
        :param str url: Elasticsearch connection URL
        """
        if ca is not None:
            pulumi.set(__self__, "ca", ca)
        if index_days_max is not None:
            pulumi.set(__self__, "index_days_max", index_days_max)
        if index_prefix is not None:
            pulumi.set(__self__, "index_prefix", index_prefix)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def ca(self) -> Optional[str]:
        """
        PEM encoded CA certificate
        """
        return pulumi.get(self, "ca")

    @property
    @pulumi.getter(name="indexDaysMax")
    def index_days_max(self) -> Optional[str]:
        """
        Maximum number of days of logs to keep
        """
        return pulumi.get(self, "index_days_max")

    @property
    @pulumi.getter(name="indexPrefix")
    def index_prefix(self) -> Optional[str]:
        """
        Elasticsearch index prefix
        """
        return pulumi.get(self, "index_prefix")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Elasticsearch request timeout limit
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        Elasticsearch connection URL
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logId":
            suggest = "log_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "serviceAccountCredentials":
            suggest = "service_account_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 service_account_credentials: Optional[str] = None):
        """
        :param str log_id: Google Cloud Logging log id
        :param str project_id: GCP project id.
        :param str service_account_credentials: Google Service Account Credentials
        """
        if log_id is not None:
            pulumi.set(__self__, "log_id", log_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if service_account_credentials is not None:
            pulumi.set(__self__, "service_account_credentials", service_account_credentials)

    @property
    @pulumi.getter(name="logId")
    def log_id(self) -> Optional[str]:
        """
        Google Cloud Logging log id
        """
        return pulumi.get(self, "log_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        GCP project id.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="serviceAccountCredentials")
    def service_account_credentials(self) -> Optional[str]:
        """
        Google Service Account Credentials
        """
        return pulumi.get(self, "service_account_credentials")


@pulumi.output_type
class ServiceIntegrationEndpointExternalKafkaUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootstrapServers":
            suggest = "bootstrap_servers"
        elif key == "saslMechanism":
            suggest = "sasl_mechanism"
        elif key == "saslPlainPassword":
            suggest = "sasl_plain_password"
        elif key == "saslPlainUsername":
            suggest = "sasl_plain_username"
        elif key == "securityProtocol":
            suggest = "security_protocol"
        elif key == "sslCaCert":
            suggest = "ssl_ca_cert"
        elif key == "sslClientCert":
            suggest = "ssl_client_cert"
        elif key == "sslClientKey":
            suggest = "ssl_client_key"
        elif key == "sslEndpointIdentificationAlgorithm":
            suggest = "ssl_endpoint_identification_algorithm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointExternalKafkaUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointExternalKafkaUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointExternalKafkaUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bootstrap_servers: Optional[str] = None,
                 sasl_mechanism: Optional[str] = None,
                 sasl_plain_password: Optional[str] = None,
                 sasl_plain_username: Optional[str] = None,
                 security_protocol: Optional[str] = None,
                 ssl_ca_cert: Optional[str] = None,
                 ssl_client_cert: Optional[str] = None,
                 ssl_client_key: Optional[str] = None,
                 ssl_endpoint_identification_algorithm: Optional[str] = None):
        """
        :param str bootstrap_servers: Bootstrap servers
        :param str sasl_mechanism: The list of SASL mechanisms enabled in the Kafka server.
        :param str sasl_plain_password: Password for SASL PLAIN mechanism in the Kafka server.
        :param str sasl_plain_username: Username for SASL PLAIN mechanism in the Kafka server.
        :param str security_protocol: Security protocol
        :param str ssl_ca_cert: PEM-encoded CA certificate
        :param str ssl_client_cert: PEM-encoded client certificate
        :param str ssl_client_key: PEM-encoded client key
        :param str ssl_endpoint_identification_algorithm: The endpoint identification algorithm to validate server hostname using server certificate.
        """
        if bootstrap_servers is not None:
            pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_plain_password is not None:
            pulumi.set(__self__, "sasl_plain_password", sasl_plain_password)
        if sasl_plain_username is not None:
            pulumi.set(__self__, "sasl_plain_username", sasl_plain_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)
        if ssl_ca_cert is not None:
            pulumi.set(__self__, "ssl_ca_cert", ssl_ca_cert)
        if ssl_client_cert is not None:
            pulumi.set(__self__, "ssl_client_cert", ssl_client_cert)
        if ssl_client_key is not None:
            pulumi.set(__self__, "ssl_client_key", ssl_client_key)
        if ssl_endpoint_identification_algorithm is not None:
            pulumi.set(__self__, "ssl_endpoint_identification_algorithm", ssl_endpoint_identification_algorithm)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> Optional[str]:
        """
        Bootstrap servers
        """
        return pulumi.get(self, "bootstrap_servers")

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[str]:
        """
        The list of SASL mechanisms enabled in the Kafka server.
        """
        return pulumi.get(self, "sasl_mechanism")

    @property
    @pulumi.getter(name="saslPlainPassword")
    def sasl_plain_password(self) -> Optional[str]:
        """
        Password for SASL PLAIN mechanism in the Kafka server.
        """
        return pulumi.get(self, "sasl_plain_password")

    @property
    @pulumi.getter(name="saslPlainUsername")
    def sasl_plain_username(self) -> Optional[str]:
        """
        Username for SASL PLAIN mechanism in the Kafka server.
        """
        return pulumi.get(self, "sasl_plain_username")

    @property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[str]:
        """
        Security protocol
        """
        return pulumi.get(self, "security_protocol")

    @property
    @pulumi.getter(name="sslCaCert")
    def ssl_ca_cert(self) -> Optional[str]:
        """
        PEM-encoded CA certificate
        """
        return pulumi.get(self, "ssl_ca_cert")

    @property
    @pulumi.getter(name="sslClientCert")
    def ssl_client_cert(self) -> Optional[str]:
        """
        PEM-encoded client certificate
        """
        return pulumi.get(self, "ssl_client_cert")

    @property
    @pulumi.getter(name="sslClientKey")
    def ssl_client_key(self) -> Optional[str]:
        """
        PEM-encoded client key
        """
        return pulumi.get(self, "ssl_client_key")

    @property
    @pulumi.getter(name="sslEndpointIdentificationAlgorithm")
    def ssl_endpoint_identification_algorithm(self) -> Optional[str]:
        """
        The endpoint identification algorithm to validate server hostname using server certificate.
        """
        return pulumi.get(self, "ssl_endpoint_identification_algorithm")


@pulumi.output_type
class ServiceIntegrationEndpointExternalSchemaRegistryUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuthPassword":
            suggest = "basic_auth_password"
        elif key == "basicAuthUsername":
            suggest = "basic_auth_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointExternalSchemaRegistryUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointExternalSchemaRegistryUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointExternalSchemaRegistryUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication: Optional[str] = None,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_username: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str authentication: Authentication method
        :param str basic_auth_password: Basic authentication password
        :param str basic_auth_username: Basic authentication user name
        :param str url: Schema Registry URL
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_username is not None:
            pulumi.set(__self__, "basic_auth_username", basic_auth_username)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[str]:
        """
        Authentication method
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        """
        Basic authentication password
        """
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUsername")
    def basic_auth_username(self) -> Optional[str]:
        """
        Basic authentication user name
        """
        return pulumi.get(self, "basic_auth_username")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        Schema Registry URL
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ServiceIntegrationEndpointJolokiaUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuthPassword":
            suggest = "basic_auth_password"
        elif key == "basicAuthUsername":
            suggest = "basic_auth_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointJolokiaUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointJolokiaUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointJolokiaUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_username: Optional[str] = None):
        """
        :param str basic_auth_password: Jolokia basic authentication password
        :param str basic_auth_username: Jolokia basic authentication username
        """
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_username is not None:
            pulumi.set(__self__, "basic_auth_username", basic_auth_username)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        """
        Jolokia basic authentication password
        """
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUsername")
    def basic_auth_username(self) -> Optional[str]:
        """
        Jolokia basic authentication username
        """
        return pulumi.get(self, "basic_auth_username")


@pulumi.output_type
class ServiceIntegrationEndpointPrometheusUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuthPassword":
            suggest = "basic_auth_password"
        elif key == "basicAuthUsername":
            suggest = "basic_auth_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointPrometheusUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointPrometheusUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointPrometheusUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_username: Optional[str] = None):
        """
        :param str basic_auth_password: Prometheus basic authentication password
        :param str basic_auth_username: Prometheus basic authentication username
        """
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_username is not None:
            pulumi.set(__self__, "basic_auth_username", basic_auth_username)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        """
        Prometheus basic authentication password
        """
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUsername")
    def basic_auth_username(self) -> Optional[str]:
        """
        Prometheus basic authentication username
        """
        return pulumi.get(self, "basic_auth_username")


@pulumi.output_type
class ServiceIntegrationEndpointRsyslogUserConfig(dict):
    def __init__(__self__, *,
                 ca: Optional[str] = None,
                 cert: Optional[str] = None,
                 format: Optional[str] = None,
                 key: Optional[str] = None,
                 logline: Optional[str] = None,
                 port: Optional[str] = None,
                 sd: Optional[str] = None,
                 server: Optional[str] = None,
                 tls: Optional[str] = None):
        """
        :param str ca: PEM encoded CA certificate
        :param str cert: PEM encoded client certificate
        :param str format: message format
        :param str key: PEM encoded client key
        :param str logline: custom syslog message format
        :param str port: rsyslog server port
        :param str sd: Structured data block for log message
        :param str server: rsyslog server IP address or hostname
        :param str tls: Require TLS
        """
        if ca is not None:
            pulumi.set(__self__, "ca", ca)
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if logline is not None:
            pulumi.set(__self__, "logline", logline)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if sd is not None:
            pulumi.set(__self__, "sd", sd)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def ca(self) -> Optional[str]:
        """
        PEM encoded CA certificate
        """
        return pulumi.get(self, "ca")

    @property
    @pulumi.getter
    def cert(self) -> Optional[str]:
        """
        PEM encoded client certificate
        """
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        message format
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        PEM encoded client key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def logline(self) -> Optional[str]:
        """
        custom syslog message format
        """
        return pulumi.get(self, "logline")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        rsyslog server port
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def sd(self) -> Optional[str]:
        """
        Structured data block for log message
        """
        return pulumi.get(self, "sd")

    @property
    @pulumi.getter
    def server(self) -> Optional[str]:
        """
        rsyslog server IP address or hostname
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def tls(self) -> Optional[str]:
        """
        Require TLS
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class ServiceIntegrationEndpointSignalfxUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enabledMetrics":
            suggest = "enabled_metrics"
        elif key == "signalfxApiKey":
            suggest = "signalfx_api_key"
        elif key == "signalfxRealm":
            suggest = "signalfx_realm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointSignalfxUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointSignalfxUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointSignalfxUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled_metrics: Optional[Sequence[str]] = None,
                 signalfx_api_key: Optional[str] = None,
                 signalfx_realm: Optional[str] = None):
        """
        :param Sequence[str] enabled_metrics: list of metrics to send
        :param str signalfx_api_key: SignalFX API key
        :param str signalfx_realm: SignalFX realm
        """
        if enabled_metrics is not None:
            pulumi.set(__self__, "enabled_metrics", enabled_metrics)
        if signalfx_api_key is not None:
            pulumi.set(__self__, "signalfx_api_key", signalfx_api_key)
        if signalfx_realm is not None:
            pulumi.set(__self__, "signalfx_realm", signalfx_realm)

    @property
    @pulumi.getter(name="enabledMetrics")
    def enabled_metrics(self) -> Optional[Sequence[str]]:
        """
        list of metrics to send
        """
        return pulumi.get(self, "enabled_metrics")

    @property
    @pulumi.getter(name="signalfxApiKey")
    def signalfx_api_key(self) -> Optional[str]:
        """
        SignalFX API key
        """
        return pulumi.get(self, "signalfx_api_key")

    @property
    @pulumi.getter(name="signalfxRealm")
    def signalfx_realm(self) -> Optional[str]:
        """
        SignalFX realm
        """
        return pulumi.get(self, "signalfx_realm")


@pulumi.output_type
class ServiceIntegrationKafkaConnectUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaConnect":
            suggest = "kafka_connect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationKafkaConnectUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationKafkaConnectUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationKafkaConnectUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka_connect: Optional['outputs.ServiceIntegrationKafkaConnectUserConfigKafkaConnect'] = None):
        """
        :param 'ServiceIntegrationKafkaConnectUserConfigKafkaConnectArgs' kafka_connect: Kafka Connect service configuration values
        """
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional['outputs.ServiceIntegrationKafkaConnectUserConfigKafkaConnect']:
        """
        Kafka Connect service configuration values
        """
        return pulumi.get(self, "kafka_connect")


@pulumi.output_type
class ServiceIntegrationKafkaConnectUserConfigKafkaConnect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configStorageTopic":
            suggest = "config_storage_topic"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "offsetStorageTopic":
            suggest = "offset_storage_topic"
        elif key == "statusStorageTopic":
            suggest = "status_storage_topic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationKafkaConnectUserConfigKafkaConnect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationKafkaConnectUserConfigKafkaConnect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationKafkaConnectUserConfigKafkaConnect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_storage_topic: Optional[str] = None,
                 group_id: Optional[str] = None,
                 offset_storage_topic: Optional[str] = None,
                 status_storage_topic: Optional[str] = None):
        if config_storage_topic is not None:
            pulumi.set(__self__, "config_storage_topic", config_storage_topic)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if offset_storage_topic is not None:
            pulumi.set(__self__, "offset_storage_topic", offset_storage_topic)
        if status_storage_topic is not None:
            pulumi.set(__self__, "status_storage_topic", status_storage_topic)

    @property
    @pulumi.getter(name="configStorageTopic")
    def config_storage_topic(self) -> Optional[str]:
        return pulumi.get(self, "config_storage_topic")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="offsetStorageTopic")
    def offset_storage_topic(self) -> Optional[str]:
        return pulumi.get(self, "offset_storage_topic")

    @property
    @pulumi.getter(name="statusStorageTopic")
    def status_storage_topic(self) -> Optional[str]:
        return pulumi.get(self, "status_storage_topic")


@pulumi.output_type
class ServiceIntegrationKafkaLogsUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaTopic":
            suggest = "kafka_topic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationKafkaLogsUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationKafkaLogsUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationKafkaLogsUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka_topic: Optional[str] = None):
        """
        :param str kafka_topic: Topic name
        """
        if kafka_topic is not None:
            pulumi.set(__self__, "kafka_topic", kafka_topic)

    @property
    @pulumi.getter(name="kafkaTopic")
    def kafka_topic(self) -> Optional[str]:
        """
        Topic name
        """
        return pulumi.get(self, "kafka_topic")


@pulumi.output_type
class ServiceIntegrationKafkaMirrormakerUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterAlias":
            suggest = "cluster_alias"
        elif key == "kafkaMirrormaker":
            suggest = "kafka_mirrormaker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationKafkaMirrormakerUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationKafkaMirrormakerUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationKafkaMirrormakerUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_alias: Optional[str] = None,
                 kafka_mirrormaker: Optional['outputs.ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker'] = None):
        """
        :param str cluster_alias: Kafka cluster alias
        :param 'ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormakerArgs' kafka_mirrormaker: Kafka MirrorMaker configuration values
        """
        if cluster_alias is not None:
            pulumi.set(__self__, "cluster_alias", cluster_alias)
        if kafka_mirrormaker is not None:
            pulumi.set(__self__, "kafka_mirrormaker", kafka_mirrormaker)

    @property
    @pulumi.getter(name="clusterAlias")
    def cluster_alias(self) -> Optional[str]:
        """
        Kafka cluster alias
        """
        return pulumi.get(self, "cluster_alias")

    @property
    @pulumi.getter(name="kafkaMirrormaker")
    def kafka_mirrormaker(self) -> Optional['outputs.ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker']:
        """
        Kafka MirrorMaker configuration values
        """
        return pulumi.get(self, "kafka_mirrormaker")


@pulumi.output_type
class ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerFetchMinBytes":
            suggest = "consumer_fetch_min_bytes"
        elif key == "producerBatchSize":
            suggest = "producer_batch_size"
        elif key == "producerBufferMemory":
            suggest = "producer_buffer_memory"
        elif key == "producerLingerMs":
            suggest = "producer_linger_ms"
        elif key == "producerMaxRequestSize":
            suggest = "producer_max_request_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_fetch_min_bytes: Optional[str] = None,
                 producer_batch_size: Optional[str] = None,
                 producer_buffer_memory: Optional[str] = None,
                 producer_linger_ms: Optional[str] = None,
                 producer_max_request_size: Optional[str] = None):
        if consumer_fetch_min_bytes is not None:
            pulumi.set(__self__, "consumer_fetch_min_bytes", consumer_fetch_min_bytes)
        if producer_batch_size is not None:
            pulumi.set(__self__, "producer_batch_size", producer_batch_size)
        if producer_buffer_memory is not None:
            pulumi.set(__self__, "producer_buffer_memory", producer_buffer_memory)
        if producer_linger_ms is not None:
            pulumi.set(__self__, "producer_linger_ms", producer_linger_ms)
        if producer_max_request_size is not None:
            pulumi.set(__self__, "producer_max_request_size", producer_max_request_size)

    @property
    @pulumi.getter(name="consumerFetchMinBytes")
    def consumer_fetch_min_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_fetch_min_bytes")

    @property
    @pulumi.getter(name="producerBatchSize")
    def producer_batch_size(self) -> Optional[str]:
        return pulumi.get(self, "producer_batch_size")

    @property
    @pulumi.getter(name="producerBufferMemory")
    def producer_buffer_memory(self) -> Optional[str]:
        return pulumi.get(self, "producer_buffer_memory")

    @property
    @pulumi.getter(name="producerLingerMs")
    def producer_linger_ms(self) -> Optional[str]:
        return pulumi.get(self, "producer_linger_ms")

    @property
    @pulumi.getter(name="producerMaxRequestSize")
    def producer_max_request_size(self) -> Optional[str]:
        return pulumi.get(self, "producer_max_request_size")


@pulumi.output_type
class ServiceIntegrationLogsUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elasticsearchIndexDaysMax":
            suggest = "elasticsearch_index_days_max"
        elif key == "elasticsearchIndexPrefix":
            suggest = "elasticsearch_index_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationLogsUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationLogsUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationLogsUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 elasticsearch_index_days_max: Optional[str] = None,
                 elasticsearch_index_prefix: Optional[str] = None):
        """
        :param str elasticsearch_index_days_max: Elasticsearch index retention limit
        :param str elasticsearch_index_prefix: Elasticsearch index prefix
        """
        if elasticsearch_index_days_max is not None:
            pulumi.set(__self__, "elasticsearch_index_days_max", elasticsearch_index_days_max)
        if elasticsearch_index_prefix is not None:
            pulumi.set(__self__, "elasticsearch_index_prefix", elasticsearch_index_prefix)

    @property
    @pulumi.getter(name="elasticsearchIndexDaysMax")
    def elasticsearch_index_days_max(self) -> Optional[str]:
        """
        Elasticsearch index retention limit
        """
        return pulumi.get(self, "elasticsearch_index_days_max")

    @property
    @pulumi.getter(name="elasticsearchIndexPrefix")
    def elasticsearch_index_prefix(self) -> Optional[str]:
        """
        Elasticsearch index prefix
        """
        return pulumi.get(self, "elasticsearch_index_prefix")


@pulumi.output_type
class ServiceIntegrationMetricsUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionDays":
            suggest = "retention_days"
        elif key == "roUsername":
            suggest = "ro_username"
        elif key == "sourceMysql":
            suggest = "source_mysql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationMetricsUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationMetricsUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationMetricsUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: Optional[str] = None,
                 retention_days: Optional[str] = None,
                 ro_username: Optional[str] = None,
                 source_mysql: Optional['outputs.ServiceIntegrationMetricsUserConfigSourceMysql'] = None,
                 username: Optional[str] = None):
        """
        :param str database: Name of the database where to store metric datapoints. Only affects PostgreSQL destinations. Defaults to 'metrics'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
        :param str retention_days: Number of days to keep old metrics. Only affects PostgreSQL destinations. Set to 0 for no automatic cleanup. Defaults to 30 days.
        :param str ro_username: Name of a user that can be used to read metrics. This will be used for Grafana integration (if enabled) to prevent Grafana users from making undesired changes. Only affects PostgreSQL destinations. Defaults to 'metrics_reader'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
        :param 'ServiceIntegrationMetricsUserConfigSourceMysqlArgs' source_mysql: Configuration options for metrics where source service is MySQL
        :param str username: Name of the user used to write metrics. Only affects PostgreSQL destinations. Defaults to 'metrics_writer'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if retention_days is not None:
            pulumi.set(__self__, "retention_days", retention_days)
        if ro_username is not None:
            pulumi.set(__self__, "ro_username", ro_username)
        if source_mysql is not None:
            pulumi.set(__self__, "source_mysql", source_mysql)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        Name of the database where to store metric datapoints. Only affects PostgreSQL destinations. Defaults to 'metrics'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> Optional[str]:
        """
        Number of days to keep old metrics. Only affects PostgreSQL destinations. Set to 0 for no automatic cleanup. Defaults to 30 days.
        """
        return pulumi.get(self, "retention_days")

    @property
    @pulumi.getter(name="roUsername")
    def ro_username(self) -> Optional[str]:
        """
        Name of a user that can be used to read metrics. This will be used for Grafana integration (if enabled) to prevent Grafana users from making undesired changes. Only affects PostgreSQL destinations. Defaults to 'metrics_reader'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
        """
        return pulumi.get(self, "ro_username")

    @property
    @pulumi.getter(name="sourceMysql")
    def source_mysql(self) -> Optional['outputs.ServiceIntegrationMetricsUserConfigSourceMysql']:
        """
        Configuration options for metrics where source service is MySQL
        """
        return pulumi.get(self, "source_mysql")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Name of the user used to write metrics. Only affects PostgreSQL destinations. Defaults to 'metrics_writer'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ServiceIntegrationMetricsUserConfigSourceMysql(dict):
    def __init__(__self__, *,
                 telegraf: Optional['outputs.ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf'] = None):
        if telegraf is not None:
            pulumi.set(__self__, "telegraf", telegraf)

    @property
    @pulumi.getter
    def telegraf(self) -> Optional['outputs.ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf']:
        return pulumi.get(self, "telegraf")


@pulumi.output_type
class ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatherEventWaits":
            suggest = "gather_event_waits"
        elif key == "gatherFileEventsStats":
            suggest = "gather_file_events_stats"
        elif key == "gatherIndexIoWaits":
            suggest = "gather_index_io_waits"
        elif key == "gatherInfoSchemaAutoInc":
            suggest = "gather_info_schema_auto_inc"
        elif key == "gatherInnodbMetrics":
            suggest = "gather_innodb_metrics"
        elif key == "gatherPerfEventsStatements":
            suggest = "gather_perf_events_statements"
        elif key == "gatherProcessList":
            suggest = "gather_process_list"
        elif key == "gatherSlaveStatus":
            suggest = "gather_slave_status"
        elif key == "gatherTableIoWaits":
            suggest = "gather_table_io_waits"
        elif key == "gatherTableLockWaits":
            suggest = "gather_table_lock_waits"
        elif key == "gatherTableSchema":
            suggest = "gather_table_schema"
        elif key == "perfEventsStatementsDigestTextLimit":
            suggest = "perf_events_statements_digest_text_limit"
        elif key == "perfEventsStatementsLimit":
            suggest = "perf_events_statements_limit"
        elif key == "perfEventsStatementsTimeLimit":
            suggest = "perf_events_statements_time_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gather_event_waits: Optional[str] = None,
                 gather_file_events_stats: Optional[str] = None,
                 gather_index_io_waits: Optional[str] = None,
                 gather_info_schema_auto_inc: Optional[str] = None,
                 gather_innodb_metrics: Optional[str] = None,
                 gather_perf_events_statements: Optional[str] = None,
                 gather_process_list: Optional[str] = None,
                 gather_slave_status: Optional[str] = None,
                 gather_table_io_waits: Optional[str] = None,
                 gather_table_lock_waits: Optional[str] = None,
                 gather_table_schema: Optional[str] = None,
                 perf_events_statements_digest_text_limit: Optional[str] = None,
                 perf_events_statements_limit: Optional[str] = None,
                 perf_events_statements_time_limit: Optional[str] = None):
        if gather_event_waits is not None:
            pulumi.set(__self__, "gather_event_waits", gather_event_waits)
        if gather_file_events_stats is not None:
            pulumi.set(__self__, "gather_file_events_stats", gather_file_events_stats)
        if gather_index_io_waits is not None:
            pulumi.set(__self__, "gather_index_io_waits", gather_index_io_waits)
        if gather_info_schema_auto_inc is not None:
            pulumi.set(__self__, "gather_info_schema_auto_inc", gather_info_schema_auto_inc)
        if gather_innodb_metrics is not None:
            pulumi.set(__self__, "gather_innodb_metrics", gather_innodb_metrics)
        if gather_perf_events_statements is not None:
            pulumi.set(__self__, "gather_perf_events_statements", gather_perf_events_statements)
        if gather_process_list is not None:
            pulumi.set(__self__, "gather_process_list", gather_process_list)
        if gather_slave_status is not None:
            pulumi.set(__self__, "gather_slave_status", gather_slave_status)
        if gather_table_io_waits is not None:
            pulumi.set(__self__, "gather_table_io_waits", gather_table_io_waits)
        if gather_table_lock_waits is not None:
            pulumi.set(__self__, "gather_table_lock_waits", gather_table_lock_waits)
        if gather_table_schema is not None:
            pulumi.set(__self__, "gather_table_schema", gather_table_schema)
        if perf_events_statements_digest_text_limit is not None:
            pulumi.set(__self__, "perf_events_statements_digest_text_limit", perf_events_statements_digest_text_limit)
        if perf_events_statements_limit is not None:
            pulumi.set(__self__, "perf_events_statements_limit", perf_events_statements_limit)
        if perf_events_statements_time_limit is not None:
            pulumi.set(__self__, "perf_events_statements_time_limit", perf_events_statements_time_limit)

    @property
    @pulumi.getter(name="gatherEventWaits")
    def gather_event_waits(self) -> Optional[str]:
        return pulumi.get(self, "gather_event_waits")

    @property
    @pulumi.getter(name="gatherFileEventsStats")
    def gather_file_events_stats(self) -> Optional[str]:
        return pulumi.get(self, "gather_file_events_stats")

    @property
    @pulumi.getter(name="gatherIndexIoWaits")
    def gather_index_io_waits(self) -> Optional[str]:
        return pulumi.get(self, "gather_index_io_waits")

    @property
    @pulumi.getter(name="gatherInfoSchemaAutoInc")
    def gather_info_schema_auto_inc(self) -> Optional[str]:
        return pulumi.get(self, "gather_info_schema_auto_inc")

    @property
    @pulumi.getter(name="gatherInnodbMetrics")
    def gather_innodb_metrics(self) -> Optional[str]:
        return pulumi.get(self, "gather_innodb_metrics")

    @property
    @pulumi.getter(name="gatherPerfEventsStatements")
    def gather_perf_events_statements(self) -> Optional[str]:
        return pulumi.get(self, "gather_perf_events_statements")

    @property
    @pulumi.getter(name="gatherProcessList")
    def gather_process_list(self) -> Optional[str]:
        return pulumi.get(self, "gather_process_list")

    @property
    @pulumi.getter(name="gatherSlaveStatus")
    def gather_slave_status(self) -> Optional[str]:
        return pulumi.get(self, "gather_slave_status")

    @property
    @pulumi.getter(name="gatherTableIoWaits")
    def gather_table_io_waits(self) -> Optional[str]:
        return pulumi.get(self, "gather_table_io_waits")

    @property
    @pulumi.getter(name="gatherTableLockWaits")
    def gather_table_lock_waits(self) -> Optional[str]:
        return pulumi.get(self, "gather_table_lock_waits")

    @property
    @pulumi.getter(name="gatherTableSchema")
    def gather_table_schema(self) -> Optional[str]:
        return pulumi.get(self, "gather_table_schema")

    @property
    @pulumi.getter(name="perfEventsStatementsDigestTextLimit")
    def perf_events_statements_digest_text_limit(self) -> Optional[str]:
        return pulumi.get(self, "perf_events_statements_digest_text_limit")

    @property
    @pulumi.getter(name="perfEventsStatementsLimit")
    def perf_events_statements_limit(self) -> Optional[str]:
        return pulumi.get(self, "perf_events_statements_limit")

    @property
    @pulumi.getter(name="perfEventsStatementsTimeLimit")
    def perf_events_statements_time_limit(self) -> Optional[str]:
        return pulumi.get(self, "perf_events_statements_time_limit")


@pulumi.output_type
class ServiceIntegrationMirrormakerUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mirrormakerWhitelist":
            suggest = "mirrormaker_whitelist"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationMirrormakerUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationMirrormakerUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationMirrormakerUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mirrormaker_whitelist: Optional[str] = None):
        """
        :param str mirrormaker_whitelist: Mirrormaker topic whitelist
        """
        if mirrormaker_whitelist is not None:
            pulumi.set(__self__, "mirrormaker_whitelist", mirrormaker_whitelist)

    @property
    @pulumi.getter(name="mirrormakerWhitelist")
    def mirrormaker_whitelist(self) -> Optional[str]:
        """
        Mirrormaker topic whitelist
        """
        return pulumi.get(self, "mirrormaker_whitelist")


@pulumi.output_type
class GetAccountAuthenticationSamlFieldMappingResult(dict):
    def __init__(__self__, *,
                 email: Optional[str] = None,
                 first_name: Optional[str] = None,
                 identity: Optional[str] = None,
                 last_name: Optional[str] = None,
                 real_name: Optional[str] = None):
        if email is not None:
            pulumi.set(__self__, "email", email)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if real_name is not None:
            pulumi.set(__self__, "real_name", real_name)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[str]:
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter
    def identity(self) -> Optional[str]:
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[str]:
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="realName")
    def real_name(self) -> Optional[str]:
        return pulumi.get(self, "real_name")


@pulumi.output_type
class GetCassandaCassandraResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetCassandaCassandraUserConfigResult(dict):
    def __init__(__self__, *,
                 cassandra: Optional['outputs.GetCassandaCassandraUserConfigCassandraResult'] = None,
                 cassandra_version: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 migrate_sstableloader: Optional[str] = None,
                 private_access: Optional['outputs.GetCassandaCassandraUserConfigPrivateAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetCassandaCassandraUserConfigPublicAccessResult'] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        """
        :param 'GetCassandaCassandraUserConfigCassandraArgs' cassandra: Cassandra server provided values
        :param str static_ips: Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        if cassandra is not None:
            pulumi.set(__self__, "cassandra", cassandra)
        if cassandra_version is not None:
            pulumi.set(__self__, "cassandra_version", cassandra_version)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migrate_sstableloader is not None:
            pulumi.set(__self__, "migrate_sstableloader", migrate_sstableloader)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter
    def cassandra(self) -> Optional['outputs.GetCassandaCassandraUserConfigCassandraResult']:
        """
        Cassandra server provided values
        """
        return pulumi.get(self, "cassandra")

    @property
    @pulumi.getter(name="cassandraVersion")
    def cassandra_version(self) -> Optional[str]:
        return pulumi.get(self, "cassandra_version")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="migrateSstableloader")
    def migrate_sstableloader(self) -> Optional[str]:
        return pulumi.get(self, "migrate_sstableloader")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetCassandaCassandraUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetCassandaCassandraUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetCassandaCassandraUserConfigCassandraResult(dict):
    def __init__(__self__, *,
                 batch_size_fail_threshold_in_kb: Optional[str] = None,
                 batch_size_warn_threshold_in_kb: Optional[str] = None):
        if batch_size_fail_threshold_in_kb is not None:
            pulumi.set(__self__, "batch_size_fail_threshold_in_kb", batch_size_fail_threshold_in_kb)
        if batch_size_warn_threshold_in_kb is not None:
            pulumi.set(__self__, "batch_size_warn_threshold_in_kb", batch_size_warn_threshold_in_kb)

    @property
    @pulumi.getter(name="batchSizeFailThresholdInKb")
    def batch_size_fail_threshold_in_kb(self) -> Optional[str]:
        return pulumi.get(self, "batch_size_fail_threshold_in_kb")

    @property
    @pulumi.getter(name="batchSizeWarnThresholdInKb")
    def batch_size_warn_threshold_in_kb(self) -> Optional[str]:
        return pulumi.get(self, "batch_size_warn_threshold_in_kb")


@pulumi.output_type
class GetCassandaCassandraUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetCassandaCassandraUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetCassandaComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetCassandaServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetCassandaTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCassandraCassandraResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetCassandraCassandraUserConfigResult(dict):
    def __init__(__self__, *,
                 cassandra: Optional['outputs.GetCassandraCassandraUserConfigCassandraResult'] = None,
                 cassandra_version: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 migrate_sstableloader: Optional[str] = None,
                 private_access: Optional['outputs.GetCassandraCassandraUserConfigPrivateAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetCassandraCassandraUserConfigPublicAccessResult'] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        """
        :param 'GetCassandraCassandraUserConfigCassandraArgs' cassandra: Cassandra server provided values
        :param str static_ips: Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        if cassandra is not None:
            pulumi.set(__self__, "cassandra", cassandra)
        if cassandra_version is not None:
            pulumi.set(__self__, "cassandra_version", cassandra_version)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migrate_sstableloader is not None:
            pulumi.set(__self__, "migrate_sstableloader", migrate_sstableloader)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter
    def cassandra(self) -> Optional['outputs.GetCassandraCassandraUserConfigCassandraResult']:
        """
        Cassandra server provided values
        """
        return pulumi.get(self, "cassandra")

    @property
    @pulumi.getter(name="cassandraVersion")
    def cassandra_version(self) -> Optional[str]:
        return pulumi.get(self, "cassandra_version")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="migrateSstableloader")
    def migrate_sstableloader(self) -> Optional[str]:
        return pulumi.get(self, "migrate_sstableloader")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetCassandraCassandraUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetCassandraCassandraUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetCassandraCassandraUserConfigCassandraResult(dict):
    def __init__(__self__, *,
                 batch_size_fail_threshold_in_kb: Optional[str] = None,
                 batch_size_warn_threshold_in_kb: Optional[str] = None):
        if batch_size_fail_threshold_in_kb is not None:
            pulumi.set(__self__, "batch_size_fail_threshold_in_kb", batch_size_fail_threshold_in_kb)
        if batch_size_warn_threshold_in_kb is not None:
            pulumi.set(__self__, "batch_size_warn_threshold_in_kb", batch_size_warn_threshold_in_kb)

    @property
    @pulumi.getter(name="batchSizeFailThresholdInKb")
    def batch_size_fail_threshold_in_kb(self) -> Optional[str]:
        return pulumi.get(self, "batch_size_fail_threshold_in_kb")

    @property
    @pulumi.getter(name="batchSizeWarnThresholdInKb")
    def batch_size_warn_threshold_in_kb(self) -> Optional[str]:
        return pulumi.get(self, "batch_size_warn_threshold_in_kb")


@pulumi.output_type
class GetCassandraCassandraUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetCassandraCassandraUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetCassandraComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetCassandraServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetCassandraTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClickhouseClickhouseResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClickhouseClickhouseUserConfigResult(dict):
    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 project_to_fork_from: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None):
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")


@pulumi.output_type
class GetClickhouseComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetClickhouseServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetClickhouseTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFlinkComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetFlinkFlinkResult(dict):
    def __init__(__self__, *,
                 host_ports: Sequence[str]):
        pulumi.set(__self__, "host_ports", host_ports)

    @property
    @pulumi.getter(name="hostPorts")
    def host_ports(self) -> Sequence[str]:
        return pulumi.get(self, "host_ports")


@pulumi.output_type
class GetFlinkFlinkUserConfigResult(dict):
    def __init__(__self__, *,
                 execution_checkpointing_interval_ms: Optional[str] = None,
                 execution_checkpointing_timeout_ms: Optional[str] = None,
                 flink_version: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 number_of_task_slots: Optional[str] = None,
                 parallelism_default: Optional[str] = None,
                 privatelink_access: Optional['outputs.GetFlinkFlinkUserConfigPrivatelinkAccessResult'] = None,
                 restart_strategy: Optional[str] = None,
                 restart_strategy_delay_sec: Optional[str] = None,
                 restart_strategy_failure_rate_interval_min: Optional[str] = None,
                 restart_strategy_max_failures: Optional[str] = None):
        if execution_checkpointing_interval_ms is not None:
            pulumi.set(__self__, "execution_checkpointing_interval_ms", execution_checkpointing_interval_ms)
        if execution_checkpointing_timeout_ms is not None:
            pulumi.set(__self__, "execution_checkpointing_timeout_ms", execution_checkpointing_timeout_ms)
        if flink_version is not None:
            pulumi.set(__self__, "flink_version", flink_version)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if number_of_task_slots is not None:
            pulumi.set(__self__, "number_of_task_slots", number_of_task_slots)
        if parallelism_default is not None:
            pulumi.set(__self__, "parallelism_default", parallelism_default)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if restart_strategy is not None:
            pulumi.set(__self__, "restart_strategy", restart_strategy)
        if restart_strategy_delay_sec is not None:
            pulumi.set(__self__, "restart_strategy_delay_sec", restart_strategy_delay_sec)
        if restart_strategy_failure_rate_interval_min is not None:
            pulumi.set(__self__, "restart_strategy_failure_rate_interval_min", restart_strategy_failure_rate_interval_min)
        if restart_strategy_max_failures is not None:
            pulumi.set(__self__, "restart_strategy_max_failures", restart_strategy_max_failures)

    @property
    @pulumi.getter(name="executionCheckpointingIntervalMs")
    def execution_checkpointing_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "execution_checkpointing_interval_ms")

    @property
    @pulumi.getter(name="executionCheckpointingTimeoutMs")
    def execution_checkpointing_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "execution_checkpointing_timeout_ms")

    @property
    @pulumi.getter(name="flinkVersion")
    def flink_version(self) -> Optional[str]:
        return pulumi.get(self, "flink_version")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="numberOfTaskSlots")
    def number_of_task_slots(self) -> Optional[str]:
        return pulumi.get(self, "number_of_task_slots")

    @property
    @pulumi.getter(name="parallelismDefault")
    def parallelism_default(self) -> Optional[str]:
        return pulumi.get(self, "parallelism_default")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetFlinkFlinkUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="restartStrategy")
    def restart_strategy(self) -> Optional[str]:
        return pulumi.get(self, "restart_strategy")

    @property
    @pulumi.getter(name="restartStrategyDelaySec")
    def restart_strategy_delay_sec(self) -> Optional[str]:
        return pulumi.get(self, "restart_strategy_delay_sec")

    @property
    @pulumi.getter(name="restartStrategyFailureRateIntervalMin")
    def restart_strategy_failure_rate_interval_min(self) -> Optional[str]:
        return pulumi.get(self, "restart_strategy_failure_rate_interval_min")

    @property
    @pulumi.getter(name="restartStrategyMaxFailures")
    def restart_strategy_max_failures(self) -> Optional[str]:
        return pulumi.get(self, "restart_strategy_max_failures")


@pulumi.output_type
class GetFlinkFlinkUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 flink: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str flink: Flink server provided values
        """
        if flink is not None:
            pulumi.set(__self__, "flink", flink)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def flink(self) -> Optional[str]:
        """
        Flink server provided values
        """
        return pulumi.get(self, "flink")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetFlinkServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetFlinkTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGrafanaComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetGrafanaGrafanaResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetGrafanaGrafanaUserConfigResult(dict):
    def __init__(__self__, *,
                 alerting_enabled: Optional[str] = None,
                 alerting_error_or_timeout: Optional[str] = None,
                 alerting_max_annotations_to_keep: Optional[str] = None,
                 alerting_nodata_or_nullvalues: Optional[str] = None,
                 allow_embedding: Optional[str] = None,
                 auth_azuread: Optional['outputs.GetGrafanaGrafanaUserConfigAuthAzureadResult'] = None,
                 auth_basic_enabled: Optional[str] = None,
                 auth_generic_oauth: Optional['outputs.GetGrafanaGrafanaUserConfigAuthGenericOauthResult'] = None,
                 auth_github: Optional['outputs.GetGrafanaGrafanaUserConfigAuthGithubResult'] = None,
                 auth_gitlab: Optional['outputs.GetGrafanaGrafanaUserConfigAuthGitlabResult'] = None,
                 auth_google: Optional['outputs.GetGrafanaGrafanaUserConfigAuthGoogleResult'] = None,
                 cookie_samesite: Optional[str] = None,
                 custom_domain: Optional[str] = None,
                 dashboards_min_refresh_interval: Optional[str] = None,
                 dashboards_versions_to_keep: Optional[str] = None,
                 dataproxy_send_user_header: Optional[str] = None,
                 dataproxy_timeout: Optional[str] = None,
                 date_formats: Optional['outputs.GetGrafanaGrafanaUserConfigDateFormatsResult'] = None,
                 disable_gravatar: Optional[str] = None,
                 editors_can_admin: Optional[str] = None,
                 external_image_storage: Optional['outputs.GetGrafanaGrafanaUserConfigExternalImageStorageResult'] = None,
                 google_analytics_ua_id: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 metrics_enabled: Optional[str] = None,
                 private_access: Optional['outputs.GetGrafanaGrafanaUserConfigPrivateAccessResult'] = None,
                 privatelink_access: Optional['outputs.GetGrafanaGrafanaUserConfigPrivatelinkAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetGrafanaGrafanaUserConfigPublicAccessResult'] = None,
                 recovery_basebackup_name: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 smtp_server: Optional['outputs.GetGrafanaGrafanaUserConfigSmtpServerResult'] = None,
                 static_ips: Optional[str] = None,
                 user_auto_assign_org: Optional[str] = None,
                 user_auto_assign_org_role: Optional[str] = None,
                 viewers_can_edit: Optional[str] = None):
        """
        :param str static_ips: Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        if alerting_enabled is not None:
            pulumi.set(__self__, "alerting_enabled", alerting_enabled)
        if alerting_error_or_timeout is not None:
            pulumi.set(__self__, "alerting_error_or_timeout", alerting_error_or_timeout)
        if alerting_max_annotations_to_keep is not None:
            pulumi.set(__self__, "alerting_max_annotations_to_keep", alerting_max_annotations_to_keep)
        if alerting_nodata_or_nullvalues is not None:
            pulumi.set(__self__, "alerting_nodata_or_nullvalues", alerting_nodata_or_nullvalues)
        if allow_embedding is not None:
            pulumi.set(__self__, "allow_embedding", allow_embedding)
        if auth_azuread is not None:
            pulumi.set(__self__, "auth_azuread", auth_azuread)
        if auth_basic_enabled is not None:
            pulumi.set(__self__, "auth_basic_enabled", auth_basic_enabled)
        if auth_generic_oauth is not None:
            pulumi.set(__self__, "auth_generic_oauth", auth_generic_oauth)
        if auth_github is not None:
            pulumi.set(__self__, "auth_github", auth_github)
        if auth_gitlab is not None:
            pulumi.set(__self__, "auth_gitlab", auth_gitlab)
        if auth_google is not None:
            pulumi.set(__self__, "auth_google", auth_google)
        if cookie_samesite is not None:
            pulumi.set(__self__, "cookie_samesite", cookie_samesite)
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if dashboards_min_refresh_interval is not None:
            pulumi.set(__self__, "dashboards_min_refresh_interval", dashboards_min_refresh_interval)
        if dashboards_versions_to_keep is not None:
            pulumi.set(__self__, "dashboards_versions_to_keep", dashboards_versions_to_keep)
        if dataproxy_send_user_header is not None:
            pulumi.set(__self__, "dataproxy_send_user_header", dataproxy_send_user_header)
        if dataproxy_timeout is not None:
            pulumi.set(__self__, "dataproxy_timeout", dataproxy_timeout)
        if date_formats is not None:
            pulumi.set(__self__, "date_formats", date_formats)
        if disable_gravatar is not None:
            pulumi.set(__self__, "disable_gravatar", disable_gravatar)
        if editors_can_admin is not None:
            pulumi.set(__self__, "editors_can_admin", editors_can_admin)
        if external_image_storage is not None:
            pulumi.set(__self__, "external_image_storage", external_image_storage)
        if google_analytics_ua_id is not None:
            pulumi.set(__self__, "google_analytics_ua_id", google_analytics_ua_id)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if metrics_enabled is not None:
            pulumi.set(__self__, "metrics_enabled", metrics_enabled)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_basebackup_name is not None:
            pulumi.set(__self__, "recovery_basebackup_name", recovery_basebackup_name)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if smtp_server is not None:
            pulumi.set(__self__, "smtp_server", smtp_server)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)
        if user_auto_assign_org is not None:
            pulumi.set(__self__, "user_auto_assign_org", user_auto_assign_org)
        if user_auto_assign_org_role is not None:
            pulumi.set(__self__, "user_auto_assign_org_role", user_auto_assign_org_role)
        if viewers_can_edit is not None:
            pulumi.set(__self__, "viewers_can_edit", viewers_can_edit)

    @property
    @pulumi.getter(name="alertingEnabled")
    def alerting_enabled(self) -> Optional[str]:
        return pulumi.get(self, "alerting_enabled")

    @property
    @pulumi.getter(name="alertingErrorOrTimeout")
    def alerting_error_or_timeout(self) -> Optional[str]:
        return pulumi.get(self, "alerting_error_or_timeout")

    @property
    @pulumi.getter(name="alertingMaxAnnotationsToKeep")
    def alerting_max_annotations_to_keep(self) -> Optional[str]:
        return pulumi.get(self, "alerting_max_annotations_to_keep")

    @property
    @pulumi.getter(name="alertingNodataOrNullvalues")
    def alerting_nodata_or_nullvalues(self) -> Optional[str]:
        return pulumi.get(self, "alerting_nodata_or_nullvalues")

    @property
    @pulumi.getter(name="allowEmbedding")
    def allow_embedding(self) -> Optional[str]:
        return pulumi.get(self, "allow_embedding")

    @property
    @pulumi.getter(name="authAzuread")
    def auth_azuread(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigAuthAzureadResult']:
        return pulumi.get(self, "auth_azuread")

    @property
    @pulumi.getter(name="authBasicEnabled")
    def auth_basic_enabled(self) -> Optional[str]:
        return pulumi.get(self, "auth_basic_enabled")

    @property
    @pulumi.getter(name="authGenericOauth")
    def auth_generic_oauth(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigAuthGenericOauthResult']:
        return pulumi.get(self, "auth_generic_oauth")

    @property
    @pulumi.getter(name="authGithub")
    def auth_github(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigAuthGithubResult']:
        return pulumi.get(self, "auth_github")

    @property
    @pulumi.getter(name="authGitlab")
    def auth_gitlab(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigAuthGitlabResult']:
        return pulumi.get(self, "auth_gitlab")

    @property
    @pulumi.getter(name="authGoogle")
    def auth_google(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigAuthGoogleResult']:
        return pulumi.get(self, "auth_google")

    @property
    @pulumi.getter(name="cookieSamesite")
    def cookie_samesite(self) -> Optional[str]:
        return pulumi.get(self, "cookie_samesite")

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="dashboardsMinRefreshInterval")
    def dashboards_min_refresh_interval(self) -> Optional[str]:
        return pulumi.get(self, "dashboards_min_refresh_interval")

    @property
    @pulumi.getter(name="dashboardsVersionsToKeep")
    def dashboards_versions_to_keep(self) -> Optional[str]:
        return pulumi.get(self, "dashboards_versions_to_keep")

    @property
    @pulumi.getter(name="dataproxySendUserHeader")
    def dataproxy_send_user_header(self) -> Optional[str]:
        return pulumi.get(self, "dataproxy_send_user_header")

    @property
    @pulumi.getter(name="dataproxyTimeout")
    def dataproxy_timeout(self) -> Optional[str]:
        return pulumi.get(self, "dataproxy_timeout")

    @property
    @pulumi.getter(name="dateFormats")
    def date_formats(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigDateFormatsResult']:
        return pulumi.get(self, "date_formats")

    @property
    @pulumi.getter(name="disableGravatar")
    def disable_gravatar(self) -> Optional[str]:
        return pulumi.get(self, "disable_gravatar")

    @property
    @pulumi.getter(name="editorsCanAdmin")
    def editors_can_admin(self) -> Optional[str]:
        return pulumi.get(self, "editors_can_admin")

    @property
    @pulumi.getter(name="externalImageStorage")
    def external_image_storage(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigExternalImageStorageResult']:
        return pulumi.get(self, "external_image_storage")

    @property
    @pulumi.getter(name="googleAnalyticsUaId")
    def google_analytics_ua_id(self) -> Optional[str]:
        return pulumi.get(self, "google_analytics_ua_id")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="metricsEnabled")
    def metrics_enabled(self) -> Optional[str]:
        return pulumi.get(self, "metrics_enabled")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryBasebackupName")
    def recovery_basebackup_name(self) -> Optional[str]:
        return pulumi.get(self, "recovery_basebackup_name")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="smtpServer")
    def smtp_server(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigSmtpServerResult']:
        return pulumi.get(self, "smtp_server")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        return pulumi.get(self, "static_ips")

    @property
    @pulumi.getter(name="userAutoAssignOrg")
    def user_auto_assign_org(self) -> Optional[str]:
        return pulumi.get(self, "user_auto_assign_org")

    @property
    @pulumi.getter(name="userAutoAssignOrgRole")
    def user_auto_assign_org_role(self) -> Optional[str]:
        return pulumi.get(self, "user_auto_assign_org_role")

    @property
    @pulumi.getter(name="viewersCanEdit")
    def viewers_can_edit(self) -> Optional[str]:
        return pulumi.get(self, "viewers_can_edit")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigAuthAzureadResult(dict):
    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_domains: Optional[Sequence[str]] = None,
                 allowed_groups: Optional[Sequence[str]] = None,
                 auth_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 token_url: Optional[str] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_domains")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        return pulumi.get(self, "token_url")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigAuthGenericOauthResult(dict):
    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_domains: Optional[Sequence[str]] = None,
                 allowed_organizations: Optional[Sequence[str]] = None,
                 api_url: Optional[str] = None,
                 auth_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 name: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 token_url: Optional[str] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if allowed_organizations is not None:
            pulumi.set(__self__, "allowed_organizations", allowed_organizations)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_domains")

    @property
    @pulumi.getter(name="allowedOrganizations")
    def allowed_organizations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_organizations")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        return pulumi.get(self, "token_url")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigAuthGithubResult(dict):
    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_organizations: Optional[Sequence[str]] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 team_ids: Optional[Sequence[str]] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_organizations is not None:
            pulumi.set(__self__, "allowed_organizations", allowed_organizations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if team_ids is not None:
            pulumi.set(__self__, "team_ids", team_ids)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedOrganizations")
    def allowed_organizations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_organizations")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="teamIds")
    def team_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "team_ids")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigAuthGitlabResult(dict):
    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_groups: Optional[Sequence[str]] = None,
                 api_url: Optional[str] = None,
                 auth_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 token_url: Optional[str] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        return pulumi.get(self, "token_url")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigAuthGoogleResult(dict):
    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_domains: Optional[Sequence[str]] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_domains")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigDateFormatsResult(dict):
    def __init__(__self__, *,
                 default_timezone: Optional[str] = None,
                 full_date: Optional[str] = None,
                 interval_day: Optional[str] = None,
                 interval_hour: Optional[str] = None,
                 interval_minute: Optional[str] = None,
                 interval_month: Optional[str] = None,
                 interval_second: Optional[str] = None,
                 interval_year: Optional[str] = None):
        if default_timezone is not None:
            pulumi.set(__self__, "default_timezone", default_timezone)
        if full_date is not None:
            pulumi.set(__self__, "full_date", full_date)
        if interval_day is not None:
            pulumi.set(__self__, "interval_day", interval_day)
        if interval_hour is not None:
            pulumi.set(__self__, "interval_hour", interval_hour)
        if interval_minute is not None:
            pulumi.set(__self__, "interval_minute", interval_minute)
        if interval_month is not None:
            pulumi.set(__self__, "interval_month", interval_month)
        if interval_second is not None:
            pulumi.set(__self__, "interval_second", interval_second)
        if interval_year is not None:
            pulumi.set(__self__, "interval_year", interval_year)

    @property
    @pulumi.getter(name="defaultTimezone")
    def default_timezone(self) -> Optional[str]:
        return pulumi.get(self, "default_timezone")

    @property
    @pulumi.getter(name="fullDate")
    def full_date(self) -> Optional[str]:
        return pulumi.get(self, "full_date")

    @property
    @pulumi.getter(name="intervalDay")
    def interval_day(self) -> Optional[str]:
        return pulumi.get(self, "interval_day")

    @property
    @pulumi.getter(name="intervalHour")
    def interval_hour(self) -> Optional[str]:
        return pulumi.get(self, "interval_hour")

    @property
    @pulumi.getter(name="intervalMinute")
    def interval_minute(self) -> Optional[str]:
        return pulumi.get(self, "interval_minute")

    @property
    @pulumi.getter(name="intervalMonth")
    def interval_month(self) -> Optional[str]:
        return pulumi.get(self, "interval_month")

    @property
    @pulumi.getter(name="intervalSecond")
    def interval_second(self) -> Optional[str]:
        return pulumi.get(self, "interval_second")

    @property
    @pulumi.getter(name="intervalYear")
    def interval_year(self) -> Optional[str]:
        return pulumi.get(self, "interval_year")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigExternalImageStorageResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 bucket_url: Optional[str] = None,
                 provider: Optional[str] = None,
                 secret_key: Optional[str] = None):
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bucket_url is not None:
            pulumi.set(__self__, "bucket_url", bucket_url)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bucketUrl")
    def bucket_url(self) -> Optional[str]:
        return pulumi.get(self, "bucket_url")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 grafana: Optional[str] = None):
        """
        :param str grafana: Grafana server provided values
        """
        if grafana is not None:
            pulumi.set(__self__, "grafana", grafana)

    @property
    @pulumi.getter
    def grafana(self) -> Optional[str]:
        """
        Grafana server provided values
        """
        return pulumi.get(self, "grafana")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 grafana: Optional[str] = None):
        """
        :param str grafana: Grafana server provided values
        """
        if grafana is not None:
            pulumi.set(__self__, "grafana", grafana)

    @property
    @pulumi.getter
    def grafana(self) -> Optional[str]:
        """
        Grafana server provided values
        """
        return pulumi.get(self, "grafana")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 grafana: Optional[str] = None):
        """
        :param str grafana: Grafana server provided values
        """
        if grafana is not None:
            pulumi.set(__self__, "grafana", grafana)

    @property
    @pulumi.getter
    def grafana(self) -> Optional[str]:
        """
        Grafana server provided values
        """
        return pulumi.get(self, "grafana")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigSmtpServerResult(dict):
    def __init__(__self__, *,
                 from_address: Optional[str] = None,
                 from_name: Optional[str] = None,
                 host: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 skip_verify: Optional[str] = None,
                 starttls_policy: Optional[str] = None,
                 username: Optional[str] = None):
        if from_address is not None:
            pulumi.set(__self__, "from_address", from_address)
        if from_name is not None:
            pulumi.set(__self__, "from_name", from_name)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if skip_verify is not None:
            pulumi.set(__self__, "skip_verify", skip_verify)
        if starttls_policy is not None:
            pulumi.set(__self__, "starttls_policy", starttls_policy)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="fromAddress")
    def from_address(self) -> Optional[str]:
        return pulumi.get(self, "from_address")

    @property
    @pulumi.getter(name="fromName")
    def from_name(self) -> Optional[str]:
        return pulumi.get(self, "from_name")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="skipVerify")
    def skip_verify(self) -> Optional[str]:
        return pulumi.get(self, "skip_verify")

    @property
    @pulumi.getter(name="starttlsPolicy")
    def starttls_policy(self) -> Optional[str]:
        return pulumi.get(self, "starttls_policy")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetGrafanaServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetGrafanaTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetInfluxDbComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetInfluxDbInfluxdbResult(dict):
    def __init__(__self__, *,
                 database_name: str):
        pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetInfluxDbInfluxdbUserConfigResult(dict):
    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 influxdb: Optional['outputs.GetInfluxDbInfluxdbUserConfigInfluxdbResult'] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 private_access: Optional['outputs.GetInfluxDbInfluxdbUserConfigPrivateAccessResult'] = None,
                 privatelink_access: Optional['outputs.GetInfluxDbInfluxdbUserConfigPrivatelinkAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetInfluxDbInfluxdbUserConfigPublicAccessResult'] = None,
                 recovery_basebackup_name: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        """
        :param 'GetInfluxDbInfluxdbUserConfigInfluxdbArgs' influxdb: InfluxDB server provided values
        :param str static_ips: Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if influxdb is not None:
            pulumi.set(__self__, "influxdb", influxdb)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_basebackup_name is not None:
            pulumi.set(__self__, "recovery_basebackup_name", recovery_basebackup_name)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter
    def influxdb(self) -> Optional['outputs.GetInfluxDbInfluxdbUserConfigInfluxdbResult']:
        """
        InfluxDB server provided values
        """
        return pulumi.get(self, "influxdb")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetInfluxDbInfluxdbUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetInfluxDbInfluxdbUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetInfluxDbInfluxdbUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryBasebackupName")
    def recovery_basebackup_name(self) -> Optional[str]:
        return pulumi.get(self, "recovery_basebackup_name")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetInfluxDbInfluxdbUserConfigInfluxdbResult(dict):
    def __init__(__self__, *,
                 log_queries_after: Optional[str] = None,
                 max_connection_limit: Optional[str] = None,
                 max_row_limit: Optional[str] = None,
                 max_select_buckets: Optional[str] = None,
                 max_select_point: Optional[str] = None,
                 query_timeout: Optional[str] = None):
        if log_queries_after is not None:
            pulumi.set(__self__, "log_queries_after", log_queries_after)
        if max_connection_limit is not None:
            pulumi.set(__self__, "max_connection_limit", max_connection_limit)
        if max_row_limit is not None:
            pulumi.set(__self__, "max_row_limit", max_row_limit)
        if max_select_buckets is not None:
            pulumi.set(__self__, "max_select_buckets", max_select_buckets)
        if max_select_point is not None:
            pulumi.set(__self__, "max_select_point", max_select_point)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)

    @property
    @pulumi.getter(name="logQueriesAfter")
    def log_queries_after(self) -> Optional[str]:
        return pulumi.get(self, "log_queries_after")

    @property
    @pulumi.getter(name="maxConnectionLimit")
    def max_connection_limit(self) -> Optional[str]:
        return pulumi.get(self, "max_connection_limit")

    @property
    @pulumi.getter(name="maxRowLimit")
    def max_row_limit(self) -> Optional[str]:
        return pulumi.get(self, "max_row_limit")

    @property
    @pulumi.getter(name="maxSelectBuckets")
    def max_select_buckets(self) -> Optional[str]:
        return pulumi.get(self, "max_select_buckets")

    @property
    @pulumi.getter(name="maxSelectPoint")
    def max_select_point(self) -> Optional[str]:
        return pulumi.get(self, "max_select_point")

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[str]:
        return pulumi.get(self, "query_timeout")


@pulumi.output_type
class GetInfluxDbInfluxdbUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 influxdb: Optional[str] = None):
        """
        :param str influxdb: InfluxDB server provided values
        """
        if influxdb is not None:
            pulumi.set(__self__, "influxdb", influxdb)

    @property
    @pulumi.getter
    def influxdb(self) -> Optional[str]:
        """
        InfluxDB server provided values
        """
        return pulumi.get(self, "influxdb")


@pulumi.output_type
class GetInfluxDbInfluxdbUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 influxdb: Optional[str] = None):
        """
        :param str influxdb: InfluxDB server provided values
        """
        if influxdb is not None:
            pulumi.set(__self__, "influxdb", influxdb)

    @property
    @pulumi.getter
    def influxdb(self) -> Optional[str]:
        """
        InfluxDB server provided values
        """
        return pulumi.get(self, "influxdb")


@pulumi.output_type
class GetInfluxDbInfluxdbUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 influxdb: Optional[str] = None):
        """
        :param str influxdb: InfluxDB server provided values
        """
        if influxdb is not None:
            pulumi.set(__self__, "influxdb", influxdb)

    @property
    @pulumi.getter
    def influxdb(self) -> Optional[str]:
        """
        InfluxDB server provided values
        """
        return pulumi.get(self, "influxdb")


@pulumi.output_type
class GetInfluxDbServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetInfluxDbTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetKafkaComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetKafkaConnectComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetKafkaConnectKafkaConnectResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetKafkaConnectKafkaConnectUserConfigResult(dict):
    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka_connect: Optional['outputs.GetKafkaConnectKafkaConnectUserConfigKafkaConnectResult'] = None,
                 private_access: Optional['outputs.GetKafkaConnectKafkaConnectUserConfigPrivateAccessResult'] = None,
                 privatelink_access: Optional['outputs.GetKafkaConnectKafkaConnectUserConfigPrivatelinkAccessResult'] = None,
                 public_access: Optional['outputs.GetKafkaConnectKafkaConnectUserConfigPublicAccessResult'] = None,
                 static_ips: Optional[str] = None):
        """
        :param 'GetKafkaConnectKafkaConnectUserConfigKafkaConnectArgs' kafka_connect: Kafka Connect server provided values
        :param str static_ips: Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional['outputs.GetKafkaConnectKafkaConnectUserConfigKafkaConnectResult']:
        """
        Kafka Connect server provided values
        """
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetKafkaConnectKafkaConnectUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetKafkaConnectKafkaConnectUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetKafkaConnectKafkaConnectUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetKafkaConnectKafkaConnectUserConfigKafkaConnectResult(dict):
    def __init__(__self__, *,
                 connector_client_config_override_policy: Optional[str] = None,
                 consumer_auto_offset_reset: Optional[str] = None,
                 consumer_fetch_max_bytes: Optional[str] = None,
                 consumer_isolation_level: Optional[str] = None,
                 consumer_max_partition_fetch_bytes: Optional[str] = None,
                 consumer_max_poll_interval_ms: Optional[str] = None,
                 consumer_max_poll_records: Optional[str] = None,
                 offset_flush_interval_ms: Optional[str] = None,
                 offset_flush_timeout_ms: Optional[str] = None,
                 producer_compression_type: Optional[str] = None,
                 producer_max_request_size: Optional[str] = None,
                 session_timeout_ms: Optional[str] = None):
        if connector_client_config_override_policy is not None:
            pulumi.set(__self__, "connector_client_config_override_policy", connector_client_config_override_policy)
        if consumer_auto_offset_reset is not None:
            pulumi.set(__self__, "consumer_auto_offset_reset", consumer_auto_offset_reset)
        if consumer_fetch_max_bytes is not None:
            pulumi.set(__self__, "consumer_fetch_max_bytes", consumer_fetch_max_bytes)
        if consumer_isolation_level is not None:
            pulumi.set(__self__, "consumer_isolation_level", consumer_isolation_level)
        if consumer_max_partition_fetch_bytes is not None:
            pulumi.set(__self__, "consumer_max_partition_fetch_bytes", consumer_max_partition_fetch_bytes)
        if consumer_max_poll_interval_ms is not None:
            pulumi.set(__self__, "consumer_max_poll_interval_ms", consumer_max_poll_interval_ms)
        if consumer_max_poll_records is not None:
            pulumi.set(__self__, "consumer_max_poll_records", consumer_max_poll_records)
        if offset_flush_interval_ms is not None:
            pulumi.set(__self__, "offset_flush_interval_ms", offset_flush_interval_ms)
        if offset_flush_timeout_ms is not None:
            pulumi.set(__self__, "offset_flush_timeout_ms", offset_flush_timeout_ms)
        if producer_compression_type is not None:
            pulumi.set(__self__, "producer_compression_type", producer_compression_type)
        if producer_max_request_size is not None:
            pulumi.set(__self__, "producer_max_request_size", producer_max_request_size)
        if session_timeout_ms is not None:
            pulumi.set(__self__, "session_timeout_ms", session_timeout_ms)

    @property
    @pulumi.getter(name="connectorClientConfigOverridePolicy")
    def connector_client_config_override_policy(self) -> Optional[str]:
        return pulumi.get(self, "connector_client_config_override_policy")

    @property
    @pulumi.getter(name="consumerAutoOffsetReset")
    def consumer_auto_offset_reset(self) -> Optional[str]:
        return pulumi.get(self, "consumer_auto_offset_reset")

    @property
    @pulumi.getter(name="consumerFetchMaxBytes")
    def consumer_fetch_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_fetch_max_bytes")

    @property
    @pulumi.getter(name="consumerIsolationLevel")
    def consumer_isolation_level(self) -> Optional[str]:
        return pulumi.get(self, "consumer_isolation_level")

    @property
    @pulumi.getter(name="consumerMaxPartitionFetchBytes")
    def consumer_max_partition_fetch_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_partition_fetch_bytes")

    @property
    @pulumi.getter(name="consumerMaxPollIntervalMs")
    def consumer_max_poll_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_poll_interval_ms")

    @property
    @pulumi.getter(name="consumerMaxPollRecords")
    def consumer_max_poll_records(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_poll_records")

    @property
    @pulumi.getter(name="offsetFlushIntervalMs")
    def offset_flush_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "offset_flush_interval_ms")

    @property
    @pulumi.getter(name="offsetFlushTimeoutMs")
    def offset_flush_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "offset_flush_timeout_ms")

    @property
    @pulumi.getter(name="producerCompressionType")
    def producer_compression_type(self) -> Optional[str]:
        return pulumi.get(self, "producer_compression_type")

    @property
    @pulumi.getter(name="producerMaxRequestSize")
    def producer_max_request_size(self) -> Optional[str]:
        return pulumi.get(self, "producer_max_request_size")

    @property
    @pulumi.getter(name="sessionTimeoutMs")
    def session_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "session_timeout_ms")


@pulumi.output_type
class GetKafkaConnectKafkaConnectUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 kafka_connect: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str kafka_connect: Kafka Connect server provided values
        """
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        """
        Kafka Connect server provided values
        """
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetKafkaConnectKafkaConnectUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 jolokia: Optional[str] = None,
                 kafka_connect: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str kafka_connect: Kafka Connect server provided values
        """
        if jolokia is not None:
            pulumi.set(__self__, "jolokia", jolokia)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def jolokia(self) -> Optional[str]:
        return pulumi.get(self, "jolokia")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        """
        Kafka Connect server provided values
        """
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetKafkaConnectKafkaConnectUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 kafka_connect: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str kafka_connect: Kafka Connect server provided values
        """
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        """
        Kafka Connect server provided values
        """
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetKafkaConnectServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetKafkaConnectTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetKafkaConnectorTaskResult(dict):
    def __init__(__self__, *,
                 connector: str,
                 task: int):
        """
        :param int task: List of tasks of a connector.
        """
        pulumi.set(__self__, "connector", connector)
        pulumi.set(__self__, "task", task)

    @property
    @pulumi.getter
    def connector(self) -> str:
        return pulumi.get(self, "connector")

    @property
    @pulumi.getter
    def task(self) -> int:
        """
        List of tasks of a connector.
        """
        return pulumi.get(self, "task")


@pulumi.output_type
class GetKafkaKafkaResult(dict):
    def __init__(__self__, *,
                 access_cert: str,
                 access_key: str,
                 connect_uri: str,
                 rest_uri: str,
                 schema_registry_uri: str):
        pulumi.set(__self__, "access_cert", access_cert)
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "connect_uri", connect_uri)
        pulumi.set(__self__, "rest_uri", rest_uri)
        pulumi.set(__self__, "schema_registry_uri", schema_registry_uri)

    @property
    @pulumi.getter(name="accessCert")
    def access_cert(self) -> str:
        return pulumi.get(self, "access_cert")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="connectUri")
    def connect_uri(self) -> str:
        return pulumi.get(self, "connect_uri")

    @property
    @pulumi.getter(name="restUri")
    def rest_uri(self) -> str:
        return pulumi.get(self, "rest_uri")

    @property
    @pulumi.getter(name="schemaRegistryUri")
    def schema_registry_uri(self) -> str:
        return pulumi.get(self, "schema_registry_uri")


@pulumi.output_type
class GetKafkaKafkaUserConfigResult(dict):
    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka: Optional['outputs.GetKafkaKafkaUserConfigKafkaResult'] = None,
                 kafka_authentication_methods: Optional['outputs.GetKafkaKafkaUserConfigKafkaAuthenticationMethodsResult'] = None,
                 kafka_connect: Optional[str] = None,
                 kafka_connect_config: Optional['outputs.GetKafkaKafkaUserConfigKafkaConnectConfigResult'] = None,
                 kafka_rest: Optional[str] = None,
                 kafka_rest_config: Optional['outputs.GetKafkaKafkaUserConfigKafkaRestConfigResult'] = None,
                 kafka_version: Optional[str] = None,
                 private_access: Optional['outputs.GetKafkaKafkaUserConfigPrivateAccessResult'] = None,
                 privatelink_access: Optional['outputs.GetKafkaKafkaUserConfigPrivatelinkAccessResult'] = None,
                 public_access: Optional['outputs.GetKafkaKafkaUserConfigPublicAccessResult'] = None,
                 schema_registry: Optional[str] = None,
                 schema_registry_config: Optional['outputs.GetKafkaKafkaUserConfigSchemaRegistryConfigResult'] = None,
                 static_ips: Optional[str] = None):
        """
        :param 'GetKafkaKafkaUserConfigKafkaArgs' kafka: Kafka server provided values
        :param str static_ips: Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kafka_authentication_methods is not None:
            pulumi.set(__self__, "kafka_authentication_methods", kafka_authentication_methods)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if kafka_connect_config is not None:
            pulumi.set(__self__, "kafka_connect_config", kafka_connect_config)
        if kafka_rest is not None:
            pulumi.set(__self__, "kafka_rest", kafka_rest)
        if kafka_rest_config is not None:
            pulumi.set(__self__, "kafka_rest_config", kafka_rest_config)
        if kafka_version is not None:
            pulumi.set(__self__, "kafka_version", kafka_version)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)
        if schema_registry_config is not None:
            pulumi.set(__self__, "schema_registry_config", schema_registry_config)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def kafka(self) -> Optional['outputs.GetKafkaKafkaUserConfigKafkaResult']:
        """
        Kafka server provided values
        """
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethods")
    def kafka_authentication_methods(self) -> Optional['outputs.GetKafkaKafkaUserConfigKafkaAuthenticationMethodsResult']:
        return pulumi.get(self, "kafka_authentication_methods")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter(name="kafkaConnectConfig")
    def kafka_connect_config(self) -> Optional['outputs.GetKafkaKafkaUserConfigKafkaConnectConfigResult']:
        return pulumi.get(self, "kafka_connect_config")

    @property
    @pulumi.getter(name="kafkaRest")
    def kafka_rest(self) -> Optional[str]:
        return pulumi.get(self, "kafka_rest")

    @property
    @pulumi.getter(name="kafkaRestConfig")
    def kafka_rest_config(self) -> Optional['outputs.GetKafkaKafkaUserConfigKafkaRestConfigResult']:
        return pulumi.get(self, "kafka_rest_config")

    @property
    @pulumi.getter(name="kafkaVersion")
    def kafka_version(self) -> Optional[str]:
        return pulumi.get(self, "kafka_version")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetKafkaKafkaUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetKafkaKafkaUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetKafkaKafkaUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[str]:
        return pulumi.get(self, "schema_registry")

    @property
    @pulumi.getter(name="schemaRegistryConfig")
    def schema_registry_config(self) -> Optional['outputs.GetKafkaKafkaUserConfigSchemaRegistryConfigResult']:
        return pulumi.get(self, "schema_registry_config")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetKafkaKafkaUserConfigKafkaResult(dict):
    def __init__(__self__, *,
                 auto_create_topics_enable: Optional[str] = None,
                 compression_type: Optional[str] = None,
                 connections_max_idle_ms: Optional[str] = None,
                 default_replication_factor: Optional[str] = None,
                 group_initial_rebalance_delay_ms: Optional[str] = None,
                 group_max_session_timeout_ms: Optional[str] = None,
                 group_min_session_timeout_ms: Optional[str] = None,
                 log_cleaner_delete_retention_ms: Optional[str] = None,
                 log_cleaner_max_compaction_lag_ms: Optional[str] = None,
                 log_cleaner_min_cleanable_ratio: Optional[str] = None,
                 log_cleaner_min_compaction_lag_ms: Optional[str] = None,
                 log_cleanup_policy: Optional[str] = None,
                 log_flush_interval_messages: Optional[str] = None,
                 log_flush_interval_ms: Optional[str] = None,
                 log_index_interval_bytes: Optional[str] = None,
                 log_index_size_max_bytes: Optional[str] = None,
                 log_message_downconversion_enable: Optional[str] = None,
                 log_message_timestamp_difference_max_ms: Optional[str] = None,
                 log_message_timestamp_type: Optional[str] = None,
                 log_preallocate: Optional[str] = None,
                 log_retention_bytes: Optional[str] = None,
                 log_retention_hours: Optional[str] = None,
                 log_retention_ms: Optional[str] = None,
                 log_roll_jitter_ms: Optional[str] = None,
                 log_roll_ms: Optional[str] = None,
                 log_segment_bytes: Optional[str] = None,
                 log_segment_delete_delay_ms: Optional[str] = None,
                 max_connections_per_ip: Optional[str] = None,
                 max_incremental_fetch_session_cache_slots: Optional[str] = None,
                 message_max_bytes: Optional[str] = None,
                 min_insync_replicas: Optional[str] = None,
                 num_partitions: Optional[str] = None,
                 offsets_retention_minutes: Optional[str] = None,
                 producer_purgatory_purge_interval_requests: Optional[str] = None,
                 replica_fetch_max_bytes: Optional[str] = None,
                 replica_fetch_response_max_bytes: Optional[str] = None,
                 socket_request_max_bytes: Optional[str] = None,
                 transaction_remove_expired_transaction_cleanup_interval_ms: Optional[str] = None,
                 transaction_state_log_segment_bytes: Optional[str] = None):
        if auto_create_topics_enable is not None:
            pulumi.set(__self__, "auto_create_topics_enable", auto_create_topics_enable)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if connections_max_idle_ms is not None:
            pulumi.set(__self__, "connections_max_idle_ms", connections_max_idle_ms)
        if default_replication_factor is not None:
            pulumi.set(__self__, "default_replication_factor", default_replication_factor)
        if group_initial_rebalance_delay_ms is not None:
            pulumi.set(__self__, "group_initial_rebalance_delay_ms", group_initial_rebalance_delay_ms)
        if group_max_session_timeout_ms is not None:
            pulumi.set(__self__, "group_max_session_timeout_ms", group_max_session_timeout_ms)
        if group_min_session_timeout_ms is not None:
            pulumi.set(__self__, "group_min_session_timeout_ms", group_min_session_timeout_ms)
        if log_cleaner_delete_retention_ms is not None:
            pulumi.set(__self__, "log_cleaner_delete_retention_ms", log_cleaner_delete_retention_ms)
        if log_cleaner_max_compaction_lag_ms is not None:
            pulumi.set(__self__, "log_cleaner_max_compaction_lag_ms", log_cleaner_max_compaction_lag_ms)
        if log_cleaner_min_cleanable_ratio is not None:
            pulumi.set(__self__, "log_cleaner_min_cleanable_ratio", log_cleaner_min_cleanable_ratio)
        if log_cleaner_min_compaction_lag_ms is not None:
            pulumi.set(__self__, "log_cleaner_min_compaction_lag_ms", log_cleaner_min_compaction_lag_ms)
        if log_cleanup_policy is not None:
            pulumi.set(__self__, "log_cleanup_policy", log_cleanup_policy)
        if log_flush_interval_messages is not None:
            pulumi.set(__self__, "log_flush_interval_messages", log_flush_interval_messages)
        if log_flush_interval_ms is not None:
            pulumi.set(__self__, "log_flush_interval_ms", log_flush_interval_ms)
        if log_index_interval_bytes is not None:
            pulumi.set(__self__, "log_index_interval_bytes", log_index_interval_bytes)
        if log_index_size_max_bytes is not None:
            pulumi.set(__self__, "log_index_size_max_bytes", log_index_size_max_bytes)
        if log_message_downconversion_enable is not None:
            pulumi.set(__self__, "log_message_downconversion_enable", log_message_downconversion_enable)
        if log_message_timestamp_difference_max_ms is not None:
            pulumi.set(__self__, "log_message_timestamp_difference_max_ms", log_message_timestamp_difference_max_ms)
        if log_message_timestamp_type is not None:
            pulumi.set(__self__, "log_message_timestamp_type", log_message_timestamp_type)
        if log_preallocate is not None:
            pulumi.set(__self__, "log_preallocate", log_preallocate)
        if log_retention_bytes is not None:
            pulumi.set(__self__, "log_retention_bytes", log_retention_bytes)
        if log_retention_hours is not None:
            pulumi.set(__self__, "log_retention_hours", log_retention_hours)
        if log_retention_ms is not None:
            pulumi.set(__self__, "log_retention_ms", log_retention_ms)
        if log_roll_jitter_ms is not None:
            pulumi.set(__self__, "log_roll_jitter_ms", log_roll_jitter_ms)
        if log_roll_ms is not None:
            pulumi.set(__self__, "log_roll_ms", log_roll_ms)
        if log_segment_bytes is not None:
            pulumi.set(__self__, "log_segment_bytes", log_segment_bytes)
        if log_segment_delete_delay_ms is not None:
            pulumi.set(__self__, "log_segment_delete_delay_ms", log_segment_delete_delay_ms)
        if max_connections_per_ip is not None:
            pulumi.set(__self__, "max_connections_per_ip", max_connections_per_ip)
        if max_incremental_fetch_session_cache_slots is not None:
            pulumi.set(__self__, "max_incremental_fetch_session_cache_slots", max_incremental_fetch_session_cache_slots)
        if message_max_bytes is not None:
            pulumi.set(__self__, "message_max_bytes", message_max_bytes)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if num_partitions is not None:
            pulumi.set(__self__, "num_partitions", num_partitions)
        if offsets_retention_minutes is not None:
            pulumi.set(__self__, "offsets_retention_minutes", offsets_retention_minutes)
        if producer_purgatory_purge_interval_requests is not None:
            pulumi.set(__self__, "producer_purgatory_purge_interval_requests", producer_purgatory_purge_interval_requests)
        if replica_fetch_max_bytes is not None:
            pulumi.set(__self__, "replica_fetch_max_bytes", replica_fetch_max_bytes)
        if replica_fetch_response_max_bytes is not None:
            pulumi.set(__self__, "replica_fetch_response_max_bytes", replica_fetch_response_max_bytes)
        if socket_request_max_bytes is not None:
            pulumi.set(__self__, "socket_request_max_bytes", socket_request_max_bytes)
        if transaction_remove_expired_transaction_cleanup_interval_ms is not None:
            pulumi.set(__self__, "transaction_remove_expired_transaction_cleanup_interval_ms", transaction_remove_expired_transaction_cleanup_interval_ms)
        if transaction_state_log_segment_bytes is not None:
            pulumi.set(__self__, "transaction_state_log_segment_bytes", transaction_state_log_segment_bytes)

    @property
    @pulumi.getter(name="autoCreateTopicsEnable")
    def auto_create_topics_enable(self) -> Optional[str]:
        return pulumi.get(self, "auto_create_topics_enable")

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        return pulumi.get(self, "compression_type")

    @property
    @pulumi.getter(name="connectionsMaxIdleMs")
    def connections_max_idle_ms(self) -> Optional[str]:
        return pulumi.get(self, "connections_max_idle_ms")

    @property
    @pulumi.getter(name="defaultReplicationFactor")
    def default_replication_factor(self) -> Optional[str]:
        return pulumi.get(self, "default_replication_factor")

    @property
    @pulumi.getter(name="groupInitialRebalanceDelayMs")
    def group_initial_rebalance_delay_ms(self) -> Optional[str]:
        return pulumi.get(self, "group_initial_rebalance_delay_ms")

    @property
    @pulumi.getter(name="groupMaxSessionTimeoutMs")
    def group_max_session_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "group_max_session_timeout_ms")

    @property
    @pulumi.getter(name="groupMinSessionTimeoutMs")
    def group_min_session_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "group_min_session_timeout_ms")

    @property
    @pulumi.getter(name="logCleanerDeleteRetentionMs")
    def log_cleaner_delete_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_cleaner_delete_retention_ms")

    @property
    @pulumi.getter(name="logCleanerMaxCompactionLagMs")
    def log_cleaner_max_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_cleaner_max_compaction_lag_ms")

    @property
    @pulumi.getter(name="logCleanerMinCleanableRatio")
    def log_cleaner_min_cleanable_ratio(self) -> Optional[str]:
        return pulumi.get(self, "log_cleaner_min_cleanable_ratio")

    @property
    @pulumi.getter(name="logCleanerMinCompactionLagMs")
    def log_cleaner_min_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_cleaner_min_compaction_lag_ms")

    @property
    @pulumi.getter(name="logCleanupPolicy")
    def log_cleanup_policy(self) -> Optional[str]:
        return pulumi.get(self, "log_cleanup_policy")

    @property
    @pulumi.getter(name="logFlushIntervalMessages")
    def log_flush_interval_messages(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_interval_messages")

    @property
    @pulumi.getter(name="logFlushIntervalMs")
    def log_flush_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_interval_ms")

    @property
    @pulumi.getter(name="logIndexIntervalBytes")
    def log_index_interval_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_index_interval_bytes")

    @property
    @pulumi.getter(name="logIndexSizeMaxBytes")
    def log_index_size_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_index_size_max_bytes")

    @property
    @pulumi.getter(name="logMessageDownconversionEnable")
    def log_message_downconversion_enable(self) -> Optional[str]:
        return pulumi.get(self, "log_message_downconversion_enable")

    @property
    @pulumi.getter(name="logMessageTimestampDifferenceMaxMs")
    def log_message_timestamp_difference_max_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_message_timestamp_difference_max_ms")

    @property
    @pulumi.getter(name="logMessageTimestampType")
    def log_message_timestamp_type(self) -> Optional[str]:
        return pulumi.get(self, "log_message_timestamp_type")

    @property
    @pulumi.getter(name="logPreallocate")
    def log_preallocate(self) -> Optional[str]:
        return pulumi.get(self, "log_preallocate")

    @property
    @pulumi.getter(name="logRetentionBytes")
    def log_retention_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_bytes")

    @property
    @pulumi.getter(name="logRetentionHours")
    def log_retention_hours(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_hours")

    @property
    @pulumi.getter(name="logRetentionMs")
    def log_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_ms")

    @property
    @pulumi.getter(name="logRollJitterMs")
    def log_roll_jitter_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_roll_jitter_ms")

    @property
    @pulumi.getter(name="logRollMs")
    def log_roll_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_roll_ms")

    @property
    @pulumi.getter(name="logSegmentBytes")
    def log_segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_segment_bytes")

    @property
    @pulumi.getter(name="logSegmentDeleteDelayMs")
    def log_segment_delete_delay_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_segment_delete_delay_ms")

    @property
    @pulumi.getter(name="maxConnectionsPerIp")
    def max_connections_per_ip(self) -> Optional[str]:
        return pulumi.get(self, "max_connections_per_ip")

    @property
    @pulumi.getter(name="maxIncrementalFetchSessionCacheSlots")
    def max_incremental_fetch_session_cache_slots(self) -> Optional[str]:
        return pulumi.get(self, "max_incremental_fetch_session_cache_slots")

    @property
    @pulumi.getter(name="messageMaxBytes")
    def message_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "message_max_bytes")

    @property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[str]:
        return pulumi.get(self, "min_insync_replicas")

    @property
    @pulumi.getter(name="numPartitions")
    def num_partitions(self) -> Optional[str]:
        return pulumi.get(self, "num_partitions")

    @property
    @pulumi.getter(name="offsetsRetentionMinutes")
    def offsets_retention_minutes(self) -> Optional[str]:
        return pulumi.get(self, "offsets_retention_minutes")

    @property
    @pulumi.getter(name="producerPurgatoryPurgeIntervalRequests")
    def producer_purgatory_purge_interval_requests(self) -> Optional[str]:
        return pulumi.get(self, "producer_purgatory_purge_interval_requests")

    @property
    @pulumi.getter(name="replicaFetchMaxBytes")
    def replica_fetch_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "replica_fetch_max_bytes")

    @property
    @pulumi.getter(name="replicaFetchResponseMaxBytes")
    def replica_fetch_response_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "replica_fetch_response_max_bytes")

    @property
    @pulumi.getter(name="socketRequestMaxBytes")
    def socket_request_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "socket_request_max_bytes")

    @property
    @pulumi.getter(name="transactionRemoveExpiredTransactionCleanupIntervalMs")
    def transaction_remove_expired_transaction_cleanup_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "transaction_remove_expired_transaction_cleanup_interval_ms")

    @property
    @pulumi.getter(name="transactionStateLogSegmentBytes")
    def transaction_state_log_segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "transaction_state_log_segment_bytes")


@pulumi.output_type
class GetKafkaKafkaUserConfigKafkaAuthenticationMethodsResult(dict):
    def __init__(__self__, *,
                 certificate: Optional[str] = None,
                 sasl: Optional[str] = None):
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if sasl is not None:
            pulumi.set(__self__, "sasl", sasl)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def sasl(self) -> Optional[str]:
        return pulumi.get(self, "sasl")


@pulumi.output_type
class GetKafkaKafkaUserConfigKafkaConnectConfigResult(dict):
    def __init__(__self__, *,
                 connector_client_config_override_policy: Optional[str] = None,
                 consumer_auto_offset_reset: Optional[str] = None,
                 consumer_fetch_max_bytes: Optional[str] = None,
                 consumer_isolation_level: Optional[str] = None,
                 consumer_max_partition_fetch_bytes: Optional[str] = None,
                 consumer_max_poll_interval_ms: Optional[str] = None,
                 consumer_max_poll_records: Optional[str] = None,
                 offset_flush_interval_ms: Optional[str] = None,
                 offset_flush_timeout_ms: Optional[str] = None,
                 producer_compression_type: Optional[str] = None,
                 producer_max_request_size: Optional[str] = None,
                 session_timeout_ms: Optional[str] = None):
        if connector_client_config_override_policy is not None:
            pulumi.set(__self__, "connector_client_config_override_policy", connector_client_config_override_policy)
        if consumer_auto_offset_reset is not None:
            pulumi.set(__self__, "consumer_auto_offset_reset", consumer_auto_offset_reset)
        if consumer_fetch_max_bytes is not None:
            pulumi.set(__self__, "consumer_fetch_max_bytes", consumer_fetch_max_bytes)
        if consumer_isolation_level is not None:
            pulumi.set(__self__, "consumer_isolation_level", consumer_isolation_level)
        if consumer_max_partition_fetch_bytes is not None:
            pulumi.set(__self__, "consumer_max_partition_fetch_bytes", consumer_max_partition_fetch_bytes)
        if consumer_max_poll_interval_ms is not None:
            pulumi.set(__self__, "consumer_max_poll_interval_ms", consumer_max_poll_interval_ms)
        if consumer_max_poll_records is not None:
            pulumi.set(__self__, "consumer_max_poll_records", consumer_max_poll_records)
        if offset_flush_interval_ms is not None:
            pulumi.set(__self__, "offset_flush_interval_ms", offset_flush_interval_ms)
        if offset_flush_timeout_ms is not None:
            pulumi.set(__self__, "offset_flush_timeout_ms", offset_flush_timeout_ms)
        if producer_compression_type is not None:
            pulumi.set(__self__, "producer_compression_type", producer_compression_type)
        if producer_max_request_size is not None:
            pulumi.set(__self__, "producer_max_request_size", producer_max_request_size)
        if session_timeout_ms is not None:
            pulumi.set(__self__, "session_timeout_ms", session_timeout_ms)

    @property
    @pulumi.getter(name="connectorClientConfigOverridePolicy")
    def connector_client_config_override_policy(self) -> Optional[str]:
        return pulumi.get(self, "connector_client_config_override_policy")

    @property
    @pulumi.getter(name="consumerAutoOffsetReset")
    def consumer_auto_offset_reset(self) -> Optional[str]:
        return pulumi.get(self, "consumer_auto_offset_reset")

    @property
    @pulumi.getter(name="consumerFetchMaxBytes")
    def consumer_fetch_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_fetch_max_bytes")

    @property
    @pulumi.getter(name="consumerIsolationLevel")
    def consumer_isolation_level(self) -> Optional[str]:
        return pulumi.get(self, "consumer_isolation_level")

    @property
    @pulumi.getter(name="consumerMaxPartitionFetchBytes")
    def consumer_max_partition_fetch_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_partition_fetch_bytes")

    @property
    @pulumi.getter(name="consumerMaxPollIntervalMs")
    def consumer_max_poll_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_poll_interval_ms")

    @property
    @pulumi.getter(name="consumerMaxPollRecords")
    def consumer_max_poll_records(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_poll_records")

    @property
    @pulumi.getter(name="offsetFlushIntervalMs")
    def offset_flush_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "offset_flush_interval_ms")

    @property
    @pulumi.getter(name="offsetFlushTimeoutMs")
    def offset_flush_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "offset_flush_timeout_ms")

    @property
    @pulumi.getter(name="producerCompressionType")
    def producer_compression_type(self) -> Optional[str]:
        return pulumi.get(self, "producer_compression_type")

    @property
    @pulumi.getter(name="producerMaxRequestSize")
    def producer_max_request_size(self) -> Optional[str]:
        return pulumi.get(self, "producer_max_request_size")

    @property
    @pulumi.getter(name="sessionTimeoutMs")
    def session_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "session_timeout_ms")


@pulumi.output_type
class GetKafkaKafkaUserConfigKafkaRestConfigResult(dict):
    def __init__(__self__, *,
                 consumer_enable_auto_commit: Optional[str] = None,
                 consumer_request_max_bytes: Optional[str] = None,
                 consumer_request_timeout_ms: Optional[str] = None,
                 producer_acks: Optional[str] = None,
                 producer_linger_ms: Optional[str] = None,
                 simpleconsumer_pool_size_max: Optional[str] = None):
        if consumer_enable_auto_commit is not None:
            pulumi.set(__self__, "consumer_enable_auto_commit", consumer_enable_auto_commit)
        if consumer_request_max_bytes is not None:
            pulumi.set(__self__, "consumer_request_max_bytes", consumer_request_max_bytes)
        if consumer_request_timeout_ms is not None:
            pulumi.set(__self__, "consumer_request_timeout_ms", consumer_request_timeout_ms)
        if producer_acks is not None:
            pulumi.set(__self__, "producer_acks", producer_acks)
        if producer_linger_ms is not None:
            pulumi.set(__self__, "producer_linger_ms", producer_linger_ms)
        if simpleconsumer_pool_size_max is not None:
            pulumi.set(__self__, "simpleconsumer_pool_size_max", simpleconsumer_pool_size_max)

    @property
    @pulumi.getter(name="consumerEnableAutoCommit")
    def consumer_enable_auto_commit(self) -> Optional[str]:
        return pulumi.get(self, "consumer_enable_auto_commit")

    @property
    @pulumi.getter(name="consumerRequestMaxBytes")
    def consumer_request_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_request_max_bytes")

    @property
    @pulumi.getter(name="consumerRequestTimeoutMs")
    def consumer_request_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "consumer_request_timeout_ms")

    @property
    @pulumi.getter(name="producerAcks")
    def producer_acks(self) -> Optional[str]:
        return pulumi.get(self, "producer_acks")

    @property
    @pulumi.getter(name="producerLingerMs")
    def producer_linger_ms(self) -> Optional[str]:
        return pulumi.get(self, "producer_linger_ms")

    @property
    @pulumi.getter(name="simpleconsumerPoolSizeMax")
    def simpleconsumer_pool_size_max(self) -> Optional[str]:
        return pulumi.get(self, "simpleconsumer_pool_size_max")


@pulumi.output_type
class GetKafkaKafkaUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetKafkaKafkaUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 jolokia: Optional[str] = None,
                 kafka: Optional[str] = None,
                 kafka_connect: Optional[str] = None,
                 kafka_rest: Optional[str] = None,
                 prometheus: Optional[str] = None,
                 schema_registry: Optional[str] = None):
        """
        :param str kafka: Kafka server provided values
        """
        if jolokia is not None:
            pulumi.set(__self__, "jolokia", jolokia)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if kafka_rest is not None:
            pulumi.set(__self__, "kafka_rest", kafka_rest)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)

    @property
    @pulumi.getter
    def jolokia(self) -> Optional[str]:
        return pulumi.get(self, "jolokia")

    @property
    @pulumi.getter
    def kafka(self) -> Optional[str]:
        """
        Kafka server provided values
        """
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter(name="kafkaRest")
    def kafka_rest(self) -> Optional[str]:
        return pulumi.get(self, "kafka_rest")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[str]:
        return pulumi.get(self, "schema_registry")


@pulumi.output_type
class GetKafkaKafkaUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 kafka: Optional[str] = None,
                 kafka_connect: Optional[str] = None,
                 kafka_rest: Optional[str] = None,
                 prometheus: Optional[str] = None,
                 schema_registry: Optional[str] = None):
        """
        :param str kafka: Kafka server provided values
        """
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if kafka_rest is not None:
            pulumi.set(__self__, "kafka_rest", kafka_rest)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)

    @property
    @pulumi.getter
    def kafka(self) -> Optional[str]:
        """
        Kafka server provided values
        """
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter(name="kafkaRest")
    def kafka_rest(self) -> Optional[str]:
        return pulumi.get(self, "kafka_rest")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[str]:
        return pulumi.get(self, "schema_registry")


@pulumi.output_type
class GetKafkaKafkaUserConfigSchemaRegistryConfigResult(dict):
    def __init__(__self__, *,
                 leader_eligibility: Optional[str] = None,
                 topic_name: Optional[str] = None):
        if leader_eligibility is not None:
            pulumi.set(__self__, "leader_eligibility", leader_eligibility)
        if topic_name is not None:
            pulumi.set(__self__, "topic_name", topic_name)

    @property
    @pulumi.getter(name="leaderEligibility")
    def leader_eligibility(self) -> Optional[str]:
        return pulumi.get(self, "leader_eligibility")

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> Optional[str]:
        return pulumi.get(self, "topic_name")


@pulumi.output_type
class GetKafkaMirrorMakerComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetKafkaMirrorMakerKafkaMirrormakerResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetKafkaMirrorMakerKafkaMirrormakerUserConfigResult(dict):
    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka_mirrormaker: Optional['outputs.GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormakerResult'] = None,
                 static_ips: Optional[str] = None):
        """
        :param 'GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormakerArgs' kafka_mirrormaker: Kafka MirrorMaker 2 server provided values
        :param str static_ips: Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka_mirrormaker is not None:
            pulumi.set(__self__, "kafka_mirrormaker", kafka_mirrormaker)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="kafkaMirrormaker")
    def kafka_mirrormaker(self) -> Optional['outputs.GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormakerResult']:
        """
        Kafka MirrorMaker 2 server provided values
        """
        return pulumi.get(self, "kafka_mirrormaker")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormakerResult(dict):
    def __init__(__self__, *,
                 emit_checkpoints_enabled: Optional[str] = None,
                 emit_checkpoints_interval_seconds: Optional[str] = None,
                 refresh_groups_enabled: Optional[str] = None,
                 refresh_groups_interval_seconds: Optional[str] = None,
                 refresh_topics_enabled: Optional[str] = None,
                 refresh_topics_interval_seconds: Optional[str] = None,
                 sync_group_offsets_enabled: Optional[str] = None,
                 sync_group_offsets_interval_seconds: Optional[str] = None,
                 sync_topic_configs_enabled: Optional[str] = None,
                 tasks_max_per_cpu: Optional[str] = None):
        if emit_checkpoints_enabled is not None:
            pulumi.set(__self__, "emit_checkpoints_enabled", emit_checkpoints_enabled)
        if emit_checkpoints_interval_seconds is not None:
            pulumi.set(__self__, "emit_checkpoints_interval_seconds", emit_checkpoints_interval_seconds)
        if refresh_groups_enabled is not None:
            pulumi.set(__self__, "refresh_groups_enabled", refresh_groups_enabled)
        if refresh_groups_interval_seconds is not None:
            pulumi.set(__self__, "refresh_groups_interval_seconds", refresh_groups_interval_seconds)
        if refresh_topics_enabled is not None:
            pulumi.set(__self__, "refresh_topics_enabled", refresh_topics_enabled)
        if refresh_topics_interval_seconds is not None:
            pulumi.set(__self__, "refresh_topics_interval_seconds", refresh_topics_interval_seconds)
        if sync_group_offsets_enabled is not None:
            pulumi.set(__self__, "sync_group_offsets_enabled", sync_group_offsets_enabled)
        if sync_group_offsets_interval_seconds is not None:
            pulumi.set(__self__, "sync_group_offsets_interval_seconds", sync_group_offsets_interval_seconds)
        if sync_topic_configs_enabled is not None:
            pulumi.set(__self__, "sync_topic_configs_enabled", sync_topic_configs_enabled)
        if tasks_max_per_cpu is not None:
            pulumi.set(__self__, "tasks_max_per_cpu", tasks_max_per_cpu)

    @property
    @pulumi.getter(name="emitCheckpointsEnabled")
    def emit_checkpoints_enabled(self) -> Optional[str]:
        return pulumi.get(self, "emit_checkpoints_enabled")

    @property
    @pulumi.getter(name="emitCheckpointsIntervalSeconds")
    def emit_checkpoints_interval_seconds(self) -> Optional[str]:
        return pulumi.get(self, "emit_checkpoints_interval_seconds")

    @property
    @pulumi.getter(name="refreshGroupsEnabled")
    def refresh_groups_enabled(self) -> Optional[str]:
        return pulumi.get(self, "refresh_groups_enabled")

    @property
    @pulumi.getter(name="refreshGroupsIntervalSeconds")
    def refresh_groups_interval_seconds(self) -> Optional[str]:
        return pulumi.get(self, "refresh_groups_interval_seconds")

    @property
    @pulumi.getter(name="refreshTopicsEnabled")
    def refresh_topics_enabled(self) -> Optional[str]:
        return pulumi.get(self, "refresh_topics_enabled")

    @property
    @pulumi.getter(name="refreshTopicsIntervalSeconds")
    def refresh_topics_interval_seconds(self) -> Optional[str]:
        return pulumi.get(self, "refresh_topics_interval_seconds")

    @property
    @pulumi.getter(name="syncGroupOffsetsEnabled")
    def sync_group_offsets_enabled(self) -> Optional[str]:
        return pulumi.get(self, "sync_group_offsets_enabled")

    @property
    @pulumi.getter(name="syncGroupOffsetsIntervalSeconds")
    def sync_group_offsets_interval_seconds(self) -> Optional[str]:
        return pulumi.get(self, "sync_group_offsets_interval_seconds")

    @property
    @pulumi.getter(name="syncTopicConfigsEnabled")
    def sync_topic_configs_enabled(self) -> Optional[str]:
        return pulumi.get(self, "sync_topic_configs_enabled")

    @property
    @pulumi.getter(name="tasksMaxPerCpu")
    def tasks_max_per_cpu(self) -> Optional[str]:
        return pulumi.get(self, "tasks_max_per_cpu")


@pulumi.output_type
class GetKafkaMirrorMakerServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetKafkaMirrorMakerTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetKafkaServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetKafkaTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetKafkaTopicConfigResult(dict):
    def __init__(__self__, *,
                 cleanup_policy: Optional[str] = None,
                 compression_type: Optional[str] = None,
                 delete_retention_ms: Optional[str] = None,
                 file_delete_delay_ms: Optional[str] = None,
                 flush_messages: Optional[str] = None,
                 flush_ms: Optional[str] = None,
                 index_interval_bytes: Optional[str] = None,
                 max_compaction_lag_ms: Optional[str] = None,
                 max_message_bytes: Optional[str] = None,
                 message_downconversion_enable: Optional[str] = None,
                 message_format_version: Optional[str] = None,
                 message_timestamp_difference_max_ms: Optional[str] = None,
                 message_timestamp_type: Optional[str] = None,
                 min_cleanable_dirty_ratio: Optional[str] = None,
                 min_compaction_lag_ms: Optional[str] = None,
                 min_insync_replicas: Optional[str] = None,
                 preallocate: Optional[str] = None,
                 retention_bytes: Optional[str] = None,
                 retention_ms: Optional[str] = None,
                 segment_bytes: Optional[str] = None,
                 segment_index_bytes: Optional[str] = None,
                 segment_jitter_ms: Optional[str] = None,
                 segment_ms: Optional[str] = None,
                 unclean_leader_election_enable: Optional[str] = None):
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if delete_retention_ms is not None:
            pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        if file_delete_delay_ms is not None:
            pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        if flush_messages is not None:
            pulumi.set(__self__, "flush_messages", flush_messages)
        if flush_ms is not None:
            pulumi.set(__self__, "flush_ms", flush_ms)
        if index_interval_bytes is not None:
            pulumi.set(__self__, "index_interval_bytes", index_interval_bytes)
        if max_compaction_lag_ms is not None:
            pulumi.set(__self__, "max_compaction_lag_ms", max_compaction_lag_ms)
        if max_message_bytes is not None:
            pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        if message_downconversion_enable is not None:
            pulumi.set(__self__, "message_downconversion_enable", message_downconversion_enable)
        if message_format_version is not None:
            pulumi.set(__self__, "message_format_version", message_format_version)
        if message_timestamp_difference_max_ms is not None:
            pulumi.set(__self__, "message_timestamp_difference_max_ms", message_timestamp_difference_max_ms)
        if message_timestamp_type is not None:
            pulumi.set(__self__, "message_timestamp_type", message_timestamp_type)
        if min_cleanable_dirty_ratio is not None:
            pulumi.set(__self__, "min_cleanable_dirty_ratio", min_cleanable_dirty_ratio)
        if min_compaction_lag_ms is not None:
            pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if preallocate is not None:
            pulumi.set(__self__, "preallocate", preallocate)
        if retention_bytes is not None:
            pulumi.set(__self__, "retention_bytes", retention_bytes)
        if retention_ms is not None:
            pulumi.set(__self__, "retention_ms", retention_ms)
        if segment_bytes is not None:
            pulumi.set(__self__, "segment_bytes", segment_bytes)
        if segment_index_bytes is not None:
            pulumi.set(__self__, "segment_index_bytes", segment_index_bytes)
        if segment_jitter_ms is not None:
            pulumi.set(__self__, "segment_jitter_ms", segment_jitter_ms)
        if segment_ms is not None:
            pulumi.set(__self__, "segment_ms", segment_ms)
        if unclean_leader_election_enable is not None:
            pulumi.set(__self__, "unclean_leader_election_enable", unclean_leader_election_enable)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[str]:
        return pulumi.get(self, "cleanup_policy")

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        return pulumi.get(self, "compression_type")

    @property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "delete_retention_ms")

    @property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> Optional[str]:
        return pulumi.get(self, "file_delete_delay_ms")

    @property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> Optional[str]:
        return pulumi.get(self, "flush_messages")

    @property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> Optional[str]:
        return pulumi.get(self, "flush_ms")

    @property
    @pulumi.getter(name="indexIntervalBytes")
    def index_interval_bytes(self) -> Optional[str]:
        return pulumi.get(self, "index_interval_bytes")

    @property
    @pulumi.getter(name="maxCompactionLagMs")
    def max_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "max_compaction_lag_ms")

    @property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> Optional[str]:
        return pulumi.get(self, "max_message_bytes")

    @property
    @pulumi.getter(name="messageDownconversionEnable")
    def message_downconversion_enable(self) -> Optional[str]:
        return pulumi.get(self, "message_downconversion_enable")

    @property
    @pulumi.getter(name="messageFormatVersion")
    def message_format_version(self) -> Optional[str]:
        return pulumi.get(self, "message_format_version")

    @property
    @pulumi.getter(name="messageTimestampDifferenceMaxMs")
    def message_timestamp_difference_max_ms(self) -> Optional[str]:
        return pulumi.get(self, "message_timestamp_difference_max_ms")

    @property
    @pulumi.getter(name="messageTimestampType")
    def message_timestamp_type(self) -> Optional[str]:
        return pulumi.get(self, "message_timestamp_type")

    @property
    @pulumi.getter(name="minCleanableDirtyRatio")
    def min_cleanable_dirty_ratio(self) -> Optional[str]:
        return pulumi.get(self, "min_cleanable_dirty_ratio")

    @property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "min_compaction_lag_ms")

    @property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[str]:
        return pulumi.get(self, "min_insync_replicas")

    @property
    @pulumi.getter
    def preallocate(self) -> Optional[str]:
        return pulumi.get(self, "preallocate")

    @property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> Optional[str]:
        return pulumi.get(self, "retention_bytes")

    @property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "retention_ms")

    @property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "segment_bytes")

    @property
    @pulumi.getter(name="segmentIndexBytes")
    def segment_index_bytes(self) -> Optional[str]:
        return pulumi.get(self, "segment_index_bytes")

    @property
    @pulumi.getter(name="segmentJitterMs")
    def segment_jitter_ms(self) -> Optional[str]:
        return pulumi.get(self, "segment_jitter_ms")

    @property
    @pulumi.getter(name="segmentMs")
    def segment_ms(self) -> Optional[str]:
        return pulumi.get(self, "segment_ms")

    @property
    @pulumi.getter(name="uncleanLeaderElectionEnable")
    def unclean_leader_election_enable(self) -> Optional[str]:
        return pulumi.get(self, "unclean_leader_election_enable")


@pulumi.output_type
class GetKafkaTopicTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetM3AggregatorComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetM3AggregatorM3aggregatorResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetM3AggregatorM3aggregatorUserConfigResult(dict):
    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 m3_version: Optional[str] = None,
                 m3aggregator_version: Optional[str] = None,
                 static_ips: Optional[str] = None):
        """
        :param str static_ips: Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if m3_version is not None:
            pulumi.set(__self__, "m3_version", m3_version)
        if m3aggregator_version is not None:
            pulumi.set(__self__, "m3aggregator_version", m3aggregator_version)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="m3Version")
    def m3_version(self) -> Optional[str]:
        return pulumi.get(self, "m3_version")

    @property
    @pulumi.getter(name="m3aggregatorVersion")
    def m3aggregator_version(self) -> Optional[str]:
        return pulumi.get(self, "m3aggregator_version")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetM3AggregatorServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetM3AggregatorTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetM3DbComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetM3DbM3dbResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetM3DbM3dbUserConfigResult(dict):
    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 limits: Optional['outputs.GetM3DbM3dbUserConfigLimitsResult'] = None,
                 m3_version: Optional[str] = None,
                 m3coordinator_enable_graphite_carbon_ingest: Optional[str] = None,
                 m3db_version: Optional[str] = None,
                 namespaces: Optional[Sequence['outputs.GetM3DbM3dbUserConfigNamespaceResult']] = None,
                 private_access: Optional['outputs.GetM3DbM3dbUserConfigPrivateAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetM3DbM3dbUserConfigPublicAccessResult'] = None,
                 rules: Optional['outputs.GetM3DbM3dbUserConfigRulesResult'] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        """
        :param str static_ips: Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if m3_version is not None:
            pulumi.set(__self__, "m3_version", m3_version)
        if m3coordinator_enable_graphite_carbon_ingest is not None:
            pulumi.set(__self__, "m3coordinator_enable_graphite_carbon_ingest", m3coordinator_enable_graphite_carbon_ingest)
        if m3db_version is not None:
            pulumi.set(__self__, "m3db_version", m3db_version)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def limits(self) -> Optional['outputs.GetM3DbM3dbUserConfigLimitsResult']:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter(name="m3Version")
    def m3_version(self) -> Optional[str]:
        return pulumi.get(self, "m3_version")

    @property
    @pulumi.getter(name="m3coordinatorEnableGraphiteCarbonIngest")
    def m3coordinator_enable_graphite_carbon_ingest(self) -> Optional[str]:
        return pulumi.get(self, "m3coordinator_enable_graphite_carbon_ingest")

    @property
    @pulumi.getter(name="m3dbVersion")
    def m3db_version(self) -> Optional[str]:
        return pulumi.get(self, "m3db_version")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence['outputs.GetM3DbM3dbUserConfigNamespaceResult']]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetM3DbM3dbUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetM3DbM3dbUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter
    def rules(self) -> Optional['outputs.GetM3DbM3dbUserConfigRulesResult']:
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetM3DbM3dbUserConfigLimitsResult(dict):
    def __init__(__self__, *,
                 query_docs: Optional[str] = None,
                 query_require_exhaustive: Optional[str] = None,
                 query_series: Optional[str] = None):
        if query_docs is not None:
            pulumi.set(__self__, "query_docs", query_docs)
        if query_require_exhaustive is not None:
            pulumi.set(__self__, "query_require_exhaustive", query_require_exhaustive)
        if query_series is not None:
            pulumi.set(__self__, "query_series", query_series)

    @property
    @pulumi.getter(name="queryDocs")
    def query_docs(self) -> Optional[str]:
        return pulumi.get(self, "query_docs")

    @property
    @pulumi.getter(name="queryRequireExhaustive")
    def query_require_exhaustive(self) -> Optional[str]:
        return pulumi.get(self, "query_require_exhaustive")

    @property
    @pulumi.getter(name="querySeries")
    def query_series(self) -> Optional[str]:
        return pulumi.get(self, "query_series")


@pulumi.output_type
class GetM3DbM3dbUserConfigNamespaceResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 options: Optional['outputs.GetM3DbM3dbUserConfigNamespaceOptionsResult'] = None,
                 resolution: Optional[str] = None,
                 type: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def options(self) -> Optional['outputs.GetM3DbM3dbUserConfigNamespaceOptionsResult']:
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def resolution(self) -> Optional[str]:
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetM3DbM3dbUserConfigNamespaceOptionsResult(dict):
    def __init__(__self__, *,
                 retention_options: Optional['outputs.GetM3DbM3dbUserConfigNamespaceOptionsRetentionOptionsResult'] = None,
                 snapshot_enabled: Optional[str] = None,
                 writes_to_commitlog: Optional[str] = None):
        if retention_options is not None:
            pulumi.set(__self__, "retention_options", retention_options)
        if snapshot_enabled is not None:
            pulumi.set(__self__, "snapshot_enabled", snapshot_enabled)
        if writes_to_commitlog is not None:
            pulumi.set(__self__, "writes_to_commitlog", writes_to_commitlog)

    @property
    @pulumi.getter(name="retentionOptions")
    def retention_options(self) -> Optional['outputs.GetM3DbM3dbUserConfigNamespaceOptionsRetentionOptionsResult']:
        return pulumi.get(self, "retention_options")

    @property
    @pulumi.getter(name="snapshotEnabled")
    def snapshot_enabled(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_enabled")

    @property
    @pulumi.getter(name="writesToCommitlog")
    def writes_to_commitlog(self) -> Optional[str]:
        return pulumi.get(self, "writes_to_commitlog")


@pulumi.output_type
class GetM3DbM3dbUserConfigNamespaceOptionsRetentionOptionsResult(dict):
    def __init__(__self__, *,
                 block_data_expiry_duration: Optional[str] = None,
                 blocksize_duration: Optional[str] = None,
                 buffer_future_duration: Optional[str] = None,
                 buffer_past_duration: Optional[str] = None,
                 retention_period_duration: Optional[str] = None):
        if block_data_expiry_duration is not None:
            pulumi.set(__self__, "block_data_expiry_duration", block_data_expiry_duration)
        if blocksize_duration is not None:
            pulumi.set(__self__, "blocksize_duration", blocksize_duration)
        if buffer_future_duration is not None:
            pulumi.set(__self__, "buffer_future_duration", buffer_future_duration)
        if buffer_past_duration is not None:
            pulumi.set(__self__, "buffer_past_duration", buffer_past_duration)
        if retention_period_duration is not None:
            pulumi.set(__self__, "retention_period_duration", retention_period_duration)

    @property
    @pulumi.getter(name="blockDataExpiryDuration")
    def block_data_expiry_duration(self) -> Optional[str]:
        return pulumi.get(self, "block_data_expiry_duration")

    @property
    @pulumi.getter(name="blocksizeDuration")
    def blocksize_duration(self) -> Optional[str]:
        return pulumi.get(self, "blocksize_duration")

    @property
    @pulumi.getter(name="bufferFutureDuration")
    def buffer_future_duration(self) -> Optional[str]:
        return pulumi.get(self, "buffer_future_duration")

    @property
    @pulumi.getter(name="bufferPastDuration")
    def buffer_past_duration(self) -> Optional[str]:
        return pulumi.get(self, "buffer_past_duration")

    @property
    @pulumi.getter(name="retentionPeriodDuration")
    def retention_period_duration(self) -> Optional[str]:
        return pulumi.get(self, "retention_period_duration")


@pulumi.output_type
class GetM3DbM3dbUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 m3coordinator: Optional[str] = None):
        if m3coordinator is not None:
            pulumi.set(__self__, "m3coordinator", m3coordinator)

    @property
    @pulumi.getter
    def m3coordinator(self) -> Optional[str]:
        return pulumi.get(self, "m3coordinator")


@pulumi.output_type
class GetM3DbM3dbUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 m3coordinator: Optional[str] = None):
        if m3coordinator is not None:
            pulumi.set(__self__, "m3coordinator", m3coordinator)

    @property
    @pulumi.getter
    def m3coordinator(self) -> Optional[str]:
        return pulumi.get(self, "m3coordinator")


@pulumi.output_type
class GetM3DbM3dbUserConfigRulesResult(dict):
    def __init__(__self__, *,
                 mappings: Optional[Sequence['outputs.GetM3DbM3dbUserConfigRulesMappingResult']] = None):
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter
    def mappings(self) -> Optional[Sequence['outputs.GetM3DbM3dbUserConfigRulesMappingResult']]:
        return pulumi.get(self, "mappings")


@pulumi.output_type
class GetM3DbM3dbUserConfigRulesMappingResult(dict):
    def __init__(__self__, *,
                 aggregations: Optional[Sequence[str]] = None,
                 drop: Optional[str] = None,
                 filter: Optional[str] = None,
                 name: Optional[str] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence['outputs.GetM3DbM3dbUserConfigRulesMappingTagResult']] = None):
        if aggregations is not None:
            pulumi.set(__self__, "aggregations", aggregations)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def aggregations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "aggregations")

    @property
    @pulumi.getter
    def drop(self) -> Optional[str]:
        return pulumi.get(self, "drop")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.GetM3DbM3dbUserConfigRulesMappingTagResult']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetM3DbM3dbUserConfigRulesMappingTagResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetM3DbServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetM3DbTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetMySqlComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetMySqlMysqlResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMySqlMysqlUserConfigResult(dict):
    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_hour: Optional[str] = None,
                 backup_minute: Optional[str] = None,
                 binlog_retention_period: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 migration: Optional['outputs.GetMySqlMysqlUserConfigMigrationResult'] = None,
                 mysql: Optional['outputs.GetMySqlMysqlUserConfigMysqlResult'] = None,
                 mysql_version: Optional[str] = None,
                 private_access: Optional['outputs.GetMySqlMysqlUserConfigPrivateAccessResult'] = None,
                 privatelink_access: Optional['outputs.GetMySqlMysqlUserConfigPrivatelinkAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetMySqlMysqlUserConfigPublicAccessResult'] = None,
                 recovery_target_time: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        """
        :param 'GetMySqlMysqlUserConfigMysqlArgs' mysql: MySQL specific server provided values
        :param str static_ips: Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if binlog_retention_period is not None:
            pulumi.set(__self__, "binlog_retention_period", binlog_retention_period)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if mysql_version is not None:
            pulumi.set(__self__, "mysql_version", mysql_version)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_target_time is not None:
            pulumi.set(__self__, "recovery_target_time", recovery_target_time)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[str]:
        return pulumi.get(self, "backup_hour")

    @property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[str]:
        return pulumi.get(self, "backup_minute")

    @property
    @pulumi.getter(name="binlogRetentionPeriod")
    def binlog_retention_period(self) -> Optional[str]:
        return pulumi.get(self, "binlog_retention_period")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def migration(self) -> Optional['outputs.GetMySqlMysqlUserConfigMigrationResult']:
        return pulumi.get(self, "migration")

    @property
    @pulumi.getter
    def mysql(self) -> Optional['outputs.GetMySqlMysqlUserConfigMysqlResult']:
        """
        MySQL specific server provided values
        """
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter(name="mysqlVersion")
    def mysql_version(self) -> Optional[str]:
        return pulumi.get(self, "mysql_version")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetMySqlMysqlUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetMySqlMysqlUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetMySqlMysqlUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryTargetTime")
    def recovery_target_time(self) -> Optional[str]:
        return pulumi.get(self, "recovery_target_time")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetMySqlMysqlUserConfigMigrationResult(dict):
    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 ignore_dbs: Optional[str] = None,
                 method: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 ssl: Optional[str] = None,
                 username: Optional[str] = None):
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[str]:
        return pulumi.get(self, "ignore_dbs")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetMySqlMysqlUserConfigMysqlResult(dict):
    def __init__(__self__, *,
                 connect_timeout: Optional[str] = None,
                 default_time_zone: Optional[str] = None,
                 group_concat_max_len: Optional[str] = None,
                 information_schema_stats_expiry: Optional[str] = None,
                 innodb_change_buffer_max_size: Optional[str] = None,
                 innodb_flush_neighbors: Optional[str] = None,
                 innodb_ft_min_token_size: Optional[str] = None,
                 innodb_ft_server_stopword_table: Optional[str] = None,
                 innodb_lock_wait_timeout: Optional[str] = None,
                 innodb_log_buffer_size: Optional[str] = None,
                 innodb_online_alter_log_max_size: Optional[str] = None,
                 innodb_print_all_deadlocks: Optional[str] = None,
                 innodb_read_io_threads: Optional[str] = None,
                 innodb_rollback_on_timeout: Optional[str] = None,
                 innodb_thread_concurrency: Optional[str] = None,
                 innodb_write_io_threads: Optional[str] = None,
                 interactive_timeout: Optional[str] = None,
                 internal_tmp_mem_storage_engine: Optional[str] = None,
                 long_query_time: Optional[str] = None,
                 max_allowed_packet: Optional[str] = None,
                 max_heap_table_size: Optional[str] = None,
                 net_buffer_length: Optional[str] = None,
                 net_read_timeout: Optional[str] = None,
                 net_write_timeout: Optional[str] = None,
                 slow_query_log: Optional[str] = None,
                 sort_buffer_size: Optional[str] = None,
                 sql_mode: Optional[str] = None,
                 sql_require_primary_key: Optional[str] = None,
                 tmp_table_size: Optional[str] = None,
                 wait_timeout: Optional[str] = None):
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if default_time_zone is not None:
            pulumi.set(__self__, "default_time_zone", default_time_zone)
        if group_concat_max_len is not None:
            pulumi.set(__self__, "group_concat_max_len", group_concat_max_len)
        if information_schema_stats_expiry is not None:
            pulumi.set(__self__, "information_schema_stats_expiry", information_schema_stats_expiry)
        if innodb_change_buffer_max_size is not None:
            pulumi.set(__self__, "innodb_change_buffer_max_size", innodb_change_buffer_max_size)
        if innodb_flush_neighbors is not None:
            pulumi.set(__self__, "innodb_flush_neighbors", innodb_flush_neighbors)
        if innodb_ft_min_token_size is not None:
            pulumi.set(__self__, "innodb_ft_min_token_size", innodb_ft_min_token_size)
        if innodb_ft_server_stopword_table is not None:
            pulumi.set(__self__, "innodb_ft_server_stopword_table", innodb_ft_server_stopword_table)
        if innodb_lock_wait_timeout is not None:
            pulumi.set(__self__, "innodb_lock_wait_timeout", innodb_lock_wait_timeout)
        if innodb_log_buffer_size is not None:
            pulumi.set(__self__, "innodb_log_buffer_size", innodb_log_buffer_size)
        if innodb_online_alter_log_max_size is not None:
            pulumi.set(__self__, "innodb_online_alter_log_max_size", innodb_online_alter_log_max_size)
        if innodb_print_all_deadlocks is not None:
            pulumi.set(__self__, "innodb_print_all_deadlocks", innodb_print_all_deadlocks)
        if innodb_read_io_threads is not None:
            pulumi.set(__self__, "innodb_read_io_threads", innodb_read_io_threads)
        if innodb_rollback_on_timeout is not None:
            pulumi.set(__self__, "innodb_rollback_on_timeout", innodb_rollback_on_timeout)
        if innodb_thread_concurrency is not None:
            pulumi.set(__self__, "innodb_thread_concurrency", innodb_thread_concurrency)
        if innodb_write_io_threads is not None:
            pulumi.set(__self__, "innodb_write_io_threads", innodb_write_io_threads)
        if interactive_timeout is not None:
            pulumi.set(__self__, "interactive_timeout", interactive_timeout)
        if internal_tmp_mem_storage_engine is not None:
            pulumi.set(__self__, "internal_tmp_mem_storage_engine", internal_tmp_mem_storage_engine)
        if long_query_time is not None:
            pulumi.set(__self__, "long_query_time", long_query_time)
        if max_allowed_packet is not None:
            pulumi.set(__self__, "max_allowed_packet", max_allowed_packet)
        if max_heap_table_size is not None:
            pulumi.set(__self__, "max_heap_table_size", max_heap_table_size)
        if net_buffer_length is not None:
            pulumi.set(__self__, "net_buffer_length", net_buffer_length)
        if net_read_timeout is not None:
            pulumi.set(__self__, "net_read_timeout", net_read_timeout)
        if net_write_timeout is not None:
            pulumi.set(__self__, "net_write_timeout", net_write_timeout)
        if slow_query_log is not None:
            pulumi.set(__self__, "slow_query_log", slow_query_log)
        if sort_buffer_size is not None:
            pulumi.set(__self__, "sort_buffer_size", sort_buffer_size)
        if sql_mode is not None:
            pulumi.set(__self__, "sql_mode", sql_mode)
        if sql_require_primary_key is not None:
            pulumi.set(__self__, "sql_require_primary_key", sql_require_primary_key)
        if tmp_table_size is not None:
            pulumi.set(__self__, "tmp_table_size", tmp_table_size)
        if wait_timeout is not None:
            pulumi.set(__self__, "wait_timeout", wait_timeout)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[str]:
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="defaultTimeZone")
    def default_time_zone(self) -> Optional[str]:
        return pulumi.get(self, "default_time_zone")

    @property
    @pulumi.getter(name="groupConcatMaxLen")
    def group_concat_max_len(self) -> Optional[str]:
        return pulumi.get(self, "group_concat_max_len")

    @property
    @pulumi.getter(name="informationSchemaStatsExpiry")
    def information_schema_stats_expiry(self) -> Optional[str]:
        return pulumi.get(self, "information_schema_stats_expiry")

    @property
    @pulumi.getter(name="innodbChangeBufferMaxSize")
    def innodb_change_buffer_max_size(self) -> Optional[str]:
        return pulumi.get(self, "innodb_change_buffer_max_size")

    @property
    @pulumi.getter(name="innodbFlushNeighbors")
    def innodb_flush_neighbors(self) -> Optional[str]:
        return pulumi.get(self, "innodb_flush_neighbors")

    @property
    @pulumi.getter(name="innodbFtMinTokenSize")
    def innodb_ft_min_token_size(self) -> Optional[str]:
        return pulumi.get(self, "innodb_ft_min_token_size")

    @property
    @pulumi.getter(name="innodbFtServerStopwordTable")
    def innodb_ft_server_stopword_table(self) -> Optional[str]:
        return pulumi.get(self, "innodb_ft_server_stopword_table")

    @property
    @pulumi.getter(name="innodbLockWaitTimeout")
    def innodb_lock_wait_timeout(self) -> Optional[str]:
        return pulumi.get(self, "innodb_lock_wait_timeout")

    @property
    @pulumi.getter(name="innodbLogBufferSize")
    def innodb_log_buffer_size(self) -> Optional[str]:
        return pulumi.get(self, "innodb_log_buffer_size")

    @property
    @pulumi.getter(name="innodbOnlineAlterLogMaxSize")
    def innodb_online_alter_log_max_size(self) -> Optional[str]:
        return pulumi.get(self, "innodb_online_alter_log_max_size")

    @property
    @pulumi.getter(name="innodbPrintAllDeadlocks")
    def innodb_print_all_deadlocks(self) -> Optional[str]:
        return pulumi.get(self, "innodb_print_all_deadlocks")

    @property
    @pulumi.getter(name="innodbReadIoThreads")
    def innodb_read_io_threads(self) -> Optional[str]:
        return pulumi.get(self, "innodb_read_io_threads")

    @property
    @pulumi.getter(name="innodbRollbackOnTimeout")
    def innodb_rollback_on_timeout(self) -> Optional[str]:
        return pulumi.get(self, "innodb_rollback_on_timeout")

    @property
    @pulumi.getter(name="innodbThreadConcurrency")
    def innodb_thread_concurrency(self) -> Optional[str]:
        return pulumi.get(self, "innodb_thread_concurrency")

    @property
    @pulumi.getter(name="innodbWriteIoThreads")
    def innodb_write_io_threads(self) -> Optional[str]:
        return pulumi.get(self, "innodb_write_io_threads")

    @property
    @pulumi.getter(name="interactiveTimeout")
    def interactive_timeout(self) -> Optional[str]:
        return pulumi.get(self, "interactive_timeout")

    @property
    @pulumi.getter(name="internalTmpMemStorageEngine")
    def internal_tmp_mem_storage_engine(self) -> Optional[str]:
        return pulumi.get(self, "internal_tmp_mem_storage_engine")

    @property
    @pulumi.getter(name="longQueryTime")
    def long_query_time(self) -> Optional[str]:
        return pulumi.get(self, "long_query_time")

    @property
    @pulumi.getter(name="maxAllowedPacket")
    def max_allowed_packet(self) -> Optional[str]:
        return pulumi.get(self, "max_allowed_packet")

    @property
    @pulumi.getter(name="maxHeapTableSize")
    def max_heap_table_size(self) -> Optional[str]:
        return pulumi.get(self, "max_heap_table_size")

    @property
    @pulumi.getter(name="netBufferLength")
    def net_buffer_length(self) -> Optional[str]:
        return pulumi.get(self, "net_buffer_length")

    @property
    @pulumi.getter(name="netReadTimeout")
    def net_read_timeout(self) -> Optional[str]:
        return pulumi.get(self, "net_read_timeout")

    @property
    @pulumi.getter(name="netWriteTimeout")
    def net_write_timeout(self) -> Optional[str]:
        return pulumi.get(self, "net_write_timeout")

    @property
    @pulumi.getter(name="slowQueryLog")
    def slow_query_log(self) -> Optional[str]:
        return pulumi.get(self, "slow_query_log")

    @property
    @pulumi.getter(name="sortBufferSize")
    def sort_buffer_size(self) -> Optional[str]:
        return pulumi.get(self, "sort_buffer_size")

    @property
    @pulumi.getter(name="sqlMode")
    def sql_mode(self) -> Optional[str]:
        return pulumi.get(self, "sql_mode")

    @property
    @pulumi.getter(name="sqlRequirePrimaryKey")
    def sql_require_primary_key(self) -> Optional[str]:
        return pulumi.get(self, "sql_require_primary_key")

    @property
    @pulumi.getter(name="tmpTableSize")
    def tmp_table_size(self) -> Optional[str]:
        return pulumi.get(self, "tmp_table_size")

    @property
    @pulumi.getter(name="waitTimeout")
    def wait_timeout(self) -> Optional[str]:
        return pulumi.get(self, "wait_timeout")


@pulumi.output_type
class GetMySqlMysqlUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 mysql: Optional[str] = None,
                 mysqlx: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str mysql: MySQL specific server provided values
        """
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if mysqlx is not None:
            pulumi.set(__self__, "mysqlx", mysqlx)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def mysql(self) -> Optional[str]:
        """
        MySQL specific server provided values
        """
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter
    def mysqlx(self) -> Optional[str]:
        return pulumi.get(self, "mysqlx")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetMySqlMysqlUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 mysql: Optional[str] = None,
                 mysqlx: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str mysql: MySQL specific server provided values
        """
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if mysqlx is not None:
            pulumi.set(__self__, "mysqlx", mysqlx)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def mysql(self) -> Optional[str]:
        """
        MySQL specific server provided values
        """
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter
    def mysqlx(self) -> Optional[str]:
        return pulumi.get(self, "mysqlx")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetMySqlMysqlUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 mysql: Optional[str] = None,
                 mysqlx: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str mysql: MySQL specific server provided values
        """
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if mysqlx is not None:
            pulumi.set(__self__, "mysqlx", mysqlx)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def mysql(self) -> Optional[str]:
        """
        MySQL specific server provided values
        """
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter
    def mysqlx(self) -> Optional[str]:
        return pulumi.get(self, "mysqlx")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetMySqlServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetMySqlTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetOpenSearchComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetOpenSearchOpensearchResult(dict):
    def __init__(__self__, *,
                 opensearch_dashboards_uri: str):
        pulumi.set(__self__, "opensearch_dashboards_uri", opensearch_dashboards_uri)

    @property
    @pulumi.getter(name="opensearchDashboardsUri")
    def opensearch_dashboards_uri(self) -> str:
        return pulumi.get(self, "opensearch_dashboards_uri")


@pulumi.output_type
class GetOpenSearchOpensearchUserConfigResult(dict):
    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 disable_replication_factor_adjustment: Optional[str] = None,
                 index_patterns: Optional[Sequence['outputs.GetOpenSearchOpensearchUserConfigIndexPatternResult']] = None,
                 index_template: Optional['outputs.GetOpenSearchOpensearchUserConfigIndexTemplateResult'] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 keep_index_refresh_interval: Optional[str] = None,
                 max_index_count: Optional[str] = None,
                 opensearch: Optional['outputs.GetOpenSearchOpensearchUserConfigOpensearchResult'] = None,
                 opensearch_dashboards: Optional['outputs.GetOpenSearchOpensearchUserConfigOpensearchDashboardsResult'] = None,
                 opensearch_version: Optional[str] = None,
                 private_access: Optional['outputs.GetOpenSearchOpensearchUserConfigPrivateAccessResult'] = None,
                 privatelink_access: Optional['outputs.GetOpenSearchOpensearchUserConfigPrivatelinkAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetOpenSearchOpensearchUserConfigPublicAccessResult'] = None,
                 recovery_basebackup_name: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        """
        :param 'GetOpenSearchOpensearchUserConfigOpensearchArgs' opensearch: Opensearch server provided values
        :param str static_ips: Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if disable_replication_factor_adjustment is not None:
            pulumi.set(__self__, "disable_replication_factor_adjustment", disable_replication_factor_adjustment)
        if index_patterns is not None:
            pulumi.set(__self__, "index_patterns", index_patterns)
        if index_template is not None:
            pulumi.set(__self__, "index_template", index_template)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if keep_index_refresh_interval is not None:
            pulumi.set(__self__, "keep_index_refresh_interval", keep_index_refresh_interval)
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if opensearch is not None:
            pulumi.set(__self__, "opensearch", opensearch)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if opensearch_version is not None:
            pulumi.set(__self__, "opensearch_version", opensearch_version)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_basebackup_name is not None:
            pulumi.set(__self__, "recovery_basebackup_name", recovery_basebackup_name)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="disableReplicationFactorAdjustment")
    def disable_replication_factor_adjustment(self) -> Optional[str]:
        return pulumi.get(self, "disable_replication_factor_adjustment")

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[Sequence['outputs.GetOpenSearchOpensearchUserConfigIndexPatternResult']]:
        return pulumi.get(self, "index_patterns")

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional['outputs.GetOpenSearchOpensearchUserConfigIndexTemplateResult']:
        return pulumi.get(self, "index_template")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[str]:
        return pulumi.get(self, "keep_index_refresh_interval")

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[str]:
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter
    def opensearch(self) -> Optional['outputs.GetOpenSearchOpensearchUserConfigOpensearchResult']:
        """
        Opensearch server provided values
        """
        return pulumi.get(self, "opensearch")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional['outputs.GetOpenSearchOpensearchUserConfigOpensearchDashboardsResult']:
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter(name="opensearchVersion")
    def opensearch_version(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_version")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetOpenSearchOpensearchUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetOpenSearchOpensearchUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetOpenSearchOpensearchUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryBasebackupName")
    def recovery_basebackup_name(self) -> Optional[str]:
        return pulumi.get(self, "recovery_basebackup_name")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetOpenSearchOpensearchUserConfigIndexPatternResult(dict):
    def __init__(__self__, *,
                 max_index_count: Optional[str] = None,
                 pattern: Optional[str] = None,
                 sorting_algorithm: Optional[str] = None):
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if sorting_algorithm is not None:
            pulumi.set(__self__, "sorting_algorithm", sorting_algorithm)

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[str]:
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="sortingAlgorithm")
    def sorting_algorithm(self) -> Optional[str]:
        return pulumi.get(self, "sorting_algorithm")


@pulumi.output_type
class GetOpenSearchOpensearchUserConfigIndexTemplateResult(dict):
    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[str] = None,
                 number_of_replicas: Optional[str] = None,
                 number_of_shards: Optional[str] = None):
        if mapping_nested_objects_limit is not None:
            pulumi.set(__self__, "mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[str]:
        return pulumi.get(self, "mapping_nested_objects_limit")

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[str]:
        return pulumi.get(self, "number_of_replicas")

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[str]:
        return pulumi.get(self, "number_of_shards")


@pulumi.output_type
class GetOpenSearchOpensearchUserConfigOpensearchResult(dict):
    def __init__(__self__, *,
                 action_auto_create_index_enabled: Optional[str] = None,
                 action_destructive_requires_name: Optional[str] = None,
                 cluster_max_shards_per_node: Optional[str] = None,
                 cluster_routing_allocation_node_concurrent_recoveries: Optional[str] = None,
                 email_sender_name: Optional[str] = None,
                 email_sender_password: Optional[str] = None,
                 email_sender_username: Optional[str] = None,
                 http_max_content_length: Optional[str] = None,
                 http_max_header_size: Optional[str] = None,
                 http_max_initial_line_length: Optional[str] = None,
                 indices_fielddata_cache_size: Optional[str] = None,
                 indices_memory_index_buffer_size: Optional[str] = None,
                 indices_queries_cache_size: Optional[str] = None,
                 indices_query_bool_max_clause_count: Optional[str] = None,
                 indices_recovery_max_bytes_per_sec: Optional[str] = None,
                 indices_recovery_max_concurrent_file_chunks: Optional[str] = None,
                 override_main_response_version: Optional[str] = None,
                 reindex_remote_whitelists: Optional[Sequence[str]] = None,
                 script_max_compilations_rate: Optional[str] = None,
                 search_max_buckets: Optional[str] = None,
                 thread_pool_analyze_queue_size: Optional[str] = None,
                 thread_pool_analyze_size: Optional[str] = None,
                 thread_pool_force_merge_size: Optional[str] = None,
                 thread_pool_get_queue_size: Optional[str] = None,
                 thread_pool_get_size: Optional[str] = None,
                 thread_pool_search_queue_size: Optional[str] = None,
                 thread_pool_search_size: Optional[str] = None,
                 thread_pool_search_throttled_queue_size: Optional[str] = None,
                 thread_pool_search_throttled_size: Optional[str] = None,
                 thread_pool_write_queue_size: Optional[str] = None,
                 thread_pool_write_size: Optional[str] = None):
        if action_auto_create_index_enabled is not None:
            pulumi.set(__self__, "action_auto_create_index_enabled", action_auto_create_index_enabled)
        if action_destructive_requires_name is not None:
            pulumi.set(__self__, "action_destructive_requires_name", action_destructive_requires_name)
        if cluster_max_shards_per_node is not None:
            pulumi.set(__self__, "cluster_max_shards_per_node", cluster_max_shards_per_node)
        if cluster_routing_allocation_node_concurrent_recoveries is not None:
            pulumi.set(__self__, "cluster_routing_allocation_node_concurrent_recoveries", cluster_routing_allocation_node_concurrent_recoveries)
        if email_sender_name is not None:
            pulumi.set(__self__, "email_sender_name", email_sender_name)
        if email_sender_password is not None:
            pulumi.set(__self__, "email_sender_password", email_sender_password)
        if email_sender_username is not None:
            pulumi.set(__self__, "email_sender_username", email_sender_username)
        if http_max_content_length is not None:
            pulumi.set(__self__, "http_max_content_length", http_max_content_length)
        if http_max_header_size is not None:
            pulumi.set(__self__, "http_max_header_size", http_max_header_size)
        if http_max_initial_line_length is not None:
            pulumi.set(__self__, "http_max_initial_line_length", http_max_initial_line_length)
        if indices_fielddata_cache_size is not None:
            pulumi.set(__self__, "indices_fielddata_cache_size", indices_fielddata_cache_size)
        if indices_memory_index_buffer_size is not None:
            pulumi.set(__self__, "indices_memory_index_buffer_size", indices_memory_index_buffer_size)
        if indices_queries_cache_size is not None:
            pulumi.set(__self__, "indices_queries_cache_size", indices_queries_cache_size)
        if indices_query_bool_max_clause_count is not None:
            pulumi.set(__self__, "indices_query_bool_max_clause_count", indices_query_bool_max_clause_count)
        if indices_recovery_max_bytes_per_sec is not None:
            pulumi.set(__self__, "indices_recovery_max_bytes_per_sec", indices_recovery_max_bytes_per_sec)
        if indices_recovery_max_concurrent_file_chunks is not None:
            pulumi.set(__self__, "indices_recovery_max_concurrent_file_chunks", indices_recovery_max_concurrent_file_chunks)
        if override_main_response_version is not None:
            pulumi.set(__self__, "override_main_response_version", override_main_response_version)
        if reindex_remote_whitelists is not None:
            pulumi.set(__self__, "reindex_remote_whitelists", reindex_remote_whitelists)
        if script_max_compilations_rate is not None:
            pulumi.set(__self__, "script_max_compilations_rate", script_max_compilations_rate)
        if search_max_buckets is not None:
            pulumi.set(__self__, "search_max_buckets", search_max_buckets)
        if thread_pool_analyze_queue_size is not None:
            pulumi.set(__self__, "thread_pool_analyze_queue_size", thread_pool_analyze_queue_size)
        if thread_pool_analyze_size is not None:
            pulumi.set(__self__, "thread_pool_analyze_size", thread_pool_analyze_size)
        if thread_pool_force_merge_size is not None:
            pulumi.set(__self__, "thread_pool_force_merge_size", thread_pool_force_merge_size)
        if thread_pool_get_queue_size is not None:
            pulumi.set(__self__, "thread_pool_get_queue_size", thread_pool_get_queue_size)
        if thread_pool_get_size is not None:
            pulumi.set(__self__, "thread_pool_get_size", thread_pool_get_size)
        if thread_pool_search_queue_size is not None:
            pulumi.set(__self__, "thread_pool_search_queue_size", thread_pool_search_queue_size)
        if thread_pool_search_size is not None:
            pulumi.set(__self__, "thread_pool_search_size", thread_pool_search_size)
        if thread_pool_search_throttled_queue_size is not None:
            pulumi.set(__self__, "thread_pool_search_throttled_queue_size", thread_pool_search_throttled_queue_size)
        if thread_pool_search_throttled_size is not None:
            pulumi.set(__self__, "thread_pool_search_throttled_size", thread_pool_search_throttled_size)
        if thread_pool_write_queue_size is not None:
            pulumi.set(__self__, "thread_pool_write_queue_size", thread_pool_write_queue_size)
        if thread_pool_write_size is not None:
            pulumi.set(__self__, "thread_pool_write_size", thread_pool_write_size)

    @property
    @pulumi.getter(name="actionAutoCreateIndexEnabled")
    def action_auto_create_index_enabled(self) -> Optional[str]:
        return pulumi.get(self, "action_auto_create_index_enabled")

    @property
    @pulumi.getter(name="actionDestructiveRequiresName")
    def action_destructive_requires_name(self) -> Optional[str]:
        return pulumi.get(self, "action_destructive_requires_name")

    @property
    @pulumi.getter(name="clusterMaxShardsPerNode")
    def cluster_max_shards_per_node(self) -> Optional[str]:
        return pulumi.get(self, "cluster_max_shards_per_node")

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeConcurrentRecoveries")
    def cluster_routing_allocation_node_concurrent_recoveries(self) -> Optional[str]:
        return pulumi.get(self, "cluster_routing_allocation_node_concurrent_recoveries")

    @property
    @pulumi.getter(name="emailSenderName")
    def email_sender_name(self) -> Optional[str]:
        return pulumi.get(self, "email_sender_name")

    @property
    @pulumi.getter(name="emailSenderPassword")
    def email_sender_password(self) -> Optional[str]:
        return pulumi.get(self, "email_sender_password")

    @property
    @pulumi.getter(name="emailSenderUsername")
    def email_sender_username(self) -> Optional[str]:
        return pulumi.get(self, "email_sender_username")

    @property
    @pulumi.getter(name="httpMaxContentLength")
    def http_max_content_length(self) -> Optional[str]:
        return pulumi.get(self, "http_max_content_length")

    @property
    @pulumi.getter(name="httpMaxHeaderSize")
    def http_max_header_size(self) -> Optional[str]:
        return pulumi.get(self, "http_max_header_size")

    @property
    @pulumi.getter(name="httpMaxInitialLineLength")
    def http_max_initial_line_length(self) -> Optional[str]:
        return pulumi.get(self, "http_max_initial_line_length")

    @property
    @pulumi.getter(name="indicesFielddataCacheSize")
    def indices_fielddata_cache_size(self) -> Optional[str]:
        return pulumi.get(self, "indices_fielddata_cache_size")

    @property
    @pulumi.getter(name="indicesMemoryIndexBufferSize")
    def indices_memory_index_buffer_size(self) -> Optional[str]:
        return pulumi.get(self, "indices_memory_index_buffer_size")

    @property
    @pulumi.getter(name="indicesQueriesCacheSize")
    def indices_queries_cache_size(self) -> Optional[str]:
        return pulumi.get(self, "indices_queries_cache_size")

    @property
    @pulumi.getter(name="indicesQueryBoolMaxClauseCount")
    def indices_query_bool_max_clause_count(self) -> Optional[str]:
        return pulumi.get(self, "indices_query_bool_max_clause_count")

    @property
    @pulumi.getter(name="indicesRecoveryMaxBytesPerSec")
    def indices_recovery_max_bytes_per_sec(self) -> Optional[str]:
        return pulumi.get(self, "indices_recovery_max_bytes_per_sec")

    @property
    @pulumi.getter(name="indicesRecoveryMaxConcurrentFileChunks")
    def indices_recovery_max_concurrent_file_chunks(self) -> Optional[str]:
        return pulumi.get(self, "indices_recovery_max_concurrent_file_chunks")

    @property
    @pulumi.getter(name="overrideMainResponseVersion")
    def override_main_response_version(self) -> Optional[str]:
        return pulumi.get(self, "override_main_response_version")

    @property
    @pulumi.getter(name="reindexRemoteWhitelists")
    def reindex_remote_whitelists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "reindex_remote_whitelists")

    @property
    @pulumi.getter(name="scriptMaxCompilationsRate")
    def script_max_compilations_rate(self) -> Optional[str]:
        return pulumi.get(self, "script_max_compilations_rate")

    @property
    @pulumi.getter(name="searchMaxBuckets")
    def search_max_buckets(self) -> Optional[str]:
        return pulumi.get(self, "search_max_buckets")

    @property
    @pulumi.getter(name="threadPoolAnalyzeQueueSize")
    def thread_pool_analyze_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_analyze_queue_size")

    @property
    @pulumi.getter(name="threadPoolAnalyzeSize")
    def thread_pool_analyze_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_analyze_size")

    @property
    @pulumi.getter(name="threadPoolForceMergeSize")
    def thread_pool_force_merge_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_force_merge_size")

    @property
    @pulumi.getter(name="threadPoolGetQueueSize")
    def thread_pool_get_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_get_queue_size")

    @property
    @pulumi.getter(name="threadPoolGetSize")
    def thread_pool_get_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_get_size")

    @property
    @pulumi.getter(name="threadPoolSearchQueueSize")
    def thread_pool_search_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_search_queue_size")

    @property
    @pulumi.getter(name="threadPoolSearchSize")
    def thread_pool_search_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_search_size")

    @property
    @pulumi.getter(name="threadPoolSearchThrottledQueueSize")
    def thread_pool_search_throttled_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_search_throttled_queue_size")

    @property
    @pulumi.getter(name="threadPoolSearchThrottledSize")
    def thread_pool_search_throttled_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_search_throttled_size")

    @property
    @pulumi.getter(name="threadPoolWriteQueueSize")
    def thread_pool_write_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_write_queue_size")

    @property
    @pulumi.getter(name="threadPoolWriteSize")
    def thread_pool_write_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_write_size")


@pulumi.output_type
class GetOpenSearchOpensearchUserConfigOpensearchDashboardsResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[str] = None,
                 max_old_space_size: Optional[str] = None,
                 opensearch_request_timeout: Optional[str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_old_space_size is not None:
            pulumi.set(__self__, "max_old_space_size", max_old_space_size)
        if opensearch_request_timeout is not None:
            pulumi.set(__self__, "opensearch_request_timeout", opensearch_request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[str]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[str]:
        return pulumi.get(self, "max_old_space_size")

    @property
    @pulumi.getter(name="opensearchRequestTimeout")
    def opensearch_request_timeout(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_request_timeout")


@pulumi.output_type
class GetOpenSearchOpensearchUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 opensearch: Optional[str] = None,
                 opensearch_dashboards: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str opensearch: Opensearch server provided values
        """
        if opensearch is not None:
            pulumi.set(__self__, "opensearch", opensearch)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def opensearch(self) -> Optional[str]:
        """
        Opensearch server provided values
        """
        return pulumi.get(self, "opensearch")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetOpenSearchOpensearchUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 opensearch: Optional[str] = None,
                 opensearch_dashboards: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str opensearch: Opensearch server provided values
        """
        if opensearch is not None:
            pulumi.set(__self__, "opensearch", opensearch)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def opensearch(self) -> Optional[str]:
        """
        Opensearch server provided values
        """
        return pulumi.get(self, "opensearch")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetOpenSearchOpensearchUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 opensearch: Optional[str] = None,
                 opensearch_dashboards: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str opensearch: Opensearch server provided values
        """
        if opensearch is not None:
            pulumi.set(__self__, "opensearch", opensearch)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def opensearch(self) -> Optional[str]:
        """
        Opensearch server provided values
        """
        return pulumi.get(self, "opensearch")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetOpenSearchServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetOpenSearchTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPgComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetPgPgResult(dict):
    def __init__(__self__, *,
                 dbname: str,
                 host: str,
                 max_connections: int,
                 password: str,
                 port: int,
                 replica_uri: str,
                 sslmode: str,
                 uri: str,
                 user: str):
        pulumi.set(__self__, "dbname", dbname)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "max_connections", max_connections)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "replica_uri", replica_uri)
        pulumi.set(__self__, "sslmode", sslmode)
        pulumi.set(__self__, "uri", uri)
        pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def dbname(self) -> str:
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> int:
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="replicaUri")
    def replica_uri(self) -> str:
        return pulumi.get(self, "replica_uri")

    @property
    @pulumi.getter
    def sslmode(self) -> str:
        return pulumi.get(self, "sslmode")

    @property
    @pulumi.getter
    def uri(self) -> str:
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def user(self) -> str:
        return pulumi.get(self, "user")


@pulumi.output_type
class GetPgPgUserConfigResult(dict):
    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_hour: Optional[str] = None,
                 backup_minute: Optional[str] = None,
                 enable_ipv6: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 migration: Optional['outputs.GetPgPgUserConfigMigrationResult'] = None,
                 pg: Optional['outputs.GetPgPgUserConfigPgResult'] = None,
                 pg_read_replica: Optional[str] = None,
                 pg_service_to_fork_from: Optional[str] = None,
                 pg_stat_monitor_enable: Optional[str] = None,
                 pg_version: Optional[str] = None,
                 pgbouncer: Optional['outputs.GetPgPgUserConfigPgbouncerResult'] = None,
                 pglookout: Optional['outputs.GetPgPgUserConfigPglookoutResult'] = None,
                 private_access: Optional['outputs.GetPgPgUserConfigPrivateAccessResult'] = None,
                 privatelink_access: Optional['outputs.GetPgPgUserConfigPrivatelinkAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetPgPgUserConfigPublicAccessResult'] = None,
                 recovery_target_time: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 shared_buffers_percentage: Optional[str] = None,
                 static_ips: Optional[str] = None,
                 synchronous_replication: Optional[str] = None,
                 timescaledb: Optional['outputs.GetPgPgUserConfigTimescaledbResult'] = None,
                 variant: Optional[str] = None,
                 work_mem: Optional[str] = None):
        """
        :param 'GetPgPgUserConfigPgArgs' pg: PostgreSQL specific server provided values
        :param str static_ips: Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if enable_ipv6 is not None:
            pulumi.set(__self__, "enable_ipv6", enable_ipv6)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if pg_read_replica is not None:
            pulumi.set(__self__, "pg_read_replica", pg_read_replica)
        if pg_service_to_fork_from is not None:
            pulumi.set(__self__, "pg_service_to_fork_from", pg_service_to_fork_from)
        if pg_stat_monitor_enable is not None:
            pulumi.set(__self__, "pg_stat_monitor_enable", pg_stat_monitor_enable)
        if pg_version is not None:
            pulumi.set(__self__, "pg_version", pg_version)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if pglookout is not None:
            pulumi.set(__self__, "pglookout", pglookout)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_target_time is not None:
            pulumi.set(__self__, "recovery_target_time", recovery_target_time)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if shared_buffers_percentage is not None:
            pulumi.set(__self__, "shared_buffers_percentage", shared_buffers_percentage)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)
        if synchronous_replication is not None:
            pulumi.set(__self__, "synchronous_replication", synchronous_replication)
        if timescaledb is not None:
            pulumi.set(__self__, "timescaledb", timescaledb)
        if variant is not None:
            pulumi.set(__self__, "variant", variant)
        if work_mem is not None:
            pulumi.set(__self__, "work_mem", work_mem)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[str]:
        return pulumi.get(self, "backup_hour")

    @property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[str]:
        return pulumi.get(self, "backup_minute")

    @property
    @pulumi.getter(name="enableIpv6")
    def enable_ipv6(self) -> Optional[str]:
        return pulumi.get(self, "enable_ipv6")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def migration(self) -> Optional['outputs.GetPgPgUserConfigMigrationResult']:
        return pulumi.get(self, "migration")

    @property
    @pulumi.getter
    def pg(self) -> Optional['outputs.GetPgPgUserConfigPgResult']:
        """
        PostgreSQL specific server provided values
        """
        return pulumi.get(self, "pg")

    @property
    @pulumi.getter(name="pgReadReplica")
    def pg_read_replica(self) -> Optional[str]:
        return pulumi.get(self, "pg_read_replica")

    @property
    @pulumi.getter(name="pgServiceToForkFrom")
    def pg_service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "pg_service_to_fork_from")

    @property
    @pulumi.getter(name="pgStatMonitorEnable")
    def pg_stat_monitor_enable(self) -> Optional[str]:
        return pulumi.get(self, "pg_stat_monitor_enable")

    @property
    @pulumi.getter(name="pgVersion")
    def pg_version(self) -> Optional[str]:
        return pulumi.get(self, "pg_version")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional['outputs.GetPgPgUserConfigPgbouncerResult']:
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def pglookout(self) -> Optional['outputs.GetPgPgUserConfigPglookoutResult']:
        return pulumi.get(self, "pglookout")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetPgPgUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetPgPgUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetPgPgUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryTargetTime")
    def recovery_target_time(self) -> Optional[str]:
        return pulumi.get(self, "recovery_target_time")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="sharedBuffersPercentage")
    def shared_buffers_percentage(self) -> Optional[str]:
        return pulumi.get(self, "shared_buffers_percentage")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        return pulumi.get(self, "static_ips")

    @property
    @pulumi.getter(name="synchronousReplication")
    def synchronous_replication(self) -> Optional[str]:
        return pulumi.get(self, "synchronous_replication")

    @property
    @pulumi.getter
    def timescaledb(self) -> Optional['outputs.GetPgPgUserConfigTimescaledbResult']:
        return pulumi.get(self, "timescaledb")

    @property
    @pulumi.getter
    def variant(self) -> Optional[str]:
        return pulumi.get(self, "variant")

    @property
    @pulumi.getter(name="workMem")
    def work_mem(self) -> Optional[str]:
        return pulumi.get(self, "work_mem")


@pulumi.output_type
class GetPgPgUserConfigMigrationResult(dict):
    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 ignore_dbs: Optional[str] = None,
                 method: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 ssl: Optional[str] = None,
                 username: Optional[str] = None):
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[str]:
        return pulumi.get(self, "ignore_dbs")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetPgPgUserConfigPgResult(dict):
    def __init__(__self__, *,
                 autovacuum_analyze_scale_factor: Optional[str] = None,
                 autovacuum_analyze_threshold: Optional[str] = None,
                 autovacuum_freeze_max_age: Optional[str] = None,
                 autovacuum_max_workers: Optional[str] = None,
                 autovacuum_naptime: Optional[str] = None,
                 autovacuum_vacuum_cost_delay: Optional[str] = None,
                 autovacuum_vacuum_cost_limit: Optional[str] = None,
                 autovacuum_vacuum_scale_factor: Optional[str] = None,
                 autovacuum_vacuum_threshold: Optional[str] = None,
                 bgwriter_delay: Optional[str] = None,
                 bgwriter_flush_after: Optional[str] = None,
                 bgwriter_lru_maxpages: Optional[str] = None,
                 bgwriter_lru_multiplier: Optional[str] = None,
                 deadlock_timeout: Optional[str] = None,
                 default_toast_compression: Optional[str] = None,
                 idle_in_transaction_session_timeout: Optional[str] = None,
                 jit: Optional[str] = None,
                 log_autovacuum_min_duration: Optional[str] = None,
                 log_error_verbosity: Optional[str] = None,
                 log_line_prefix: Optional[str] = None,
                 log_min_duration_statement: Optional[str] = None,
                 log_temp_files: Optional[str] = None,
                 max_files_per_process: Optional[str] = None,
                 max_locks_per_transaction: Optional[str] = None,
                 max_logical_replication_workers: Optional[str] = None,
                 max_parallel_workers: Optional[str] = None,
                 max_parallel_workers_per_gather: Optional[str] = None,
                 max_pred_locks_per_transaction: Optional[str] = None,
                 max_prepared_transactions: Optional[str] = None,
                 max_replication_slots: Optional[str] = None,
                 max_slot_wal_keep_size: Optional[str] = None,
                 max_stack_depth: Optional[str] = None,
                 max_standby_archive_delay: Optional[str] = None,
                 max_standby_streaming_delay: Optional[str] = None,
                 max_wal_senders: Optional[str] = None,
                 max_worker_processes: Optional[str] = None,
                 pg_partman_bgw_dot_interval: Optional[str] = None,
                 pg_partman_bgw_dot_role: Optional[str] = None,
                 pg_stat_statements_dot_track: Optional[str] = None,
                 temp_file_limit: Optional[str] = None,
                 timezone: Optional[str] = None,
                 track_activity_query_size: Optional[str] = None,
                 track_commit_timestamp: Optional[str] = None,
                 track_functions: Optional[str] = None,
                 track_io_timing: Optional[str] = None,
                 wal_sender_timeout: Optional[str] = None,
                 wal_writer_delay: Optional[str] = None):
        if autovacuum_analyze_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_analyze_scale_factor", autovacuum_analyze_scale_factor)
        if autovacuum_analyze_threshold is not None:
            pulumi.set(__self__, "autovacuum_analyze_threshold", autovacuum_analyze_threshold)
        if autovacuum_freeze_max_age is not None:
            pulumi.set(__self__, "autovacuum_freeze_max_age", autovacuum_freeze_max_age)
        if autovacuum_max_workers is not None:
            pulumi.set(__self__, "autovacuum_max_workers", autovacuum_max_workers)
        if autovacuum_naptime is not None:
            pulumi.set(__self__, "autovacuum_naptime", autovacuum_naptime)
        if autovacuum_vacuum_cost_delay is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_delay", autovacuum_vacuum_cost_delay)
        if autovacuum_vacuum_cost_limit is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_limit", autovacuum_vacuum_cost_limit)
        if autovacuum_vacuum_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_vacuum_scale_factor", autovacuum_vacuum_scale_factor)
        if autovacuum_vacuum_threshold is not None:
            pulumi.set(__self__, "autovacuum_vacuum_threshold", autovacuum_vacuum_threshold)
        if bgwriter_delay is not None:
            pulumi.set(__self__, "bgwriter_delay", bgwriter_delay)
        if bgwriter_flush_after is not None:
            pulumi.set(__self__, "bgwriter_flush_after", bgwriter_flush_after)
        if bgwriter_lru_maxpages is not None:
            pulumi.set(__self__, "bgwriter_lru_maxpages", bgwriter_lru_maxpages)
        if bgwriter_lru_multiplier is not None:
            pulumi.set(__self__, "bgwriter_lru_multiplier", bgwriter_lru_multiplier)
        if deadlock_timeout is not None:
            pulumi.set(__self__, "deadlock_timeout", deadlock_timeout)
        if default_toast_compression is not None:
            pulumi.set(__self__, "default_toast_compression", default_toast_compression)
        if idle_in_transaction_session_timeout is not None:
            pulumi.set(__self__, "idle_in_transaction_session_timeout", idle_in_transaction_session_timeout)
        if jit is not None:
            pulumi.set(__self__, "jit", jit)
        if log_autovacuum_min_duration is not None:
            pulumi.set(__self__, "log_autovacuum_min_duration", log_autovacuum_min_duration)
        if log_error_verbosity is not None:
            pulumi.set(__self__, "log_error_verbosity", log_error_verbosity)
        if log_line_prefix is not None:
            pulumi.set(__self__, "log_line_prefix", log_line_prefix)
        if log_min_duration_statement is not None:
            pulumi.set(__self__, "log_min_duration_statement", log_min_duration_statement)
        if log_temp_files is not None:
            pulumi.set(__self__, "log_temp_files", log_temp_files)
        if max_files_per_process is not None:
            pulumi.set(__self__, "max_files_per_process", max_files_per_process)
        if max_locks_per_transaction is not None:
            pulumi.set(__self__, "max_locks_per_transaction", max_locks_per_transaction)
        if max_logical_replication_workers is not None:
            pulumi.set(__self__, "max_logical_replication_workers", max_logical_replication_workers)
        if max_parallel_workers is not None:
            pulumi.set(__self__, "max_parallel_workers", max_parallel_workers)
        if max_parallel_workers_per_gather is not None:
            pulumi.set(__self__, "max_parallel_workers_per_gather", max_parallel_workers_per_gather)
        if max_pred_locks_per_transaction is not None:
            pulumi.set(__self__, "max_pred_locks_per_transaction", max_pred_locks_per_transaction)
        if max_prepared_transactions is not None:
            pulumi.set(__self__, "max_prepared_transactions", max_prepared_transactions)
        if max_replication_slots is not None:
            pulumi.set(__self__, "max_replication_slots", max_replication_slots)
        if max_slot_wal_keep_size is not None:
            pulumi.set(__self__, "max_slot_wal_keep_size", max_slot_wal_keep_size)
        if max_stack_depth is not None:
            pulumi.set(__self__, "max_stack_depth", max_stack_depth)
        if max_standby_archive_delay is not None:
            pulumi.set(__self__, "max_standby_archive_delay", max_standby_archive_delay)
        if max_standby_streaming_delay is not None:
            pulumi.set(__self__, "max_standby_streaming_delay", max_standby_streaming_delay)
        if max_wal_senders is not None:
            pulumi.set(__self__, "max_wal_senders", max_wal_senders)
        if max_worker_processes is not None:
            pulumi.set(__self__, "max_worker_processes", max_worker_processes)
        if pg_partman_bgw_dot_interval is not None:
            pulumi.set(__self__, "pg_partman_bgw_dot_interval", pg_partman_bgw_dot_interval)
        if pg_partman_bgw_dot_role is not None:
            pulumi.set(__self__, "pg_partman_bgw_dot_role", pg_partman_bgw_dot_role)
        if pg_stat_statements_dot_track is not None:
            pulumi.set(__self__, "pg_stat_statements_dot_track", pg_stat_statements_dot_track)
        if temp_file_limit is not None:
            pulumi.set(__self__, "temp_file_limit", temp_file_limit)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if track_activity_query_size is not None:
            pulumi.set(__self__, "track_activity_query_size", track_activity_query_size)
        if track_commit_timestamp is not None:
            pulumi.set(__self__, "track_commit_timestamp", track_commit_timestamp)
        if track_functions is not None:
            pulumi.set(__self__, "track_functions", track_functions)
        if track_io_timing is not None:
            pulumi.set(__self__, "track_io_timing", track_io_timing)
        if wal_sender_timeout is not None:
            pulumi.set(__self__, "wal_sender_timeout", wal_sender_timeout)
        if wal_writer_delay is not None:
            pulumi.set(__self__, "wal_writer_delay", wal_writer_delay)

    @property
    @pulumi.getter(name="autovacuumAnalyzeScaleFactor")
    def autovacuum_analyze_scale_factor(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_analyze_scale_factor")

    @property
    @pulumi.getter(name="autovacuumAnalyzeThreshold")
    def autovacuum_analyze_threshold(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_analyze_threshold")

    @property
    @pulumi.getter(name="autovacuumFreezeMaxAge")
    def autovacuum_freeze_max_age(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_freeze_max_age")

    @property
    @pulumi.getter(name="autovacuumMaxWorkers")
    def autovacuum_max_workers(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_max_workers")

    @property
    @pulumi.getter(name="autovacuumNaptime")
    def autovacuum_naptime(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_naptime")

    @property
    @pulumi.getter(name="autovacuumVacuumCostDelay")
    def autovacuum_vacuum_cost_delay(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_vacuum_cost_delay")

    @property
    @pulumi.getter(name="autovacuumVacuumCostLimit")
    def autovacuum_vacuum_cost_limit(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_vacuum_cost_limit")

    @property
    @pulumi.getter(name="autovacuumVacuumScaleFactor")
    def autovacuum_vacuum_scale_factor(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_vacuum_scale_factor")

    @property
    @pulumi.getter(name="autovacuumVacuumThreshold")
    def autovacuum_vacuum_threshold(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_vacuum_threshold")

    @property
    @pulumi.getter(name="bgwriterDelay")
    def bgwriter_delay(self) -> Optional[str]:
        return pulumi.get(self, "bgwriter_delay")

    @property
    @pulumi.getter(name="bgwriterFlushAfter")
    def bgwriter_flush_after(self) -> Optional[str]:
        return pulumi.get(self, "bgwriter_flush_after")

    @property
    @pulumi.getter(name="bgwriterLruMaxpages")
    def bgwriter_lru_maxpages(self) -> Optional[str]:
        return pulumi.get(self, "bgwriter_lru_maxpages")

    @property
    @pulumi.getter(name="bgwriterLruMultiplier")
    def bgwriter_lru_multiplier(self) -> Optional[str]:
        return pulumi.get(self, "bgwriter_lru_multiplier")

    @property
    @pulumi.getter(name="deadlockTimeout")
    def deadlock_timeout(self) -> Optional[str]:
        return pulumi.get(self, "deadlock_timeout")

    @property
    @pulumi.getter(name="defaultToastCompression")
    def default_toast_compression(self) -> Optional[str]:
        return pulumi.get(self, "default_toast_compression")

    @property
    @pulumi.getter(name="idleInTransactionSessionTimeout")
    def idle_in_transaction_session_timeout(self) -> Optional[str]:
        return pulumi.get(self, "idle_in_transaction_session_timeout")

    @property
    @pulumi.getter
    def jit(self) -> Optional[str]:
        return pulumi.get(self, "jit")

    @property
    @pulumi.getter(name="logAutovacuumMinDuration")
    def log_autovacuum_min_duration(self) -> Optional[str]:
        return pulumi.get(self, "log_autovacuum_min_duration")

    @property
    @pulumi.getter(name="logErrorVerbosity")
    def log_error_verbosity(self) -> Optional[str]:
        return pulumi.get(self, "log_error_verbosity")

    @property
    @pulumi.getter(name="logLinePrefix")
    def log_line_prefix(self) -> Optional[str]:
        return pulumi.get(self, "log_line_prefix")

    @property
    @pulumi.getter(name="logMinDurationStatement")
    def log_min_duration_statement(self) -> Optional[str]:
        return pulumi.get(self, "log_min_duration_statement")

    @property
    @pulumi.getter(name="logTempFiles")
    def log_temp_files(self) -> Optional[str]:
        return pulumi.get(self, "log_temp_files")

    @property
    @pulumi.getter(name="maxFilesPerProcess")
    def max_files_per_process(self) -> Optional[str]:
        return pulumi.get(self, "max_files_per_process")

    @property
    @pulumi.getter(name="maxLocksPerTransaction")
    def max_locks_per_transaction(self) -> Optional[str]:
        return pulumi.get(self, "max_locks_per_transaction")

    @property
    @pulumi.getter(name="maxLogicalReplicationWorkers")
    def max_logical_replication_workers(self) -> Optional[str]:
        return pulumi.get(self, "max_logical_replication_workers")

    @property
    @pulumi.getter(name="maxParallelWorkers")
    def max_parallel_workers(self) -> Optional[str]:
        return pulumi.get(self, "max_parallel_workers")

    @property
    @pulumi.getter(name="maxParallelWorkersPerGather")
    def max_parallel_workers_per_gather(self) -> Optional[str]:
        return pulumi.get(self, "max_parallel_workers_per_gather")

    @property
    @pulumi.getter(name="maxPredLocksPerTransaction")
    def max_pred_locks_per_transaction(self) -> Optional[str]:
        return pulumi.get(self, "max_pred_locks_per_transaction")

    @property
    @pulumi.getter(name="maxPreparedTransactions")
    def max_prepared_transactions(self) -> Optional[str]:
        return pulumi.get(self, "max_prepared_transactions")

    @property
    @pulumi.getter(name="maxReplicationSlots")
    def max_replication_slots(self) -> Optional[str]:
        return pulumi.get(self, "max_replication_slots")

    @property
    @pulumi.getter(name="maxSlotWalKeepSize")
    def max_slot_wal_keep_size(self) -> Optional[str]:
        return pulumi.get(self, "max_slot_wal_keep_size")

    @property
    @pulumi.getter(name="maxStackDepth")
    def max_stack_depth(self) -> Optional[str]:
        return pulumi.get(self, "max_stack_depth")

    @property
    @pulumi.getter(name="maxStandbyArchiveDelay")
    def max_standby_archive_delay(self) -> Optional[str]:
        return pulumi.get(self, "max_standby_archive_delay")

    @property
    @pulumi.getter(name="maxStandbyStreamingDelay")
    def max_standby_streaming_delay(self) -> Optional[str]:
        return pulumi.get(self, "max_standby_streaming_delay")

    @property
    @pulumi.getter(name="maxWalSenders")
    def max_wal_senders(self) -> Optional[str]:
        return pulumi.get(self, "max_wal_senders")

    @property
    @pulumi.getter(name="maxWorkerProcesses")
    def max_worker_processes(self) -> Optional[str]:
        return pulumi.get(self, "max_worker_processes")

    @property
    @pulumi.getter(name="pgPartmanBgwDotInterval")
    def pg_partman_bgw_dot_interval(self) -> Optional[str]:
        return pulumi.get(self, "pg_partman_bgw_dot_interval")

    @property
    @pulumi.getter(name="pgPartmanBgwDotRole")
    def pg_partman_bgw_dot_role(self) -> Optional[str]:
        return pulumi.get(self, "pg_partman_bgw_dot_role")

    @property
    @pulumi.getter(name="pgStatStatementsDotTrack")
    def pg_stat_statements_dot_track(self) -> Optional[str]:
        return pulumi.get(self, "pg_stat_statements_dot_track")

    @property
    @pulumi.getter(name="tempFileLimit")
    def temp_file_limit(self) -> Optional[str]:
        return pulumi.get(self, "temp_file_limit")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter(name="trackActivityQuerySize")
    def track_activity_query_size(self) -> Optional[str]:
        return pulumi.get(self, "track_activity_query_size")

    @property
    @pulumi.getter(name="trackCommitTimestamp")
    def track_commit_timestamp(self) -> Optional[str]:
        return pulumi.get(self, "track_commit_timestamp")

    @property
    @pulumi.getter(name="trackFunctions")
    def track_functions(self) -> Optional[str]:
        return pulumi.get(self, "track_functions")

    @property
    @pulumi.getter(name="trackIoTiming")
    def track_io_timing(self) -> Optional[str]:
        return pulumi.get(self, "track_io_timing")

    @property
    @pulumi.getter(name="walSenderTimeout")
    def wal_sender_timeout(self) -> Optional[str]:
        return pulumi.get(self, "wal_sender_timeout")

    @property
    @pulumi.getter(name="walWriterDelay")
    def wal_writer_delay(self) -> Optional[str]:
        return pulumi.get(self, "wal_writer_delay")


@pulumi.output_type
class GetPgPgUserConfigPgbouncerResult(dict):
    def __init__(__self__, *,
                 autodb_idle_timeout: Optional[str] = None,
                 autodb_max_db_connections: Optional[str] = None,
                 autodb_pool_mode: Optional[str] = None,
                 autodb_pool_size: Optional[str] = None,
                 ignore_startup_parameters: Optional[Sequence[str]] = None,
                 min_pool_size: Optional[str] = None,
                 server_idle_timeout: Optional[str] = None,
                 server_lifetime: Optional[str] = None,
                 server_reset_query_always: Optional[str] = None):
        if autodb_idle_timeout is not None:
            pulumi.set(__self__, "autodb_idle_timeout", autodb_idle_timeout)
        if autodb_max_db_connections is not None:
            pulumi.set(__self__, "autodb_max_db_connections", autodb_max_db_connections)
        if autodb_pool_mode is not None:
            pulumi.set(__self__, "autodb_pool_mode", autodb_pool_mode)
        if autodb_pool_size is not None:
            pulumi.set(__self__, "autodb_pool_size", autodb_pool_size)
        if ignore_startup_parameters is not None:
            pulumi.set(__self__, "ignore_startup_parameters", ignore_startup_parameters)
        if min_pool_size is not None:
            pulumi.set(__self__, "min_pool_size", min_pool_size)
        if server_idle_timeout is not None:
            pulumi.set(__self__, "server_idle_timeout", server_idle_timeout)
        if server_lifetime is not None:
            pulumi.set(__self__, "server_lifetime", server_lifetime)
        if server_reset_query_always is not None:
            pulumi.set(__self__, "server_reset_query_always", server_reset_query_always)

    @property
    @pulumi.getter(name="autodbIdleTimeout")
    def autodb_idle_timeout(self) -> Optional[str]:
        return pulumi.get(self, "autodb_idle_timeout")

    @property
    @pulumi.getter(name="autodbMaxDbConnections")
    def autodb_max_db_connections(self) -> Optional[str]:
        return pulumi.get(self, "autodb_max_db_connections")

    @property
    @pulumi.getter(name="autodbPoolMode")
    def autodb_pool_mode(self) -> Optional[str]:
        return pulumi.get(self, "autodb_pool_mode")

    @property
    @pulumi.getter(name="autodbPoolSize")
    def autodb_pool_size(self) -> Optional[str]:
        return pulumi.get(self, "autodb_pool_size")

    @property
    @pulumi.getter(name="ignoreStartupParameters")
    def ignore_startup_parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ignore_startup_parameters")

    @property
    @pulumi.getter(name="minPoolSize")
    def min_pool_size(self) -> Optional[str]:
        return pulumi.get(self, "min_pool_size")

    @property
    @pulumi.getter(name="serverIdleTimeout")
    def server_idle_timeout(self) -> Optional[str]:
        return pulumi.get(self, "server_idle_timeout")

    @property
    @pulumi.getter(name="serverLifetime")
    def server_lifetime(self) -> Optional[str]:
        return pulumi.get(self, "server_lifetime")

    @property
    @pulumi.getter(name="serverResetQueryAlways")
    def server_reset_query_always(self) -> Optional[str]:
        return pulumi.get(self, "server_reset_query_always")


@pulumi.output_type
class GetPgPgUserConfigPglookoutResult(dict):
    def __init__(__self__, *,
                 max_failover_replication_time_lag: Optional[str] = None):
        if max_failover_replication_time_lag is not None:
            pulumi.set(__self__, "max_failover_replication_time_lag", max_failover_replication_time_lag)

    @property
    @pulumi.getter(name="maxFailoverReplicationTimeLag")
    def max_failover_replication_time_lag(self) -> Optional[str]:
        return pulumi.get(self, "max_failover_replication_time_lag")


@pulumi.output_type
class GetPgPgUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 pg: Optional[str] = None,
                 pgbouncer: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str pg: PostgreSQL specific server provided values
        """
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def pg(self) -> Optional[str]:
        """
        PostgreSQL specific server provided values
        """
        return pulumi.get(self, "pg")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional[str]:
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetPgPgUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 pg: Optional[str] = None,
                 pgbouncer: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str pg: PostgreSQL specific server provided values
        """
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def pg(self) -> Optional[str]:
        """
        PostgreSQL specific server provided values
        """
        return pulumi.get(self, "pg")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional[str]:
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetPgPgUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 pg: Optional[str] = None,
                 pgbouncer: Optional[str] = None,
                 prometheus: Optional[str] = None):
        """
        :param str pg: PostgreSQL specific server provided values
        """
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def pg(self) -> Optional[str]:
        """
        PostgreSQL specific server provided values
        """
        return pulumi.get(self, "pg")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional[str]:
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetPgPgUserConfigTimescaledbResult(dict):
    def __init__(__self__, *,
                 max_background_workers: Optional[str] = None):
        if max_background_workers is not None:
            pulumi.set(__self__, "max_background_workers", max_background_workers)

    @property
    @pulumi.getter(name="maxBackgroundWorkers")
    def max_background_workers(self) -> Optional[str]:
        return pulumi.get(self, "max_background_workers")


@pulumi.output_type
class GetPgServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetPgTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetProjectTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRedisComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetRedisRediResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetRedisRedisUserConfigResult(dict):
    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 migration: Optional['outputs.GetRedisRedisUserConfigMigrationResult'] = None,
                 private_access: Optional['outputs.GetRedisRedisUserConfigPrivateAccessResult'] = None,
                 privatelink_access: Optional['outputs.GetRedisRedisUserConfigPrivatelinkAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetRedisRedisUserConfigPublicAccessResult'] = None,
                 recovery_basebackup_name: Optional[str] = None,
                 redis_acl_channels_default: Optional[str] = None,
                 redis_io_threads: Optional[str] = None,
                 redis_lfu_decay_time: Optional[str] = None,
                 redis_lfu_log_factor: Optional[str] = None,
                 redis_maxmemory_policy: Optional[str] = None,
                 redis_notify_keyspace_events: Optional[str] = None,
                 redis_number_of_databases: Optional[str] = None,
                 redis_persistence: Optional[str] = None,
                 redis_pubsub_client_output_buffer_limit: Optional[str] = None,
                 redis_ssl: Optional[str] = None,
                 redis_timeout: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        """
        :param str static_ips: Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_basebackup_name is not None:
            pulumi.set(__self__, "recovery_basebackup_name", recovery_basebackup_name)
        if redis_acl_channels_default is not None:
            pulumi.set(__self__, "redis_acl_channels_default", redis_acl_channels_default)
        if redis_io_threads is not None:
            pulumi.set(__self__, "redis_io_threads", redis_io_threads)
        if redis_lfu_decay_time is not None:
            pulumi.set(__self__, "redis_lfu_decay_time", redis_lfu_decay_time)
        if redis_lfu_log_factor is not None:
            pulumi.set(__self__, "redis_lfu_log_factor", redis_lfu_log_factor)
        if redis_maxmemory_policy is not None:
            pulumi.set(__self__, "redis_maxmemory_policy", redis_maxmemory_policy)
        if redis_notify_keyspace_events is not None:
            pulumi.set(__self__, "redis_notify_keyspace_events", redis_notify_keyspace_events)
        if redis_number_of_databases is not None:
            pulumi.set(__self__, "redis_number_of_databases", redis_number_of_databases)
        if redis_persistence is not None:
            pulumi.set(__self__, "redis_persistence", redis_persistence)
        if redis_pubsub_client_output_buffer_limit is not None:
            pulumi.set(__self__, "redis_pubsub_client_output_buffer_limit", redis_pubsub_client_output_buffer_limit)
        if redis_ssl is not None:
            pulumi.set(__self__, "redis_ssl", redis_ssl)
        if redis_timeout is not None:
            pulumi.set(__self__, "redis_timeout", redis_timeout)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def migration(self) -> Optional['outputs.GetRedisRedisUserConfigMigrationResult']:
        return pulumi.get(self, "migration")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetRedisRedisUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetRedisRedisUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetRedisRedisUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryBasebackupName")
    def recovery_basebackup_name(self) -> Optional[str]:
        return pulumi.get(self, "recovery_basebackup_name")

    @property
    @pulumi.getter(name="redisAclChannelsDefault")
    def redis_acl_channels_default(self) -> Optional[str]:
        return pulumi.get(self, "redis_acl_channels_default")

    @property
    @pulumi.getter(name="redisIoThreads")
    def redis_io_threads(self) -> Optional[str]:
        return pulumi.get(self, "redis_io_threads")

    @property
    @pulumi.getter(name="redisLfuDecayTime")
    def redis_lfu_decay_time(self) -> Optional[str]:
        return pulumi.get(self, "redis_lfu_decay_time")

    @property
    @pulumi.getter(name="redisLfuLogFactor")
    def redis_lfu_log_factor(self) -> Optional[str]:
        return pulumi.get(self, "redis_lfu_log_factor")

    @property
    @pulumi.getter(name="redisMaxmemoryPolicy")
    def redis_maxmemory_policy(self) -> Optional[str]:
        return pulumi.get(self, "redis_maxmemory_policy")

    @property
    @pulumi.getter(name="redisNotifyKeyspaceEvents")
    def redis_notify_keyspace_events(self) -> Optional[str]:
        return pulumi.get(self, "redis_notify_keyspace_events")

    @property
    @pulumi.getter(name="redisNumberOfDatabases")
    def redis_number_of_databases(self) -> Optional[str]:
        return pulumi.get(self, "redis_number_of_databases")

    @property
    @pulumi.getter(name="redisPersistence")
    def redis_persistence(self) -> Optional[str]:
        return pulumi.get(self, "redis_persistence")

    @property
    @pulumi.getter(name="redisPubsubClientOutputBufferLimit")
    def redis_pubsub_client_output_buffer_limit(self) -> Optional[str]:
        return pulumi.get(self, "redis_pubsub_client_output_buffer_limit")

    @property
    @pulumi.getter(name="redisSsl")
    def redis_ssl(self) -> Optional[str]:
        return pulumi.get(self, "redis_ssl")

    @property
    @pulumi.getter(name="redisTimeout")
    def redis_timeout(self) -> Optional[str]:
        return pulumi.get(self, "redis_timeout")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        """
        Static IPs that are going to be associated with this service. Please assign a value using the 'toset' function. Once a static ip resource is in the 'assigned' state it cannot be unbound from the node again
        """
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetRedisRedisUserConfigMigrationResult(dict):
    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 ignore_dbs: Optional[str] = None,
                 method: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 ssl: Optional[str] = None,
                 username: Optional[str] = None):
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[str]:
        return pulumi.get(self, "ignore_dbs")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetRedisRedisUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None,
                 redis: Optional[str] = None):
        """
        :param str redis: Redis server provided values
        """
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter
    def redis(self) -> Optional[str]:
        """
        Redis server provided values
        """
        return pulumi.get(self, "redis")


@pulumi.output_type
class GetRedisRedisUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None,
                 redis: Optional[str] = None):
        """
        :param str redis: Redis server provided values
        """
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter
    def redis(self) -> Optional[str]:
        """
        Redis server provided values
        """
        return pulumi.get(self, "redis")


@pulumi.output_type
class GetRedisRedisUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None,
                 redis: Optional[str] = None):
        """
        :param str redis: Redis server provided values
        """
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter
    def redis(self) -> Optional[str]:
        """
        Redis server provided values
        """
        return pulumi.get(self, "redis")


@pulumi.output_type
class GetRedisServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetRedisTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServiceIntegrationEndpointDatadogUserConfigResult(dict):
    def __init__(__self__, *,
                 datadog_api_key: Optional[str] = None,
                 datadog_tags: Optional[Sequence['outputs.GetServiceIntegrationEndpointDatadogUserConfigDatadogTagResult']] = None,
                 disable_consumer_stats: Optional[str] = None,
                 kafka_consumer_check_instances: Optional[str] = None,
                 kafka_consumer_stats_timeout: Optional[str] = None,
                 max_partition_contexts: Optional[str] = None,
                 site: Optional[str] = None):
        if datadog_api_key is not None:
            pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        if datadog_tags is not None:
            pulumi.set(__self__, "datadog_tags", datadog_tags)
        if disable_consumer_stats is not None:
            pulumi.set(__self__, "disable_consumer_stats", disable_consumer_stats)
        if kafka_consumer_check_instances is not None:
            pulumi.set(__self__, "kafka_consumer_check_instances", kafka_consumer_check_instances)
        if kafka_consumer_stats_timeout is not None:
            pulumi.set(__self__, "kafka_consumer_stats_timeout", kafka_consumer_stats_timeout)
        if max_partition_contexts is not None:
            pulumi.set(__self__, "max_partition_contexts", max_partition_contexts)
        if site is not None:
            pulumi.set(__self__, "site", site)

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> Optional[str]:
        return pulumi.get(self, "datadog_api_key")

    @property
    @pulumi.getter(name="datadogTags")
    def datadog_tags(self) -> Optional[Sequence['outputs.GetServiceIntegrationEndpointDatadogUserConfigDatadogTagResult']]:
        return pulumi.get(self, "datadog_tags")

    @property
    @pulumi.getter(name="disableConsumerStats")
    def disable_consumer_stats(self) -> Optional[str]:
        return pulumi.get(self, "disable_consumer_stats")

    @property
    @pulumi.getter(name="kafkaConsumerCheckInstances")
    def kafka_consumer_check_instances(self) -> Optional[str]:
        return pulumi.get(self, "kafka_consumer_check_instances")

    @property
    @pulumi.getter(name="kafkaConsumerStatsTimeout")
    def kafka_consumer_stats_timeout(self) -> Optional[str]:
        return pulumi.get(self, "kafka_consumer_stats_timeout")

    @property
    @pulumi.getter(name="maxPartitionContexts")
    def max_partition_contexts(self) -> Optional[str]:
        return pulumi.get(self, "max_partition_contexts")

    @property
    @pulumi.getter
    def site(self) -> Optional[str]:
        return pulumi.get(self, "site")


@pulumi.output_type
class GetServiceIntegrationEndpointDatadogUserConfigDatadogTagResult(dict):
    def __init__(__self__, *,
                 comment: Optional[str] = None,
                 tag: Optional[str] = None):
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")


@pulumi.output_type
class GetServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfigResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 log_group_name: Optional[str] = None,
                 region: Optional[str] = None,
                 secret_key: Optional[str] = None):
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[str]:
        return pulumi.get(self, "log_group_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class GetServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfigResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 namespace: Optional[str] = None,
                 region: Optional[str] = None,
                 secret_key: Optional[str] = None):
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class GetServiceIntegrationEndpointExternalElasticsearchLogsUserConfigResult(dict):
    def __init__(__self__, *,
                 ca: Optional[str] = None,
                 index_days_max: Optional[str] = None,
                 index_prefix: Optional[str] = None,
                 timeout: Optional[str] = None,
                 url: Optional[str] = None):
        if ca is not None:
            pulumi.set(__self__, "ca", ca)
        if index_days_max is not None:
            pulumi.set(__self__, "index_days_max", index_days_max)
        if index_prefix is not None:
            pulumi.set(__self__, "index_prefix", index_prefix)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def ca(self) -> Optional[str]:
        return pulumi.get(self, "ca")

    @property
    @pulumi.getter(name="indexDaysMax")
    def index_days_max(self) -> Optional[str]:
        return pulumi.get(self, "index_days_max")

    @property
    @pulumi.getter(name="indexPrefix")
    def index_prefix(self) -> Optional[str]:
        return pulumi.get(self, "index_prefix")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class GetServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfigResult(dict):
    def __init__(__self__, *,
                 log_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 service_account_credentials: Optional[str] = None):
        if log_id is not None:
            pulumi.set(__self__, "log_id", log_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if service_account_credentials is not None:
            pulumi.set(__self__, "service_account_credentials", service_account_credentials)

    @property
    @pulumi.getter(name="logId")
    def log_id(self) -> Optional[str]:
        return pulumi.get(self, "log_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="serviceAccountCredentials")
    def service_account_credentials(self) -> Optional[str]:
        return pulumi.get(self, "service_account_credentials")


@pulumi.output_type
class GetServiceIntegrationEndpointExternalKafkaUserConfigResult(dict):
    def __init__(__self__, *,
                 bootstrap_servers: Optional[str] = None,
                 sasl_mechanism: Optional[str] = None,
                 sasl_plain_password: Optional[str] = None,
                 sasl_plain_username: Optional[str] = None,
                 security_protocol: Optional[str] = None,
                 ssl_ca_cert: Optional[str] = None,
                 ssl_client_cert: Optional[str] = None,
                 ssl_client_key: Optional[str] = None,
                 ssl_endpoint_identification_algorithm: Optional[str] = None):
        if bootstrap_servers is not None:
            pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_plain_password is not None:
            pulumi.set(__self__, "sasl_plain_password", sasl_plain_password)
        if sasl_plain_username is not None:
            pulumi.set(__self__, "sasl_plain_username", sasl_plain_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)
        if ssl_ca_cert is not None:
            pulumi.set(__self__, "ssl_ca_cert", ssl_ca_cert)
        if ssl_client_cert is not None:
            pulumi.set(__self__, "ssl_client_cert", ssl_client_cert)
        if ssl_client_key is not None:
            pulumi.set(__self__, "ssl_client_key", ssl_client_key)
        if ssl_endpoint_identification_algorithm is not None:
            pulumi.set(__self__, "ssl_endpoint_identification_algorithm", ssl_endpoint_identification_algorithm)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> Optional[str]:
        return pulumi.get(self, "bootstrap_servers")

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[str]:
        return pulumi.get(self, "sasl_mechanism")

    @property
    @pulumi.getter(name="saslPlainPassword")
    def sasl_plain_password(self) -> Optional[str]:
        return pulumi.get(self, "sasl_plain_password")

    @property
    @pulumi.getter(name="saslPlainUsername")
    def sasl_plain_username(self) -> Optional[str]:
        return pulumi.get(self, "sasl_plain_username")

    @property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[str]:
        return pulumi.get(self, "security_protocol")

    @property
    @pulumi.getter(name="sslCaCert")
    def ssl_ca_cert(self) -> Optional[str]:
        return pulumi.get(self, "ssl_ca_cert")

    @property
    @pulumi.getter(name="sslClientCert")
    def ssl_client_cert(self) -> Optional[str]:
        return pulumi.get(self, "ssl_client_cert")

    @property
    @pulumi.getter(name="sslClientKey")
    def ssl_client_key(self) -> Optional[str]:
        return pulumi.get(self, "ssl_client_key")

    @property
    @pulumi.getter(name="sslEndpointIdentificationAlgorithm")
    def ssl_endpoint_identification_algorithm(self) -> Optional[str]:
        return pulumi.get(self, "ssl_endpoint_identification_algorithm")


@pulumi.output_type
class GetServiceIntegrationEndpointExternalSchemaRegistryUserConfigResult(dict):
    def __init__(__self__, *,
                 authentication: Optional[str] = None,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_username: Optional[str] = None,
                 url: Optional[str] = None):
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_username is not None:
            pulumi.set(__self__, "basic_auth_username", basic_auth_username)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[str]:
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUsername")
    def basic_auth_username(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_username")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class GetServiceIntegrationEndpointJolokiaUserConfigResult(dict):
    def __init__(__self__, *,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_username: Optional[str] = None):
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_username is not None:
            pulumi.set(__self__, "basic_auth_username", basic_auth_username)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUsername")
    def basic_auth_username(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_username")


@pulumi.output_type
class GetServiceIntegrationEndpointPrometheusUserConfigResult(dict):
    def __init__(__self__, *,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_username: Optional[str] = None):
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_username is not None:
            pulumi.set(__self__, "basic_auth_username", basic_auth_username)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUsername")
    def basic_auth_username(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_username")


@pulumi.output_type
class GetServiceIntegrationEndpointRsyslogUserConfigResult(dict):
    def __init__(__self__, *,
                 ca: Optional[str] = None,
                 cert: Optional[str] = None,
                 format: Optional[str] = None,
                 key: Optional[str] = None,
                 logline: Optional[str] = None,
                 port: Optional[str] = None,
                 sd: Optional[str] = None,
                 server: Optional[str] = None,
                 tls: Optional[str] = None):
        if ca is not None:
            pulumi.set(__self__, "ca", ca)
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if logline is not None:
            pulumi.set(__self__, "logline", logline)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if sd is not None:
            pulumi.set(__self__, "sd", sd)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def ca(self) -> Optional[str]:
        return pulumi.get(self, "ca")

    @property
    @pulumi.getter
    def cert(self) -> Optional[str]:
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def logline(self) -> Optional[str]:
        return pulumi.get(self, "logline")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def sd(self) -> Optional[str]:
        return pulumi.get(self, "sd")

    @property
    @pulumi.getter
    def server(self) -> Optional[str]:
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def tls(self) -> Optional[str]:
        return pulumi.get(self, "tls")


@pulumi.output_type
class GetServiceIntegrationEndpointSignalfxUserConfigResult(dict):
    def __init__(__self__, *,
                 enabled_metrics: Optional[Sequence[str]] = None,
                 signalfx_api_key: Optional[str] = None,
                 signalfx_realm: Optional[str] = None):
        if enabled_metrics is not None:
            pulumi.set(__self__, "enabled_metrics", enabled_metrics)
        if signalfx_api_key is not None:
            pulumi.set(__self__, "signalfx_api_key", signalfx_api_key)
        if signalfx_realm is not None:
            pulumi.set(__self__, "signalfx_realm", signalfx_realm)

    @property
    @pulumi.getter(name="enabledMetrics")
    def enabled_metrics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "enabled_metrics")

    @property
    @pulumi.getter(name="signalfxApiKey")
    def signalfx_api_key(self) -> Optional[str]:
        return pulumi.get(self, "signalfx_api_key")

    @property
    @pulumi.getter(name="signalfxRealm")
    def signalfx_realm(self) -> Optional[str]:
        return pulumi.get(self, "signalfx_realm")


@pulumi.output_type
class GetServiceIntegrationKafkaConnectUserConfigResult(dict):
    def __init__(__self__, *,
                 kafka_connect: Optional['outputs.GetServiceIntegrationKafkaConnectUserConfigKafkaConnectResult'] = None):
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional['outputs.GetServiceIntegrationKafkaConnectUserConfigKafkaConnectResult']:
        return pulumi.get(self, "kafka_connect")


@pulumi.output_type
class GetServiceIntegrationKafkaConnectUserConfigKafkaConnectResult(dict):
    def __init__(__self__, *,
                 config_storage_topic: Optional[str] = None,
                 group_id: Optional[str] = None,
                 offset_storage_topic: Optional[str] = None,
                 status_storage_topic: Optional[str] = None):
        if config_storage_topic is not None:
            pulumi.set(__self__, "config_storage_topic", config_storage_topic)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if offset_storage_topic is not None:
            pulumi.set(__self__, "offset_storage_topic", offset_storage_topic)
        if status_storage_topic is not None:
            pulumi.set(__self__, "status_storage_topic", status_storage_topic)

    @property
    @pulumi.getter(name="configStorageTopic")
    def config_storage_topic(self) -> Optional[str]:
        return pulumi.get(self, "config_storage_topic")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="offsetStorageTopic")
    def offset_storage_topic(self) -> Optional[str]:
        return pulumi.get(self, "offset_storage_topic")

    @property
    @pulumi.getter(name="statusStorageTopic")
    def status_storage_topic(self) -> Optional[str]:
        return pulumi.get(self, "status_storage_topic")


@pulumi.output_type
class GetServiceIntegrationKafkaLogsUserConfigResult(dict):
    def __init__(__self__, *,
                 kafka_topic: Optional[str] = None):
        if kafka_topic is not None:
            pulumi.set(__self__, "kafka_topic", kafka_topic)

    @property
    @pulumi.getter(name="kafkaTopic")
    def kafka_topic(self) -> Optional[str]:
        return pulumi.get(self, "kafka_topic")


@pulumi.output_type
class GetServiceIntegrationKafkaMirrormakerUserConfigResult(dict):
    def __init__(__self__, *,
                 cluster_alias: Optional[str] = None,
                 kafka_mirrormaker: Optional['outputs.GetServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormakerResult'] = None):
        if cluster_alias is not None:
            pulumi.set(__self__, "cluster_alias", cluster_alias)
        if kafka_mirrormaker is not None:
            pulumi.set(__self__, "kafka_mirrormaker", kafka_mirrormaker)

    @property
    @pulumi.getter(name="clusterAlias")
    def cluster_alias(self) -> Optional[str]:
        return pulumi.get(self, "cluster_alias")

    @property
    @pulumi.getter(name="kafkaMirrormaker")
    def kafka_mirrormaker(self) -> Optional['outputs.GetServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormakerResult']:
        return pulumi.get(self, "kafka_mirrormaker")


@pulumi.output_type
class GetServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormakerResult(dict):
    def __init__(__self__, *,
                 consumer_fetch_min_bytes: Optional[str] = None,
                 producer_batch_size: Optional[str] = None,
                 producer_buffer_memory: Optional[str] = None,
                 producer_linger_ms: Optional[str] = None,
                 producer_max_request_size: Optional[str] = None):
        if consumer_fetch_min_bytes is not None:
            pulumi.set(__self__, "consumer_fetch_min_bytes", consumer_fetch_min_bytes)
        if producer_batch_size is not None:
            pulumi.set(__self__, "producer_batch_size", producer_batch_size)
        if producer_buffer_memory is not None:
            pulumi.set(__self__, "producer_buffer_memory", producer_buffer_memory)
        if producer_linger_ms is not None:
            pulumi.set(__self__, "producer_linger_ms", producer_linger_ms)
        if producer_max_request_size is not None:
            pulumi.set(__self__, "producer_max_request_size", producer_max_request_size)

    @property
    @pulumi.getter(name="consumerFetchMinBytes")
    def consumer_fetch_min_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_fetch_min_bytes")

    @property
    @pulumi.getter(name="producerBatchSize")
    def producer_batch_size(self) -> Optional[str]:
        return pulumi.get(self, "producer_batch_size")

    @property
    @pulumi.getter(name="producerBufferMemory")
    def producer_buffer_memory(self) -> Optional[str]:
        return pulumi.get(self, "producer_buffer_memory")

    @property
    @pulumi.getter(name="producerLingerMs")
    def producer_linger_ms(self) -> Optional[str]:
        return pulumi.get(self, "producer_linger_ms")

    @property
    @pulumi.getter(name="producerMaxRequestSize")
    def producer_max_request_size(self) -> Optional[str]:
        return pulumi.get(self, "producer_max_request_size")


@pulumi.output_type
class GetServiceIntegrationLogsUserConfigResult(dict):
    def __init__(__self__, *,
                 elasticsearch_index_days_max: Optional[str] = None,
                 elasticsearch_index_prefix: Optional[str] = None):
        if elasticsearch_index_days_max is not None:
            pulumi.set(__self__, "elasticsearch_index_days_max", elasticsearch_index_days_max)
        if elasticsearch_index_prefix is not None:
            pulumi.set(__self__, "elasticsearch_index_prefix", elasticsearch_index_prefix)

    @property
    @pulumi.getter(name="elasticsearchIndexDaysMax")
    def elasticsearch_index_days_max(self) -> Optional[str]:
        return pulumi.get(self, "elasticsearch_index_days_max")

    @property
    @pulumi.getter(name="elasticsearchIndexPrefix")
    def elasticsearch_index_prefix(self) -> Optional[str]:
        return pulumi.get(self, "elasticsearch_index_prefix")


@pulumi.output_type
class GetServiceIntegrationMetricsUserConfigResult(dict):
    def __init__(__self__, *,
                 database: Optional[str] = None,
                 retention_days: Optional[str] = None,
                 ro_username: Optional[str] = None,
                 source_mysql: Optional['outputs.GetServiceIntegrationMetricsUserConfigSourceMysqlResult'] = None,
                 username: Optional[str] = None):
        if database is not None:
            pulumi.set(__self__, "database", database)
        if retention_days is not None:
            pulumi.set(__self__, "retention_days", retention_days)
        if ro_username is not None:
            pulumi.set(__self__, "ro_username", ro_username)
        if source_mysql is not None:
            pulumi.set(__self__, "source_mysql", source_mysql)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> Optional[str]:
        return pulumi.get(self, "retention_days")

    @property
    @pulumi.getter(name="roUsername")
    def ro_username(self) -> Optional[str]:
        return pulumi.get(self, "ro_username")

    @property
    @pulumi.getter(name="sourceMysql")
    def source_mysql(self) -> Optional['outputs.GetServiceIntegrationMetricsUserConfigSourceMysqlResult']:
        return pulumi.get(self, "source_mysql")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetServiceIntegrationMetricsUserConfigSourceMysqlResult(dict):
    def __init__(__self__, *,
                 telegraf: Optional['outputs.GetServiceIntegrationMetricsUserConfigSourceMysqlTelegrafResult'] = None):
        if telegraf is not None:
            pulumi.set(__self__, "telegraf", telegraf)

    @property
    @pulumi.getter
    def telegraf(self) -> Optional['outputs.GetServiceIntegrationMetricsUserConfigSourceMysqlTelegrafResult']:
        return pulumi.get(self, "telegraf")


@pulumi.output_type
class GetServiceIntegrationMetricsUserConfigSourceMysqlTelegrafResult(dict):
    def __init__(__self__, *,
                 gather_event_waits: Optional[str] = None,
                 gather_file_events_stats: Optional[str] = None,
                 gather_index_io_waits: Optional[str] = None,
                 gather_info_schema_auto_inc: Optional[str] = None,
                 gather_innodb_metrics: Optional[str] = None,
                 gather_perf_events_statements: Optional[str] = None,
                 gather_process_list: Optional[str] = None,
                 gather_slave_status: Optional[str] = None,
                 gather_table_io_waits: Optional[str] = None,
                 gather_table_lock_waits: Optional[str] = None,
                 gather_table_schema: Optional[str] = None,
                 perf_events_statements_digest_text_limit: Optional[str] = None,
                 perf_events_statements_limit: Optional[str] = None,
                 perf_events_statements_time_limit: Optional[str] = None):
        if gather_event_waits is not None:
            pulumi.set(__self__, "gather_event_waits", gather_event_waits)
        if gather_file_events_stats is not None:
            pulumi.set(__self__, "gather_file_events_stats", gather_file_events_stats)
        if gather_index_io_waits is not None:
            pulumi.set(__self__, "gather_index_io_waits", gather_index_io_waits)
        if gather_info_schema_auto_inc is not None:
            pulumi.set(__self__, "gather_info_schema_auto_inc", gather_info_schema_auto_inc)
        if gather_innodb_metrics is not None:
            pulumi.set(__self__, "gather_innodb_metrics", gather_innodb_metrics)
        if gather_perf_events_statements is not None:
            pulumi.set(__self__, "gather_perf_events_statements", gather_perf_events_statements)
        if gather_process_list is not None:
            pulumi.set(__self__, "gather_process_list", gather_process_list)
        if gather_slave_status is not None:
            pulumi.set(__self__, "gather_slave_status", gather_slave_status)
        if gather_table_io_waits is not None:
            pulumi.set(__self__, "gather_table_io_waits", gather_table_io_waits)
        if gather_table_lock_waits is not None:
            pulumi.set(__self__, "gather_table_lock_waits", gather_table_lock_waits)
        if gather_table_schema is not None:
            pulumi.set(__self__, "gather_table_schema", gather_table_schema)
        if perf_events_statements_digest_text_limit is not None:
            pulumi.set(__self__, "perf_events_statements_digest_text_limit", perf_events_statements_digest_text_limit)
        if perf_events_statements_limit is not None:
            pulumi.set(__self__, "perf_events_statements_limit", perf_events_statements_limit)
        if perf_events_statements_time_limit is not None:
            pulumi.set(__self__, "perf_events_statements_time_limit", perf_events_statements_time_limit)

    @property
    @pulumi.getter(name="gatherEventWaits")
    def gather_event_waits(self) -> Optional[str]:
        return pulumi.get(self, "gather_event_waits")

    @property
    @pulumi.getter(name="gatherFileEventsStats")
    def gather_file_events_stats(self) -> Optional[str]:
        return pulumi.get(self, "gather_file_events_stats")

    @property
    @pulumi.getter(name="gatherIndexIoWaits")
    def gather_index_io_waits(self) -> Optional[str]:
        return pulumi.get(self, "gather_index_io_waits")

    @property
    @pulumi.getter(name="gatherInfoSchemaAutoInc")
    def gather_info_schema_auto_inc(self) -> Optional[str]:
        return pulumi.get(self, "gather_info_schema_auto_inc")

    @property
    @pulumi.getter(name="gatherInnodbMetrics")
    def gather_innodb_metrics(self) -> Optional[str]:
        return pulumi.get(self, "gather_innodb_metrics")

    @property
    @pulumi.getter(name="gatherPerfEventsStatements")
    def gather_perf_events_statements(self) -> Optional[str]:
        return pulumi.get(self, "gather_perf_events_statements")

    @property
    @pulumi.getter(name="gatherProcessList")
    def gather_process_list(self) -> Optional[str]:
        return pulumi.get(self, "gather_process_list")

    @property
    @pulumi.getter(name="gatherSlaveStatus")
    def gather_slave_status(self) -> Optional[str]:
        return pulumi.get(self, "gather_slave_status")

    @property
    @pulumi.getter(name="gatherTableIoWaits")
    def gather_table_io_waits(self) -> Optional[str]:
        return pulumi.get(self, "gather_table_io_waits")

    @property
    @pulumi.getter(name="gatherTableLockWaits")
    def gather_table_lock_waits(self) -> Optional[str]:
        return pulumi.get(self, "gather_table_lock_waits")

    @property
    @pulumi.getter(name="gatherTableSchema")
    def gather_table_schema(self) -> Optional[str]:
        return pulumi.get(self, "gather_table_schema")

    @property
    @pulumi.getter(name="perfEventsStatementsDigestTextLimit")
    def perf_events_statements_digest_text_limit(self) -> Optional[str]:
        return pulumi.get(self, "perf_events_statements_digest_text_limit")

    @property
    @pulumi.getter(name="perfEventsStatementsLimit")
    def perf_events_statements_limit(self) -> Optional[str]:
        return pulumi.get(self, "perf_events_statements_limit")

    @property
    @pulumi.getter(name="perfEventsStatementsTimeLimit")
    def perf_events_statements_time_limit(self) -> Optional[str]:
        return pulumi.get(self, "perf_events_statements_time_limit")


@pulumi.output_type
class GetServiceIntegrationMirrormakerUserConfigResult(dict):
    def __init__(__self__, *,
                 mirrormaker_whitelist: Optional[str] = None):
        if mirrormaker_whitelist is not None:
            pulumi.set(__self__, "mirrormaker_whitelist", mirrormaker_whitelist)

    @property
    @pulumi.getter(name="mirrormakerWhitelist")
    def mirrormaker_whitelist(self) -> Optional[str]:
        return pulumi.get(self, "mirrormaker_whitelist")


