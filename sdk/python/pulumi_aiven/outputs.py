# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'CassandraCassandra',
    'CassandraCassandraUserConfig',
    'CassandraCassandraUserConfigCassandra',
    'CassandraCassandraUserConfigPrivateAccess',
    'CassandraCassandraUserConfigPublicAccess',
    'CassandraComponent',
    'CassandraServiceIntegration',
    'CassandraTag',
    'ClickhouseClickhouse',
    'ClickhouseClickhouseUserConfig',
    'ClickhouseComponent',
    'ClickhouseGrantPrivilegeGrant',
    'ClickhouseGrantRoleGrant',
    'ClickhouseServiceIntegration',
    'ClickhouseTag',
    'FlinkComponent',
    'FlinkFlink',
    'FlinkFlinkUserConfig',
    'FlinkFlinkUserConfigPrivatelinkAccess',
    'FlinkJobTableUpsertKafka',
    'FlinkServiceIntegration',
    'FlinkTag',
    'GrafanaComponent',
    'GrafanaGrafana',
    'GrafanaGrafanaUserConfig',
    'GrafanaGrafanaUserConfigAuthAzuread',
    'GrafanaGrafanaUserConfigAuthGenericOauth',
    'GrafanaGrafanaUserConfigAuthGithub',
    'GrafanaGrafanaUserConfigAuthGitlab',
    'GrafanaGrafanaUserConfigAuthGoogle',
    'GrafanaGrafanaUserConfigDateFormats',
    'GrafanaGrafanaUserConfigExternalImageStorage',
    'GrafanaGrafanaUserConfigPrivateAccess',
    'GrafanaGrafanaUserConfigPrivatelinkAccess',
    'GrafanaGrafanaUserConfigPublicAccess',
    'GrafanaGrafanaUserConfigSmtpServer',
    'GrafanaServiceIntegration',
    'GrafanaTag',
    'InfluxDbComponent',
    'InfluxDbInfluxdb',
    'InfluxDbInfluxdbUserConfig',
    'InfluxDbInfluxdbUserConfigInfluxdb',
    'InfluxDbInfluxdbUserConfigPrivateAccess',
    'InfluxDbInfluxdbUserConfigPrivatelinkAccess',
    'InfluxDbInfluxdbUserConfigPublicAccess',
    'InfluxDbServiceIntegration',
    'InfluxDbTag',
    'KafkaComponent',
    'KafkaConnectComponent',
    'KafkaConnectKafkaConnect',
    'KafkaConnectKafkaConnectUserConfig',
    'KafkaConnectKafkaConnectUserConfigKafkaConnect',
    'KafkaConnectKafkaConnectUserConfigPrivateAccess',
    'KafkaConnectKafkaConnectUserConfigPrivatelinkAccess',
    'KafkaConnectKafkaConnectUserConfigPublicAccess',
    'KafkaConnectServiceIntegration',
    'KafkaConnectTag',
    'KafkaConnectorTask',
    'KafkaKafka',
    'KafkaKafkaUserConfig',
    'KafkaKafkaUserConfigKafka',
    'KafkaKafkaUserConfigKafkaAuthenticationMethods',
    'KafkaKafkaUserConfigKafkaConnectConfig',
    'KafkaKafkaUserConfigKafkaRestConfig',
    'KafkaKafkaUserConfigPrivateAccess',
    'KafkaKafkaUserConfigPrivatelinkAccess',
    'KafkaKafkaUserConfigPublicAccess',
    'KafkaKafkaUserConfigSchemaRegistryConfig',
    'KafkaMirrorMakerComponent',
    'KafkaMirrorMakerKafkaMirrormaker',
    'KafkaMirrorMakerKafkaMirrormakerUserConfig',
    'KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker',
    'KafkaMirrorMakerServiceIntegration',
    'KafkaMirrorMakerTag',
    'KafkaServiceIntegration',
    'KafkaTag',
    'KafkaTopicConfig',
    'KafkaTopicTag',
    'M3AggregatorComponent',
    'M3AggregatorM3aggregator',
    'M3AggregatorM3aggregatorUserConfig',
    'M3AggregatorServiceIntegration',
    'M3AggregatorTag',
    'M3DbComponent',
    'M3DbM3db',
    'M3DbM3dbUserConfig',
    'M3DbM3dbUserConfigLimits',
    'M3DbM3dbUserConfigNamespace',
    'M3DbM3dbUserConfigNamespaceOptions',
    'M3DbM3dbUserConfigNamespaceOptionsRetentionOptions',
    'M3DbM3dbUserConfigPrivateAccess',
    'M3DbM3dbUserConfigPublicAccess',
    'M3DbM3dbUserConfigRules',
    'M3DbM3dbUserConfigRulesMapping',
    'M3DbM3dbUserConfigRulesMappingTag',
    'M3DbServiceIntegration',
    'M3DbTag',
    'MySqlComponent',
    'MySqlMysql',
    'MySqlMysqlUserConfig',
    'MySqlMysqlUserConfigMigration',
    'MySqlMysqlUserConfigMysql',
    'MySqlMysqlUserConfigPrivateAccess',
    'MySqlMysqlUserConfigPrivatelinkAccess',
    'MySqlMysqlUserConfigPublicAccess',
    'MySqlServiceIntegration',
    'MySqlTag',
    'OpenSearchComponent',
    'OpenSearchOpensearch',
    'OpenSearchOpensearchUserConfig',
    'OpenSearchOpensearchUserConfigIndexPattern',
    'OpenSearchOpensearchUserConfigIndexTemplate',
    'OpenSearchOpensearchUserConfigOpensearch',
    'OpenSearchOpensearchUserConfigOpensearchDashboards',
    'OpenSearchOpensearchUserConfigPrivateAccess',
    'OpenSearchOpensearchUserConfigPrivatelinkAccess',
    'OpenSearchOpensearchUserConfigPublicAccess',
    'OpenSearchServiceIntegration',
    'OpenSearchTag',
    'PgComponent',
    'PgPg',
    'PgPgUserConfig',
    'PgPgUserConfigMigration',
    'PgPgUserConfigPg',
    'PgPgUserConfigPgbouncer',
    'PgPgUserConfigPglookout',
    'PgPgUserConfigPrivateAccess',
    'PgPgUserConfigPrivatelinkAccess',
    'PgPgUserConfigPublicAccess',
    'PgPgUserConfigTimescaledb',
    'PgServiceIntegration',
    'PgTag',
    'ProjectTag',
    'RedisComponent',
    'RedisRedi',
    'RedisRedisUserConfig',
    'RedisRedisUserConfigMigration',
    'RedisRedisUserConfigPrivateAccess',
    'RedisRedisUserConfigPrivatelinkAccess',
    'RedisRedisUserConfigPublicAccess',
    'RedisServiceIntegration',
    'RedisTag',
    'ServiceIntegrationEndpointDatadogUserConfig',
    'ServiceIntegrationEndpointDatadogUserConfigDatadogTag',
    'ServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig',
    'ServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig',
    'ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig',
    'ServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig',
    'ServiceIntegrationEndpointExternalKafkaUserConfig',
    'ServiceIntegrationEndpointExternalSchemaRegistryUserConfig',
    'ServiceIntegrationEndpointJolokiaUserConfig',
    'ServiceIntegrationEndpointPrometheusUserConfig',
    'ServiceIntegrationEndpointRsyslogUserConfig',
    'ServiceIntegrationEndpointSignalfxUserConfig',
    'ServiceIntegrationKafkaConnectUserConfig',
    'ServiceIntegrationKafkaConnectUserConfigKafkaConnect',
    'ServiceIntegrationKafkaLogsUserConfig',
    'ServiceIntegrationKafkaMirrormakerUserConfig',
    'ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker',
    'ServiceIntegrationLogsUserConfig',
    'ServiceIntegrationMetricsUserConfig',
    'ServiceIntegrationMetricsUserConfigSourceMysql',
    'ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf',
    'ServiceIntegrationMirrormakerUserConfig',
    'GetCassandaCassandraResult',
    'GetCassandaCassandraUserConfigResult',
    'GetCassandaCassandraUserConfigCassandraResult',
    'GetCassandaCassandraUserConfigPrivateAccessResult',
    'GetCassandaCassandraUserConfigPublicAccessResult',
    'GetCassandaComponentResult',
    'GetCassandaServiceIntegrationResult',
    'GetCassandaTagResult',
    'GetCassandraCassandraResult',
    'GetCassandraCassandraUserConfigResult',
    'GetCassandraCassandraUserConfigCassandraResult',
    'GetCassandraCassandraUserConfigPrivateAccessResult',
    'GetCassandraCassandraUserConfigPublicAccessResult',
    'GetCassandraComponentResult',
    'GetCassandraServiceIntegrationResult',
    'GetCassandraTagResult',
    'GetClickhouseClickhouseResult',
    'GetClickhouseClickhouseUserConfigResult',
    'GetClickhouseComponentResult',
    'GetClickhouseServiceIntegrationResult',
    'GetClickhouseTagResult',
    'GetFlinkComponentResult',
    'GetFlinkFlinkResult',
    'GetFlinkFlinkUserConfigResult',
    'GetFlinkFlinkUserConfigPrivatelinkAccessResult',
    'GetFlinkServiceIntegrationResult',
    'GetFlinkTagResult',
    'GetGrafanaComponentResult',
    'GetGrafanaGrafanaResult',
    'GetGrafanaGrafanaUserConfigResult',
    'GetGrafanaGrafanaUserConfigAuthAzureadResult',
    'GetGrafanaGrafanaUserConfigAuthGenericOauthResult',
    'GetGrafanaGrafanaUserConfigAuthGithubResult',
    'GetGrafanaGrafanaUserConfigAuthGitlabResult',
    'GetGrafanaGrafanaUserConfigAuthGoogleResult',
    'GetGrafanaGrafanaUserConfigDateFormatsResult',
    'GetGrafanaGrafanaUserConfigExternalImageStorageResult',
    'GetGrafanaGrafanaUserConfigPrivateAccessResult',
    'GetGrafanaGrafanaUserConfigPrivatelinkAccessResult',
    'GetGrafanaGrafanaUserConfigPublicAccessResult',
    'GetGrafanaGrafanaUserConfigSmtpServerResult',
    'GetGrafanaServiceIntegrationResult',
    'GetGrafanaTagResult',
    'GetInfluxDbComponentResult',
    'GetInfluxDbInfluxdbResult',
    'GetInfluxDbInfluxdbUserConfigResult',
    'GetInfluxDbInfluxdbUserConfigInfluxdbResult',
    'GetInfluxDbInfluxdbUserConfigPrivateAccessResult',
    'GetInfluxDbInfluxdbUserConfigPrivatelinkAccessResult',
    'GetInfluxDbInfluxdbUserConfigPublicAccessResult',
    'GetInfluxDbServiceIntegrationResult',
    'GetInfluxDbTagResult',
    'GetKafkaComponentResult',
    'GetKafkaConnectComponentResult',
    'GetKafkaConnectKafkaConnectResult',
    'GetKafkaConnectKafkaConnectUserConfigResult',
    'GetKafkaConnectKafkaConnectUserConfigKafkaConnectResult',
    'GetKafkaConnectKafkaConnectUserConfigPrivateAccessResult',
    'GetKafkaConnectKafkaConnectUserConfigPrivatelinkAccessResult',
    'GetKafkaConnectKafkaConnectUserConfigPublicAccessResult',
    'GetKafkaConnectServiceIntegrationResult',
    'GetKafkaConnectTagResult',
    'GetKafkaConnectorTaskResult',
    'GetKafkaKafkaResult',
    'GetKafkaKafkaUserConfigResult',
    'GetKafkaKafkaUserConfigKafkaResult',
    'GetKafkaKafkaUserConfigKafkaAuthenticationMethodsResult',
    'GetKafkaKafkaUserConfigKafkaConnectConfigResult',
    'GetKafkaKafkaUserConfigKafkaRestConfigResult',
    'GetKafkaKafkaUserConfigPrivateAccessResult',
    'GetKafkaKafkaUserConfigPrivatelinkAccessResult',
    'GetKafkaKafkaUserConfigPublicAccessResult',
    'GetKafkaKafkaUserConfigSchemaRegistryConfigResult',
    'GetKafkaMirrorMakerComponentResult',
    'GetKafkaMirrorMakerKafkaMirrormakerResult',
    'GetKafkaMirrorMakerKafkaMirrormakerUserConfigResult',
    'GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormakerResult',
    'GetKafkaMirrorMakerServiceIntegrationResult',
    'GetKafkaMirrorMakerTagResult',
    'GetKafkaServiceIntegrationResult',
    'GetKafkaTagResult',
    'GetKafkaTopicConfigResult',
    'GetKafkaTopicTagResult',
    'GetM3AggregatorComponentResult',
    'GetM3AggregatorM3aggregatorResult',
    'GetM3AggregatorM3aggregatorUserConfigResult',
    'GetM3AggregatorServiceIntegrationResult',
    'GetM3AggregatorTagResult',
    'GetM3DbComponentResult',
    'GetM3DbM3dbResult',
    'GetM3DbM3dbUserConfigResult',
    'GetM3DbM3dbUserConfigLimitsResult',
    'GetM3DbM3dbUserConfigNamespaceResult',
    'GetM3DbM3dbUserConfigNamespaceOptionsResult',
    'GetM3DbM3dbUserConfigNamespaceOptionsRetentionOptionsResult',
    'GetM3DbM3dbUserConfigPrivateAccessResult',
    'GetM3DbM3dbUserConfigPublicAccessResult',
    'GetM3DbM3dbUserConfigRulesResult',
    'GetM3DbM3dbUserConfigRulesMappingResult',
    'GetM3DbM3dbUserConfigRulesMappingTagResult',
    'GetM3DbServiceIntegrationResult',
    'GetM3DbTagResult',
    'GetMySqlComponentResult',
    'GetMySqlMysqlResult',
    'GetMySqlMysqlUserConfigResult',
    'GetMySqlMysqlUserConfigMigrationResult',
    'GetMySqlMysqlUserConfigMysqlResult',
    'GetMySqlMysqlUserConfigPrivateAccessResult',
    'GetMySqlMysqlUserConfigPrivatelinkAccessResult',
    'GetMySqlMysqlUserConfigPublicAccessResult',
    'GetMySqlServiceIntegrationResult',
    'GetMySqlTagResult',
    'GetOpenSearchComponentResult',
    'GetOpenSearchOpensearchResult',
    'GetOpenSearchOpensearchUserConfigResult',
    'GetOpenSearchOpensearchUserConfigIndexPatternResult',
    'GetOpenSearchOpensearchUserConfigIndexTemplateResult',
    'GetOpenSearchOpensearchUserConfigOpensearchResult',
    'GetOpenSearchOpensearchUserConfigOpensearchDashboardsResult',
    'GetOpenSearchOpensearchUserConfigPrivateAccessResult',
    'GetOpenSearchOpensearchUserConfigPrivatelinkAccessResult',
    'GetOpenSearchOpensearchUserConfigPublicAccessResult',
    'GetOpenSearchServiceIntegrationResult',
    'GetOpenSearchTagResult',
    'GetPgComponentResult',
    'GetPgPgResult',
    'GetPgPgUserConfigResult',
    'GetPgPgUserConfigMigrationResult',
    'GetPgPgUserConfigPgResult',
    'GetPgPgUserConfigPgbouncerResult',
    'GetPgPgUserConfigPglookoutResult',
    'GetPgPgUserConfigPrivateAccessResult',
    'GetPgPgUserConfigPrivatelinkAccessResult',
    'GetPgPgUserConfigPublicAccessResult',
    'GetPgPgUserConfigTimescaledbResult',
    'GetPgServiceIntegrationResult',
    'GetPgTagResult',
    'GetProjectTagResult',
    'GetRedisComponentResult',
    'GetRedisRediResult',
    'GetRedisRedisUserConfigResult',
    'GetRedisRedisUserConfigMigrationResult',
    'GetRedisRedisUserConfigPrivateAccessResult',
    'GetRedisRedisUserConfigPrivatelinkAccessResult',
    'GetRedisRedisUserConfigPublicAccessResult',
    'GetRedisServiceIntegrationResult',
    'GetRedisTagResult',
    'GetServiceIntegrationEndpointDatadogUserConfigResult',
    'GetServiceIntegrationEndpointDatadogUserConfigDatadogTagResult',
    'GetServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfigResult',
    'GetServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfigResult',
    'GetServiceIntegrationEndpointExternalElasticsearchLogsUserConfigResult',
    'GetServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfigResult',
    'GetServiceIntegrationEndpointExternalKafkaUserConfigResult',
    'GetServiceIntegrationEndpointExternalSchemaRegistryUserConfigResult',
    'GetServiceIntegrationEndpointJolokiaUserConfigResult',
    'GetServiceIntegrationEndpointPrometheusUserConfigResult',
    'GetServiceIntegrationEndpointRsyslogUserConfigResult',
    'GetServiceIntegrationEndpointSignalfxUserConfigResult',
    'GetServiceIntegrationKafkaConnectUserConfigResult',
    'GetServiceIntegrationKafkaConnectUserConfigKafkaConnectResult',
    'GetServiceIntegrationKafkaLogsUserConfigResult',
    'GetServiceIntegrationKafkaMirrormakerUserConfigResult',
    'GetServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormakerResult',
    'GetServiceIntegrationLogsUserConfigResult',
    'GetServiceIntegrationMetricsUserConfigResult',
    'GetServiceIntegrationMetricsUserConfigSourceMysqlResult',
    'GetServiceIntegrationMetricsUserConfigSourceMysqlTelegrafResult',
    'GetServiceIntegrationMirrormakerUserConfigResult',
]

@pulumi.output_type
class CassandraCassandra(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class CassandraCassandraUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cassandraVersion":
            suggest = "cassandra_version"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "migrateSstableloader":
            suggest = "migrate_sstableloader"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CassandraCassandraUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CassandraCassandraUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CassandraCassandraUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cassandra: Optional['outputs.CassandraCassandraUserConfigCassandra'] = None,
                 cassandra_version: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 migrate_sstableloader: Optional[str] = None,
                 private_access: Optional['outputs.CassandraCassandraUserConfigPrivateAccess'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.CassandraCassandraUserConfigPublicAccess'] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        if cassandra is not None:
            pulumi.set(__self__, "cassandra", cassandra)
        if cassandra_version is not None:
            pulumi.set(__self__, "cassandra_version", cassandra_version)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migrate_sstableloader is not None:
            pulumi.set(__self__, "migrate_sstableloader", migrate_sstableloader)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter
    def cassandra(self) -> Optional['outputs.CassandraCassandraUserConfigCassandra']:
        return pulumi.get(self, "cassandra")

    @property
    @pulumi.getter(name="cassandraVersion")
    def cassandra_version(self) -> Optional[str]:
        return pulumi.get(self, "cassandra_version")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="migrateSstableloader")
    def migrate_sstableloader(self) -> Optional[str]:
        return pulumi.get(self, "migrate_sstableloader")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.CassandraCassandraUserConfigPrivateAccess']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.CassandraCassandraUserConfigPublicAccess']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class CassandraCassandraUserConfigCassandra(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchSizeFailThresholdInKb":
            suggest = "batch_size_fail_threshold_in_kb"
        elif key == "batchSizeWarnThresholdInKb":
            suggest = "batch_size_warn_threshold_in_kb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CassandraCassandraUserConfigCassandra. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CassandraCassandraUserConfigCassandra.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CassandraCassandraUserConfigCassandra.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_size_fail_threshold_in_kb: Optional[str] = None,
                 batch_size_warn_threshold_in_kb: Optional[str] = None):
        if batch_size_fail_threshold_in_kb is not None:
            pulumi.set(__self__, "batch_size_fail_threshold_in_kb", batch_size_fail_threshold_in_kb)
        if batch_size_warn_threshold_in_kb is not None:
            pulumi.set(__self__, "batch_size_warn_threshold_in_kb", batch_size_warn_threshold_in_kb)

    @property
    @pulumi.getter(name="batchSizeFailThresholdInKb")
    def batch_size_fail_threshold_in_kb(self) -> Optional[str]:
        return pulumi.get(self, "batch_size_fail_threshold_in_kb")

    @property
    @pulumi.getter(name="batchSizeWarnThresholdInKb")
    def batch_size_warn_threshold_in_kb(self) -> Optional[str]:
        return pulumi.get(self, "batch_size_warn_threshold_in_kb")


@pulumi.output_type
class CassandraCassandraUserConfigPrivateAccess(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class CassandraCassandraUserConfigPublicAccess(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class CassandraComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CassandraComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CassandraComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CassandraComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class CassandraServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CassandraServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CassandraServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CassandraServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class CassandraTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClickhouseClickhouse(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClickhouseClickhouseUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClickhouseClickhouseUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClickhouseClickhouseUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClickhouseClickhouseUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 project_to_fork_from: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None):
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")


@pulumi.output_type
class ClickhouseComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClickhouseComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClickhouseComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClickhouseComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class ClickhouseGrantPrivilegeGrant(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "withGrant":
            suggest = "with_grant"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClickhouseGrantPrivilegeGrant. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClickhouseGrantPrivilegeGrant.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClickhouseGrantPrivilegeGrant.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 column: Optional[str] = None,
                 privilege: Optional[str] = None,
                 table: Optional[str] = None,
                 with_grant: Optional[bool] = None):
        pulumi.set(__self__, "database", database)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if privilege is not None:
            pulumi.set(__self__, "privilege", privilege)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if with_grant is not None:
            pulumi.set(__self__, "with_grant", with_grant)

    @property
    @pulumi.getter
    def database(self) -> str:
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def privilege(self) -> Optional[str]:
        return pulumi.get(self, "privilege")

    @property
    @pulumi.getter
    def table(self) -> Optional[str]:
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="withGrant")
    def with_grant(self) -> Optional[bool]:
        return pulumi.get(self, "with_grant")


@pulumi.output_type
class ClickhouseGrantRoleGrant(dict):
    def __init__(__self__, *,
                 role: Optional[str] = None):
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")


@pulumi.output_type
class ClickhouseServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClickhouseServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClickhouseServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClickhouseServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class ClickhouseTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class FlinkComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class FlinkFlink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostPorts":
            suggest = "host_ports"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkFlink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkFlink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkFlink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_ports: Optional[Sequence[str]] = None):
        if host_ports is not None:
            pulumi.set(__self__, "host_ports", host_ports)

    @property
    @pulumi.getter(name="hostPorts")
    def host_ports(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "host_ports")


@pulumi.output_type
class FlinkFlinkUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionCheckpointingIntervalMs":
            suggest = "execution_checkpointing_interval_ms"
        elif key == "executionCheckpointingTimeoutMs":
            suggest = "execution_checkpointing_timeout_ms"
        elif key == "flinkVersion":
            suggest = "flink_version"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "numberOfTaskSlots":
            suggest = "number_of_task_slots"
        elif key == "parallelismDefault":
            suggest = "parallelism_default"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "restartStrategy":
            suggest = "restart_strategy"
        elif key == "restartStrategyDelaySec":
            suggest = "restart_strategy_delay_sec"
        elif key == "restartStrategyFailureRateIntervalMin":
            suggest = "restart_strategy_failure_rate_interval_min"
        elif key == "restartStrategyMaxFailures":
            suggest = "restart_strategy_max_failures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkFlinkUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkFlinkUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkFlinkUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_checkpointing_interval_ms: Optional[str] = None,
                 execution_checkpointing_timeout_ms: Optional[str] = None,
                 flink_version: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 number_of_task_slots: Optional[str] = None,
                 parallelism_default: Optional[str] = None,
                 privatelink_access: Optional['outputs.FlinkFlinkUserConfigPrivatelinkAccess'] = None,
                 restart_strategy: Optional[str] = None,
                 restart_strategy_delay_sec: Optional[str] = None,
                 restart_strategy_failure_rate_interval_min: Optional[str] = None,
                 restart_strategy_max_failures: Optional[str] = None):
        if execution_checkpointing_interval_ms is not None:
            pulumi.set(__self__, "execution_checkpointing_interval_ms", execution_checkpointing_interval_ms)
        if execution_checkpointing_timeout_ms is not None:
            pulumi.set(__self__, "execution_checkpointing_timeout_ms", execution_checkpointing_timeout_ms)
        if flink_version is not None:
            pulumi.set(__self__, "flink_version", flink_version)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if number_of_task_slots is not None:
            pulumi.set(__self__, "number_of_task_slots", number_of_task_slots)
        if parallelism_default is not None:
            pulumi.set(__self__, "parallelism_default", parallelism_default)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if restart_strategy is not None:
            pulumi.set(__self__, "restart_strategy", restart_strategy)
        if restart_strategy_delay_sec is not None:
            pulumi.set(__self__, "restart_strategy_delay_sec", restart_strategy_delay_sec)
        if restart_strategy_failure_rate_interval_min is not None:
            pulumi.set(__self__, "restart_strategy_failure_rate_interval_min", restart_strategy_failure_rate_interval_min)
        if restart_strategy_max_failures is not None:
            pulumi.set(__self__, "restart_strategy_max_failures", restart_strategy_max_failures)

    @property
    @pulumi.getter(name="executionCheckpointingIntervalMs")
    def execution_checkpointing_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "execution_checkpointing_interval_ms")

    @property
    @pulumi.getter(name="executionCheckpointingTimeoutMs")
    def execution_checkpointing_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "execution_checkpointing_timeout_ms")

    @property
    @pulumi.getter(name="flinkVersion")
    def flink_version(self) -> Optional[str]:
        return pulumi.get(self, "flink_version")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="numberOfTaskSlots")
    def number_of_task_slots(self) -> Optional[str]:
        return pulumi.get(self, "number_of_task_slots")

    @property
    @pulumi.getter(name="parallelismDefault")
    def parallelism_default(self) -> Optional[str]:
        return pulumi.get(self, "parallelism_default")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.FlinkFlinkUserConfigPrivatelinkAccess']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="restartStrategy")
    def restart_strategy(self) -> Optional[str]:
        return pulumi.get(self, "restart_strategy")

    @property
    @pulumi.getter(name="restartStrategyDelaySec")
    def restart_strategy_delay_sec(self) -> Optional[str]:
        return pulumi.get(self, "restart_strategy_delay_sec")

    @property
    @pulumi.getter(name="restartStrategyFailureRateIntervalMin")
    def restart_strategy_failure_rate_interval_min(self) -> Optional[str]:
        return pulumi.get(self, "restart_strategy_failure_rate_interval_min")

    @property
    @pulumi.getter(name="restartStrategyMaxFailures")
    def restart_strategy_max_failures(self) -> Optional[str]:
        return pulumi.get(self, "restart_strategy_max_failures")


@pulumi.output_type
class FlinkFlinkUserConfigPrivatelinkAccess(dict):
    def __init__(__self__, *,
                 flink: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if flink is not None:
            pulumi.set(__self__, "flink", flink)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def flink(self) -> Optional[str]:
        return pulumi.get(self, "flink")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class FlinkJobTableUpsertKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyFields":
            suggest = "key_fields"
        elif key == "keyFormat":
            suggest = "key_format"
        elif key == "scanStartupMode":
            suggest = "scan_startup_mode"
        elif key == "valueFieldsInclude":
            suggest = "value_fields_include"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkJobTableUpsertKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkJobTableUpsertKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkJobTableUpsertKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_fields: Optional[Sequence[str]] = None,
                 key_format: Optional[str] = None,
                 scan_startup_mode: Optional[str] = None,
                 topic: Optional[str] = None,
                 value_fields_include: Optional[str] = None,
                 value_format: Optional[str] = None):
        if key_fields is not None:
            pulumi.set(__self__, "key_fields", key_fields)
        if key_format is not None:
            pulumi.set(__self__, "key_format", key_format)
        if scan_startup_mode is not None:
            pulumi.set(__self__, "scan_startup_mode", scan_startup_mode)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)
        if value_fields_include is not None:
            pulumi.set(__self__, "value_fields_include", value_fields_include)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter(name="keyFields")
    def key_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "key_fields")

    @property
    @pulumi.getter(name="keyFormat")
    def key_format(self) -> Optional[str]:
        return pulumi.get(self, "key_format")

    @property
    @pulumi.getter(name="scanStartupMode")
    def scan_startup_mode(self) -> Optional[str]:
        return pulumi.get(self, "scan_startup_mode")

    @property
    @pulumi.getter
    def topic(self) -> Optional[str]:
        return pulumi.get(self, "topic")

    @property
    @pulumi.getter(name="valueFieldsInclude")
    def value_fields_include(self) -> Optional[str]:
        return pulumi.get(self, "value_fields_include")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[str]:
        return pulumi.get(self, "value_format")


@pulumi.output_type
class FlinkServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class FlinkTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GrafanaComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GrafanaGrafana(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GrafanaGrafanaUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingEnabled":
            suggest = "alerting_enabled"
        elif key == "alertingErrorOrTimeout":
            suggest = "alerting_error_or_timeout"
        elif key == "alertingMaxAnnotationsToKeep":
            suggest = "alerting_max_annotations_to_keep"
        elif key == "alertingNodataOrNullvalues":
            suggest = "alerting_nodata_or_nullvalues"
        elif key == "allowEmbedding":
            suggest = "allow_embedding"
        elif key == "authAzuread":
            suggest = "auth_azuread"
        elif key == "authBasicEnabled":
            suggest = "auth_basic_enabled"
        elif key == "authGenericOauth":
            suggest = "auth_generic_oauth"
        elif key == "authGithub":
            suggest = "auth_github"
        elif key == "authGitlab":
            suggest = "auth_gitlab"
        elif key == "authGoogle":
            suggest = "auth_google"
        elif key == "cookieSamesite":
            suggest = "cookie_samesite"
        elif key == "customDomain":
            suggest = "custom_domain"
        elif key == "dashboardsMinRefreshInterval":
            suggest = "dashboards_min_refresh_interval"
        elif key == "dashboardsVersionsToKeep":
            suggest = "dashboards_versions_to_keep"
        elif key == "dataproxySendUserHeader":
            suggest = "dataproxy_send_user_header"
        elif key == "dataproxyTimeout":
            suggest = "dataproxy_timeout"
        elif key == "dateFormats":
            suggest = "date_formats"
        elif key == "disableGravatar":
            suggest = "disable_gravatar"
        elif key == "editorsCanAdmin":
            suggest = "editors_can_admin"
        elif key == "externalImageStorage":
            suggest = "external_image_storage"
        elif key == "googleAnalyticsUaId":
            suggest = "google_analytics_ua_id"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "metricsEnabled":
            suggest = "metrics_enabled"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "recoveryBasebackupName":
            suggest = "recovery_basebackup_name"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"
        elif key == "smtpServer":
            suggest = "smtp_server"
        elif key == "staticIps":
            suggest = "static_ips"
        elif key == "userAutoAssignOrg":
            suggest = "user_auto_assign_org"
        elif key == "userAutoAssignOrgRole":
            suggest = "user_auto_assign_org_role"
        elif key == "viewersCanEdit":
            suggest = "viewers_can_edit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alerting_enabled: Optional[str] = None,
                 alerting_error_or_timeout: Optional[str] = None,
                 alerting_max_annotations_to_keep: Optional[str] = None,
                 alerting_nodata_or_nullvalues: Optional[str] = None,
                 allow_embedding: Optional[str] = None,
                 auth_azuread: Optional['outputs.GrafanaGrafanaUserConfigAuthAzuread'] = None,
                 auth_basic_enabled: Optional[str] = None,
                 auth_generic_oauth: Optional['outputs.GrafanaGrafanaUserConfigAuthGenericOauth'] = None,
                 auth_github: Optional['outputs.GrafanaGrafanaUserConfigAuthGithub'] = None,
                 auth_gitlab: Optional['outputs.GrafanaGrafanaUserConfigAuthGitlab'] = None,
                 auth_google: Optional['outputs.GrafanaGrafanaUserConfigAuthGoogle'] = None,
                 cookie_samesite: Optional[str] = None,
                 custom_domain: Optional[str] = None,
                 dashboards_min_refresh_interval: Optional[str] = None,
                 dashboards_versions_to_keep: Optional[str] = None,
                 dataproxy_send_user_header: Optional[str] = None,
                 dataproxy_timeout: Optional[str] = None,
                 date_formats: Optional['outputs.GrafanaGrafanaUserConfigDateFormats'] = None,
                 disable_gravatar: Optional[str] = None,
                 editors_can_admin: Optional[str] = None,
                 external_image_storage: Optional['outputs.GrafanaGrafanaUserConfigExternalImageStorage'] = None,
                 google_analytics_ua_id: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 metrics_enabled: Optional[str] = None,
                 private_access: Optional['outputs.GrafanaGrafanaUserConfigPrivateAccess'] = None,
                 privatelink_access: Optional['outputs.GrafanaGrafanaUserConfigPrivatelinkAccess'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GrafanaGrafanaUserConfigPublicAccess'] = None,
                 recovery_basebackup_name: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 smtp_server: Optional['outputs.GrafanaGrafanaUserConfigSmtpServer'] = None,
                 static_ips: Optional[str] = None,
                 user_auto_assign_org: Optional[str] = None,
                 user_auto_assign_org_role: Optional[str] = None,
                 viewers_can_edit: Optional[str] = None):
        if alerting_enabled is not None:
            pulumi.set(__self__, "alerting_enabled", alerting_enabled)
        if alerting_error_or_timeout is not None:
            pulumi.set(__self__, "alerting_error_or_timeout", alerting_error_or_timeout)
        if alerting_max_annotations_to_keep is not None:
            pulumi.set(__self__, "alerting_max_annotations_to_keep", alerting_max_annotations_to_keep)
        if alerting_nodata_or_nullvalues is not None:
            pulumi.set(__self__, "alerting_nodata_or_nullvalues", alerting_nodata_or_nullvalues)
        if allow_embedding is not None:
            pulumi.set(__self__, "allow_embedding", allow_embedding)
        if auth_azuread is not None:
            pulumi.set(__self__, "auth_azuread", auth_azuread)
        if auth_basic_enabled is not None:
            pulumi.set(__self__, "auth_basic_enabled", auth_basic_enabled)
        if auth_generic_oauth is not None:
            pulumi.set(__self__, "auth_generic_oauth", auth_generic_oauth)
        if auth_github is not None:
            pulumi.set(__self__, "auth_github", auth_github)
        if auth_gitlab is not None:
            pulumi.set(__self__, "auth_gitlab", auth_gitlab)
        if auth_google is not None:
            pulumi.set(__self__, "auth_google", auth_google)
        if cookie_samesite is not None:
            pulumi.set(__self__, "cookie_samesite", cookie_samesite)
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if dashboards_min_refresh_interval is not None:
            pulumi.set(__self__, "dashboards_min_refresh_interval", dashboards_min_refresh_interval)
        if dashboards_versions_to_keep is not None:
            pulumi.set(__self__, "dashboards_versions_to_keep", dashboards_versions_to_keep)
        if dataproxy_send_user_header is not None:
            pulumi.set(__self__, "dataproxy_send_user_header", dataproxy_send_user_header)
        if dataproxy_timeout is not None:
            pulumi.set(__self__, "dataproxy_timeout", dataproxy_timeout)
        if date_formats is not None:
            pulumi.set(__self__, "date_formats", date_formats)
        if disable_gravatar is not None:
            pulumi.set(__self__, "disable_gravatar", disable_gravatar)
        if editors_can_admin is not None:
            pulumi.set(__self__, "editors_can_admin", editors_can_admin)
        if external_image_storage is not None:
            pulumi.set(__self__, "external_image_storage", external_image_storage)
        if google_analytics_ua_id is not None:
            pulumi.set(__self__, "google_analytics_ua_id", google_analytics_ua_id)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if metrics_enabled is not None:
            pulumi.set(__self__, "metrics_enabled", metrics_enabled)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_basebackup_name is not None:
            pulumi.set(__self__, "recovery_basebackup_name", recovery_basebackup_name)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if smtp_server is not None:
            pulumi.set(__self__, "smtp_server", smtp_server)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)
        if user_auto_assign_org is not None:
            pulumi.set(__self__, "user_auto_assign_org", user_auto_assign_org)
        if user_auto_assign_org_role is not None:
            pulumi.set(__self__, "user_auto_assign_org_role", user_auto_assign_org_role)
        if viewers_can_edit is not None:
            pulumi.set(__self__, "viewers_can_edit", viewers_can_edit)

    @property
    @pulumi.getter(name="alertingEnabled")
    def alerting_enabled(self) -> Optional[str]:
        return pulumi.get(self, "alerting_enabled")

    @property
    @pulumi.getter(name="alertingErrorOrTimeout")
    def alerting_error_or_timeout(self) -> Optional[str]:
        return pulumi.get(self, "alerting_error_or_timeout")

    @property
    @pulumi.getter(name="alertingMaxAnnotationsToKeep")
    def alerting_max_annotations_to_keep(self) -> Optional[str]:
        return pulumi.get(self, "alerting_max_annotations_to_keep")

    @property
    @pulumi.getter(name="alertingNodataOrNullvalues")
    def alerting_nodata_or_nullvalues(self) -> Optional[str]:
        return pulumi.get(self, "alerting_nodata_or_nullvalues")

    @property
    @pulumi.getter(name="allowEmbedding")
    def allow_embedding(self) -> Optional[str]:
        return pulumi.get(self, "allow_embedding")

    @property
    @pulumi.getter(name="authAzuread")
    def auth_azuread(self) -> Optional['outputs.GrafanaGrafanaUserConfigAuthAzuread']:
        return pulumi.get(self, "auth_azuread")

    @property
    @pulumi.getter(name="authBasicEnabled")
    def auth_basic_enabled(self) -> Optional[str]:
        return pulumi.get(self, "auth_basic_enabled")

    @property
    @pulumi.getter(name="authGenericOauth")
    def auth_generic_oauth(self) -> Optional['outputs.GrafanaGrafanaUserConfigAuthGenericOauth']:
        return pulumi.get(self, "auth_generic_oauth")

    @property
    @pulumi.getter(name="authGithub")
    def auth_github(self) -> Optional['outputs.GrafanaGrafanaUserConfigAuthGithub']:
        return pulumi.get(self, "auth_github")

    @property
    @pulumi.getter(name="authGitlab")
    def auth_gitlab(self) -> Optional['outputs.GrafanaGrafanaUserConfigAuthGitlab']:
        return pulumi.get(self, "auth_gitlab")

    @property
    @pulumi.getter(name="authGoogle")
    def auth_google(self) -> Optional['outputs.GrafanaGrafanaUserConfigAuthGoogle']:
        return pulumi.get(self, "auth_google")

    @property
    @pulumi.getter(name="cookieSamesite")
    def cookie_samesite(self) -> Optional[str]:
        return pulumi.get(self, "cookie_samesite")

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="dashboardsMinRefreshInterval")
    def dashboards_min_refresh_interval(self) -> Optional[str]:
        return pulumi.get(self, "dashboards_min_refresh_interval")

    @property
    @pulumi.getter(name="dashboardsVersionsToKeep")
    def dashboards_versions_to_keep(self) -> Optional[str]:
        return pulumi.get(self, "dashboards_versions_to_keep")

    @property
    @pulumi.getter(name="dataproxySendUserHeader")
    def dataproxy_send_user_header(self) -> Optional[str]:
        return pulumi.get(self, "dataproxy_send_user_header")

    @property
    @pulumi.getter(name="dataproxyTimeout")
    def dataproxy_timeout(self) -> Optional[str]:
        return pulumi.get(self, "dataproxy_timeout")

    @property
    @pulumi.getter(name="dateFormats")
    def date_formats(self) -> Optional['outputs.GrafanaGrafanaUserConfigDateFormats']:
        return pulumi.get(self, "date_formats")

    @property
    @pulumi.getter(name="disableGravatar")
    def disable_gravatar(self) -> Optional[str]:
        return pulumi.get(self, "disable_gravatar")

    @property
    @pulumi.getter(name="editorsCanAdmin")
    def editors_can_admin(self) -> Optional[str]:
        return pulumi.get(self, "editors_can_admin")

    @property
    @pulumi.getter(name="externalImageStorage")
    def external_image_storage(self) -> Optional['outputs.GrafanaGrafanaUserConfigExternalImageStorage']:
        return pulumi.get(self, "external_image_storage")

    @property
    @pulumi.getter(name="googleAnalyticsUaId")
    def google_analytics_ua_id(self) -> Optional[str]:
        return pulumi.get(self, "google_analytics_ua_id")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="metricsEnabled")
    def metrics_enabled(self) -> Optional[str]:
        return pulumi.get(self, "metrics_enabled")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GrafanaGrafanaUserConfigPrivateAccess']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GrafanaGrafanaUserConfigPrivatelinkAccess']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GrafanaGrafanaUserConfigPublicAccess']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryBasebackupName")
    def recovery_basebackup_name(self) -> Optional[str]:
        return pulumi.get(self, "recovery_basebackup_name")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="smtpServer")
    def smtp_server(self) -> Optional['outputs.GrafanaGrafanaUserConfigSmtpServer']:
        return pulumi.get(self, "smtp_server")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")

    @property
    @pulumi.getter(name="userAutoAssignOrg")
    def user_auto_assign_org(self) -> Optional[str]:
        return pulumi.get(self, "user_auto_assign_org")

    @property
    @pulumi.getter(name="userAutoAssignOrgRole")
    def user_auto_assign_org_role(self) -> Optional[str]:
        return pulumi.get(self, "user_auto_assign_org_role")

    @property
    @pulumi.getter(name="viewersCanEdit")
    def viewers_can_edit(self) -> Optional[str]:
        return pulumi.get(self, "viewers_can_edit")


@pulumi.output_type
class GrafanaGrafanaUserConfigAuthAzuread(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSignUp":
            suggest = "allow_sign_up"
        elif key == "allowedDomains":
            suggest = "allowed_domains"
        elif key == "allowedGroups":
            suggest = "allowed_groups"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfigAuthAzuread. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfigAuthAzuread.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfigAuthAzuread.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_domains: Optional[Sequence[str]] = None,
                 allowed_groups: Optional[Sequence[str]] = None,
                 auth_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 token_url: Optional[str] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_domains")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        return pulumi.get(self, "token_url")


@pulumi.output_type
class GrafanaGrafanaUserConfigAuthGenericOauth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSignUp":
            suggest = "allow_sign_up"
        elif key == "allowedDomains":
            suggest = "allowed_domains"
        elif key == "allowedOrganizations":
            suggest = "allowed_organizations"
        elif key == "apiUrl":
            suggest = "api_url"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfigAuthGenericOauth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfigAuthGenericOauth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfigAuthGenericOauth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_domains: Optional[Sequence[str]] = None,
                 allowed_organizations: Optional[Sequence[str]] = None,
                 api_url: Optional[str] = None,
                 auth_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 name: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 token_url: Optional[str] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if allowed_organizations is not None:
            pulumi.set(__self__, "allowed_organizations", allowed_organizations)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_domains")

    @property
    @pulumi.getter(name="allowedOrganizations")
    def allowed_organizations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_organizations")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        return pulumi.get(self, "token_url")


@pulumi.output_type
class GrafanaGrafanaUserConfigAuthGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSignUp":
            suggest = "allow_sign_up"
        elif key == "allowedOrganizations":
            suggest = "allowed_organizations"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "teamIds":
            suggest = "team_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfigAuthGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfigAuthGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfigAuthGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_organizations: Optional[Sequence[str]] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 team_ids: Optional[Sequence[str]] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_organizations is not None:
            pulumi.set(__self__, "allowed_organizations", allowed_organizations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if team_ids is not None:
            pulumi.set(__self__, "team_ids", team_ids)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedOrganizations")
    def allowed_organizations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_organizations")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="teamIds")
    def team_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "team_ids")


@pulumi.output_type
class GrafanaGrafanaUserConfigAuthGitlab(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSignUp":
            suggest = "allow_sign_up"
        elif key == "allowedGroups":
            suggest = "allowed_groups"
        elif key == "apiUrl":
            suggest = "api_url"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfigAuthGitlab. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfigAuthGitlab.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfigAuthGitlab.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_groups: Optional[Sequence[str]] = None,
                 api_url: Optional[str] = None,
                 auth_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 token_url: Optional[str] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        return pulumi.get(self, "token_url")


@pulumi.output_type
class GrafanaGrafanaUserConfigAuthGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSignUp":
            suggest = "allow_sign_up"
        elif key == "allowedDomains":
            suggest = "allowed_domains"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfigAuthGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfigAuthGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfigAuthGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_domains: Optional[Sequence[str]] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_domains")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class GrafanaGrafanaUserConfigDateFormats(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultTimezone":
            suggest = "default_timezone"
        elif key == "fullDate":
            suggest = "full_date"
        elif key == "intervalDay":
            suggest = "interval_day"
        elif key == "intervalHour":
            suggest = "interval_hour"
        elif key == "intervalMinute":
            suggest = "interval_minute"
        elif key == "intervalMonth":
            suggest = "interval_month"
        elif key == "intervalSecond":
            suggest = "interval_second"
        elif key == "intervalYear":
            suggest = "interval_year"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfigDateFormats. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfigDateFormats.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfigDateFormats.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_timezone: Optional[str] = None,
                 full_date: Optional[str] = None,
                 interval_day: Optional[str] = None,
                 interval_hour: Optional[str] = None,
                 interval_minute: Optional[str] = None,
                 interval_month: Optional[str] = None,
                 interval_second: Optional[str] = None,
                 interval_year: Optional[str] = None):
        if default_timezone is not None:
            pulumi.set(__self__, "default_timezone", default_timezone)
        if full_date is not None:
            pulumi.set(__self__, "full_date", full_date)
        if interval_day is not None:
            pulumi.set(__self__, "interval_day", interval_day)
        if interval_hour is not None:
            pulumi.set(__self__, "interval_hour", interval_hour)
        if interval_minute is not None:
            pulumi.set(__self__, "interval_minute", interval_minute)
        if interval_month is not None:
            pulumi.set(__self__, "interval_month", interval_month)
        if interval_second is not None:
            pulumi.set(__self__, "interval_second", interval_second)
        if interval_year is not None:
            pulumi.set(__self__, "interval_year", interval_year)

    @property
    @pulumi.getter(name="defaultTimezone")
    def default_timezone(self) -> Optional[str]:
        return pulumi.get(self, "default_timezone")

    @property
    @pulumi.getter(name="fullDate")
    def full_date(self) -> Optional[str]:
        return pulumi.get(self, "full_date")

    @property
    @pulumi.getter(name="intervalDay")
    def interval_day(self) -> Optional[str]:
        return pulumi.get(self, "interval_day")

    @property
    @pulumi.getter(name="intervalHour")
    def interval_hour(self) -> Optional[str]:
        return pulumi.get(self, "interval_hour")

    @property
    @pulumi.getter(name="intervalMinute")
    def interval_minute(self) -> Optional[str]:
        return pulumi.get(self, "interval_minute")

    @property
    @pulumi.getter(name="intervalMonth")
    def interval_month(self) -> Optional[str]:
        return pulumi.get(self, "interval_month")

    @property
    @pulumi.getter(name="intervalSecond")
    def interval_second(self) -> Optional[str]:
        return pulumi.get(self, "interval_second")

    @property
    @pulumi.getter(name="intervalYear")
    def interval_year(self) -> Optional[str]:
        return pulumi.get(self, "interval_year")


@pulumi.output_type
class GrafanaGrafanaUserConfigExternalImageStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "bucketUrl":
            suggest = "bucket_url"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfigExternalImageStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfigExternalImageStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfigExternalImageStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 bucket_url: Optional[str] = None,
                 provider: Optional[str] = None,
                 secret_key: Optional[str] = None):
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bucket_url is not None:
            pulumi.set(__self__, "bucket_url", bucket_url)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bucketUrl")
    def bucket_url(self) -> Optional[str]:
        return pulumi.get(self, "bucket_url")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class GrafanaGrafanaUserConfigPrivateAccess(dict):
    def __init__(__self__, *,
                 grafana: Optional[str] = None):
        if grafana is not None:
            pulumi.set(__self__, "grafana", grafana)

    @property
    @pulumi.getter
    def grafana(self) -> Optional[str]:
        return pulumi.get(self, "grafana")


@pulumi.output_type
class GrafanaGrafanaUserConfigPrivatelinkAccess(dict):
    def __init__(__self__, *,
                 grafana: Optional[str] = None):
        if grafana is not None:
            pulumi.set(__self__, "grafana", grafana)

    @property
    @pulumi.getter
    def grafana(self) -> Optional[str]:
        return pulumi.get(self, "grafana")


@pulumi.output_type
class GrafanaGrafanaUserConfigPublicAccess(dict):
    def __init__(__self__, *,
                 grafana: Optional[str] = None):
        if grafana is not None:
            pulumi.set(__self__, "grafana", grafana)

    @property
    @pulumi.getter
    def grafana(self) -> Optional[str]:
        return pulumi.get(self, "grafana")


@pulumi.output_type
class GrafanaGrafanaUserConfigSmtpServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromAddress":
            suggest = "from_address"
        elif key == "fromName":
            suggest = "from_name"
        elif key == "skipVerify":
            suggest = "skip_verify"
        elif key == "starttlsPolicy":
            suggest = "starttls_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaGrafanaUserConfigSmtpServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaGrafanaUserConfigSmtpServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaGrafanaUserConfigSmtpServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_address: Optional[str] = None,
                 from_name: Optional[str] = None,
                 host: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 skip_verify: Optional[str] = None,
                 starttls_policy: Optional[str] = None,
                 username: Optional[str] = None):
        if from_address is not None:
            pulumi.set(__self__, "from_address", from_address)
        if from_name is not None:
            pulumi.set(__self__, "from_name", from_name)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if skip_verify is not None:
            pulumi.set(__self__, "skip_verify", skip_verify)
        if starttls_policy is not None:
            pulumi.set(__self__, "starttls_policy", starttls_policy)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="fromAddress")
    def from_address(self) -> Optional[str]:
        return pulumi.get(self, "from_address")

    @property
    @pulumi.getter(name="fromName")
    def from_name(self) -> Optional[str]:
        return pulumi.get(self, "from_name")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="skipVerify")
    def skip_verify(self) -> Optional[str]:
        return pulumi.get(self, "skip_verify")

    @property
    @pulumi.getter(name="starttlsPolicy")
    def starttls_policy(self) -> Optional[str]:
        return pulumi.get(self, "starttls_policy")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class GrafanaServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrafanaServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrafanaServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrafanaServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GrafanaTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class InfluxDbComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfluxDbComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfluxDbComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfluxDbComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class InfluxDbInfluxdb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfluxDbInfluxdb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfluxDbInfluxdb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfluxDbInfluxdb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: Optional[str] = None):
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        return pulumi.get(self, "database_name")


@pulumi.output_type
class InfluxDbInfluxdbUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDomain":
            suggest = "custom_domain"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "recoveryBasebackupName":
            suggest = "recovery_basebackup_name"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfluxDbInfluxdbUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfluxDbInfluxdbUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfluxDbInfluxdbUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 influxdb: Optional['outputs.InfluxDbInfluxdbUserConfigInfluxdb'] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 private_access: Optional['outputs.InfluxDbInfluxdbUserConfigPrivateAccess'] = None,
                 privatelink_access: Optional['outputs.InfluxDbInfluxdbUserConfigPrivatelinkAccess'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.InfluxDbInfluxdbUserConfigPublicAccess'] = None,
                 recovery_basebackup_name: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if influxdb is not None:
            pulumi.set(__self__, "influxdb", influxdb)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_basebackup_name is not None:
            pulumi.set(__self__, "recovery_basebackup_name", recovery_basebackup_name)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter
    def influxdb(self) -> Optional['outputs.InfluxDbInfluxdbUserConfigInfluxdb']:
        return pulumi.get(self, "influxdb")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.InfluxDbInfluxdbUserConfigPrivateAccess']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.InfluxDbInfluxdbUserConfigPrivatelinkAccess']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.InfluxDbInfluxdbUserConfigPublicAccess']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryBasebackupName")
    def recovery_basebackup_name(self) -> Optional[str]:
        return pulumi.get(self, "recovery_basebackup_name")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class InfluxDbInfluxdbUserConfigInfluxdb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logQueriesAfter":
            suggest = "log_queries_after"
        elif key == "maxConnectionLimit":
            suggest = "max_connection_limit"
        elif key == "maxRowLimit":
            suggest = "max_row_limit"
        elif key == "maxSelectBuckets":
            suggest = "max_select_buckets"
        elif key == "maxSelectPoint":
            suggest = "max_select_point"
        elif key == "queryTimeout":
            suggest = "query_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfluxDbInfluxdbUserConfigInfluxdb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfluxDbInfluxdbUserConfigInfluxdb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfluxDbInfluxdbUserConfigInfluxdb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_queries_after: Optional[str] = None,
                 max_connection_limit: Optional[str] = None,
                 max_row_limit: Optional[str] = None,
                 max_select_buckets: Optional[str] = None,
                 max_select_point: Optional[str] = None,
                 query_timeout: Optional[str] = None):
        if log_queries_after is not None:
            pulumi.set(__self__, "log_queries_after", log_queries_after)
        if max_connection_limit is not None:
            pulumi.set(__self__, "max_connection_limit", max_connection_limit)
        if max_row_limit is not None:
            pulumi.set(__self__, "max_row_limit", max_row_limit)
        if max_select_buckets is not None:
            pulumi.set(__self__, "max_select_buckets", max_select_buckets)
        if max_select_point is not None:
            pulumi.set(__self__, "max_select_point", max_select_point)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)

    @property
    @pulumi.getter(name="logQueriesAfter")
    def log_queries_after(self) -> Optional[str]:
        return pulumi.get(self, "log_queries_after")

    @property
    @pulumi.getter(name="maxConnectionLimit")
    def max_connection_limit(self) -> Optional[str]:
        return pulumi.get(self, "max_connection_limit")

    @property
    @pulumi.getter(name="maxRowLimit")
    def max_row_limit(self) -> Optional[str]:
        return pulumi.get(self, "max_row_limit")

    @property
    @pulumi.getter(name="maxSelectBuckets")
    def max_select_buckets(self) -> Optional[str]:
        return pulumi.get(self, "max_select_buckets")

    @property
    @pulumi.getter(name="maxSelectPoint")
    def max_select_point(self) -> Optional[str]:
        return pulumi.get(self, "max_select_point")

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[str]:
        return pulumi.get(self, "query_timeout")


@pulumi.output_type
class InfluxDbInfluxdbUserConfigPrivateAccess(dict):
    def __init__(__self__, *,
                 influxdb: Optional[str] = None):
        if influxdb is not None:
            pulumi.set(__self__, "influxdb", influxdb)

    @property
    @pulumi.getter
    def influxdb(self) -> Optional[str]:
        return pulumi.get(self, "influxdb")


@pulumi.output_type
class InfluxDbInfluxdbUserConfigPrivatelinkAccess(dict):
    def __init__(__self__, *,
                 influxdb: Optional[str] = None):
        if influxdb is not None:
            pulumi.set(__self__, "influxdb", influxdb)

    @property
    @pulumi.getter
    def influxdb(self) -> Optional[str]:
        return pulumi.get(self, "influxdb")


@pulumi.output_type
class InfluxDbInfluxdbUserConfigPublicAccess(dict):
    def __init__(__self__, *,
                 influxdb: Optional[str] = None):
        if influxdb is not None:
            pulumi.set(__self__, "influxdb", influxdb)

    @property
    @pulumi.getter
    def influxdb(self) -> Optional[str]:
        return pulumi.get(self, "influxdb")


@pulumi.output_type
class InfluxDbServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfluxDbServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfluxDbServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfluxDbServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class InfluxDbTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class KafkaComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class KafkaConnectComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaConnectComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaConnectComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaConnectComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class KafkaConnectKafkaConnect(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class KafkaConnectKafkaConnectUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "kafkaConnect":
            suggest = "kafka_connect"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaConnectKafkaConnectUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaConnectKafkaConnectUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaConnectKafkaConnectUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka_connect: Optional['outputs.KafkaConnectKafkaConnectUserConfigKafkaConnect'] = None,
                 private_access: Optional['outputs.KafkaConnectKafkaConnectUserConfigPrivateAccess'] = None,
                 privatelink_access: Optional['outputs.KafkaConnectKafkaConnectUserConfigPrivatelinkAccess'] = None,
                 public_access: Optional['outputs.KafkaConnectKafkaConnectUserConfigPublicAccess'] = None,
                 static_ips: Optional[str] = None):
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional['outputs.KafkaConnectKafkaConnectUserConfigKafkaConnect']:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.KafkaConnectKafkaConnectUserConfigPrivateAccess']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.KafkaConnectKafkaConnectUserConfigPrivatelinkAccess']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.KafkaConnectKafkaConnectUserConfigPublicAccess']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class KafkaConnectKafkaConnectUserConfigKafkaConnect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorClientConfigOverridePolicy":
            suggest = "connector_client_config_override_policy"
        elif key == "consumerAutoOffsetReset":
            suggest = "consumer_auto_offset_reset"
        elif key == "consumerFetchMaxBytes":
            suggest = "consumer_fetch_max_bytes"
        elif key == "consumerIsolationLevel":
            suggest = "consumer_isolation_level"
        elif key == "consumerMaxPartitionFetchBytes":
            suggest = "consumer_max_partition_fetch_bytes"
        elif key == "consumerMaxPollIntervalMs":
            suggest = "consumer_max_poll_interval_ms"
        elif key == "consumerMaxPollRecords":
            suggest = "consumer_max_poll_records"
        elif key == "offsetFlushIntervalMs":
            suggest = "offset_flush_interval_ms"
        elif key == "offsetFlushTimeoutMs":
            suggest = "offset_flush_timeout_ms"
        elif key == "producerCompressionType":
            suggest = "producer_compression_type"
        elif key == "producerMaxRequestSize":
            suggest = "producer_max_request_size"
        elif key == "sessionTimeoutMs":
            suggest = "session_timeout_ms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaConnectKafkaConnectUserConfigKafkaConnect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaConnectKafkaConnectUserConfigKafkaConnect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaConnectKafkaConnectUserConfigKafkaConnect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_client_config_override_policy: Optional[str] = None,
                 consumer_auto_offset_reset: Optional[str] = None,
                 consumer_fetch_max_bytes: Optional[str] = None,
                 consumer_isolation_level: Optional[str] = None,
                 consumer_max_partition_fetch_bytes: Optional[str] = None,
                 consumer_max_poll_interval_ms: Optional[str] = None,
                 consumer_max_poll_records: Optional[str] = None,
                 offset_flush_interval_ms: Optional[str] = None,
                 offset_flush_timeout_ms: Optional[str] = None,
                 producer_compression_type: Optional[str] = None,
                 producer_max_request_size: Optional[str] = None,
                 session_timeout_ms: Optional[str] = None):
        if connector_client_config_override_policy is not None:
            pulumi.set(__self__, "connector_client_config_override_policy", connector_client_config_override_policy)
        if consumer_auto_offset_reset is not None:
            pulumi.set(__self__, "consumer_auto_offset_reset", consumer_auto_offset_reset)
        if consumer_fetch_max_bytes is not None:
            pulumi.set(__self__, "consumer_fetch_max_bytes", consumer_fetch_max_bytes)
        if consumer_isolation_level is not None:
            pulumi.set(__self__, "consumer_isolation_level", consumer_isolation_level)
        if consumer_max_partition_fetch_bytes is not None:
            pulumi.set(__self__, "consumer_max_partition_fetch_bytes", consumer_max_partition_fetch_bytes)
        if consumer_max_poll_interval_ms is not None:
            pulumi.set(__self__, "consumer_max_poll_interval_ms", consumer_max_poll_interval_ms)
        if consumer_max_poll_records is not None:
            pulumi.set(__self__, "consumer_max_poll_records", consumer_max_poll_records)
        if offset_flush_interval_ms is not None:
            pulumi.set(__self__, "offset_flush_interval_ms", offset_flush_interval_ms)
        if offset_flush_timeout_ms is not None:
            pulumi.set(__self__, "offset_flush_timeout_ms", offset_flush_timeout_ms)
        if producer_compression_type is not None:
            pulumi.set(__self__, "producer_compression_type", producer_compression_type)
        if producer_max_request_size is not None:
            pulumi.set(__self__, "producer_max_request_size", producer_max_request_size)
        if session_timeout_ms is not None:
            pulumi.set(__self__, "session_timeout_ms", session_timeout_ms)

    @property
    @pulumi.getter(name="connectorClientConfigOverridePolicy")
    def connector_client_config_override_policy(self) -> Optional[str]:
        return pulumi.get(self, "connector_client_config_override_policy")

    @property
    @pulumi.getter(name="consumerAutoOffsetReset")
    def consumer_auto_offset_reset(self) -> Optional[str]:
        return pulumi.get(self, "consumer_auto_offset_reset")

    @property
    @pulumi.getter(name="consumerFetchMaxBytes")
    def consumer_fetch_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_fetch_max_bytes")

    @property
    @pulumi.getter(name="consumerIsolationLevel")
    def consumer_isolation_level(self) -> Optional[str]:
        return pulumi.get(self, "consumer_isolation_level")

    @property
    @pulumi.getter(name="consumerMaxPartitionFetchBytes")
    def consumer_max_partition_fetch_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_partition_fetch_bytes")

    @property
    @pulumi.getter(name="consumerMaxPollIntervalMs")
    def consumer_max_poll_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_poll_interval_ms")

    @property
    @pulumi.getter(name="consumerMaxPollRecords")
    def consumer_max_poll_records(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_poll_records")

    @property
    @pulumi.getter(name="offsetFlushIntervalMs")
    def offset_flush_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "offset_flush_interval_ms")

    @property
    @pulumi.getter(name="offsetFlushTimeoutMs")
    def offset_flush_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "offset_flush_timeout_ms")

    @property
    @pulumi.getter(name="producerCompressionType")
    def producer_compression_type(self) -> Optional[str]:
        return pulumi.get(self, "producer_compression_type")

    @property
    @pulumi.getter(name="producerMaxRequestSize")
    def producer_max_request_size(self) -> Optional[str]:
        return pulumi.get(self, "producer_max_request_size")

    @property
    @pulumi.getter(name="sessionTimeoutMs")
    def session_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "session_timeout_ms")


@pulumi.output_type
class KafkaConnectKafkaConnectUserConfigPrivateAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaConnect":
            suggest = "kafka_connect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaConnectKafkaConnectUserConfigPrivateAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaConnectKafkaConnectUserConfigPrivateAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaConnectKafkaConnectUserConfigPrivateAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka_connect: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class KafkaConnectKafkaConnectUserConfigPrivatelinkAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaConnect":
            suggest = "kafka_connect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaConnectKafkaConnectUserConfigPrivatelinkAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaConnectKafkaConnectUserConfigPrivatelinkAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaConnectKafkaConnectUserConfigPrivatelinkAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 jolokia: Optional[str] = None,
                 kafka_connect: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if jolokia is not None:
            pulumi.set(__self__, "jolokia", jolokia)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def jolokia(self) -> Optional[str]:
        return pulumi.get(self, "jolokia")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class KafkaConnectKafkaConnectUserConfigPublicAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaConnect":
            suggest = "kafka_connect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaConnectKafkaConnectUserConfigPublicAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaConnectKafkaConnectUserConfigPublicAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaConnectKafkaConnectUserConfigPublicAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka_connect: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class KafkaConnectServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaConnectServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaConnectServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaConnectServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class KafkaConnectTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class KafkaConnectorTask(dict):
    def __init__(__self__, *,
                 connector: Optional[str] = None,
                 task: Optional[int] = None):
        if connector is not None:
            pulumi.set(__self__, "connector", connector)
        if task is not None:
            pulumi.set(__self__, "task", task)

    @property
    @pulumi.getter
    def connector(self) -> Optional[str]:
        return pulumi.get(self, "connector")

    @property
    @pulumi.getter
    def task(self) -> Optional[int]:
        return pulumi.get(self, "task")


@pulumi.output_type
class KafkaKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessCert":
            suggest = "access_cert"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "connectUri":
            suggest = "connect_uri"
        elif key == "restUri":
            suggest = "rest_uri"
        elif key == "schemaRegistryUri":
            suggest = "schema_registry_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_cert: Optional[str] = None,
                 access_key: Optional[str] = None,
                 connect_uri: Optional[str] = None,
                 rest_uri: Optional[str] = None,
                 schema_registry_uri: Optional[str] = None):
        if access_cert is not None:
            pulumi.set(__self__, "access_cert", access_cert)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if connect_uri is not None:
            pulumi.set(__self__, "connect_uri", connect_uri)
        if rest_uri is not None:
            pulumi.set(__self__, "rest_uri", rest_uri)
        if schema_registry_uri is not None:
            pulumi.set(__self__, "schema_registry_uri", schema_registry_uri)

    @property
    @pulumi.getter(name="accessCert")
    def access_cert(self) -> Optional[str]:
        return pulumi.get(self, "access_cert")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="connectUri")
    def connect_uri(self) -> Optional[str]:
        return pulumi.get(self, "connect_uri")

    @property
    @pulumi.getter(name="restUri")
    def rest_uri(self) -> Optional[str]:
        return pulumi.get(self, "rest_uri")

    @property
    @pulumi.getter(name="schemaRegistryUri")
    def schema_registry_uri(self) -> Optional[str]:
        return pulumi.get(self, "schema_registry_uri")


@pulumi.output_type
class KafkaKafkaUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDomain":
            suggest = "custom_domain"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "kafkaAuthenticationMethods":
            suggest = "kafka_authentication_methods"
        elif key == "kafkaConnect":
            suggest = "kafka_connect"
        elif key == "kafkaConnectConfig":
            suggest = "kafka_connect_config"
        elif key == "kafkaRest":
            suggest = "kafka_rest"
        elif key == "kafkaRestConfig":
            suggest = "kafka_rest_config"
        elif key == "kafkaVersion":
            suggest = "kafka_version"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "schemaRegistry":
            suggest = "schema_registry"
        elif key == "schemaRegistryConfig":
            suggest = "schema_registry_config"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaKafkaUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaKafkaUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaKafkaUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka: Optional['outputs.KafkaKafkaUserConfigKafka'] = None,
                 kafka_authentication_methods: Optional['outputs.KafkaKafkaUserConfigKafkaAuthenticationMethods'] = None,
                 kafka_connect: Optional[str] = None,
                 kafka_connect_config: Optional['outputs.KafkaKafkaUserConfigKafkaConnectConfig'] = None,
                 kafka_rest: Optional[str] = None,
                 kafka_rest_config: Optional['outputs.KafkaKafkaUserConfigKafkaRestConfig'] = None,
                 kafka_version: Optional[str] = None,
                 private_access: Optional['outputs.KafkaKafkaUserConfigPrivateAccess'] = None,
                 privatelink_access: Optional['outputs.KafkaKafkaUserConfigPrivatelinkAccess'] = None,
                 public_access: Optional['outputs.KafkaKafkaUserConfigPublicAccess'] = None,
                 schema_registry: Optional[str] = None,
                 schema_registry_config: Optional['outputs.KafkaKafkaUserConfigSchemaRegistryConfig'] = None,
                 static_ips: Optional[str] = None):
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kafka_authentication_methods is not None:
            pulumi.set(__self__, "kafka_authentication_methods", kafka_authentication_methods)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if kafka_connect_config is not None:
            pulumi.set(__self__, "kafka_connect_config", kafka_connect_config)
        if kafka_rest is not None:
            pulumi.set(__self__, "kafka_rest", kafka_rest)
        if kafka_rest_config is not None:
            pulumi.set(__self__, "kafka_rest_config", kafka_rest_config)
        if kafka_version is not None:
            pulumi.set(__self__, "kafka_version", kafka_version)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)
        if schema_registry_config is not None:
            pulumi.set(__self__, "schema_registry_config", schema_registry_config)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def kafka(self) -> Optional['outputs.KafkaKafkaUserConfigKafka']:
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethods")
    def kafka_authentication_methods(self) -> Optional['outputs.KafkaKafkaUserConfigKafkaAuthenticationMethods']:
        return pulumi.get(self, "kafka_authentication_methods")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter(name="kafkaConnectConfig")
    def kafka_connect_config(self) -> Optional['outputs.KafkaKafkaUserConfigKafkaConnectConfig']:
        return pulumi.get(self, "kafka_connect_config")

    @property
    @pulumi.getter(name="kafkaRest")
    def kafka_rest(self) -> Optional[str]:
        return pulumi.get(self, "kafka_rest")

    @property
    @pulumi.getter(name="kafkaRestConfig")
    def kafka_rest_config(self) -> Optional['outputs.KafkaKafkaUserConfigKafkaRestConfig']:
        return pulumi.get(self, "kafka_rest_config")

    @property
    @pulumi.getter(name="kafkaVersion")
    def kafka_version(self) -> Optional[str]:
        return pulumi.get(self, "kafka_version")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.KafkaKafkaUserConfigPrivateAccess']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.KafkaKafkaUserConfigPrivatelinkAccess']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.KafkaKafkaUserConfigPublicAccess']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[str]:
        return pulumi.get(self, "schema_registry")

    @property
    @pulumi.getter(name="schemaRegistryConfig")
    def schema_registry_config(self) -> Optional['outputs.KafkaKafkaUserConfigSchemaRegistryConfig']:
        return pulumi.get(self, "schema_registry_config")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class KafkaKafkaUserConfigKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoCreateTopicsEnable":
            suggest = "auto_create_topics_enable"
        elif key == "compressionType":
            suggest = "compression_type"
        elif key == "connectionsMaxIdleMs":
            suggest = "connections_max_idle_ms"
        elif key == "defaultReplicationFactor":
            suggest = "default_replication_factor"
        elif key == "groupInitialRebalanceDelayMs":
            suggest = "group_initial_rebalance_delay_ms"
        elif key == "groupMaxSessionTimeoutMs":
            suggest = "group_max_session_timeout_ms"
        elif key == "groupMinSessionTimeoutMs":
            suggest = "group_min_session_timeout_ms"
        elif key == "logCleanerDeleteRetentionMs":
            suggest = "log_cleaner_delete_retention_ms"
        elif key == "logCleanerMaxCompactionLagMs":
            suggest = "log_cleaner_max_compaction_lag_ms"
        elif key == "logCleanerMinCleanableRatio":
            suggest = "log_cleaner_min_cleanable_ratio"
        elif key == "logCleanerMinCompactionLagMs":
            suggest = "log_cleaner_min_compaction_lag_ms"
        elif key == "logCleanupPolicy":
            suggest = "log_cleanup_policy"
        elif key == "logFlushIntervalMessages":
            suggest = "log_flush_interval_messages"
        elif key == "logFlushIntervalMs":
            suggest = "log_flush_interval_ms"
        elif key == "logIndexIntervalBytes":
            suggest = "log_index_interval_bytes"
        elif key == "logIndexSizeMaxBytes":
            suggest = "log_index_size_max_bytes"
        elif key == "logMessageDownconversionEnable":
            suggest = "log_message_downconversion_enable"
        elif key == "logMessageTimestampDifferenceMaxMs":
            suggest = "log_message_timestamp_difference_max_ms"
        elif key == "logMessageTimestampType":
            suggest = "log_message_timestamp_type"
        elif key == "logPreallocate":
            suggest = "log_preallocate"
        elif key == "logRetentionBytes":
            suggest = "log_retention_bytes"
        elif key == "logRetentionHours":
            suggest = "log_retention_hours"
        elif key == "logRetentionMs":
            suggest = "log_retention_ms"
        elif key == "logRollJitterMs":
            suggest = "log_roll_jitter_ms"
        elif key == "logRollMs":
            suggest = "log_roll_ms"
        elif key == "logSegmentBytes":
            suggest = "log_segment_bytes"
        elif key == "logSegmentDeleteDelayMs":
            suggest = "log_segment_delete_delay_ms"
        elif key == "maxConnectionsPerIp":
            suggest = "max_connections_per_ip"
        elif key == "maxIncrementalFetchSessionCacheSlots":
            suggest = "max_incremental_fetch_session_cache_slots"
        elif key == "messageMaxBytes":
            suggest = "message_max_bytes"
        elif key == "minInsyncReplicas":
            suggest = "min_insync_replicas"
        elif key == "numPartitions":
            suggest = "num_partitions"
        elif key == "offsetsRetentionMinutes":
            suggest = "offsets_retention_minutes"
        elif key == "producerPurgatoryPurgeIntervalRequests":
            suggest = "producer_purgatory_purge_interval_requests"
        elif key == "replicaFetchMaxBytes":
            suggest = "replica_fetch_max_bytes"
        elif key == "replicaFetchResponseMaxBytes":
            suggest = "replica_fetch_response_max_bytes"
        elif key == "socketRequestMaxBytes":
            suggest = "socket_request_max_bytes"
        elif key == "transactionRemoveExpiredTransactionCleanupIntervalMs":
            suggest = "transaction_remove_expired_transaction_cleanup_interval_ms"
        elif key == "transactionStateLogSegmentBytes":
            suggest = "transaction_state_log_segment_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaKafkaUserConfigKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaKafkaUserConfigKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaKafkaUserConfigKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_create_topics_enable: Optional[str] = None,
                 compression_type: Optional[str] = None,
                 connections_max_idle_ms: Optional[str] = None,
                 default_replication_factor: Optional[str] = None,
                 group_initial_rebalance_delay_ms: Optional[str] = None,
                 group_max_session_timeout_ms: Optional[str] = None,
                 group_min_session_timeout_ms: Optional[str] = None,
                 log_cleaner_delete_retention_ms: Optional[str] = None,
                 log_cleaner_max_compaction_lag_ms: Optional[str] = None,
                 log_cleaner_min_cleanable_ratio: Optional[str] = None,
                 log_cleaner_min_compaction_lag_ms: Optional[str] = None,
                 log_cleanup_policy: Optional[str] = None,
                 log_flush_interval_messages: Optional[str] = None,
                 log_flush_interval_ms: Optional[str] = None,
                 log_index_interval_bytes: Optional[str] = None,
                 log_index_size_max_bytes: Optional[str] = None,
                 log_message_downconversion_enable: Optional[str] = None,
                 log_message_timestamp_difference_max_ms: Optional[str] = None,
                 log_message_timestamp_type: Optional[str] = None,
                 log_preallocate: Optional[str] = None,
                 log_retention_bytes: Optional[str] = None,
                 log_retention_hours: Optional[str] = None,
                 log_retention_ms: Optional[str] = None,
                 log_roll_jitter_ms: Optional[str] = None,
                 log_roll_ms: Optional[str] = None,
                 log_segment_bytes: Optional[str] = None,
                 log_segment_delete_delay_ms: Optional[str] = None,
                 max_connections_per_ip: Optional[str] = None,
                 max_incremental_fetch_session_cache_slots: Optional[str] = None,
                 message_max_bytes: Optional[str] = None,
                 min_insync_replicas: Optional[str] = None,
                 num_partitions: Optional[str] = None,
                 offsets_retention_minutes: Optional[str] = None,
                 producer_purgatory_purge_interval_requests: Optional[str] = None,
                 replica_fetch_max_bytes: Optional[str] = None,
                 replica_fetch_response_max_bytes: Optional[str] = None,
                 socket_request_max_bytes: Optional[str] = None,
                 transaction_remove_expired_transaction_cleanup_interval_ms: Optional[str] = None,
                 transaction_state_log_segment_bytes: Optional[str] = None):
        if auto_create_topics_enable is not None:
            pulumi.set(__self__, "auto_create_topics_enable", auto_create_topics_enable)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if connections_max_idle_ms is not None:
            pulumi.set(__self__, "connections_max_idle_ms", connections_max_idle_ms)
        if default_replication_factor is not None:
            pulumi.set(__self__, "default_replication_factor", default_replication_factor)
        if group_initial_rebalance_delay_ms is not None:
            pulumi.set(__self__, "group_initial_rebalance_delay_ms", group_initial_rebalance_delay_ms)
        if group_max_session_timeout_ms is not None:
            pulumi.set(__self__, "group_max_session_timeout_ms", group_max_session_timeout_ms)
        if group_min_session_timeout_ms is not None:
            pulumi.set(__self__, "group_min_session_timeout_ms", group_min_session_timeout_ms)
        if log_cleaner_delete_retention_ms is not None:
            pulumi.set(__self__, "log_cleaner_delete_retention_ms", log_cleaner_delete_retention_ms)
        if log_cleaner_max_compaction_lag_ms is not None:
            pulumi.set(__self__, "log_cleaner_max_compaction_lag_ms", log_cleaner_max_compaction_lag_ms)
        if log_cleaner_min_cleanable_ratio is not None:
            pulumi.set(__self__, "log_cleaner_min_cleanable_ratio", log_cleaner_min_cleanable_ratio)
        if log_cleaner_min_compaction_lag_ms is not None:
            pulumi.set(__self__, "log_cleaner_min_compaction_lag_ms", log_cleaner_min_compaction_lag_ms)
        if log_cleanup_policy is not None:
            pulumi.set(__self__, "log_cleanup_policy", log_cleanup_policy)
        if log_flush_interval_messages is not None:
            pulumi.set(__self__, "log_flush_interval_messages", log_flush_interval_messages)
        if log_flush_interval_ms is not None:
            pulumi.set(__self__, "log_flush_interval_ms", log_flush_interval_ms)
        if log_index_interval_bytes is not None:
            pulumi.set(__self__, "log_index_interval_bytes", log_index_interval_bytes)
        if log_index_size_max_bytes is not None:
            pulumi.set(__self__, "log_index_size_max_bytes", log_index_size_max_bytes)
        if log_message_downconversion_enable is not None:
            pulumi.set(__self__, "log_message_downconversion_enable", log_message_downconversion_enable)
        if log_message_timestamp_difference_max_ms is not None:
            pulumi.set(__self__, "log_message_timestamp_difference_max_ms", log_message_timestamp_difference_max_ms)
        if log_message_timestamp_type is not None:
            pulumi.set(__self__, "log_message_timestamp_type", log_message_timestamp_type)
        if log_preallocate is not None:
            pulumi.set(__self__, "log_preallocate", log_preallocate)
        if log_retention_bytes is not None:
            pulumi.set(__self__, "log_retention_bytes", log_retention_bytes)
        if log_retention_hours is not None:
            pulumi.set(__self__, "log_retention_hours", log_retention_hours)
        if log_retention_ms is not None:
            pulumi.set(__self__, "log_retention_ms", log_retention_ms)
        if log_roll_jitter_ms is not None:
            pulumi.set(__self__, "log_roll_jitter_ms", log_roll_jitter_ms)
        if log_roll_ms is not None:
            pulumi.set(__self__, "log_roll_ms", log_roll_ms)
        if log_segment_bytes is not None:
            pulumi.set(__self__, "log_segment_bytes", log_segment_bytes)
        if log_segment_delete_delay_ms is not None:
            pulumi.set(__self__, "log_segment_delete_delay_ms", log_segment_delete_delay_ms)
        if max_connections_per_ip is not None:
            pulumi.set(__self__, "max_connections_per_ip", max_connections_per_ip)
        if max_incremental_fetch_session_cache_slots is not None:
            pulumi.set(__self__, "max_incremental_fetch_session_cache_slots", max_incremental_fetch_session_cache_slots)
        if message_max_bytes is not None:
            pulumi.set(__self__, "message_max_bytes", message_max_bytes)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if num_partitions is not None:
            pulumi.set(__self__, "num_partitions", num_partitions)
        if offsets_retention_minutes is not None:
            pulumi.set(__self__, "offsets_retention_minutes", offsets_retention_minutes)
        if producer_purgatory_purge_interval_requests is not None:
            pulumi.set(__self__, "producer_purgatory_purge_interval_requests", producer_purgatory_purge_interval_requests)
        if replica_fetch_max_bytes is not None:
            pulumi.set(__self__, "replica_fetch_max_bytes", replica_fetch_max_bytes)
        if replica_fetch_response_max_bytes is not None:
            pulumi.set(__self__, "replica_fetch_response_max_bytes", replica_fetch_response_max_bytes)
        if socket_request_max_bytes is not None:
            pulumi.set(__self__, "socket_request_max_bytes", socket_request_max_bytes)
        if transaction_remove_expired_transaction_cleanup_interval_ms is not None:
            pulumi.set(__self__, "transaction_remove_expired_transaction_cleanup_interval_ms", transaction_remove_expired_transaction_cleanup_interval_ms)
        if transaction_state_log_segment_bytes is not None:
            pulumi.set(__self__, "transaction_state_log_segment_bytes", transaction_state_log_segment_bytes)

    @property
    @pulumi.getter(name="autoCreateTopicsEnable")
    def auto_create_topics_enable(self) -> Optional[str]:
        return pulumi.get(self, "auto_create_topics_enable")

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        return pulumi.get(self, "compression_type")

    @property
    @pulumi.getter(name="connectionsMaxIdleMs")
    def connections_max_idle_ms(self) -> Optional[str]:
        return pulumi.get(self, "connections_max_idle_ms")

    @property
    @pulumi.getter(name="defaultReplicationFactor")
    def default_replication_factor(self) -> Optional[str]:
        return pulumi.get(self, "default_replication_factor")

    @property
    @pulumi.getter(name="groupInitialRebalanceDelayMs")
    def group_initial_rebalance_delay_ms(self) -> Optional[str]:
        return pulumi.get(self, "group_initial_rebalance_delay_ms")

    @property
    @pulumi.getter(name="groupMaxSessionTimeoutMs")
    def group_max_session_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "group_max_session_timeout_ms")

    @property
    @pulumi.getter(name="groupMinSessionTimeoutMs")
    def group_min_session_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "group_min_session_timeout_ms")

    @property
    @pulumi.getter(name="logCleanerDeleteRetentionMs")
    def log_cleaner_delete_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_cleaner_delete_retention_ms")

    @property
    @pulumi.getter(name="logCleanerMaxCompactionLagMs")
    def log_cleaner_max_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_cleaner_max_compaction_lag_ms")

    @property
    @pulumi.getter(name="logCleanerMinCleanableRatio")
    def log_cleaner_min_cleanable_ratio(self) -> Optional[str]:
        return pulumi.get(self, "log_cleaner_min_cleanable_ratio")

    @property
    @pulumi.getter(name="logCleanerMinCompactionLagMs")
    def log_cleaner_min_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_cleaner_min_compaction_lag_ms")

    @property
    @pulumi.getter(name="logCleanupPolicy")
    def log_cleanup_policy(self) -> Optional[str]:
        return pulumi.get(self, "log_cleanup_policy")

    @property
    @pulumi.getter(name="logFlushIntervalMessages")
    def log_flush_interval_messages(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_interval_messages")

    @property
    @pulumi.getter(name="logFlushIntervalMs")
    def log_flush_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_interval_ms")

    @property
    @pulumi.getter(name="logIndexIntervalBytes")
    def log_index_interval_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_index_interval_bytes")

    @property
    @pulumi.getter(name="logIndexSizeMaxBytes")
    def log_index_size_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_index_size_max_bytes")

    @property
    @pulumi.getter(name="logMessageDownconversionEnable")
    def log_message_downconversion_enable(self) -> Optional[str]:
        return pulumi.get(self, "log_message_downconversion_enable")

    @property
    @pulumi.getter(name="logMessageTimestampDifferenceMaxMs")
    def log_message_timestamp_difference_max_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_message_timestamp_difference_max_ms")

    @property
    @pulumi.getter(name="logMessageTimestampType")
    def log_message_timestamp_type(self) -> Optional[str]:
        return pulumi.get(self, "log_message_timestamp_type")

    @property
    @pulumi.getter(name="logPreallocate")
    def log_preallocate(self) -> Optional[str]:
        return pulumi.get(self, "log_preallocate")

    @property
    @pulumi.getter(name="logRetentionBytes")
    def log_retention_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_bytes")

    @property
    @pulumi.getter(name="logRetentionHours")
    def log_retention_hours(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_hours")

    @property
    @pulumi.getter(name="logRetentionMs")
    def log_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_ms")

    @property
    @pulumi.getter(name="logRollJitterMs")
    def log_roll_jitter_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_roll_jitter_ms")

    @property
    @pulumi.getter(name="logRollMs")
    def log_roll_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_roll_ms")

    @property
    @pulumi.getter(name="logSegmentBytes")
    def log_segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_segment_bytes")

    @property
    @pulumi.getter(name="logSegmentDeleteDelayMs")
    def log_segment_delete_delay_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_segment_delete_delay_ms")

    @property
    @pulumi.getter(name="maxConnectionsPerIp")
    def max_connections_per_ip(self) -> Optional[str]:
        return pulumi.get(self, "max_connections_per_ip")

    @property
    @pulumi.getter(name="maxIncrementalFetchSessionCacheSlots")
    def max_incremental_fetch_session_cache_slots(self) -> Optional[str]:
        return pulumi.get(self, "max_incremental_fetch_session_cache_slots")

    @property
    @pulumi.getter(name="messageMaxBytes")
    def message_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "message_max_bytes")

    @property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[str]:
        return pulumi.get(self, "min_insync_replicas")

    @property
    @pulumi.getter(name="numPartitions")
    def num_partitions(self) -> Optional[str]:
        return pulumi.get(self, "num_partitions")

    @property
    @pulumi.getter(name="offsetsRetentionMinutes")
    def offsets_retention_minutes(self) -> Optional[str]:
        return pulumi.get(self, "offsets_retention_minutes")

    @property
    @pulumi.getter(name="producerPurgatoryPurgeIntervalRequests")
    def producer_purgatory_purge_interval_requests(self) -> Optional[str]:
        return pulumi.get(self, "producer_purgatory_purge_interval_requests")

    @property
    @pulumi.getter(name="replicaFetchMaxBytes")
    def replica_fetch_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "replica_fetch_max_bytes")

    @property
    @pulumi.getter(name="replicaFetchResponseMaxBytes")
    def replica_fetch_response_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "replica_fetch_response_max_bytes")

    @property
    @pulumi.getter(name="socketRequestMaxBytes")
    def socket_request_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "socket_request_max_bytes")

    @property
    @pulumi.getter(name="transactionRemoveExpiredTransactionCleanupIntervalMs")
    def transaction_remove_expired_transaction_cleanup_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "transaction_remove_expired_transaction_cleanup_interval_ms")

    @property
    @pulumi.getter(name="transactionStateLogSegmentBytes")
    def transaction_state_log_segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "transaction_state_log_segment_bytes")


@pulumi.output_type
class KafkaKafkaUserConfigKafkaAuthenticationMethods(dict):
    def __init__(__self__, *,
                 certificate: Optional[str] = None,
                 sasl: Optional[str] = None):
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if sasl is not None:
            pulumi.set(__self__, "sasl", sasl)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def sasl(self) -> Optional[str]:
        return pulumi.get(self, "sasl")


@pulumi.output_type
class KafkaKafkaUserConfigKafkaConnectConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorClientConfigOverridePolicy":
            suggest = "connector_client_config_override_policy"
        elif key == "consumerAutoOffsetReset":
            suggest = "consumer_auto_offset_reset"
        elif key == "consumerFetchMaxBytes":
            suggest = "consumer_fetch_max_bytes"
        elif key == "consumerIsolationLevel":
            suggest = "consumer_isolation_level"
        elif key == "consumerMaxPartitionFetchBytes":
            suggest = "consumer_max_partition_fetch_bytes"
        elif key == "consumerMaxPollIntervalMs":
            suggest = "consumer_max_poll_interval_ms"
        elif key == "consumerMaxPollRecords":
            suggest = "consumer_max_poll_records"
        elif key == "offsetFlushIntervalMs":
            suggest = "offset_flush_interval_ms"
        elif key == "offsetFlushTimeoutMs":
            suggest = "offset_flush_timeout_ms"
        elif key == "producerCompressionType":
            suggest = "producer_compression_type"
        elif key == "producerMaxRequestSize":
            suggest = "producer_max_request_size"
        elif key == "sessionTimeoutMs":
            suggest = "session_timeout_ms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaKafkaUserConfigKafkaConnectConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaKafkaUserConfigKafkaConnectConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaKafkaUserConfigKafkaConnectConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_client_config_override_policy: Optional[str] = None,
                 consumer_auto_offset_reset: Optional[str] = None,
                 consumer_fetch_max_bytes: Optional[str] = None,
                 consumer_isolation_level: Optional[str] = None,
                 consumer_max_partition_fetch_bytes: Optional[str] = None,
                 consumer_max_poll_interval_ms: Optional[str] = None,
                 consumer_max_poll_records: Optional[str] = None,
                 offset_flush_interval_ms: Optional[str] = None,
                 offset_flush_timeout_ms: Optional[str] = None,
                 producer_compression_type: Optional[str] = None,
                 producer_max_request_size: Optional[str] = None,
                 session_timeout_ms: Optional[str] = None):
        if connector_client_config_override_policy is not None:
            pulumi.set(__self__, "connector_client_config_override_policy", connector_client_config_override_policy)
        if consumer_auto_offset_reset is not None:
            pulumi.set(__self__, "consumer_auto_offset_reset", consumer_auto_offset_reset)
        if consumer_fetch_max_bytes is not None:
            pulumi.set(__self__, "consumer_fetch_max_bytes", consumer_fetch_max_bytes)
        if consumer_isolation_level is not None:
            pulumi.set(__self__, "consumer_isolation_level", consumer_isolation_level)
        if consumer_max_partition_fetch_bytes is not None:
            pulumi.set(__self__, "consumer_max_partition_fetch_bytes", consumer_max_partition_fetch_bytes)
        if consumer_max_poll_interval_ms is not None:
            pulumi.set(__self__, "consumer_max_poll_interval_ms", consumer_max_poll_interval_ms)
        if consumer_max_poll_records is not None:
            pulumi.set(__self__, "consumer_max_poll_records", consumer_max_poll_records)
        if offset_flush_interval_ms is not None:
            pulumi.set(__self__, "offset_flush_interval_ms", offset_flush_interval_ms)
        if offset_flush_timeout_ms is not None:
            pulumi.set(__self__, "offset_flush_timeout_ms", offset_flush_timeout_ms)
        if producer_compression_type is not None:
            pulumi.set(__self__, "producer_compression_type", producer_compression_type)
        if producer_max_request_size is not None:
            pulumi.set(__self__, "producer_max_request_size", producer_max_request_size)
        if session_timeout_ms is not None:
            pulumi.set(__self__, "session_timeout_ms", session_timeout_ms)

    @property
    @pulumi.getter(name="connectorClientConfigOverridePolicy")
    def connector_client_config_override_policy(self) -> Optional[str]:
        return pulumi.get(self, "connector_client_config_override_policy")

    @property
    @pulumi.getter(name="consumerAutoOffsetReset")
    def consumer_auto_offset_reset(self) -> Optional[str]:
        return pulumi.get(self, "consumer_auto_offset_reset")

    @property
    @pulumi.getter(name="consumerFetchMaxBytes")
    def consumer_fetch_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_fetch_max_bytes")

    @property
    @pulumi.getter(name="consumerIsolationLevel")
    def consumer_isolation_level(self) -> Optional[str]:
        return pulumi.get(self, "consumer_isolation_level")

    @property
    @pulumi.getter(name="consumerMaxPartitionFetchBytes")
    def consumer_max_partition_fetch_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_partition_fetch_bytes")

    @property
    @pulumi.getter(name="consumerMaxPollIntervalMs")
    def consumer_max_poll_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_poll_interval_ms")

    @property
    @pulumi.getter(name="consumerMaxPollRecords")
    def consumer_max_poll_records(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_poll_records")

    @property
    @pulumi.getter(name="offsetFlushIntervalMs")
    def offset_flush_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "offset_flush_interval_ms")

    @property
    @pulumi.getter(name="offsetFlushTimeoutMs")
    def offset_flush_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "offset_flush_timeout_ms")

    @property
    @pulumi.getter(name="producerCompressionType")
    def producer_compression_type(self) -> Optional[str]:
        return pulumi.get(self, "producer_compression_type")

    @property
    @pulumi.getter(name="producerMaxRequestSize")
    def producer_max_request_size(self) -> Optional[str]:
        return pulumi.get(self, "producer_max_request_size")

    @property
    @pulumi.getter(name="sessionTimeoutMs")
    def session_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "session_timeout_ms")


@pulumi.output_type
class KafkaKafkaUserConfigKafkaRestConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerEnableAutoCommit":
            suggest = "consumer_enable_auto_commit"
        elif key == "consumerRequestMaxBytes":
            suggest = "consumer_request_max_bytes"
        elif key == "consumerRequestTimeoutMs":
            suggest = "consumer_request_timeout_ms"
        elif key == "producerAcks":
            suggest = "producer_acks"
        elif key == "producerLingerMs":
            suggest = "producer_linger_ms"
        elif key == "simpleconsumerPoolSizeMax":
            suggest = "simpleconsumer_pool_size_max"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaKafkaUserConfigKafkaRestConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaKafkaUserConfigKafkaRestConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaKafkaUserConfigKafkaRestConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_enable_auto_commit: Optional[str] = None,
                 consumer_request_max_bytes: Optional[str] = None,
                 consumer_request_timeout_ms: Optional[str] = None,
                 producer_acks: Optional[str] = None,
                 producer_linger_ms: Optional[str] = None,
                 simpleconsumer_pool_size_max: Optional[str] = None):
        if consumer_enable_auto_commit is not None:
            pulumi.set(__self__, "consumer_enable_auto_commit", consumer_enable_auto_commit)
        if consumer_request_max_bytes is not None:
            pulumi.set(__self__, "consumer_request_max_bytes", consumer_request_max_bytes)
        if consumer_request_timeout_ms is not None:
            pulumi.set(__self__, "consumer_request_timeout_ms", consumer_request_timeout_ms)
        if producer_acks is not None:
            pulumi.set(__self__, "producer_acks", producer_acks)
        if producer_linger_ms is not None:
            pulumi.set(__self__, "producer_linger_ms", producer_linger_ms)
        if simpleconsumer_pool_size_max is not None:
            pulumi.set(__self__, "simpleconsumer_pool_size_max", simpleconsumer_pool_size_max)

    @property
    @pulumi.getter(name="consumerEnableAutoCommit")
    def consumer_enable_auto_commit(self) -> Optional[str]:
        return pulumi.get(self, "consumer_enable_auto_commit")

    @property
    @pulumi.getter(name="consumerRequestMaxBytes")
    def consumer_request_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_request_max_bytes")

    @property
    @pulumi.getter(name="consumerRequestTimeoutMs")
    def consumer_request_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "consumer_request_timeout_ms")

    @property
    @pulumi.getter(name="producerAcks")
    def producer_acks(self) -> Optional[str]:
        return pulumi.get(self, "producer_acks")

    @property
    @pulumi.getter(name="producerLingerMs")
    def producer_linger_ms(self) -> Optional[str]:
        return pulumi.get(self, "producer_linger_ms")

    @property
    @pulumi.getter(name="simpleconsumerPoolSizeMax")
    def simpleconsumer_pool_size_max(self) -> Optional[str]:
        return pulumi.get(self, "simpleconsumer_pool_size_max")


@pulumi.output_type
class KafkaKafkaUserConfigPrivateAccess(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class KafkaKafkaUserConfigPrivatelinkAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaConnect":
            suggest = "kafka_connect"
        elif key == "kafkaRest":
            suggest = "kafka_rest"
        elif key == "schemaRegistry":
            suggest = "schema_registry"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaKafkaUserConfigPrivatelinkAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaKafkaUserConfigPrivatelinkAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaKafkaUserConfigPrivatelinkAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 jolokia: Optional[str] = None,
                 kafka: Optional[str] = None,
                 kafka_connect: Optional[str] = None,
                 kafka_rest: Optional[str] = None,
                 prometheus: Optional[str] = None,
                 schema_registry: Optional[str] = None):
        if jolokia is not None:
            pulumi.set(__self__, "jolokia", jolokia)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if kafka_rest is not None:
            pulumi.set(__self__, "kafka_rest", kafka_rest)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)

    @property
    @pulumi.getter
    def jolokia(self) -> Optional[str]:
        return pulumi.get(self, "jolokia")

    @property
    @pulumi.getter
    def kafka(self) -> Optional[str]:
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter(name="kafkaRest")
    def kafka_rest(self) -> Optional[str]:
        return pulumi.get(self, "kafka_rest")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[str]:
        return pulumi.get(self, "schema_registry")


@pulumi.output_type
class KafkaKafkaUserConfigPublicAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaConnect":
            suggest = "kafka_connect"
        elif key == "kafkaRest":
            suggest = "kafka_rest"
        elif key == "schemaRegistry":
            suggest = "schema_registry"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaKafkaUserConfigPublicAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaKafkaUserConfigPublicAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaKafkaUserConfigPublicAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka: Optional[str] = None,
                 kafka_connect: Optional[str] = None,
                 kafka_rest: Optional[str] = None,
                 prometheus: Optional[str] = None,
                 schema_registry: Optional[str] = None):
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if kafka_rest is not None:
            pulumi.set(__self__, "kafka_rest", kafka_rest)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)

    @property
    @pulumi.getter
    def kafka(self) -> Optional[str]:
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter(name="kafkaRest")
    def kafka_rest(self) -> Optional[str]:
        return pulumi.get(self, "kafka_rest")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[str]:
        return pulumi.get(self, "schema_registry")


@pulumi.output_type
class KafkaKafkaUserConfigSchemaRegistryConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "leaderEligibility":
            suggest = "leader_eligibility"
        elif key == "topicName":
            suggest = "topic_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaKafkaUserConfigSchemaRegistryConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaKafkaUserConfigSchemaRegistryConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaKafkaUserConfigSchemaRegistryConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 leader_eligibility: Optional[str] = None,
                 topic_name: Optional[str] = None):
        if leader_eligibility is not None:
            pulumi.set(__self__, "leader_eligibility", leader_eligibility)
        if topic_name is not None:
            pulumi.set(__self__, "topic_name", topic_name)

    @property
    @pulumi.getter(name="leaderEligibility")
    def leader_eligibility(self) -> Optional[str]:
        return pulumi.get(self, "leader_eligibility")

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> Optional[str]:
        return pulumi.get(self, "topic_name")


@pulumi.output_type
class KafkaMirrorMakerComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaMirrorMakerComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaMirrorMakerComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaMirrorMakerComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class KafkaMirrorMakerKafkaMirrormaker(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class KafkaMirrorMakerKafkaMirrormakerUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "kafkaMirrormaker":
            suggest = "kafka_mirrormaker"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaMirrorMakerKafkaMirrormakerUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaMirrorMakerKafkaMirrormakerUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaMirrorMakerKafkaMirrormakerUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka_mirrormaker: Optional['outputs.KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker'] = None,
                 static_ips: Optional[str] = None):
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka_mirrormaker is not None:
            pulumi.set(__self__, "kafka_mirrormaker", kafka_mirrormaker)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="kafkaMirrormaker")
    def kafka_mirrormaker(self) -> Optional['outputs.KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker']:
        return pulumi.get(self, "kafka_mirrormaker")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emitCheckpointsEnabled":
            suggest = "emit_checkpoints_enabled"
        elif key == "emitCheckpointsIntervalSeconds":
            suggest = "emit_checkpoints_interval_seconds"
        elif key == "refreshGroupsEnabled":
            suggest = "refresh_groups_enabled"
        elif key == "refreshGroupsIntervalSeconds":
            suggest = "refresh_groups_interval_seconds"
        elif key == "refreshTopicsEnabled":
            suggest = "refresh_topics_enabled"
        elif key == "refreshTopicsIntervalSeconds":
            suggest = "refresh_topics_interval_seconds"
        elif key == "syncGroupOffsetsEnabled":
            suggest = "sync_group_offsets_enabled"
        elif key == "syncGroupOffsetsIntervalSeconds":
            suggest = "sync_group_offsets_interval_seconds"
        elif key == "syncTopicConfigsEnabled":
            suggest = "sync_topic_configs_enabled"
        elif key == "tasksMaxPerCpu":
            suggest = "tasks_max_per_cpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormaker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emit_checkpoints_enabled: Optional[str] = None,
                 emit_checkpoints_interval_seconds: Optional[str] = None,
                 refresh_groups_enabled: Optional[str] = None,
                 refresh_groups_interval_seconds: Optional[str] = None,
                 refresh_topics_enabled: Optional[str] = None,
                 refresh_topics_interval_seconds: Optional[str] = None,
                 sync_group_offsets_enabled: Optional[str] = None,
                 sync_group_offsets_interval_seconds: Optional[str] = None,
                 sync_topic_configs_enabled: Optional[str] = None,
                 tasks_max_per_cpu: Optional[str] = None):
        if emit_checkpoints_enabled is not None:
            pulumi.set(__self__, "emit_checkpoints_enabled", emit_checkpoints_enabled)
        if emit_checkpoints_interval_seconds is not None:
            pulumi.set(__self__, "emit_checkpoints_interval_seconds", emit_checkpoints_interval_seconds)
        if refresh_groups_enabled is not None:
            pulumi.set(__self__, "refresh_groups_enabled", refresh_groups_enabled)
        if refresh_groups_interval_seconds is not None:
            pulumi.set(__self__, "refresh_groups_interval_seconds", refresh_groups_interval_seconds)
        if refresh_topics_enabled is not None:
            pulumi.set(__self__, "refresh_topics_enabled", refresh_topics_enabled)
        if refresh_topics_interval_seconds is not None:
            pulumi.set(__self__, "refresh_topics_interval_seconds", refresh_topics_interval_seconds)
        if sync_group_offsets_enabled is not None:
            pulumi.set(__self__, "sync_group_offsets_enabled", sync_group_offsets_enabled)
        if sync_group_offsets_interval_seconds is not None:
            pulumi.set(__self__, "sync_group_offsets_interval_seconds", sync_group_offsets_interval_seconds)
        if sync_topic_configs_enabled is not None:
            pulumi.set(__self__, "sync_topic_configs_enabled", sync_topic_configs_enabled)
        if tasks_max_per_cpu is not None:
            pulumi.set(__self__, "tasks_max_per_cpu", tasks_max_per_cpu)

    @property
    @pulumi.getter(name="emitCheckpointsEnabled")
    def emit_checkpoints_enabled(self) -> Optional[str]:
        return pulumi.get(self, "emit_checkpoints_enabled")

    @property
    @pulumi.getter(name="emitCheckpointsIntervalSeconds")
    def emit_checkpoints_interval_seconds(self) -> Optional[str]:
        return pulumi.get(self, "emit_checkpoints_interval_seconds")

    @property
    @pulumi.getter(name="refreshGroupsEnabled")
    def refresh_groups_enabled(self) -> Optional[str]:
        return pulumi.get(self, "refresh_groups_enabled")

    @property
    @pulumi.getter(name="refreshGroupsIntervalSeconds")
    def refresh_groups_interval_seconds(self) -> Optional[str]:
        return pulumi.get(self, "refresh_groups_interval_seconds")

    @property
    @pulumi.getter(name="refreshTopicsEnabled")
    def refresh_topics_enabled(self) -> Optional[str]:
        return pulumi.get(self, "refresh_topics_enabled")

    @property
    @pulumi.getter(name="refreshTopicsIntervalSeconds")
    def refresh_topics_interval_seconds(self) -> Optional[str]:
        return pulumi.get(self, "refresh_topics_interval_seconds")

    @property
    @pulumi.getter(name="syncGroupOffsetsEnabled")
    def sync_group_offsets_enabled(self) -> Optional[str]:
        return pulumi.get(self, "sync_group_offsets_enabled")

    @property
    @pulumi.getter(name="syncGroupOffsetsIntervalSeconds")
    def sync_group_offsets_interval_seconds(self) -> Optional[str]:
        return pulumi.get(self, "sync_group_offsets_interval_seconds")

    @property
    @pulumi.getter(name="syncTopicConfigsEnabled")
    def sync_topic_configs_enabled(self) -> Optional[str]:
        return pulumi.get(self, "sync_topic_configs_enabled")

    @property
    @pulumi.getter(name="tasksMaxPerCpu")
    def tasks_max_per_cpu(self) -> Optional[str]:
        return pulumi.get(self, "tasks_max_per_cpu")


@pulumi.output_type
class KafkaMirrorMakerServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaMirrorMakerServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaMirrorMakerServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaMirrorMakerServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class KafkaMirrorMakerTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class KafkaServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class KafkaTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class KafkaTopicConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupPolicy":
            suggest = "cleanup_policy"
        elif key == "compressionType":
            suggest = "compression_type"
        elif key == "deleteRetentionMs":
            suggest = "delete_retention_ms"
        elif key == "fileDeleteDelayMs":
            suggest = "file_delete_delay_ms"
        elif key == "flushMessages":
            suggest = "flush_messages"
        elif key == "flushMs":
            suggest = "flush_ms"
        elif key == "indexIntervalBytes":
            suggest = "index_interval_bytes"
        elif key == "maxCompactionLagMs":
            suggest = "max_compaction_lag_ms"
        elif key == "maxMessageBytes":
            suggest = "max_message_bytes"
        elif key == "messageDownconversionEnable":
            suggest = "message_downconversion_enable"
        elif key == "messageFormatVersion":
            suggest = "message_format_version"
        elif key == "messageTimestampDifferenceMaxMs":
            suggest = "message_timestamp_difference_max_ms"
        elif key == "messageTimestampType":
            suggest = "message_timestamp_type"
        elif key == "minCleanableDirtyRatio":
            suggest = "min_cleanable_dirty_ratio"
        elif key == "minCompactionLagMs":
            suggest = "min_compaction_lag_ms"
        elif key == "minInsyncReplicas":
            suggest = "min_insync_replicas"
        elif key == "retentionBytes":
            suggest = "retention_bytes"
        elif key == "retentionMs":
            suggest = "retention_ms"
        elif key == "segmentBytes":
            suggest = "segment_bytes"
        elif key == "segmentIndexBytes":
            suggest = "segment_index_bytes"
        elif key == "segmentJitterMs":
            suggest = "segment_jitter_ms"
        elif key == "segmentMs":
            suggest = "segment_ms"
        elif key == "uncleanLeaderElectionEnable":
            suggest = "unclean_leader_election_enable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaTopicConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaTopicConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaTopicConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cleanup_policy: Optional[str] = None,
                 compression_type: Optional[str] = None,
                 delete_retention_ms: Optional[str] = None,
                 file_delete_delay_ms: Optional[str] = None,
                 flush_messages: Optional[str] = None,
                 flush_ms: Optional[str] = None,
                 index_interval_bytes: Optional[str] = None,
                 max_compaction_lag_ms: Optional[str] = None,
                 max_message_bytes: Optional[str] = None,
                 message_downconversion_enable: Optional[str] = None,
                 message_format_version: Optional[str] = None,
                 message_timestamp_difference_max_ms: Optional[str] = None,
                 message_timestamp_type: Optional[str] = None,
                 min_cleanable_dirty_ratio: Optional[str] = None,
                 min_compaction_lag_ms: Optional[str] = None,
                 min_insync_replicas: Optional[str] = None,
                 preallocate: Optional[str] = None,
                 retention_bytes: Optional[str] = None,
                 retention_ms: Optional[str] = None,
                 segment_bytes: Optional[str] = None,
                 segment_index_bytes: Optional[str] = None,
                 segment_jitter_ms: Optional[str] = None,
                 segment_ms: Optional[str] = None,
                 unclean_leader_election_enable: Optional[str] = None):
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if delete_retention_ms is not None:
            pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        if file_delete_delay_ms is not None:
            pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        if flush_messages is not None:
            pulumi.set(__self__, "flush_messages", flush_messages)
        if flush_ms is not None:
            pulumi.set(__self__, "flush_ms", flush_ms)
        if index_interval_bytes is not None:
            pulumi.set(__self__, "index_interval_bytes", index_interval_bytes)
        if max_compaction_lag_ms is not None:
            pulumi.set(__self__, "max_compaction_lag_ms", max_compaction_lag_ms)
        if max_message_bytes is not None:
            pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        if message_downconversion_enable is not None:
            pulumi.set(__self__, "message_downconversion_enable", message_downconversion_enable)
        if message_format_version is not None:
            pulumi.set(__self__, "message_format_version", message_format_version)
        if message_timestamp_difference_max_ms is not None:
            pulumi.set(__self__, "message_timestamp_difference_max_ms", message_timestamp_difference_max_ms)
        if message_timestamp_type is not None:
            pulumi.set(__self__, "message_timestamp_type", message_timestamp_type)
        if min_cleanable_dirty_ratio is not None:
            pulumi.set(__self__, "min_cleanable_dirty_ratio", min_cleanable_dirty_ratio)
        if min_compaction_lag_ms is not None:
            pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if preallocate is not None:
            pulumi.set(__self__, "preallocate", preallocate)
        if retention_bytes is not None:
            pulumi.set(__self__, "retention_bytes", retention_bytes)
        if retention_ms is not None:
            pulumi.set(__self__, "retention_ms", retention_ms)
        if segment_bytes is not None:
            pulumi.set(__self__, "segment_bytes", segment_bytes)
        if segment_index_bytes is not None:
            pulumi.set(__self__, "segment_index_bytes", segment_index_bytes)
        if segment_jitter_ms is not None:
            pulumi.set(__self__, "segment_jitter_ms", segment_jitter_ms)
        if segment_ms is not None:
            pulumi.set(__self__, "segment_ms", segment_ms)
        if unclean_leader_election_enable is not None:
            pulumi.set(__self__, "unclean_leader_election_enable", unclean_leader_election_enable)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[str]:
        return pulumi.get(self, "cleanup_policy")

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        return pulumi.get(self, "compression_type")

    @property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "delete_retention_ms")

    @property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> Optional[str]:
        return pulumi.get(self, "file_delete_delay_ms")

    @property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> Optional[str]:
        return pulumi.get(self, "flush_messages")

    @property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> Optional[str]:
        return pulumi.get(self, "flush_ms")

    @property
    @pulumi.getter(name="indexIntervalBytes")
    def index_interval_bytes(self) -> Optional[str]:
        return pulumi.get(self, "index_interval_bytes")

    @property
    @pulumi.getter(name="maxCompactionLagMs")
    def max_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "max_compaction_lag_ms")

    @property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> Optional[str]:
        return pulumi.get(self, "max_message_bytes")

    @property
    @pulumi.getter(name="messageDownconversionEnable")
    def message_downconversion_enable(self) -> Optional[str]:
        return pulumi.get(self, "message_downconversion_enable")

    @property
    @pulumi.getter(name="messageFormatVersion")
    def message_format_version(self) -> Optional[str]:
        return pulumi.get(self, "message_format_version")

    @property
    @pulumi.getter(name="messageTimestampDifferenceMaxMs")
    def message_timestamp_difference_max_ms(self) -> Optional[str]:
        return pulumi.get(self, "message_timestamp_difference_max_ms")

    @property
    @pulumi.getter(name="messageTimestampType")
    def message_timestamp_type(self) -> Optional[str]:
        return pulumi.get(self, "message_timestamp_type")

    @property
    @pulumi.getter(name="minCleanableDirtyRatio")
    def min_cleanable_dirty_ratio(self) -> Optional[str]:
        return pulumi.get(self, "min_cleanable_dirty_ratio")

    @property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "min_compaction_lag_ms")

    @property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[str]:
        return pulumi.get(self, "min_insync_replicas")

    @property
    @pulumi.getter
    def preallocate(self) -> Optional[str]:
        return pulumi.get(self, "preallocate")

    @property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> Optional[str]:
        return pulumi.get(self, "retention_bytes")

    @property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "retention_ms")

    @property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "segment_bytes")

    @property
    @pulumi.getter(name="segmentIndexBytes")
    def segment_index_bytes(self) -> Optional[str]:
        return pulumi.get(self, "segment_index_bytes")

    @property
    @pulumi.getter(name="segmentJitterMs")
    def segment_jitter_ms(self) -> Optional[str]:
        return pulumi.get(self, "segment_jitter_ms")

    @property
    @pulumi.getter(name="segmentMs")
    def segment_ms(self) -> Optional[str]:
        return pulumi.get(self, "segment_ms")

    @property
    @pulumi.getter(name="uncleanLeaderElectionEnable")
    def unclean_leader_election_enable(self) -> Optional[str]:
        return pulumi.get(self, "unclean_leader_election_enable")


@pulumi.output_type
class KafkaTopicTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class M3AggregatorComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3AggregatorComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3AggregatorComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3AggregatorComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class M3AggregatorM3aggregator(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class M3AggregatorM3aggregatorUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDomain":
            suggest = "custom_domain"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "m3Version":
            suggest = "m3_version"
        elif key == "m3aggregatorVersion":
            suggest = "m3aggregator_version"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3AggregatorM3aggregatorUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3AggregatorM3aggregatorUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3AggregatorM3aggregatorUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 m3_version: Optional[str] = None,
                 m3aggregator_version: Optional[str] = None,
                 static_ips: Optional[str] = None):
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if m3_version is not None:
            pulumi.set(__self__, "m3_version", m3_version)
        if m3aggregator_version is not None:
            pulumi.set(__self__, "m3aggregator_version", m3aggregator_version)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="m3Version")
    def m3_version(self) -> Optional[str]:
        return pulumi.get(self, "m3_version")

    @property
    @pulumi.getter(name="m3aggregatorVersion")
    def m3aggregator_version(self) -> Optional[str]:
        return pulumi.get(self, "m3aggregator_version")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class M3AggregatorServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3AggregatorServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3AggregatorServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3AggregatorServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class M3AggregatorTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class M3DbComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3DbComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3DbComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3DbComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class M3DbM3db(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class M3DbM3dbUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDomain":
            suggest = "custom_domain"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "m3Version":
            suggest = "m3_version"
        elif key == "m3coordinatorEnableGraphiteCarbonIngest":
            suggest = "m3coordinator_enable_graphite_carbon_ingest"
        elif key == "m3dbVersion":
            suggest = "m3db_version"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3DbM3dbUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3DbM3dbUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3DbM3dbUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 limits: Optional['outputs.M3DbM3dbUserConfigLimits'] = None,
                 m3_version: Optional[str] = None,
                 m3coordinator_enable_graphite_carbon_ingest: Optional[str] = None,
                 m3db_version: Optional[str] = None,
                 namespaces: Optional[Sequence['outputs.M3DbM3dbUserConfigNamespace']] = None,
                 private_access: Optional['outputs.M3DbM3dbUserConfigPrivateAccess'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.M3DbM3dbUserConfigPublicAccess'] = None,
                 rules: Optional['outputs.M3DbM3dbUserConfigRules'] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if m3_version is not None:
            pulumi.set(__self__, "m3_version", m3_version)
        if m3coordinator_enable_graphite_carbon_ingest is not None:
            pulumi.set(__self__, "m3coordinator_enable_graphite_carbon_ingest", m3coordinator_enable_graphite_carbon_ingest)
        if m3db_version is not None:
            pulumi.set(__self__, "m3db_version", m3db_version)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def limits(self) -> Optional['outputs.M3DbM3dbUserConfigLimits']:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter(name="m3Version")
    def m3_version(self) -> Optional[str]:
        return pulumi.get(self, "m3_version")

    @property
    @pulumi.getter(name="m3coordinatorEnableGraphiteCarbonIngest")
    def m3coordinator_enable_graphite_carbon_ingest(self) -> Optional[str]:
        return pulumi.get(self, "m3coordinator_enable_graphite_carbon_ingest")

    @property
    @pulumi.getter(name="m3dbVersion")
    def m3db_version(self) -> Optional[str]:
        return pulumi.get(self, "m3db_version")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence['outputs.M3DbM3dbUserConfigNamespace']]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.M3DbM3dbUserConfigPrivateAccess']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.M3DbM3dbUserConfigPublicAccess']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter
    def rules(self) -> Optional['outputs.M3DbM3dbUserConfigRules']:
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class M3DbM3dbUserConfigLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryRequireExhaustive":
            suggest = "query_require_exhaustive"
        elif key == "querySeries":
            suggest = "query_series"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3DbM3dbUserConfigLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3DbM3dbUserConfigLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3DbM3dbUserConfigLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_require_exhaustive: Optional[str] = None,
                 query_series: Optional[str] = None):
        if query_require_exhaustive is not None:
            pulumi.set(__self__, "query_require_exhaustive", query_require_exhaustive)
        if query_series is not None:
            pulumi.set(__self__, "query_series", query_series)

    @property
    @pulumi.getter(name="queryRequireExhaustive")
    def query_require_exhaustive(self) -> Optional[str]:
        return pulumi.get(self, "query_require_exhaustive")

    @property
    @pulumi.getter(name="querySeries")
    def query_series(self) -> Optional[str]:
        return pulumi.get(self, "query_series")


@pulumi.output_type
class M3DbM3dbUserConfigNamespace(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 options: Optional['outputs.M3DbM3dbUserConfigNamespaceOptions'] = None,
                 resolution: Optional[str] = None,
                 type: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def options(self) -> Optional['outputs.M3DbM3dbUserConfigNamespaceOptions']:
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def resolution(self) -> Optional[str]:
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class M3DbM3dbUserConfigNamespaceOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionOptions":
            suggest = "retention_options"
        elif key == "snapshotEnabled":
            suggest = "snapshot_enabled"
        elif key == "writesToCommitlog":
            suggest = "writes_to_commitlog"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3DbM3dbUserConfigNamespaceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3DbM3dbUserConfigNamespaceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3DbM3dbUserConfigNamespaceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_options: Optional['outputs.M3DbM3dbUserConfigNamespaceOptionsRetentionOptions'] = None,
                 snapshot_enabled: Optional[str] = None,
                 writes_to_commitlog: Optional[str] = None):
        if retention_options is not None:
            pulumi.set(__self__, "retention_options", retention_options)
        if snapshot_enabled is not None:
            pulumi.set(__self__, "snapshot_enabled", snapshot_enabled)
        if writes_to_commitlog is not None:
            pulumi.set(__self__, "writes_to_commitlog", writes_to_commitlog)

    @property
    @pulumi.getter(name="retentionOptions")
    def retention_options(self) -> Optional['outputs.M3DbM3dbUserConfigNamespaceOptionsRetentionOptions']:
        return pulumi.get(self, "retention_options")

    @property
    @pulumi.getter(name="snapshotEnabled")
    def snapshot_enabled(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_enabled")

    @property
    @pulumi.getter(name="writesToCommitlog")
    def writes_to_commitlog(self) -> Optional[str]:
        return pulumi.get(self, "writes_to_commitlog")


@pulumi.output_type
class M3DbM3dbUserConfigNamespaceOptionsRetentionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockDataExpiryDuration":
            suggest = "block_data_expiry_duration"
        elif key == "blocksizeDuration":
            suggest = "blocksize_duration"
        elif key == "bufferFutureDuration":
            suggest = "buffer_future_duration"
        elif key == "bufferPastDuration":
            suggest = "buffer_past_duration"
        elif key == "retentionPeriodDuration":
            suggest = "retention_period_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3DbM3dbUserConfigNamespaceOptionsRetentionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3DbM3dbUserConfigNamespaceOptionsRetentionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3DbM3dbUserConfigNamespaceOptionsRetentionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_data_expiry_duration: Optional[str] = None,
                 blocksize_duration: Optional[str] = None,
                 buffer_future_duration: Optional[str] = None,
                 buffer_past_duration: Optional[str] = None,
                 retention_period_duration: Optional[str] = None):
        if block_data_expiry_duration is not None:
            pulumi.set(__self__, "block_data_expiry_duration", block_data_expiry_duration)
        if blocksize_duration is not None:
            pulumi.set(__self__, "blocksize_duration", blocksize_duration)
        if buffer_future_duration is not None:
            pulumi.set(__self__, "buffer_future_duration", buffer_future_duration)
        if buffer_past_duration is not None:
            pulumi.set(__self__, "buffer_past_duration", buffer_past_duration)
        if retention_period_duration is not None:
            pulumi.set(__self__, "retention_period_duration", retention_period_duration)

    @property
    @pulumi.getter(name="blockDataExpiryDuration")
    def block_data_expiry_duration(self) -> Optional[str]:
        return pulumi.get(self, "block_data_expiry_duration")

    @property
    @pulumi.getter(name="blocksizeDuration")
    def blocksize_duration(self) -> Optional[str]:
        return pulumi.get(self, "blocksize_duration")

    @property
    @pulumi.getter(name="bufferFutureDuration")
    def buffer_future_duration(self) -> Optional[str]:
        return pulumi.get(self, "buffer_future_duration")

    @property
    @pulumi.getter(name="bufferPastDuration")
    def buffer_past_duration(self) -> Optional[str]:
        return pulumi.get(self, "buffer_past_duration")

    @property
    @pulumi.getter(name="retentionPeriodDuration")
    def retention_period_duration(self) -> Optional[str]:
        return pulumi.get(self, "retention_period_duration")


@pulumi.output_type
class M3DbM3dbUserConfigPrivateAccess(dict):
    def __init__(__self__, *,
                 m3coordinator: Optional[str] = None):
        if m3coordinator is not None:
            pulumi.set(__self__, "m3coordinator", m3coordinator)

    @property
    @pulumi.getter
    def m3coordinator(self) -> Optional[str]:
        return pulumi.get(self, "m3coordinator")


@pulumi.output_type
class M3DbM3dbUserConfigPublicAccess(dict):
    def __init__(__self__, *,
                 m3coordinator: Optional[str] = None):
        if m3coordinator is not None:
            pulumi.set(__self__, "m3coordinator", m3coordinator)

    @property
    @pulumi.getter
    def m3coordinator(self) -> Optional[str]:
        return pulumi.get(self, "m3coordinator")


@pulumi.output_type
class M3DbM3dbUserConfigRules(dict):
    def __init__(__self__, *,
                 mappings: Optional[Sequence['outputs.M3DbM3dbUserConfigRulesMapping']] = None):
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter
    def mappings(self) -> Optional[Sequence['outputs.M3DbM3dbUserConfigRulesMapping']]:
        return pulumi.get(self, "mappings")


@pulumi.output_type
class M3DbM3dbUserConfigRulesMapping(dict):
    def __init__(__self__, *,
                 aggregations: Optional[Sequence[str]] = None,
                 drop: Optional[str] = None,
                 filter: Optional[str] = None,
                 name: Optional[str] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence['outputs.M3DbM3dbUserConfigRulesMappingTag']] = None):
        if aggregations is not None:
            pulumi.set(__self__, "aggregations", aggregations)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def aggregations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "aggregations")

    @property
    @pulumi.getter
    def drop(self) -> Optional[str]:
        return pulumi.get(self, "drop")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.M3DbM3dbUserConfigRulesMappingTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class M3DbM3dbUserConfigRulesMappingTag(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class M3DbServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in M3DbServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        M3DbServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        M3DbServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class M3DbTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class MySqlComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MySqlComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MySqlComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MySqlComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class MySqlMysql(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class MySqlMysqlUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupHour":
            suggest = "backup_hour"
        elif key == "backupMinute":
            suggest = "backup_minute"
        elif key == "binlogRetentionPeriod":
            suggest = "binlog_retention_period"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "mysqlVersion":
            suggest = "mysql_version"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "recoveryTargetTime":
            suggest = "recovery_target_time"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MySqlMysqlUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MySqlMysqlUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MySqlMysqlUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_hour: Optional[str] = None,
                 backup_minute: Optional[str] = None,
                 binlog_retention_period: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 migration: Optional['outputs.MySqlMysqlUserConfigMigration'] = None,
                 mysql: Optional['outputs.MySqlMysqlUserConfigMysql'] = None,
                 mysql_version: Optional[str] = None,
                 private_access: Optional['outputs.MySqlMysqlUserConfigPrivateAccess'] = None,
                 privatelink_access: Optional['outputs.MySqlMysqlUserConfigPrivatelinkAccess'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.MySqlMysqlUserConfigPublicAccess'] = None,
                 recovery_target_time: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if binlog_retention_period is not None:
            pulumi.set(__self__, "binlog_retention_period", binlog_retention_period)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if mysql_version is not None:
            pulumi.set(__self__, "mysql_version", mysql_version)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_target_time is not None:
            pulumi.set(__self__, "recovery_target_time", recovery_target_time)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[str]:
        return pulumi.get(self, "backup_hour")

    @property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[str]:
        return pulumi.get(self, "backup_minute")

    @property
    @pulumi.getter(name="binlogRetentionPeriod")
    def binlog_retention_period(self) -> Optional[str]:
        return pulumi.get(self, "binlog_retention_period")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def migration(self) -> Optional['outputs.MySqlMysqlUserConfigMigration']:
        return pulumi.get(self, "migration")

    @property
    @pulumi.getter
    def mysql(self) -> Optional['outputs.MySqlMysqlUserConfigMysql']:
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter(name="mysqlVersion")
    def mysql_version(self) -> Optional[str]:
        return pulumi.get(self, "mysql_version")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.MySqlMysqlUserConfigPrivateAccess']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.MySqlMysqlUserConfigPrivatelinkAccess']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.MySqlMysqlUserConfigPublicAccess']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryTargetTime")
    def recovery_target_time(self) -> Optional[str]:
        return pulumi.get(self, "recovery_target_time")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class MySqlMysqlUserConfigMigration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreDbs":
            suggest = "ignore_dbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MySqlMysqlUserConfigMigration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MySqlMysqlUserConfigMigration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MySqlMysqlUserConfigMigration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 ignore_dbs: Optional[str] = None,
                 method: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 ssl: Optional[str] = None,
                 username: Optional[str] = None):
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[str]:
        return pulumi.get(self, "ignore_dbs")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class MySqlMysqlUserConfigMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "defaultTimeZone":
            suggest = "default_time_zone"
        elif key == "groupConcatMaxLen":
            suggest = "group_concat_max_len"
        elif key == "informationSchemaStatsExpiry":
            suggest = "information_schema_stats_expiry"
        elif key == "innodbFtMinTokenSize":
            suggest = "innodb_ft_min_token_size"
        elif key == "innodbFtServerStopwordTable":
            suggest = "innodb_ft_server_stopword_table"
        elif key == "innodbLockWaitTimeout":
            suggest = "innodb_lock_wait_timeout"
        elif key == "innodbLogBufferSize":
            suggest = "innodb_log_buffer_size"
        elif key == "innodbOnlineAlterLogMaxSize":
            suggest = "innodb_online_alter_log_max_size"
        elif key == "innodbPrintAllDeadlocks":
            suggest = "innodb_print_all_deadlocks"
        elif key == "innodbRollbackOnTimeout":
            suggest = "innodb_rollback_on_timeout"
        elif key == "interactiveTimeout":
            suggest = "interactive_timeout"
        elif key == "internalTmpMemStorageEngine":
            suggest = "internal_tmp_mem_storage_engine"
        elif key == "longQueryTime":
            suggest = "long_query_time"
        elif key == "maxAllowedPacket":
            suggest = "max_allowed_packet"
        elif key == "maxHeapTableSize":
            suggest = "max_heap_table_size"
        elif key == "netReadTimeout":
            suggest = "net_read_timeout"
        elif key == "netWriteTimeout":
            suggest = "net_write_timeout"
        elif key == "slowQueryLog":
            suggest = "slow_query_log"
        elif key == "sortBufferSize":
            suggest = "sort_buffer_size"
        elif key == "sqlMode":
            suggest = "sql_mode"
        elif key == "sqlRequirePrimaryKey":
            suggest = "sql_require_primary_key"
        elif key == "tmpTableSize":
            suggest = "tmp_table_size"
        elif key == "waitTimeout":
            suggest = "wait_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MySqlMysqlUserConfigMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MySqlMysqlUserConfigMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MySqlMysqlUserConfigMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connect_timeout: Optional[str] = None,
                 default_time_zone: Optional[str] = None,
                 group_concat_max_len: Optional[str] = None,
                 information_schema_stats_expiry: Optional[str] = None,
                 innodb_ft_min_token_size: Optional[str] = None,
                 innodb_ft_server_stopword_table: Optional[str] = None,
                 innodb_lock_wait_timeout: Optional[str] = None,
                 innodb_log_buffer_size: Optional[str] = None,
                 innodb_online_alter_log_max_size: Optional[str] = None,
                 innodb_print_all_deadlocks: Optional[str] = None,
                 innodb_rollback_on_timeout: Optional[str] = None,
                 interactive_timeout: Optional[str] = None,
                 internal_tmp_mem_storage_engine: Optional[str] = None,
                 long_query_time: Optional[str] = None,
                 max_allowed_packet: Optional[str] = None,
                 max_heap_table_size: Optional[str] = None,
                 net_read_timeout: Optional[str] = None,
                 net_write_timeout: Optional[str] = None,
                 slow_query_log: Optional[str] = None,
                 sort_buffer_size: Optional[str] = None,
                 sql_mode: Optional[str] = None,
                 sql_require_primary_key: Optional[str] = None,
                 tmp_table_size: Optional[str] = None,
                 wait_timeout: Optional[str] = None):
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if default_time_zone is not None:
            pulumi.set(__self__, "default_time_zone", default_time_zone)
        if group_concat_max_len is not None:
            pulumi.set(__self__, "group_concat_max_len", group_concat_max_len)
        if information_schema_stats_expiry is not None:
            pulumi.set(__self__, "information_schema_stats_expiry", information_schema_stats_expiry)
        if innodb_ft_min_token_size is not None:
            pulumi.set(__self__, "innodb_ft_min_token_size", innodb_ft_min_token_size)
        if innodb_ft_server_stopword_table is not None:
            pulumi.set(__self__, "innodb_ft_server_stopword_table", innodb_ft_server_stopword_table)
        if innodb_lock_wait_timeout is not None:
            pulumi.set(__self__, "innodb_lock_wait_timeout", innodb_lock_wait_timeout)
        if innodb_log_buffer_size is not None:
            pulumi.set(__self__, "innodb_log_buffer_size", innodb_log_buffer_size)
        if innodb_online_alter_log_max_size is not None:
            pulumi.set(__self__, "innodb_online_alter_log_max_size", innodb_online_alter_log_max_size)
        if innodb_print_all_deadlocks is not None:
            pulumi.set(__self__, "innodb_print_all_deadlocks", innodb_print_all_deadlocks)
        if innodb_rollback_on_timeout is not None:
            pulumi.set(__self__, "innodb_rollback_on_timeout", innodb_rollback_on_timeout)
        if interactive_timeout is not None:
            pulumi.set(__self__, "interactive_timeout", interactive_timeout)
        if internal_tmp_mem_storage_engine is not None:
            pulumi.set(__self__, "internal_tmp_mem_storage_engine", internal_tmp_mem_storage_engine)
        if long_query_time is not None:
            pulumi.set(__self__, "long_query_time", long_query_time)
        if max_allowed_packet is not None:
            pulumi.set(__self__, "max_allowed_packet", max_allowed_packet)
        if max_heap_table_size is not None:
            pulumi.set(__self__, "max_heap_table_size", max_heap_table_size)
        if net_read_timeout is not None:
            pulumi.set(__self__, "net_read_timeout", net_read_timeout)
        if net_write_timeout is not None:
            pulumi.set(__self__, "net_write_timeout", net_write_timeout)
        if slow_query_log is not None:
            pulumi.set(__self__, "slow_query_log", slow_query_log)
        if sort_buffer_size is not None:
            pulumi.set(__self__, "sort_buffer_size", sort_buffer_size)
        if sql_mode is not None:
            pulumi.set(__self__, "sql_mode", sql_mode)
        if sql_require_primary_key is not None:
            pulumi.set(__self__, "sql_require_primary_key", sql_require_primary_key)
        if tmp_table_size is not None:
            pulumi.set(__self__, "tmp_table_size", tmp_table_size)
        if wait_timeout is not None:
            pulumi.set(__self__, "wait_timeout", wait_timeout)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[str]:
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="defaultTimeZone")
    def default_time_zone(self) -> Optional[str]:
        return pulumi.get(self, "default_time_zone")

    @property
    @pulumi.getter(name="groupConcatMaxLen")
    def group_concat_max_len(self) -> Optional[str]:
        return pulumi.get(self, "group_concat_max_len")

    @property
    @pulumi.getter(name="informationSchemaStatsExpiry")
    def information_schema_stats_expiry(self) -> Optional[str]:
        return pulumi.get(self, "information_schema_stats_expiry")

    @property
    @pulumi.getter(name="innodbFtMinTokenSize")
    def innodb_ft_min_token_size(self) -> Optional[str]:
        return pulumi.get(self, "innodb_ft_min_token_size")

    @property
    @pulumi.getter(name="innodbFtServerStopwordTable")
    def innodb_ft_server_stopword_table(self) -> Optional[str]:
        return pulumi.get(self, "innodb_ft_server_stopword_table")

    @property
    @pulumi.getter(name="innodbLockWaitTimeout")
    def innodb_lock_wait_timeout(self) -> Optional[str]:
        return pulumi.get(self, "innodb_lock_wait_timeout")

    @property
    @pulumi.getter(name="innodbLogBufferSize")
    def innodb_log_buffer_size(self) -> Optional[str]:
        return pulumi.get(self, "innodb_log_buffer_size")

    @property
    @pulumi.getter(name="innodbOnlineAlterLogMaxSize")
    def innodb_online_alter_log_max_size(self) -> Optional[str]:
        return pulumi.get(self, "innodb_online_alter_log_max_size")

    @property
    @pulumi.getter(name="innodbPrintAllDeadlocks")
    def innodb_print_all_deadlocks(self) -> Optional[str]:
        return pulumi.get(self, "innodb_print_all_deadlocks")

    @property
    @pulumi.getter(name="innodbRollbackOnTimeout")
    def innodb_rollback_on_timeout(self) -> Optional[str]:
        return pulumi.get(self, "innodb_rollback_on_timeout")

    @property
    @pulumi.getter(name="interactiveTimeout")
    def interactive_timeout(self) -> Optional[str]:
        return pulumi.get(self, "interactive_timeout")

    @property
    @pulumi.getter(name="internalTmpMemStorageEngine")
    def internal_tmp_mem_storage_engine(self) -> Optional[str]:
        return pulumi.get(self, "internal_tmp_mem_storage_engine")

    @property
    @pulumi.getter(name="longQueryTime")
    def long_query_time(self) -> Optional[str]:
        return pulumi.get(self, "long_query_time")

    @property
    @pulumi.getter(name="maxAllowedPacket")
    def max_allowed_packet(self) -> Optional[str]:
        return pulumi.get(self, "max_allowed_packet")

    @property
    @pulumi.getter(name="maxHeapTableSize")
    def max_heap_table_size(self) -> Optional[str]:
        return pulumi.get(self, "max_heap_table_size")

    @property
    @pulumi.getter(name="netReadTimeout")
    def net_read_timeout(self) -> Optional[str]:
        return pulumi.get(self, "net_read_timeout")

    @property
    @pulumi.getter(name="netWriteTimeout")
    def net_write_timeout(self) -> Optional[str]:
        return pulumi.get(self, "net_write_timeout")

    @property
    @pulumi.getter(name="slowQueryLog")
    def slow_query_log(self) -> Optional[str]:
        return pulumi.get(self, "slow_query_log")

    @property
    @pulumi.getter(name="sortBufferSize")
    def sort_buffer_size(self) -> Optional[str]:
        return pulumi.get(self, "sort_buffer_size")

    @property
    @pulumi.getter(name="sqlMode")
    def sql_mode(self) -> Optional[str]:
        return pulumi.get(self, "sql_mode")

    @property
    @pulumi.getter(name="sqlRequirePrimaryKey")
    def sql_require_primary_key(self) -> Optional[str]:
        return pulumi.get(self, "sql_require_primary_key")

    @property
    @pulumi.getter(name="tmpTableSize")
    def tmp_table_size(self) -> Optional[str]:
        return pulumi.get(self, "tmp_table_size")

    @property
    @pulumi.getter(name="waitTimeout")
    def wait_timeout(self) -> Optional[str]:
        return pulumi.get(self, "wait_timeout")


@pulumi.output_type
class MySqlMysqlUserConfigPrivateAccess(dict):
    def __init__(__self__, *,
                 mysql: Optional[str] = None,
                 mysqlx: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if mysqlx is not None:
            pulumi.set(__self__, "mysqlx", mysqlx)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def mysql(self) -> Optional[str]:
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter
    def mysqlx(self) -> Optional[str]:
        return pulumi.get(self, "mysqlx")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class MySqlMysqlUserConfigPrivatelinkAccess(dict):
    def __init__(__self__, *,
                 mysql: Optional[str] = None,
                 mysqlx: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if mysqlx is not None:
            pulumi.set(__self__, "mysqlx", mysqlx)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def mysql(self) -> Optional[str]:
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter
    def mysqlx(self) -> Optional[str]:
        return pulumi.get(self, "mysqlx")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class MySqlMysqlUserConfigPublicAccess(dict):
    def __init__(__self__, *,
                 mysql: Optional[str] = None,
                 mysqlx: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if mysqlx is not None:
            pulumi.set(__self__, "mysqlx", mysqlx)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def mysql(self) -> Optional[str]:
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter
    def mysqlx(self) -> Optional[str]:
        return pulumi.get(self, "mysqlx")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class MySqlServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MySqlServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MySqlServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MySqlServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class MySqlTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class OpenSearchComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class OpenSearchOpensearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "opensearchDashboardsUri":
            suggest = "opensearch_dashboards_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 opensearch_dashboards_uri: Optional[str] = None):
        if opensearch_dashboards_uri is not None:
            pulumi.set(__self__, "opensearch_dashboards_uri", opensearch_dashboards_uri)

    @property
    @pulumi.getter(name="opensearchDashboardsUri")
    def opensearch_dashboards_uri(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_dashboards_uri")


@pulumi.output_type
class OpenSearchOpensearchUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDomain":
            suggest = "custom_domain"
        elif key == "disableReplicationFactorAdjustment":
            suggest = "disable_replication_factor_adjustment"
        elif key == "indexPatterns":
            suggest = "index_patterns"
        elif key == "indexTemplate":
            suggest = "index_template"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "keepIndexRefreshInterval":
            suggest = "keep_index_refresh_interval"
        elif key == "maxIndexCount":
            suggest = "max_index_count"
        elif key == "opensearchDashboards":
            suggest = "opensearch_dashboards"
        elif key == "opensearchVersion":
            suggest = "opensearch_version"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "recoveryBasebackupName":
            suggest = "recovery_basebackup_name"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearchUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearchUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearchUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 disable_replication_factor_adjustment: Optional[str] = None,
                 index_patterns: Optional[Sequence['outputs.OpenSearchOpensearchUserConfigIndexPattern']] = None,
                 index_template: Optional['outputs.OpenSearchOpensearchUserConfigIndexTemplate'] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 keep_index_refresh_interval: Optional[str] = None,
                 max_index_count: Optional[str] = None,
                 opensearch: Optional['outputs.OpenSearchOpensearchUserConfigOpensearch'] = None,
                 opensearch_dashboards: Optional['outputs.OpenSearchOpensearchUserConfigOpensearchDashboards'] = None,
                 opensearch_version: Optional[str] = None,
                 private_access: Optional['outputs.OpenSearchOpensearchUserConfigPrivateAccess'] = None,
                 privatelink_access: Optional['outputs.OpenSearchOpensearchUserConfigPrivatelinkAccess'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.OpenSearchOpensearchUserConfigPublicAccess'] = None,
                 recovery_basebackup_name: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if disable_replication_factor_adjustment is not None:
            pulumi.set(__self__, "disable_replication_factor_adjustment", disable_replication_factor_adjustment)
        if index_patterns is not None:
            pulumi.set(__self__, "index_patterns", index_patterns)
        if index_template is not None:
            pulumi.set(__self__, "index_template", index_template)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if keep_index_refresh_interval is not None:
            pulumi.set(__self__, "keep_index_refresh_interval", keep_index_refresh_interval)
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if opensearch is not None:
            pulumi.set(__self__, "opensearch", opensearch)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if opensearch_version is not None:
            pulumi.set(__self__, "opensearch_version", opensearch_version)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_basebackup_name is not None:
            pulumi.set(__self__, "recovery_basebackup_name", recovery_basebackup_name)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="disableReplicationFactorAdjustment")
    def disable_replication_factor_adjustment(self) -> Optional[str]:
        return pulumi.get(self, "disable_replication_factor_adjustment")

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[Sequence['outputs.OpenSearchOpensearchUserConfigIndexPattern']]:
        return pulumi.get(self, "index_patterns")

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional['outputs.OpenSearchOpensearchUserConfigIndexTemplate']:
        return pulumi.get(self, "index_template")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[str]:
        return pulumi.get(self, "keep_index_refresh_interval")

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[str]:
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter
    def opensearch(self) -> Optional['outputs.OpenSearchOpensearchUserConfigOpensearch']:
        return pulumi.get(self, "opensearch")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional['outputs.OpenSearchOpensearchUserConfigOpensearchDashboards']:
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter(name="opensearchVersion")
    def opensearch_version(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_version")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.OpenSearchOpensearchUserConfigPrivateAccess']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.OpenSearchOpensearchUserConfigPrivatelinkAccess']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.OpenSearchOpensearchUserConfigPublicAccess']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryBasebackupName")
    def recovery_basebackup_name(self) -> Optional[str]:
        return pulumi.get(self, "recovery_basebackup_name")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class OpenSearchOpensearchUserConfigIndexPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxIndexCount":
            suggest = "max_index_count"
        elif key == "sortingAlgorithm":
            suggest = "sorting_algorithm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearchUserConfigIndexPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearchUserConfigIndexPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearchUserConfigIndexPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_index_count: Optional[str] = None,
                 pattern: Optional[str] = None,
                 sorting_algorithm: Optional[str] = None):
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if sorting_algorithm is not None:
            pulumi.set(__self__, "sorting_algorithm", sorting_algorithm)

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[str]:
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="sortingAlgorithm")
    def sorting_algorithm(self) -> Optional[str]:
        return pulumi.get(self, "sorting_algorithm")


@pulumi.output_type
class OpenSearchOpensearchUserConfigIndexTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mappingNestedObjectsLimit":
            suggest = "mapping_nested_objects_limit"
        elif key == "numberOfReplicas":
            suggest = "number_of_replicas"
        elif key == "numberOfShards":
            suggest = "number_of_shards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearchUserConfigIndexTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearchUserConfigIndexTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearchUserConfigIndexTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[str] = None,
                 number_of_replicas: Optional[str] = None,
                 number_of_shards: Optional[str] = None):
        if mapping_nested_objects_limit is not None:
            pulumi.set(__self__, "mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[str]:
        return pulumi.get(self, "mapping_nested_objects_limit")

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[str]:
        return pulumi.get(self, "number_of_replicas")

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[str]:
        return pulumi.get(self, "number_of_shards")


@pulumi.output_type
class OpenSearchOpensearchUserConfigOpensearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionAutoCreateIndexEnabled":
            suggest = "action_auto_create_index_enabled"
        elif key == "actionDestructiveRequiresName":
            suggest = "action_destructive_requires_name"
        elif key == "clusterMaxShardsPerNode":
            suggest = "cluster_max_shards_per_node"
        elif key == "clusterRoutingAllocationNodeConcurrentRecoveries":
            suggest = "cluster_routing_allocation_node_concurrent_recoveries"
        elif key == "httpMaxContentLength":
            suggest = "http_max_content_length"
        elif key == "httpMaxHeaderSize":
            suggest = "http_max_header_size"
        elif key == "httpMaxInitialLineLength":
            suggest = "http_max_initial_line_length"
        elif key == "indicesFielddataCacheSize":
            suggest = "indices_fielddata_cache_size"
        elif key == "indicesMemoryIndexBufferSize":
            suggest = "indices_memory_index_buffer_size"
        elif key == "indicesQueriesCacheSize":
            suggest = "indices_queries_cache_size"
        elif key == "indicesQueryBoolMaxClauseCount":
            suggest = "indices_query_bool_max_clause_count"
        elif key == "indicesRecoveryMaxBytesPerSec":
            suggest = "indices_recovery_max_bytes_per_sec"
        elif key == "indicesRecoveryMaxConcurrentFileChunks":
            suggest = "indices_recovery_max_concurrent_file_chunks"
        elif key == "overrideMainResponseVersion":
            suggest = "override_main_response_version"
        elif key == "reindexRemoteWhitelists":
            suggest = "reindex_remote_whitelists"
        elif key == "scriptMaxCompilationsRate":
            suggest = "script_max_compilations_rate"
        elif key == "searchMaxBuckets":
            suggest = "search_max_buckets"
        elif key == "threadPoolAnalyzeQueueSize":
            suggest = "thread_pool_analyze_queue_size"
        elif key == "threadPoolAnalyzeSize":
            suggest = "thread_pool_analyze_size"
        elif key == "threadPoolForceMergeSize":
            suggest = "thread_pool_force_merge_size"
        elif key == "threadPoolGetQueueSize":
            suggest = "thread_pool_get_queue_size"
        elif key == "threadPoolGetSize":
            suggest = "thread_pool_get_size"
        elif key == "threadPoolSearchQueueSize":
            suggest = "thread_pool_search_queue_size"
        elif key == "threadPoolSearchSize":
            suggest = "thread_pool_search_size"
        elif key == "threadPoolSearchThrottledQueueSize":
            suggest = "thread_pool_search_throttled_queue_size"
        elif key == "threadPoolSearchThrottledSize":
            suggest = "thread_pool_search_throttled_size"
        elif key == "threadPoolWriteQueueSize":
            suggest = "thread_pool_write_queue_size"
        elif key == "threadPoolWriteSize":
            suggest = "thread_pool_write_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearchUserConfigOpensearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearchUserConfigOpensearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearchUserConfigOpensearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_auto_create_index_enabled: Optional[str] = None,
                 action_destructive_requires_name: Optional[str] = None,
                 cluster_max_shards_per_node: Optional[str] = None,
                 cluster_routing_allocation_node_concurrent_recoveries: Optional[str] = None,
                 http_max_content_length: Optional[str] = None,
                 http_max_header_size: Optional[str] = None,
                 http_max_initial_line_length: Optional[str] = None,
                 indices_fielddata_cache_size: Optional[str] = None,
                 indices_memory_index_buffer_size: Optional[str] = None,
                 indices_queries_cache_size: Optional[str] = None,
                 indices_query_bool_max_clause_count: Optional[str] = None,
                 indices_recovery_max_bytes_per_sec: Optional[str] = None,
                 indices_recovery_max_concurrent_file_chunks: Optional[str] = None,
                 override_main_response_version: Optional[str] = None,
                 reindex_remote_whitelists: Optional[Sequence[str]] = None,
                 script_max_compilations_rate: Optional[str] = None,
                 search_max_buckets: Optional[str] = None,
                 thread_pool_analyze_queue_size: Optional[str] = None,
                 thread_pool_analyze_size: Optional[str] = None,
                 thread_pool_force_merge_size: Optional[str] = None,
                 thread_pool_get_queue_size: Optional[str] = None,
                 thread_pool_get_size: Optional[str] = None,
                 thread_pool_search_queue_size: Optional[str] = None,
                 thread_pool_search_size: Optional[str] = None,
                 thread_pool_search_throttled_queue_size: Optional[str] = None,
                 thread_pool_search_throttled_size: Optional[str] = None,
                 thread_pool_write_queue_size: Optional[str] = None,
                 thread_pool_write_size: Optional[str] = None):
        if action_auto_create_index_enabled is not None:
            pulumi.set(__self__, "action_auto_create_index_enabled", action_auto_create_index_enabled)
        if action_destructive_requires_name is not None:
            pulumi.set(__self__, "action_destructive_requires_name", action_destructive_requires_name)
        if cluster_max_shards_per_node is not None:
            pulumi.set(__self__, "cluster_max_shards_per_node", cluster_max_shards_per_node)
        if cluster_routing_allocation_node_concurrent_recoveries is not None:
            pulumi.set(__self__, "cluster_routing_allocation_node_concurrent_recoveries", cluster_routing_allocation_node_concurrent_recoveries)
        if http_max_content_length is not None:
            pulumi.set(__self__, "http_max_content_length", http_max_content_length)
        if http_max_header_size is not None:
            pulumi.set(__self__, "http_max_header_size", http_max_header_size)
        if http_max_initial_line_length is not None:
            pulumi.set(__self__, "http_max_initial_line_length", http_max_initial_line_length)
        if indices_fielddata_cache_size is not None:
            pulumi.set(__self__, "indices_fielddata_cache_size", indices_fielddata_cache_size)
        if indices_memory_index_buffer_size is not None:
            pulumi.set(__self__, "indices_memory_index_buffer_size", indices_memory_index_buffer_size)
        if indices_queries_cache_size is not None:
            pulumi.set(__self__, "indices_queries_cache_size", indices_queries_cache_size)
        if indices_query_bool_max_clause_count is not None:
            pulumi.set(__self__, "indices_query_bool_max_clause_count", indices_query_bool_max_clause_count)
        if indices_recovery_max_bytes_per_sec is not None:
            pulumi.set(__self__, "indices_recovery_max_bytes_per_sec", indices_recovery_max_bytes_per_sec)
        if indices_recovery_max_concurrent_file_chunks is not None:
            pulumi.set(__self__, "indices_recovery_max_concurrent_file_chunks", indices_recovery_max_concurrent_file_chunks)
        if override_main_response_version is not None:
            pulumi.set(__self__, "override_main_response_version", override_main_response_version)
        if reindex_remote_whitelists is not None:
            pulumi.set(__self__, "reindex_remote_whitelists", reindex_remote_whitelists)
        if script_max_compilations_rate is not None:
            pulumi.set(__self__, "script_max_compilations_rate", script_max_compilations_rate)
        if search_max_buckets is not None:
            pulumi.set(__self__, "search_max_buckets", search_max_buckets)
        if thread_pool_analyze_queue_size is not None:
            pulumi.set(__self__, "thread_pool_analyze_queue_size", thread_pool_analyze_queue_size)
        if thread_pool_analyze_size is not None:
            pulumi.set(__self__, "thread_pool_analyze_size", thread_pool_analyze_size)
        if thread_pool_force_merge_size is not None:
            pulumi.set(__self__, "thread_pool_force_merge_size", thread_pool_force_merge_size)
        if thread_pool_get_queue_size is not None:
            pulumi.set(__self__, "thread_pool_get_queue_size", thread_pool_get_queue_size)
        if thread_pool_get_size is not None:
            pulumi.set(__self__, "thread_pool_get_size", thread_pool_get_size)
        if thread_pool_search_queue_size is not None:
            pulumi.set(__self__, "thread_pool_search_queue_size", thread_pool_search_queue_size)
        if thread_pool_search_size is not None:
            pulumi.set(__self__, "thread_pool_search_size", thread_pool_search_size)
        if thread_pool_search_throttled_queue_size is not None:
            pulumi.set(__self__, "thread_pool_search_throttled_queue_size", thread_pool_search_throttled_queue_size)
        if thread_pool_search_throttled_size is not None:
            pulumi.set(__self__, "thread_pool_search_throttled_size", thread_pool_search_throttled_size)
        if thread_pool_write_queue_size is not None:
            pulumi.set(__self__, "thread_pool_write_queue_size", thread_pool_write_queue_size)
        if thread_pool_write_size is not None:
            pulumi.set(__self__, "thread_pool_write_size", thread_pool_write_size)

    @property
    @pulumi.getter(name="actionAutoCreateIndexEnabled")
    def action_auto_create_index_enabled(self) -> Optional[str]:
        return pulumi.get(self, "action_auto_create_index_enabled")

    @property
    @pulumi.getter(name="actionDestructiveRequiresName")
    def action_destructive_requires_name(self) -> Optional[str]:
        return pulumi.get(self, "action_destructive_requires_name")

    @property
    @pulumi.getter(name="clusterMaxShardsPerNode")
    def cluster_max_shards_per_node(self) -> Optional[str]:
        return pulumi.get(self, "cluster_max_shards_per_node")

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeConcurrentRecoveries")
    def cluster_routing_allocation_node_concurrent_recoveries(self) -> Optional[str]:
        return pulumi.get(self, "cluster_routing_allocation_node_concurrent_recoveries")

    @property
    @pulumi.getter(name="httpMaxContentLength")
    def http_max_content_length(self) -> Optional[str]:
        return pulumi.get(self, "http_max_content_length")

    @property
    @pulumi.getter(name="httpMaxHeaderSize")
    def http_max_header_size(self) -> Optional[str]:
        return pulumi.get(self, "http_max_header_size")

    @property
    @pulumi.getter(name="httpMaxInitialLineLength")
    def http_max_initial_line_length(self) -> Optional[str]:
        return pulumi.get(self, "http_max_initial_line_length")

    @property
    @pulumi.getter(name="indicesFielddataCacheSize")
    def indices_fielddata_cache_size(self) -> Optional[str]:
        return pulumi.get(self, "indices_fielddata_cache_size")

    @property
    @pulumi.getter(name="indicesMemoryIndexBufferSize")
    def indices_memory_index_buffer_size(self) -> Optional[str]:
        return pulumi.get(self, "indices_memory_index_buffer_size")

    @property
    @pulumi.getter(name="indicesQueriesCacheSize")
    def indices_queries_cache_size(self) -> Optional[str]:
        return pulumi.get(self, "indices_queries_cache_size")

    @property
    @pulumi.getter(name="indicesQueryBoolMaxClauseCount")
    def indices_query_bool_max_clause_count(self) -> Optional[str]:
        return pulumi.get(self, "indices_query_bool_max_clause_count")

    @property
    @pulumi.getter(name="indicesRecoveryMaxBytesPerSec")
    def indices_recovery_max_bytes_per_sec(self) -> Optional[str]:
        return pulumi.get(self, "indices_recovery_max_bytes_per_sec")

    @property
    @pulumi.getter(name="indicesRecoveryMaxConcurrentFileChunks")
    def indices_recovery_max_concurrent_file_chunks(self) -> Optional[str]:
        return pulumi.get(self, "indices_recovery_max_concurrent_file_chunks")

    @property
    @pulumi.getter(name="overrideMainResponseVersion")
    def override_main_response_version(self) -> Optional[str]:
        return pulumi.get(self, "override_main_response_version")

    @property
    @pulumi.getter(name="reindexRemoteWhitelists")
    def reindex_remote_whitelists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "reindex_remote_whitelists")

    @property
    @pulumi.getter(name="scriptMaxCompilationsRate")
    def script_max_compilations_rate(self) -> Optional[str]:
        return pulumi.get(self, "script_max_compilations_rate")

    @property
    @pulumi.getter(name="searchMaxBuckets")
    def search_max_buckets(self) -> Optional[str]:
        return pulumi.get(self, "search_max_buckets")

    @property
    @pulumi.getter(name="threadPoolAnalyzeQueueSize")
    def thread_pool_analyze_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_analyze_queue_size")

    @property
    @pulumi.getter(name="threadPoolAnalyzeSize")
    def thread_pool_analyze_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_analyze_size")

    @property
    @pulumi.getter(name="threadPoolForceMergeSize")
    def thread_pool_force_merge_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_force_merge_size")

    @property
    @pulumi.getter(name="threadPoolGetQueueSize")
    def thread_pool_get_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_get_queue_size")

    @property
    @pulumi.getter(name="threadPoolGetSize")
    def thread_pool_get_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_get_size")

    @property
    @pulumi.getter(name="threadPoolSearchQueueSize")
    def thread_pool_search_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_search_queue_size")

    @property
    @pulumi.getter(name="threadPoolSearchSize")
    def thread_pool_search_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_search_size")

    @property
    @pulumi.getter(name="threadPoolSearchThrottledQueueSize")
    def thread_pool_search_throttled_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_search_throttled_queue_size")

    @property
    @pulumi.getter(name="threadPoolSearchThrottledSize")
    def thread_pool_search_throttled_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_search_throttled_size")

    @property
    @pulumi.getter(name="threadPoolWriteQueueSize")
    def thread_pool_write_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_write_queue_size")

    @property
    @pulumi.getter(name="threadPoolWriteSize")
    def thread_pool_write_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_write_size")


@pulumi.output_type
class OpenSearchOpensearchUserConfigOpensearchDashboards(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxOldSpaceSize":
            suggest = "max_old_space_size"
        elif key == "opensearchRequestTimeout":
            suggest = "opensearch_request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearchUserConfigOpensearchDashboards. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearchUserConfigOpensearchDashboards.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearchUserConfigOpensearchDashboards.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[str] = None,
                 max_old_space_size: Optional[str] = None,
                 opensearch_request_timeout: Optional[str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_old_space_size is not None:
            pulumi.set(__self__, "max_old_space_size", max_old_space_size)
        if opensearch_request_timeout is not None:
            pulumi.set(__self__, "opensearch_request_timeout", opensearch_request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[str]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[str]:
        return pulumi.get(self, "max_old_space_size")

    @property
    @pulumi.getter(name="opensearchRequestTimeout")
    def opensearch_request_timeout(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_request_timeout")


@pulumi.output_type
class OpenSearchOpensearchUserConfigPrivateAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "opensearchDashboards":
            suggest = "opensearch_dashboards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearchUserConfigPrivateAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearchUserConfigPrivateAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearchUserConfigPrivateAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 opensearch: Optional[str] = None,
                 opensearch_dashboards: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if opensearch is not None:
            pulumi.set(__self__, "opensearch", opensearch)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def opensearch(self) -> Optional[str]:
        return pulumi.get(self, "opensearch")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class OpenSearchOpensearchUserConfigPrivatelinkAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "opensearchDashboards":
            suggest = "opensearch_dashboards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearchUserConfigPrivatelinkAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearchUserConfigPrivatelinkAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearchUserConfigPrivatelinkAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 opensearch: Optional[str] = None,
                 opensearch_dashboards: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if opensearch is not None:
            pulumi.set(__self__, "opensearch", opensearch)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def opensearch(self) -> Optional[str]:
        return pulumi.get(self, "opensearch")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class OpenSearchOpensearchUserConfigPublicAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "opensearchDashboards":
            suggest = "opensearch_dashboards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchOpensearchUserConfigPublicAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchOpensearchUserConfigPublicAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchOpensearchUserConfigPublicAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 opensearch: Optional[str] = None,
                 opensearch_dashboards: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if opensearch is not None:
            pulumi.set(__self__, "opensearch", opensearch)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def opensearch(self) -> Optional[str]:
        return pulumi.get(self, "opensearch")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class OpenSearchServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class OpenSearchTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class PgComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class PgPg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicaUri":
            suggest = "replica_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgPg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgPg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgPg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 replica_uri: Optional[str] = None,
                 sslmode: Optional[str] = None,
                 uri: Optional[str] = None,
                 user: Optional[str] = None):
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if replica_uri is not None:
            pulumi.set(__self__, "replica_uri", replica_uri)
        if sslmode is not None:
            pulumi.set(__self__, "sslmode", sslmode)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="replicaUri")
    def replica_uri(self) -> Optional[str]:
        return pulumi.get(self, "replica_uri")

    @property
    @pulumi.getter
    def sslmode(self) -> Optional[str]:
        return pulumi.get(self, "sslmode")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class PgPgUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupHour":
            suggest = "backup_hour"
        elif key == "backupMinute":
            suggest = "backup_minute"
        elif key == "enableIpv6":
            suggest = "enable_ipv6"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "pgReadReplica":
            suggest = "pg_read_replica"
        elif key == "pgServiceToForkFrom":
            suggest = "pg_service_to_fork_from"
        elif key == "pgVersion":
            suggest = "pg_version"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "recoveryTargetTime":
            suggest = "recovery_target_time"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"
        elif key == "sharedBuffersPercentage":
            suggest = "shared_buffers_percentage"
        elif key == "staticIps":
            suggest = "static_ips"
        elif key == "synchronousReplication":
            suggest = "synchronous_replication"
        elif key == "workMem":
            suggest = "work_mem"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgPgUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgPgUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgPgUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_hour: Optional[str] = None,
                 backup_minute: Optional[str] = None,
                 enable_ipv6: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 migration: Optional['outputs.PgPgUserConfigMigration'] = None,
                 pg: Optional['outputs.PgPgUserConfigPg'] = None,
                 pg_read_replica: Optional[str] = None,
                 pg_service_to_fork_from: Optional[str] = None,
                 pg_version: Optional[str] = None,
                 pgbouncer: Optional['outputs.PgPgUserConfigPgbouncer'] = None,
                 pglookout: Optional['outputs.PgPgUserConfigPglookout'] = None,
                 private_access: Optional['outputs.PgPgUserConfigPrivateAccess'] = None,
                 privatelink_access: Optional['outputs.PgPgUserConfigPrivatelinkAccess'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.PgPgUserConfigPublicAccess'] = None,
                 recovery_target_time: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 shared_buffers_percentage: Optional[str] = None,
                 static_ips: Optional[str] = None,
                 synchronous_replication: Optional[str] = None,
                 timescaledb: Optional['outputs.PgPgUserConfigTimescaledb'] = None,
                 variant: Optional[str] = None,
                 work_mem: Optional[str] = None):
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if enable_ipv6 is not None:
            pulumi.set(__self__, "enable_ipv6", enable_ipv6)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if pg_read_replica is not None:
            pulumi.set(__self__, "pg_read_replica", pg_read_replica)
        if pg_service_to_fork_from is not None:
            pulumi.set(__self__, "pg_service_to_fork_from", pg_service_to_fork_from)
        if pg_version is not None:
            pulumi.set(__self__, "pg_version", pg_version)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if pglookout is not None:
            pulumi.set(__self__, "pglookout", pglookout)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_target_time is not None:
            pulumi.set(__self__, "recovery_target_time", recovery_target_time)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if shared_buffers_percentage is not None:
            pulumi.set(__self__, "shared_buffers_percentage", shared_buffers_percentage)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)
        if synchronous_replication is not None:
            pulumi.set(__self__, "synchronous_replication", synchronous_replication)
        if timescaledb is not None:
            pulumi.set(__self__, "timescaledb", timescaledb)
        if variant is not None:
            pulumi.set(__self__, "variant", variant)
        if work_mem is not None:
            pulumi.set(__self__, "work_mem", work_mem)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[str]:
        return pulumi.get(self, "backup_hour")

    @property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[str]:
        return pulumi.get(self, "backup_minute")

    @property
    @pulumi.getter(name="enableIpv6")
    def enable_ipv6(self) -> Optional[str]:
        return pulumi.get(self, "enable_ipv6")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def migration(self) -> Optional['outputs.PgPgUserConfigMigration']:
        return pulumi.get(self, "migration")

    @property
    @pulumi.getter
    def pg(self) -> Optional['outputs.PgPgUserConfigPg']:
        return pulumi.get(self, "pg")

    @property
    @pulumi.getter(name="pgReadReplica")
    def pg_read_replica(self) -> Optional[str]:
        return pulumi.get(self, "pg_read_replica")

    @property
    @pulumi.getter(name="pgServiceToForkFrom")
    def pg_service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "pg_service_to_fork_from")

    @property
    @pulumi.getter(name="pgVersion")
    def pg_version(self) -> Optional[str]:
        return pulumi.get(self, "pg_version")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional['outputs.PgPgUserConfigPgbouncer']:
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def pglookout(self) -> Optional['outputs.PgPgUserConfigPglookout']:
        return pulumi.get(self, "pglookout")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.PgPgUserConfigPrivateAccess']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.PgPgUserConfigPrivatelinkAccess']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.PgPgUserConfigPublicAccess']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryTargetTime")
    def recovery_target_time(self) -> Optional[str]:
        return pulumi.get(self, "recovery_target_time")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="sharedBuffersPercentage")
    def shared_buffers_percentage(self) -> Optional[str]:
        return pulumi.get(self, "shared_buffers_percentage")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")

    @property
    @pulumi.getter(name="synchronousReplication")
    def synchronous_replication(self) -> Optional[str]:
        return pulumi.get(self, "synchronous_replication")

    @property
    @pulumi.getter
    def timescaledb(self) -> Optional['outputs.PgPgUserConfigTimescaledb']:
        return pulumi.get(self, "timescaledb")

    @property
    @pulumi.getter
    def variant(self) -> Optional[str]:
        return pulumi.get(self, "variant")

    @property
    @pulumi.getter(name="workMem")
    def work_mem(self) -> Optional[str]:
        return pulumi.get(self, "work_mem")


@pulumi.output_type
class PgPgUserConfigMigration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreDbs":
            suggest = "ignore_dbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgPgUserConfigMigration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgPgUserConfigMigration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgPgUserConfigMigration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 ignore_dbs: Optional[str] = None,
                 method: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 ssl: Optional[str] = None,
                 username: Optional[str] = None):
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[str]:
        return pulumi.get(self, "ignore_dbs")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class PgPgUserConfigPg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autovacuumAnalyzeScaleFactor":
            suggest = "autovacuum_analyze_scale_factor"
        elif key == "autovacuumAnalyzeThreshold":
            suggest = "autovacuum_analyze_threshold"
        elif key == "autovacuumFreezeMaxAge":
            suggest = "autovacuum_freeze_max_age"
        elif key == "autovacuumMaxWorkers":
            suggest = "autovacuum_max_workers"
        elif key == "autovacuumNaptime":
            suggest = "autovacuum_naptime"
        elif key == "autovacuumVacuumCostDelay":
            suggest = "autovacuum_vacuum_cost_delay"
        elif key == "autovacuumVacuumCostLimit":
            suggest = "autovacuum_vacuum_cost_limit"
        elif key == "autovacuumVacuumScaleFactor":
            suggest = "autovacuum_vacuum_scale_factor"
        elif key == "autovacuumVacuumThreshold":
            suggest = "autovacuum_vacuum_threshold"
        elif key == "bgwriterDelay":
            suggest = "bgwriter_delay"
        elif key == "bgwriterFlushAfter":
            suggest = "bgwriter_flush_after"
        elif key == "bgwriterLruMaxpages":
            suggest = "bgwriter_lru_maxpages"
        elif key == "bgwriterLruMultiplier":
            suggest = "bgwriter_lru_multiplier"
        elif key == "deadlockTimeout":
            suggest = "deadlock_timeout"
        elif key == "defaultToastCompression":
            suggest = "default_toast_compression"
        elif key == "idleInTransactionSessionTimeout":
            suggest = "idle_in_transaction_session_timeout"
        elif key == "logAutovacuumMinDuration":
            suggest = "log_autovacuum_min_duration"
        elif key == "logErrorVerbosity":
            suggest = "log_error_verbosity"
        elif key == "logLinePrefix":
            suggest = "log_line_prefix"
        elif key == "logMinDurationStatement":
            suggest = "log_min_duration_statement"
        elif key == "maxFilesPerProcess":
            suggest = "max_files_per_process"
        elif key == "maxLocksPerTransaction":
            suggest = "max_locks_per_transaction"
        elif key == "maxLogicalReplicationWorkers":
            suggest = "max_logical_replication_workers"
        elif key == "maxParallelWorkers":
            suggest = "max_parallel_workers"
        elif key == "maxParallelWorkersPerGather":
            suggest = "max_parallel_workers_per_gather"
        elif key == "maxPredLocksPerTransaction":
            suggest = "max_pred_locks_per_transaction"
        elif key == "maxPreparedTransactions":
            suggest = "max_prepared_transactions"
        elif key == "maxReplicationSlots":
            suggest = "max_replication_slots"
        elif key == "maxSlotWalKeepSize":
            suggest = "max_slot_wal_keep_size"
        elif key == "maxStackDepth":
            suggest = "max_stack_depth"
        elif key == "maxStandbyArchiveDelay":
            suggest = "max_standby_archive_delay"
        elif key == "maxStandbyStreamingDelay":
            suggest = "max_standby_streaming_delay"
        elif key == "maxWalSenders":
            suggest = "max_wal_senders"
        elif key == "maxWorkerProcesses":
            suggest = "max_worker_processes"
        elif key == "pgPartmanBgwDotInterval":
            suggest = "pg_partman_bgw_dot_interval"
        elif key == "pgPartmanBgwDotRole":
            suggest = "pg_partman_bgw_dot_role"
        elif key == "pgStatStatementsDotTrack":
            suggest = "pg_stat_statements_dot_track"
        elif key == "tempFileLimit":
            suggest = "temp_file_limit"
        elif key == "trackActivityQuerySize":
            suggest = "track_activity_query_size"
        elif key == "trackCommitTimestamp":
            suggest = "track_commit_timestamp"
        elif key == "trackFunctions":
            suggest = "track_functions"
        elif key == "trackIoTiming":
            suggest = "track_io_timing"
        elif key == "walSenderTimeout":
            suggest = "wal_sender_timeout"
        elif key == "walWriterDelay":
            suggest = "wal_writer_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgPgUserConfigPg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgPgUserConfigPg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgPgUserConfigPg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autovacuum_analyze_scale_factor: Optional[str] = None,
                 autovacuum_analyze_threshold: Optional[str] = None,
                 autovacuum_freeze_max_age: Optional[str] = None,
                 autovacuum_max_workers: Optional[str] = None,
                 autovacuum_naptime: Optional[str] = None,
                 autovacuum_vacuum_cost_delay: Optional[str] = None,
                 autovacuum_vacuum_cost_limit: Optional[str] = None,
                 autovacuum_vacuum_scale_factor: Optional[str] = None,
                 autovacuum_vacuum_threshold: Optional[str] = None,
                 bgwriter_delay: Optional[str] = None,
                 bgwriter_flush_after: Optional[str] = None,
                 bgwriter_lru_maxpages: Optional[str] = None,
                 bgwriter_lru_multiplier: Optional[str] = None,
                 deadlock_timeout: Optional[str] = None,
                 default_toast_compression: Optional[str] = None,
                 idle_in_transaction_session_timeout: Optional[str] = None,
                 jit: Optional[str] = None,
                 log_autovacuum_min_duration: Optional[str] = None,
                 log_error_verbosity: Optional[str] = None,
                 log_line_prefix: Optional[str] = None,
                 log_min_duration_statement: Optional[str] = None,
                 max_files_per_process: Optional[str] = None,
                 max_locks_per_transaction: Optional[str] = None,
                 max_logical_replication_workers: Optional[str] = None,
                 max_parallel_workers: Optional[str] = None,
                 max_parallel_workers_per_gather: Optional[str] = None,
                 max_pred_locks_per_transaction: Optional[str] = None,
                 max_prepared_transactions: Optional[str] = None,
                 max_replication_slots: Optional[str] = None,
                 max_slot_wal_keep_size: Optional[str] = None,
                 max_stack_depth: Optional[str] = None,
                 max_standby_archive_delay: Optional[str] = None,
                 max_standby_streaming_delay: Optional[str] = None,
                 max_wal_senders: Optional[str] = None,
                 max_worker_processes: Optional[str] = None,
                 pg_partman_bgw_dot_interval: Optional[str] = None,
                 pg_partman_bgw_dot_role: Optional[str] = None,
                 pg_stat_statements_dot_track: Optional[str] = None,
                 temp_file_limit: Optional[str] = None,
                 timezone: Optional[str] = None,
                 track_activity_query_size: Optional[str] = None,
                 track_commit_timestamp: Optional[str] = None,
                 track_functions: Optional[str] = None,
                 track_io_timing: Optional[str] = None,
                 wal_sender_timeout: Optional[str] = None,
                 wal_writer_delay: Optional[str] = None):
        if autovacuum_analyze_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_analyze_scale_factor", autovacuum_analyze_scale_factor)
        if autovacuum_analyze_threshold is not None:
            pulumi.set(__self__, "autovacuum_analyze_threshold", autovacuum_analyze_threshold)
        if autovacuum_freeze_max_age is not None:
            pulumi.set(__self__, "autovacuum_freeze_max_age", autovacuum_freeze_max_age)
        if autovacuum_max_workers is not None:
            pulumi.set(__self__, "autovacuum_max_workers", autovacuum_max_workers)
        if autovacuum_naptime is not None:
            pulumi.set(__self__, "autovacuum_naptime", autovacuum_naptime)
        if autovacuum_vacuum_cost_delay is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_delay", autovacuum_vacuum_cost_delay)
        if autovacuum_vacuum_cost_limit is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_limit", autovacuum_vacuum_cost_limit)
        if autovacuum_vacuum_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_vacuum_scale_factor", autovacuum_vacuum_scale_factor)
        if autovacuum_vacuum_threshold is not None:
            pulumi.set(__self__, "autovacuum_vacuum_threshold", autovacuum_vacuum_threshold)
        if bgwriter_delay is not None:
            pulumi.set(__self__, "bgwriter_delay", bgwriter_delay)
        if bgwriter_flush_after is not None:
            pulumi.set(__self__, "bgwriter_flush_after", bgwriter_flush_after)
        if bgwriter_lru_maxpages is not None:
            pulumi.set(__self__, "bgwriter_lru_maxpages", bgwriter_lru_maxpages)
        if bgwriter_lru_multiplier is not None:
            pulumi.set(__self__, "bgwriter_lru_multiplier", bgwriter_lru_multiplier)
        if deadlock_timeout is not None:
            pulumi.set(__self__, "deadlock_timeout", deadlock_timeout)
        if default_toast_compression is not None:
            pulumi.set(__self__, "default_toast_compression", default_toast_compression)
        if idle_in_transaction_session_timeout is not None:
            pulumi.set(__self__, "idle_in_transaction_session_timeout", idle_in_transaction_session_timeout)
        if jit is not None:
            pulumi.set(__self__, "jit", jit)
        if log_autovacuum_min_duration is not None:
            pulumi.set(__self__, "log_autovacuum_min_duration", log_autovacuum_min_duration)
        if log_error_verbosity is not None:
            pulumi.set(__self__, "log_error_verbosity", log_error_verbosity)
        if log_line_prefix is not None:
            pulumi.set(__self__, "log_line_prefix", log_line_prefix)
        if log_min_duration_statement is not None:
            pulumi.set(__self__, "log_min_duration_statement", log_min_duration_statement)
        if max_files_per_process is not None:
            pulumi.set(__self__, "max_files_per_process", max_files_per_process)
        if max_locks_per_transaction is not None:
            pulumi.set(__self__, "max_locks_per_transaction", max_locks_per_transaction)
        if max_logical_replication_workers is not None:
            pulumi.set(__self__, "max_logical_replication_workers", max_logical_replication_workers)
        if max_parallel_workers is not None:
            pulumi.set(__self__, "max_parallel_workers", max_parallel_workers)
        if max_parallel_workers_per_gather is not None:
            pulumi.set(__self__, "max_parallel_workers_per_gather", max_parallel_workers_per_gather)
        if max_pred_locks_per_transaction is not None:
            pulumi.set(__self__, "max_pred_locks_per_transaction", max_pred_locks_per_transaction)
        if max_prepared_transactions is not None:
            pulumi.set(__self__, "max_prepared_transactions", max_prepared_transactions)
        if max_replication_slots is not None:
            pulumi.set(__self__, "max_replication_slots", max_replication_slots)
        if max_slot_wal_keep_size is not None:
            pulumi.set(__self__, "max_slot_wal_keep_size", max_slot_wal_keep_size)
        if max_stack_depth is not None:
            pulumi.set(__self__, "max_stack_depth", max_stack_depth)
        if max_standby_archive_delay is not None:
            pulumi.set(__self__, "max_standby_archive_delay", max_standby_archive_delay)
        if max_standby_streaming_delay is not None:
            pulumi.set(__self__, "max_standby_streaming_delay", max_standby_streaming_delay)
        if max_wal_senders is not None:
            pulumi.set(__self__, "max_wal_senders", max_wal_senders)
        if max_worker_processes is not None:
            pulumi.set(__self__, "max_worker_processes", max_worker_processes)
        if pg_partman_bgw_dot_interval is not None:
            pulumi.set(__self__, "pg_partman_bgw_dot_interval", pg_partman_bgw_dot_interval)
        if pg_partman_bgw_dot_role is not None:
            pulumi.set(__self__, "pg_partman_bgw_dot_role", pg_partman_bgw_dot_role)
        if pg_stat_statements_dot_track is not None:
            pulumi.set(__self__, "pg_stat_statements_dot_track", pg_stat_statements_dot_track)
        if temp_file_limit is not None:
            pulumi.set(__self__, "temp_file_limit", temp_file_limit)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if track_activity_query_size is not None:
            pulumi.set(__self__, "track_activity_query_size", track_activity_query_size)
        if track_commit_timestamp is not None:
            pulumi.set(__self__, "track_commit_timestamp", track_commit_timestamp)
        if track_functions is not None:
            pulumi.set(__self__, "track_functions", track_functions)
        if track_io_timing is not None:
            pulumi.set(__self__, "track_io_timing", track_io_timing)
        if wal_sender_timeout is not None:
            pulumi.set(__self__, "wal_sender_timeout", wal_sender_timeout)
        if wal_writer_delay is not None:
            pulumi.set(__self__, "wal_writer_delay", wal_writer_delay)

    @property
    @pulumi.getter(name="autovacuumAnalyzeScaleFactor")
    def autovacuum_analyze_scale_factor(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_analyze_scale_factor")

    @property
    @pulumi.getter(name="autovacuumAnalyzeThreshold")
    def autovacuum_analyze_threshold(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_analyze_threshold")

    @property
    @pulumi.getter(name="autovacuumFreezeMaxAge")
    def autovacuum_freeze_max_age(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_freeze_max_age")

    @property
    @pulumi.getter(name="autovacuumMaxWorkers")
    def autovacuum_max_workers(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_max_workers")

    @property
    @pulumi.getter(name="autovacuumNaptime")
    def autovacuum_naptime(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_naptime")

    @property
    @pulumi.getter(name="autovacuumVacuumCostDelay")
    def autovacuum_vacuum_cost_delay(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_vacuum_cost_delay")

    @property
    @pulumi.getter(name="autovacuumVacuumCostLimit")
    def autovacuum_vacuum_cost_limit(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_vacuum_cost_limit")

    @property
    @pulumi.getter(name="autovacuumVacuumScaleFactor")
    def autovacuum_vacuum_scale_factor(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_vacuum_scale_factor")

    @property
    @pulumi.getter(name="autovacuumVacuumThreshold")
    def autovacuum_vacuum_threshold(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_vacuum_threshold")

    @property
    @pulumi.getter(name="bgwriterDelay")
    def bgwriter_delay(self) -> Optional[str]:
        return pulumi.get(self, "bgwriter_delay")

    @property
    @pulumi.getter(name="bgwriterFlushAfter")
    def bgwriter_flush_after(self) -> Optional[str]:
        return pulumi.get(self, "bgwriter_flush_after")

    @property
    @pulumi.getter(name="bgwriterLruMaxpages")
    def bgwriter_lru_maxpages(self) -> Optional[str]:
        return pulumi.get(self, "bgwriter_lru_maxpages")

    @property
    @pulumi.getter(name="bgwriterLruMultiplier")
    def bgwriter_lru_multiplier(self) -> Optional[str]:
        return pulumi.get(self, "bgwriter_lru_multiplier")

    @property
    @pulumi.getter(name="deadlockTimeout")
    def deadlock_timeout(self) -> Optional[str]:
        return pulumi.get(self, "deadlock_timeout")

    @property
    @pulumi.getter(name="defaultToastCompression")
    def default_toast_compression(self) -> Optional[str]:
        return pulumi.get(self, "default_toast_compression")

    @property
    @pulumi.getter(name="idleInTransactionSessionTimeout")
    def idle_in_transaction_session_timeout(self) -> Optional[str]:
        return pulumi.get(self, "idle_in_transaction_session_timeout")

    @property
    @pulumi.getter
    def jit(self) -> Optional[str]:
        return pulumi.get(self, "jit")

    @property
    @pulumi.getter(name="logAutovacuumMinDuration")
    def log_autovacuum_min_duration(self) -> Optional[str]:
        return pulumi.get(self, "log_autovacuum_min_duration")

    @property
    @pulumi.getter(name="logErrorVerbosity")
    def log_error_verbosity(self) -> Optional[str]:
        return pulumi.get(self, "log_error_verbosity")

    @property
    @pulumi.getter(name="logLinePrefix")
    def log_line_prefix(self) -> Optional[str]:
        return pulumi.get(self, "log_line_prefix")

    @property
    @pulumi.getter(name="logMinDurationStatement")
    def log_min_duration_statement(self) -> Optional[str]:
        return pulumi.get(self, "log_min_duration_statement")

    @property
    @pulumi.getter(name="maxFilesPerProcess")
    def max_files_per_process(self) -> Optional[str]:
        return pulumi.get(self, "max_files_per_process")

    @property
    @pulumi.getter(name="maxLocksPerTransaction")
    def max_locks_per_transaction(self) -> Optional[str]:
        return pulumi.get(self, "max_locks_per_transaction")

    @property
    @pulumi.getter(name="maxLogicalReplicationWorkers")
    def max_logical_replication_workers(self) -> Optional[str]:
        return pulumi.get(self, "max_logical_replication_workers")

    @property
    @pulumi.getter(name="maxParallelWorkers")
    def max_parallel_workers(self) -> Optional[str]:
        return pulumi.get(self, "max_parallel_workers")

    @property
    @pulumi.getter(name="maxParallelWorkersPerGather")
    def max_parallel_workers_per_gather(self) -> Optional[str]:
        return pulumi.get(self, "max_parallel_workers_per_gather")

    @property
    @pulumi.getter(name="maxPredLocksPerTransaction")
    def max_pred_locks_per_transaction(self) -> Optional[str]:
        return pulumi.get(self, "max_pred_locks_per_transaction")

    @property
    @pulumi.getter(name="maxPreparedTransactions")
    def max_prepared_transactions(self) -> Optional[str]:
        return pulumi.get(self, "max_prepared_transactions")

    @property
    @pulumi.getter(name="maxReplicationSlots")
    def max_replication_slots(self) -> Optional[str]:
        return pulumi.get(self, "max_replication_slots")

    @property
    @pulumi.getter(name="maxSlotWalKeepSize")
    def max_slot_wal_keep_size(self) -> Optional[str]:
        return pulumi.get(self, "max_slot_wal_keep_size")

    @property
    @pulumi.getter(name="maxStackDepth")
    def max_stack_depth(self) -> Optional[str]:
        return pulumi.get(self, "max_stack_depth")

    @property
    @pulumi.getter(name="maxStandbyArchiveDelay")
    def max_standby_archive_delay(self) -> Optional[str]:
        return pulumi.get(self, "max_standby_archive_delay")

    @property
    @pulumi.getter(name="maxStandbyStreamingDelay")
    def max_standby_streaming_delay(self) -> Optional[str]:
        return pulumi.get(self, "max_standby_streaming_delay")

    @property
    @pulumi.getter(name="maxWalSenders")
    def max_wal_senders(self) -> Optional[str]:
        return pulumi.get(self, "max_wal_senders")

    @property
    @pulumi.getter(name="maxWorkerProcesses")
    def max_worker_processes(self) -> Optional[str]:
        return pulumi.get(self, "max_worker_processes")

    @property
    @pulumi.getter(name="pgPartmanBgwDotInterval")
    def pg_partman_bgw_dot_interval(self) -> Optional[str]:
        return pulumi.get(self, "pg_partman_bgw_dot_interval")

    @property
    @pulumi.getter(name="pgPartmanBgwDotRole")
    def pg_partman_bgw_dot_role(self) -> Optional[str]:
        return pulumi.get(self, "pg_partman_bgw_dot_role")

    @property
    @pulumi.getter(name="pgStatStatementsDotTrack")
    def pg_stat_statements_dot_track(self) -> Optional[str]:
        return pulumi.get(self, "pg_stat_statements_dot_track")

    @property
    @pulumi.getter(name="tempFileLimit")
    def temp_file_limit(self) -> Optional[str]:
        return pulumi.get(self, "temp_file_limit")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter(name="trackActivityQuerySize")
    def track_activity_query_size(self) -> Optional[str]:
        return pulumi.get(self, "track_activity_query_size")

    @property
    @pulumi.getter(name="trackCommitTimestamp")
    def track_commit_timestamp(self) -> Optional[str]:
        return pulumi.get(self, "track_commit_timestamp")

    @property
    @pulumi.getter(name="trackFunctions")
    def track_functions(self) -> Optional[str]:
        return pulumi.get(self, "track_functions")

    @property
    @pulumi.getter(name="trackIoTiming")
    def track_io_timing(self) -> Optional[str]:
        return pulumi.get(self, "track_io_timing")

    @property
    @pulumi.getter(name="walSenderTimeout")
    def wal_sender_timeout(self) -> Optional[str]:
        return pulumi.get(self, "wal_sender_timeout")

    @property
    @pulumi.getter(name="walWriterDelay")
    def wal_writer_delay(self) -> Optional[str]:
        return pulumi.get(self, "wal_writer_delay")


@pulumi.output_type
class PgPgUserConfigPgbouncer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autodbIdleTimeout":
            suggest = "autodb_idle_timeout"
        elif key == "autodbMaxDbConnections":
            suggest = "autodb_max_db_connections"
        elif key == "autodbPoolMode":
            suggest = "autodb_pool_mode"
        elif key == "autodbPoolSize":
            suggest = "autodb_pool_size"
        elif key == "ignoreStartupParameters":
            suggest = "ignore_startup_parameters"
        elif key == "minPoolSize":
            suggest = "min_pool_size"
        elif key == "serverIdleTimeout":
            suggest = "server_idle_timeout"
        elif key == "serverLifetime":
            suggest = "server_lifetime"
        elif key == "serverResetQueryAlways":
            suggest = "server_reset_query_always"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgPgUserConfigPgbouncer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgPgUserConfigPgbouncer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgPgUserConfigPgbouncer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autodb_idle_timeout: Optional[str] = None,
                 autodb_max_db_connections: Optional[str] = None,
                 autodb_pool_mode: Optional[str] = None,
                 autodb_pool_size: Optional[str] = None,
                 ignore_startup_parameters: Optional[Sequence[str]] = None,
                 min_pool_size: Optional[str] = None,
                 server_idle_timeout: Optional[str] = None,
                 server_lifetime: Optional[str] = None,
                 server_reset_query_always: Optional[str] = None):
        if autodb_idle_timeout is not None:
            pulumi.set(__self__, "autodb_idle_timeout", autodb_idle_timeout)
        if autodb_max_db_connections is not None:
            pulumi.set(__self__, "autodb_max_db_connections", autodb_max_db_connections)
        if autodb_pool_mode is not None:
            pulumi.set(__self__, "autodb_pool_mode", autodb_pool_mode)
        if autodb_pool_size is not None:
            pulumi.set(__self__, "autodb_pool_size", autodb_pool_size)
        if ignore_startup_parameters is not None:
            pulumi.set(__self__, "ignore_startup_parameters", ignore_startup_parameters)
        if min_pool_size is not None:
            pulumi.set(__self__, "min_pool_size", min_pool_size)
        if server_idle_timeout is not None:
            pulumi.set(__self__, "server_idle_timeout", server_idle_timeout)
        if server_lifetime is not None:
            pulumi.set(__self__, "server_lifetime", server_lifetime)
        if server_reset_query_always is not None:
            pulumi.set(__self__, "server_reset_query_always", server_reset_query_always)

    @property
    @pulumi.getter(name="autodbIdleTimeout")
    def autodb_idle_timeout(self) -> Optional[str]:
        return pulumi.get(self, "autodb_idle_timeout")

    @property
    @pulumi.getter(name="autodbMaxDbConnections")
    def autodb_max_db_connections(self) -> Optional[str]:
        return pulumi.get(self, "autodb_max_db_connections")

    @property
    @pulumi.getter(name="autodbPoolMode")
    def autodb_pool_mode(self) -> Optional[str]:
        return pulumi.get(self, "autodb_pool_mode")

    @property
    @pulumi.getter(name="autodbPoolSize")
    def autodb_pool_size(self) -> Optional[str]:
        return pulumi.get(self, "autodb_pool_size")

    @property
    @pulumi.getter(name="ignoreStartupParameters")
    def ignore_startup_parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ignore_startup_parameters")

    @property
    @pulumi.getter(name="minPoolSize")
    def min_pool_size(self) -> Optional[str]:
        return pulumi.get(self, "min_pool_size")

    @property
    @pulumi.getter(name="serverIdleTimeout")
    def server_idle_timeout(self) -> Optional[str]:
        return pulumi.get(self, "server_idle_timeout")

    @property
    @pulumi.getter(name="serverLifetime")
    def server_lifetime(self) -> Optional[str]:
        return pulumi.get(self, "server_lifetime")

    @property
    @pulumi.getter(name="serverResetQueryAlways")
    def server_reset_query_always(self) -> Optional[str]:
        return pulumi.get(self, "server_reset_query_always")


@pulumi.output_type
class PgPgUserConfigPglookout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxFailoverReplicationTimeLag":
            suggest = "max_failover_replication_time_lag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgPgUserConfigPglookout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgPgUserConfigPglookout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgPgUserConfigPglookout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_failover_replication_time_lag: Optional[str] = None):
        if max_failover_replication_time_lag is not None:
            pulumi.set(__self__, "max_failover_replication_time_lag", max_failover_replication_time_lag)

    @property
    @pulumi.getter(name="maxFailoverReplicationTimeLag")
    def max_failover_replication_time_lag(self) -> Optional[str]:
        return pulumi.get(self, "max_failover_replication_time_lag")


@pulumi.output_type
class PgPgUserConfigPrivateAccess(dict):
    def __init__(__self__, *,
                 pg: Optional[str] = None,
                 pgbouncer: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def pg(self) -> Optional[str]:
        return pulumi.get(self, "pg")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional[str]:
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class PgPgUserConfigPrivatelinkAccess(dict):
    def __init__(__self__, *,
                 pg: Optional[str] = None,
                 pgbouncer: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def pg(self) -> Optional[str]:
        return pulumi.get(self, "pg")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional[str]:
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class PgPgUserConfigPublicAccess(dict):
    def __init__(__self__, *,
                 pg: Optional[str] = None,
                 pgbouncer: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def pg(self) -> Optional[str]:
        return pulumi.get(self, "pg")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional[str]:
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class PgPgUserConfigTimescaledb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxBackgroundWorkers":
            suggest = "max_background_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgPgUserConfigTimescaledb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgPgUserConfigTimescaledb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgPgUserConfigTimescaledb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_background_workers: Optional[str] = None):
        if max_background_workers is not None:
            pulumi.set(__self__, "max_background_workers", max_background_workers)

    @property
    @pulumi.getter(name="maxBackgroundWorkers")
    def max_background_workers(self) -> Optional[str]:
        return pulumi.get(self, "max_background_workers")


@pulumi.output_type
class PgServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class PgTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProjectTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class RedisComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAuthenticationMethod":
            suggest = "kafka_authentication_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RedisComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RedisComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RedisComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 kafka_authentication_method: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 usage: Optional[str] = None):
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_authentication_method is not None:
            pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> Optional[str]:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        return pulumi.get(self, "usage")


@pulumi.output_type
class RedisRedi(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RedisRedisUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "privatelinkAccess":
            suggest = "privatelink_access"
        elif key == "projectToForkFrom":
            suggest = "project_to_fork_from"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "recoveryBasebackupName":
            suggest = "recovery_basebackup_name"
        elif key == "redisAclChannelsDefault":
            suggest = "redis_acl_channels_default"
        elif key == "redisIoThreads":
            suggest = "redis_io_threads"
        elif key == "redisLfuDecayTime":
            suggest = "redis_lfu_decay_time"
        elif key == "redisLfuLogFactor":
            suggest = "redis_lfu_log_factor"
        elif key == "redisMaxmemoryPolicy":
            suggest = "redis_maxmemory_policy"
        elif key == "redisNotifyKeyspaceEvents":
            suggest = "redis_notify_keyspace_events"
        elif key == "redisNumberOfDatabases":
            suggest = "redis_number_of_databases"
        elif key == "redisPersistence":
            suggest = "redis_persistence"
        elif key == "redisPubsubClientOutputBufferLimit":
            suggest = "redis_pubsub_client_output_buffer_limit"
        elif key == "redisSsl":
            suggest = "redis_ssl"
        elif key == "redisTimeout":
            suggest = "redis_timeout"
        elif key == "serviceToForkFrom":
            suggest = "service_to_fork_from"
        elif key == "staticIps":
            suggest = "static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RedisRedisUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RedisRedisUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RedisRedisUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 migration: Optional['outputs.RedisRedisUserConfigMigration'] = None,
                 private_access: Optional['outputs.RedisRedisUserConfigPrivateAccess'] = None,
                 privatelink_access: Optional['outputs.RedisRedisUserConfigPrivatelinkAccess'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.RedisRedisUserConfigPublicAccess'] = None,
                 recovery_basebackup_name: Optional[str] = None,
                 redis_acl_channels_default: Optional[str] = None,
                 redis_io_threads: Optional[str] = None,
                 redis_lfu_decay_time: Optional[str] = None,
                 redis_lfu_log_factor: Optional[str] = None,
                 redis_maxmemory_policy: Optional[str] = None,
                 redis_notify_keyspace_events: Optional[str] = None,
                 redis_number_of_databases: Optional[str] = None,
                 redis_persistence: Optional[str] = None,
                 redis_pubsub_client_output_buffer_limit: Optional[str] = None,
                 redis_ssl: Optional[str] = None,
                 redis_timeout: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_basebackup_name is not None:
            pulumi.set(__self__, "recovery_basebackup_name", recovery_basebackup_name)
        if redis_acl_channels_default is not None:
            pulumi.set(__self__, "redis_acl_channels_default", redis_acl_channels_default)
        if redis_io_threads is not None:
            pulumi.set(__self__, "redis_io_threads", redis_io_threads)
        if redis_lfu_decay_time is not None:
            pulumi.set(__self__, "redis_lfu_decay_time", redis_lfu_decay_time)
        if redis_lfu_log_factor is not None:
            pulumi.set(__self__, "redis_lfu_log_factor", redis_lfu_log_factor)
        if redis_maxmemory_policy is not None:
            pulumi.set(__self__, "redis_maxmemory_policy", redis_maxmemory_policy)
        if redis_notify_keyspace_events is not None:
            pulumi.set(__self__, "redis_notify_keyspace_events", redis_notify_keyspace_events)
        if redis_number_of_databases is not None:
            pulumi.set(__self__, "redis_number_of_databases", redis_number_of_databases)
        if redis_persistence is not None:
            pulumi.set(__self__, "redis_persistence", redis_persistence)
        if redis_pubsub_client_output_buffer_limit is not None:
            pulumi.set(__self__, "redis_pubsub_client_output_buffer_limit", redis_pubsub_client_output_buffer_limit)
        if redis_ssl is not None:
            pulumi.set(__self__, "redis_ssl", redis_ssl)
        if redis_timeout is not None:
            pulumi.set(__self__, "redis_timeout", redis_timeout)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def migration(self) -> Optional['outputs.RedisRedisUserConfigMigration']:
        return pulumi.get(self, "migration")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.RedisRedisUserConfigPrivateAccess']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.RedisRedisUserConfigPrivatelinkAccess']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.RedisRedisUserConfigPublicAccess']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryBasebackupName")
    def recovery_basebackup_name(self) -> Optional[str]:
        return pulumi.get(self, "recovery_basebackup_name")

    @property
    @pulumi.getter(name="redisAclChannelsDefault")
    def redis_acl_channels_default(self) -> Optional[str]:
        return pulumi.get(self, "redis_acl_channels_default")

    @property
    @pulumi.getter(name="redisIoThreads")
    def redis_io_threads(self) -> Optional[str]:
        return pulumi.get(self, "redis_io_threads")

    @property
    @pulumi.getter(name="redisLfuDecayTime")
    def redis_lfu_decay_time(self) -> Optional[str]:
        return pulumi.get(self, "redis_lfu_decay_time")

    @property
    @pulumi.getter(name="redisLfuLogFactor")
    def redis_lfu_log_factor(self) -> Optional[str]:
        return pulumi.get(self, "redis_lfu_log_factor")

    @property
    @pulumi.getter(name="redisMaxmemoryPolicy")
    def redis_maxmemory_policy(self) -> Optional[str]:
        return pulumi.get(self, "redis_maxmemory_policy")

    @property
    @pulumi.getter(name="redisNotifyKeyspaceEvents")
    def redis_notify_keyspace_events(self) -> Optional[str]:
        return pulumi.get(self, "redis_notify_keyspace_events")

    @property
    @pulumi.getter(name="redisNumberOfDatabases")
    def redis_number_of_databases(self) -> Optional[str]:
        return pulumi.get(self, "redis_number_of_databases")

    @property
    @pulumi.getter(name="redisPersistence")
    def redis_persistence(self) -> Optional[str]:
        return pulumi.get(self, "redis_persistence")

    @property
    @pulumi.getter(name="redisPubsubClientOutputBufferLimit")
    def redis_pubsub_client_output_buffer_limit(self) -> Optional[str]:
        return pulumi.get(self, "redis_pubsub_client_output_buffer_limit")

    @property
    @pulumi.getter(name="redisSsl")
    def redis_ssl(self) -> Optional[str]:
        return pulumi.get(self, "redis_ssl")

    @property
    @pulumi.getter(name="redisTimeout")
    def redis_timeout(self) -> Optional[str]:
        return pulumi.get(self, "redis_timeout")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class RedisRedisUserConfigMigration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreDbs":
            suggest = "ignore_dbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RedisRedisUserConfigMigration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RedisRedisUserConfigMigration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RedisRedisUserConfigMigration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 ignore_dbs: Optional[str] = None,
                 method: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 ssl: Optional[str] = None,
                 username: Optional[str] = None):
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[str]:
        return pulumi.get(self, "ignore_dbs")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class RedisRedisUserConfigPrivateAccess(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None,
                 redis: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter
    def redis(self) -> Optional[str]:
        return pulumi.get(self, "redis")


@pulumi.output_type
class RedisRedisUserConfigPrivatelinkAccess(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None,
                 redis: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter
    def redis(self) -> Optional[str]:
        return pulumi.get(self, "redis")


@pulumi.output_type
class RedisRedisUserConfigPublicAccess(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None,
                 redis: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter
    def redis(self) -> Optional[str]:
        return pulumi.get(self, "redis")


@pulumi.output_type
class RedisServiceIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "sourceServiceName":
            suggest = "source_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RedisServiceIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RedisServiceIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RedisServiceIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class RedisTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceIntegrationEndpointDatadogUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datadogApiKey":
            suggest = "datadog_api_key"
        elif key == "datadogTags":
            suggest = "datadog_tags"
        elif key == "disableConsumerStats":
            suggest = "disable_consumer_stats"
        elif key == "kafkaConsumerCheckInstances":
            suggest = "kafka_consumer_check_instances"
        elif key == "kafkaConsumerStatsTimeout":
            suggest = "kafka_consumer_stats_timeout"
        elif key == "maxPartitionContexts":
            suggest = "max_partition_contexts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointDatadogUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointDatadogUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointDatadogUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datadog_api_key: Optional[str] = None,
                 datadog_tags: Optional[Sequence['outputs.ServiceIntegrationEndpointDatadogUserConfigDatadogTag']] = None,
                 disable_consumer_stats: Optional[str] = None,
                 kafka_consumer_check_instances: Optional[str] = None,
                 kafka_consumer_stats_timeout: Optional[str] = None,
                 max_partition_contexts: Optional[str] = None,
                 site: Optional[str] = None):
        if datadog_api_key is not None:
            pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        if datadog_tags is not None:
            pulumi.set(__self__, "datadog_tags", datadog_tags)
        if disable_consumer_stats is not None:
            pulumi.set(__self__, "disable_consumer_stats", disable_consumer_stats)
        if kafka_consumer_check_instances is not None:
            pulumi.set(__self__, "kafka_consumer_check_instances", kafka_consumer_check_instances)
        if kafka_consumer_stats_timeout is not None:
            pulumi.set(__self__, "kafka_consumer_stats_timeout", kafka_consumer_stats_timeout)
        if max_partition_contexts is not None:
            pulumi.set(__self__, "max_partition_contexts", max_partition_contexts)
        if site is not None:
            pulumi.set(__self__, "site", site)

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> Optional[str]:
        return pulumi.get(self, "datadog_api_key")

    @property
    @pulumi.getter(name="datadogTags")
    def datadog_tags(self) -> Optional[Sequence['outputs.ServiceIntegrationEndpointDatadogUserConfigDatadogTag']]:
        return pulumi.get(self, "datadog_tags")

    @property
    @pulumi.getter(name="disableConsumerStats")
    def disable_consumer_stats(self) -> Optional[str]:
        return pulumi.get(self, "disable_consumer_stats")

    @property
    @pulumi.getter(name="kafkaConsumerCheckInstances")
    def kafka_consumer_check_instances(self) -> Optional[str]:
        return pulumi.get(self, "kafka_consumer_check_instances")

    @property
    @pulumi.getter(name="kafkaConsumerStatsTimeout")
    def kafka_consumer_stats_timeout(self) -> Optional[str]:
        return pulumi.get(self, "kafka_consumer_stats_timeout")

    @property
    @pulumi.getter(name="maxPartitionContexts")
    def max_partition_contexts(self) -> Optional[str]:
        return pulumi.get(self, "max_partition_contexts")

    @property
    @pulumi.getter
    def site(self) -> Optional[str]:
        return pulumi.get(self, "site")


@pulumi.output_type
class ServiceIntegrationEndpointDatadogUserConfigDatadogTag(dict):
    def __init__(__self__, *,
                 comment: Optional[str] = None,
                 tag: Optional[str] = None):
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")


@pulumi.output_type
class ServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "logGroupName":
            suggest = "log_group_name"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 log_group_name: Optional[str] = None,
                 region: Optional[str] = None,
                 secret_key: Optional[str] = None):
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[str]:
        return pulumi.get(self, "log_group_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class ServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 namespace: Optional[str] = None,
                 region: Optional[str] = None,
                 secret_key: Optional[str] = None):
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "indexDaysMax":
            suggest = "index_days_max"
        elif key == "indexPrefix":
            suggest = "index_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointExternalElasticsearchLogsUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca: Optional[str] = None,
                 index_days_max: Optional[str] = None,
                 index_prefix: Optional[str] = None,
                 timeout: Optional[str] = None,
                 url: Optional[str] = None):
        if ca is not None:
            pulumi.set(__self__, "ca", ca)
        if index_days_max is not None:
            pulumi.set(__self__, "index_days_max", index_days_max)
        if index_prefix is not None:
            pulumi.set(__self__, "index_prefix", index_prefix)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def ca(self) -> Optional[str]:
        return pulumi.get(self, "ca")

    @property
    @pulumi.getter(name="indexDaysMax")
    def index_days_max(self) -> Optional[str]:
        return pulumi.get(self, "index_days_max")

    @property
    @pulumi.getter(name="indexPrefix")
    def index_prefix(self) -> Optional[str]:
        return pulumi.get(self, "index_prefix")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class ServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logId":
            suggest = "log_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "serviceAccountCredentials":
            suggest = "service_account_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 service_account_credentials: Optional[str] = None):
        if log_id is not None:
            pulumi.set(__self__, "log_id", log_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if service_account_credentials is not None:
            pulumi.set(__self__, "service_account_credentials", service_account_credentials)

    @property
    @pulumi.getter(name="logId")
    def log_id(self) -> Optional[str]:
        return pulumi.get(self, "log_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="serviceAccountCredentials")
    def service_account_credentials(self) -> Optional[str]:
        return pulumi.get(self, "service_account_credentials")


@pulumi.output_type
class ServiceIntegrationEndpointExternalKafkaUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootstrapServers":
            suggest = "bootstrap_servers"
        elif key == "saslMechanism":
            suggest = "sasl_mechanism"
        elif key == "saslPlainPassword":
            suggest = "sasl_plain_password"
        elif key == "saslPlainUsername":
            suggest = "sasl_plain_username"
        elif key == "securityProtocol":
            suggest = "security_protocol"
        elif key == "sslCaCert":
            suggest = "ssl_ca_cert"
        elif key == "sslClientCert":
            suggest = "ssl_client_cert"
        elif key == "sslClientKey":
            suggest = "ssl_client_key"
        elif key == "sslEndpointIdentificationAlgorithm":
            suggest = "ssl_endpoint_identification_algorithm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointExternalKafkaUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointExternalKafkaUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointExternalKafkaUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bootstrap_servers: Optional[str] = None,
                 sasl_mechanism: Optional[str] = None,
                 sasl_plain_password: Optional[str] = None,
                 sasl_plain_username: Optional[str] = None,
                 security_protocol: Optional[str] = None,
                 ssl_ca_cert: Optional[str] = None,
                 ssl_client_cert: Optional[str] = None,
                 ssl_client_key: Optional[str] = None,
                 ssl_endpoint_identification_algorithm: Optional[str] = None):
        if bootstrap_servers is not None:
            pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_plain_password is not None:
            pulumi.set(__self__, "sasl_plain_password", sasl_plain_password)
        if sasl_plain_username is not None:
            pulumi.set(__self__, "sasl_plain_username", sasl_plain_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)
        if ssl_ca_cert is not None:
            pulumi.set(__self__, "ssl_ca_cert", ssl_ca_cert)
        if ssl_client_cert is not None:
            pulumi.set(__self__, "ssl_client_cert", ssl_client_cert)
        if ssl_client_key is not None:
            pulumi.set(__self__, "ssl_client_key", ssl_client_key)
        if ssl_endpoint_identification_algorithm is not None:
            pulumi.set(__self__, "ssl_endpoint_identification_algorithm", ssl_endpoint_identification_algorithm)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> Optional[str]:
        return pulumi.get(self, "bootstrap_servers")

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[str]:
        return pulumi.get(self, "sasl_mechanism")

    @property
    @pulumi.getter(name="saslPlainPassword")
    def sasl_plain_password(self) -> Optional[str]:
        return pulumi.get(self, "sasl_plain_password")

    @property
    @pulumi.getter(name="saslPlainUsername")
    def sasl_plain_username(self) -> Optional[str]:
        return pulumi.get(self, "sasl_plain_username")

    @property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[str]:
        return pulumi.get(self, "security_protocol")

    @property
    @pulumi.getter(name="sslCaCert")
    def ssl_ca_cert(self) -> Optional[str]:
        return pulumi.get(self, "ssl_ca_cert")

    @property
    @pulumi.getter(name="sslClientCert")
    def ssl_client_cert(self) -> Optional[str]:
        return pulumi.get(self, "ssl_client_cert")

    @property
    @pulumi.getter(name="sslClientKey")
    def ssl_client_key(self) -> Optional[str]:
        return pulumi.get(self, "ssl_client_key")

    @property
    @pulumi.getter(name="sslEndpointIdentificationAlgorithm")
    def ssl_endpoint_identification_algorithm(self) -> Optional[str]:
        return pulumi.get(self, "ssl_endpoint_identification_algorithm")


@pulumi.output_type
class ServiceIntegrationEndpointExternalSchemaRegistryUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuthPassword":
            suggest = "basic_auth_password"
        elif key == "basicAuthUsername":
            suggest = "basic_auth_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointExternalSchemaRegistryUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointExternalSchemaRegistryUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointExternalSchemaRegistryUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication: Optional[str] = None,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_username: Optional[str] = None,
                 url: Optional[str] = None):
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_username is not None:
            pulumi.set(__self__, "basic_auth_username", basic_auth_username)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[str]:
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUsername")
    def basic_auth_username(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_username")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class ServiceIntegrationEndpointJolokiaUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuthPassword":
            suggest = "basic_auth_password"
        elif key == "basicAuthUsername":
            suggest = "basic_auth_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointJolokiaUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointJolokiaUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointJolokiaUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_username: Optional[str] = None):
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_username is not None:
            pulumi.set(__self__, "basic_auth_username", basic_auth_username)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUsername")
    def basic_auth_username(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_username")


@pulumi.output_type
class ServiceIntegrationEndpointPrometheusUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuthPassword":
            suggest = "basic_auth_password"
        elif key == "basicAuthUsername":
            suggest = "basic_auth_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointPrometheusUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointPrometheusUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointPrometheusUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_username: Optional[str] = None):
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_username is not None:
            pulumi.set(__self__, "basic_auth_username", basic_auth_username)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUsername")
    def basic_auth_username(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_username")


@pulumi.output_type
class ServiceIntegrationEndpointRsyslogUserConfig(dict):
    def __init__(__self__, *,
                 ca: Optional[str] = None,
                 cert: Optional[str] = None,
                 format: Optional[str] = None,
                 key: Optional[str] = None,
                 logline: Optional[str] = None,
                 port: Optional[str] = None,
                 sd: Optional[str] = None,
                 server: Optional[str] = None,
                 tls: Optional[str] = None):
        if ca is not None:
            pulumi.set(__self__, "ca", ca)
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if logline is not None:
            pulumi.set(__self__, "logline", logline)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if sd is not None:
            pulumi.set(__self__, "sd", sd)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def ca(self) -> Optional[str]:
        return pulumi.get(self, "ca")

    @property
    @pulumi.getter
    def cert(self) -> Optional[str]:
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def logline(self) -> Optional[str]:
        return pulumi.get(self, "logline")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def sd(self) -> Optional[str]:
        return pulumi.get(self, "sd")

    @property
    @pulumi.getter
    def server(self) -> Optional[str]:
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def tls(self) -> Optional[str]:
        return pulumi.get(self, "tls")


@pulumi.output_type
class ServiceIntegrationEndpointSignalfxUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enabledMetrics":
            suggest = "enabled_metrics"
        elif key == "signalfxApiKey":
            suggest = "signalfx_api_key"
        elif key == "signalfxRealm":
            suggest = "signalfx_realm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEndpointSignalfxUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEndpointSignalfxUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEndpointSignalfxUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled_metrics: Optional[Sequence[str]] = None,
                 signalfx_api_key: Optional[str] = None,
                 signalfx_realm: Optional[str] = None):
        if enabled_metrics is not None:
            pulumi.set(__self__, "enabled_metrics", enabled_metrics)
        if signalfx_api_key is not None:
            pulumi.set(__self__, "signalfx_api_key", signalfx_api_key)
        if signalfx_realm is not None:
            pulumi.set(__self__, "signalfx_realm", signalfx_realm)

    @property
    @pulumi.getter(name="enabledMetrics")
    def enabled_metrics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "enabled_metrics")

    @property
    @pulumi.getter(name="signalfxApiKey")
    def signalfx_api_key(self) -> Optional[str]:
        return pulumi.get(self, "signalfx_api_key")

    @property
    @pulumi.getter(name="signalfxRealm")
    def signalfx_realm(self) -> Optional[str]:
        return pulumi.get(self, "signalfx_realm")


@pulumi.output_type
class ServiceIntegrationKafkaConnectUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaConnect":
            suggest = "kafka_connect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationKafkaConnectUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationKafkaConnectUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationKafkaConnectUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka_connect: Optional['outputs.ServiceIntegrationKafkaConnectUserConfigKafkaConnect'] = None):
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional['outputs.ServiceIntegrationKafkaConnectUserConfigKafkaConnect']:
        return pulumi.get(self, "kafka_connect")


@pulumi.output_type
class ServiceIntegrationKafkaConnectUserConfigKafkaConnect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configStorageTopic":
            suggest = "config_storage_topic"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "offsetStorageTopic":
            suggest = "offset_storage_topic"
        elif key == "statusStorageTopic":
            suggest = "status_storage_topic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationKafkaConnectUserConfigKafkaConnect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationKafkaConnectUserConfigKafkaConnect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationKafkaConnectUserConfigKafkaConnect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_storage_topic: Optional[str] = None,
                 group_id: Optional[str] = None,
                 offset_storage_topic: Optional[str] = None,
                 status_storage_topic: Optional[str] = None):
        if config_storage_topic is not None:
            pulumi.set(__self__, "config_storage_topic", config_storage_topic)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if offset_storage_topic is not None:
            pulumi.set(__self__, "offset_storage_topic", offset_storage_topic)
        if status_storage_topic is not None:
            pulumi.set(__self__, "status_storage_topic", status_storage_topic)

    @property
    @pulumi.getter(name="configStorageTopic")
    def config_storage_topic(self) -> Optional[str]:
        return pulumi.get(self, "config_storage_topic")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="offsetStorageTopic")
    def offset_storage_topic(self) -> Optional[str]:
        return pulumi.get(self, "offset_storage_topic")

    @property
    @pulumi.getter(name="statusStorageTopic")
    def status_storage_topic(self) -> Optional[str]:
        return pulumi.get(self, "status_storage_topic")


@pulumi.output_type
class ServiceIntegrationKafkaLogsUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaTopic":
            suggest = "kafka_topic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationKafkaLogsUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationKafkaLogsUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationKafkaLogsUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka_topic: Optional[str] = None):
        if kafka_topic is not None:
            pulumi.set(__self__, "kafka_topic", kafka_topic)

    @property
    @pulumi.getter(name="kafkaTopic")
    def kafka_topic(self) -> Optional[str]:
        return pulumi.get(self, "kafka_topic")


@pulumi.output_type
class ServiceIntegrationKafkaMirrormakerUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterAlias":
            suggest = "cluster_alias"
        elif key == "kafkaMirrormaker":
            suggest = "kafka_mirrormaker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationKafkaMirrormakerUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationKafkaMirrormakerUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationKafkaMirrormakerUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_alias: Optional[str] = None,
                 kafka_mirrormaker: Optional['outputs.ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker'] = None):
        if cluster_alias is not None:
            pulumi.set(__self__, "cluster_alias", cluster_alias)
        if kafka_mirrormaker is not None:
            pulumi.set(__self__, "kafka_mirrormaker", kafka_mirrormaker)

    @property
    @pulumi.getter(name="clusterAlias")
    def cluster_alias(self) -> Optional[str]:
        return pulumi.get(self, "cluster_alias")

    @property
    @pulumi.getter(name="kafkaMirrormaker")
    def kafka_mirrormaker(self) -> Optional['outputs.ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker']:
        return pulumi.get(self, "kafka_mirrormaker")


@pulumi.output_type
class ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerFetchMinBytes":
            suggest = "consumer_fetch_min_bytes"
        elif key == "producerBatchSize":
            suggest = "producer_batch_size"
        elif key == "producerBufferMemory":
            suggest = "producer_buffer_memory"
        elif key == "producerLingerMs":
            suggest = "producer_linger_ms"
        elif key == "producerMaxRequestSize":
            suggest = "producer_max_request_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormaker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_fetch_min_bytes: Optional[str] = None,
                 producer_batch_size: Optional[str] = None,
                 producer_buffer_memory: Optional[str] = None,
                 producer_linger_ms: Optional[str] = None,
                 producer_max_request_size: Optional[str] = None):
        if consumer_fetch_min_bytes is not None:
            pulumi.set(__self__, "consumer_fetch_min_bytes", consumer_fetch_min_bytes)
        if producer_batch_size is not None:
            pulumi.set(__self__, "producer_batch_size", producer_batch_size)
        if producer_buffer_memory is not None:
            pulumi.set(__self__, "producer_buffer_memory", producer_buffer_memory)
        if producer_linger_ms is not None:
            pulumi.set(__self__, "producer_linger_ms", producer_linger_ms)
        if producer_max_request_size is not None:
            pulumi.set(__self__, "producer_max_request_size", producer_max_request_size)

    @property
    @pulumi.getter(name="consumerFetchMinBytes")
    def consumer_fetch_min_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_fetch_min_bytes")

    @property
    @pulumi.getter(name="producerBatchSize")
    def producer_batch_size(self) -> Optional[str]:
        return pulumi.get(self, "producer_batch_size")

    @property
    @pulumi.getter(name="producerBufferMemory")
    def producer_buffer_memory(self) -> Optional[str]:
        return pulumi.get(self, "producer_buffer_memory")

    @property
    @pulumi.getter(name="producerLingerMs")
    def producer_linger_ms(self) -> Optional[str]:
        return pulumi.get(self, "producer_linger_ms")

    @property
    @pulumi.getter(name="producerMaxRequestSize")
    def producer_max_request_size(self) -> Optional[str]:
        return pulumi.get(self, "producer_max_request_size")


@pulumi.output_type
class ServiceIntegrationLogsUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elasticsearchIndexDaysMax":
            suggest = "elasticsearch_index_days_max"
        elif key == "elasticsearchIndexPrefix":
            suggest = "elasticsearch_index_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationLogsUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationLogsUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationLogsUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 elasticsearch_index_days_max: Optional[str] = None,
                 elasticsearch_index_prefix: Optional[str] = None):
        if elasticsearch_index_days_max is not None:
            pulumi.set(__self__, "elasticsearch_index_days_max", elasticsearch_index_days_max)
        if elasticsearch_index_prefix is not None:
            pulumi.set(__self__, "elasticsearch_index_prefix", elasticsearch_index_prefix)

    @property
    @pulumi.getter(name="elasticsearchIndexDaysMax")
    def elasticsearch_index_days_max(self) -> Optional[str]:
        return pulumi.get(self, "elasticsearch_index_days_max")

    @property
    @pulumi.getter(name="elasticsearchIndexPrefix")
    def elasticsearch_index_prefix(self) -> Optional[str]:
        return pulumi.get(self, "elasticsearch_index_prefix")


@pulumi.output_type
class ServiceIntegrationMetricsUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionDays":
            suggest = "retention_days"
        elif key == "roUsername":
            suggest = "ro_username"
        elif key == "sourceMysql":
            suggest = "source_mysql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationMetricsUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationMetricsUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationMetricsUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: Optional[str] = None,
                 retention_days: Optional[str] = None,
                 ro_username: Optional[str] = None,
                 source_mysql: Optional['outputs.ServiceIntegrationMetricsUserConfigSourceMysql'] = None,
                 username: Optional[str] = None):
        if database is not None:
            pulumi.set(__self__, "database", database)
        if retention_days is not None:
            pulumi.set(__self__, "retention_days", retention_days)
        if ro_username is not None:
            pulumi.set(__self__, "ro_username", ro_username)
        if source_mysql is not None:
            pulumi.set(__self__, "source_mysql", source_mysql)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> Optional[str]:
        return pulumi.get(self, "retention_days")

    @property
    @pulumi.getter(name="roUsername")
    def ro_username(self) -> Optional[str]:
        return pulumi.get(self, "ro_username")

    @property
    @pulumi.getter(name="sourceMysql")
    def source_mysql(self) -> Optional['outputs.ServiceIntegrationMetricsUserConfigSourceMysql']:
        return pulumi.get(self, "source_mysql")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class ServiceIntegrationMetricsUserConfigSourceMysql(dict):
    def __init__(__self__, *,
                 telegraf: Optional['outputs.ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf'] = None):
        if telegraf is not None:
            pulumi.set(__self__, "telegraf", telegraf)

    @property
    @pulumi.getter
    def telegraf(self) -> Optional['outputs.ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf']:
        return pulumi.get(self, "telegraf")


@pulumi.output_type
class ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatherEventWaits":
            suggest = "gather_event_waits"
        elif key == "gatherFileEventsStats":
            suggest = "gather_file_events_stats"
        elif key == "gatherIndexIoWaits":
            suggest = "gather_index_io_waits"
        elif key == "gatherInfoSchemaAutoInc":
            suggest = "gather_info_schema_auto_inc"
        elif key == "gatherInnodbMetrics":
            suggest = "gather_innodb_metrics"
        elif key == "gatherPerfEventsStatements":
            suggest = "gather_perf_events_statements"
        elif key == "gatherProcessList":
            suggest = "gather_process_list"
        elif key == "gatherSlaveStatus":
            suggest = "gather_slave_status"
        elif key == "gatherTableIoWaits":
            suggest = "gather_table_io_waits"
        elif key == "gatherTableLockWaits":
            suggest = "gather_table_lock_waits"
        elif key == "gatherTableSchema":
            suggest = "gather_table_schema"
        elif key == "perfEventsStatementsDigestTextLimit":
            suggest = "perf_events_statements_digest_text_limit"
        elif key == "perfEventsStatementsLimit":
            suggest = "perf_events_statements_limit"
        elif key == "perfEventsStatementsTimeLimit":
            suggest = "perf_events_statements_time_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationMetricsUserConfigSourceMysqlTelegraf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gather_event_waits: Optional[str] = None,
                 gather_file_events_stats: Optional[str] = None,
                 gather_index_io_waits: Optional[str] = None,
                 gather_info_schema_auto_inc: Optional[str] = None,
                 gather_innodb_metrics: Optional[str] = None,
                 gather_perf_events_statements: Optional[str] = None,
                 gather_process_list: Optional[str] = None,
                 gather_slave_status: Optional[str] = None,
                 gather_table_io_waits: Optional[str] = None,
                 gather_table_lock_waits: Optional[str] = None,
                 gather_table_schema: Optional[str] = None,
                 perf_events_statements_digest_text_limit: Optional[str] = None,
                 perf_events_statements_limit: Optional[str] = None,
                 perf_events_statements_time_limit: Optional[str] = None):
        if gather_event_waits is not None:
            pulumi.set(__self__, "gather_event_waits", gather_event_waits)
        if gather_file_events_stats is not None:
            pulumi.set(__self__, "gather_file_events_stats", gather_file_events_stats)
        if gather_index_io_waits is not None:
            pulumi.set(__self__, "gather_index_io_waits", gather_index_io_waits)
        if gather_info_schema_auto_inc is not None:
            pulumi.set(__self__, "gather_info_schema_auto_inc", gather_info_schema_auto_inc)
        if gather_innodb_metrics is not None:
            pulumi.set(__self__, "gather_innodb_metrics", gather_innodb_metrics)
        if gather_perf_events_statements is not None:
            pulumi.set(__self__, "gather_perf_events_statements", gather_perf_events_statements)
        if gather_process_list is not None:
            pulumi.set(__self__, "gather_process_list", gather_process_list)
        if gather_slave_status is not None:
            pulumi.set(__self__, "gather_slave_status", gather_slave_status)
        if gather_table_io_waits is not None:
            pulumi.set(__self__, "gather_table_io_waits", gather_table_io_waits)
        if gather_table_lock_waits is not None:
            pulumi.set(__self__, "gather_table_lock_waits", gather_table_lock_waits)
        if gather_table_schema is not None:
            pulumi.set(__self__, "gather_table_schema", gather_table_schema)
        if perf_events_statements_digest_text_limit is not None:
            pulumi.set(__self__, "perf_events_statements_digest_text_limit", perf_events_statements_digest_text_limit)
        if perf_events_statements_limit is not None:
            pulumi.set(__self__, "perf_events_statements_limit", perf_events_statements_limit)
        if perf_events_statements_time_limit is not None:
            pulumi.set(__self__, "perf_events_statements_time_limit", perf_events_statements_time_limit)

    @property
    @pulumi.getter(name="gatherEventWaits")
    def gather_event_waits(self) -> Optional[str]:
        return pulumi.get(self, "gather_event_waits")

    @property
    @pulumi.getter(name="gatherFileEventsStats")
    def gather_file_events_stats(self) -> Optional[str]:
        return pulumi.get(self, "gather_file_events_stats")

    @property
    @pulumi.getter(name="gatherIndexIoWaits")
    def gather_index_io_waits(self) -> Optional[str]:
        return pulumi.get(self, "gather_index_io_waits")

    @property
    @pulumi.getter(name="gatherInfoSchemaAutoInc")
    def gather_info_schema_auto_inc(self) -> Optional[str]:
        return pulumi.get(self, "gather_info_schema_auto_inc")

    @property
    @pulumi.getter(name="gatherInnodbMetrics")
    def gather_innodb_metrics(self) -> Optional[str]:
        return pulumi.get(self, "gather_innodb_metrics")

    @property
    @pulumi.getter(name="gatherPerfEventsStatements")
    def gather_perf_events_statements(self) -> Optional[str]:
        return pulumi.get(self, "gather_perf_events_statements")

    @property
    @pulumi.getter(name="gatherProcessList")
    def gather_process_list(self) -> Optional[str]:
        return pulumi.get(self, "gather_process_list")

    @property
    @pulumi.getter(name="gatherSlaveStatus")
    def gather_slave_status(self) -> Optional[str]:
        return pulumi.get(self, "gather_slave_status")

    @property
    @pulumi.getter(name="gatherTableIoWaits")
    def gather_table_io_waits(self) -> Optional[str]:
        return pulumi.get(self, "gather_table_io_waits")

    @property
    @pulumi.getter(name="gatherTableLockWaits")
    def gather_table_lock_waits(self) -> Optional[str]:
        return pulumi.get(self, "gather_table_lock_waits")

    @property
    @pulumi.getter(name="gatherTableSchema")
    def gather_table_schema(self) -> Optional[str]:
        return pulumi.get(self, "gather_table_schema")

    @property
    @pulumi.getter(name="perfEventsStatementsDigestTextLimit")
    def perf_events_statements_digest_text_limit(self) -> Optional[str]:
        return pulumi.get(self, "perf_events_statements_digest_text_limit")

    @property
    @pulumi.getter(name="perfEventsStatementsLimit")
    def perf_events_statements_limit(self) -> Optional[str]:
        return pulumi.get(self, "perf_events_statements_limit")

    @property
    @pulumi.getter(name="perfEventsStatementsTimeLimit")
    def perf_events_statements_time_limit(self) -> Optional[str]:
        return pulumi.get(self, "perf_events_statements_time_limit")


@pulumi.output_type
class ServiceIntegrationMirrormakerUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mirrormakerWhitelist":
            suggest = "mirrormaker_whitelist"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationMirrormakerUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationMirrormakerUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationMirrormakerUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mirrormaker_whitelist: Optional[str] = None):
        if mirrormaker_whitelist is not None:
            pulumi.set(__self__, "mirrormaker_whitelist", mirrormaker_whitelist)

    @property
    @pulumi.getter(name="mirrormakerWhitelist")
    def mirrormaker_whitelist(self) -> Optional[str]:
        return pulumi.get(self, "mirrormaker_whitelist")


@pulumi.output_type
class GetCassandaCassandraResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetCassandaCassandraUserConfigResult(dict):
    def __init__(__self__, *,
                 cassandra: Optional['outputs.GetCassandaCassandraUserConfigCassandraResult'] = None,
                 cassandra_version: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 migrate_sstableloader: Optional[str] = None,
                 private_access: Optional['outputs.GetCassandaCassandraUserConfigPrivateAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetCassandaCassandraUserConfigPublicAccessResult'] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        if cassandra is not None:
            pulumi.set(__self__, "cassandra", cassandra)
        if cassandra_version is not None:
            pulumi.set(__self__, "cassandra_version", cassandra_version)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migrate_sstableloader is not None:
            pulumi.set(__self__, "migrate_sstableloader", migrate_sstableloader)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter
    def cassandra(self) -> Optional['outputs.GetCassandaCassandraUserConfigCassandraResult']:
        return pulumi.get(self, "cassandra")

    @property
    @pulumi.getter(name="cassandraVersion")
    def cassandra_version(self) -> Optional[str]:
        return pulumi.get(self, "cassandra_version")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="migrateSstableloader")
    def migrate_sstableloader(self) -> Optional[str]:
        return pulumi.get(self, "migrate_sstableloader")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetCassandaCassandraUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetCassandaCassandraUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetCassandaCassandraUserConfigCassandraResult(dict):
    def __init__(__self__, *,
                 batch_size_fail_threshold_in_kb: Optional[str] = None,
                 batch_size_warn_threshold_in_kb: Optional[str] = None):
        if batch_size_fail_threshold_in_kb is not None:
            pulumi.set(__self__, "batch_size_fail_threshold_in_kb", batch_size_fail_threshold_in_kb)
        if batch_size_warn_threshold_in_kb is not None:
            pulumi.set(__self__, "batch_size_warn_threshold_in_kb", batch_size_warn_threshold_in_kb)

    @property
    @pulumi.getter(name="batchSizeFailThresholdInKb")
    def batch_size_fail_threshold_in_kb(self) -> Optional[str]:
        return pulumi.get(self, "batch_size_fail_threshold_in_kb")

    @property
    @pulumi.getter(name="batchSizeWarnThresholdInKb")
    def batch_size_warn_threshold_in_kb(self) -> Optional[str]:
        return pulumi.get(self, "batch_size_warn_threshold_in_kb")


@pulumi.output_type
class GetCassandaCassandraUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetCassandaCassandraUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetCassandaComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetCassandaServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetCassandaTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCassandraCassandraResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetCassandraCassandraUserConfigResult(dict):
    def __init__(__self__, *,
                 cassandra: Optional['outputs.GetCassandraCassandraUserConfigCassandraResult'] = None,
                 cassandra_version: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 migrate_sstableloader: Optional[str] = None,
                 private_access: Optional['outputs.GetCassandraCassandraUserConfigPrivateAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetCassandraCassandraUserConfigPublicAccessResult'] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        if cassandra is not None:
            pulumi.set(__self__, "cassandra", cassandra)
        if cassandra_version is not None:
            pulumi.set(__self__, "cassandra_version", cassandra_version)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migrate_sstableloader is not None:
            pulumi.set(__self__, "migrate_sstableloader", migrate_sstableloader)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter
    def cassandra(self) -> Optional['outputs.GetCassandraCassandraUserConfigCassandraResult']:
        return pulumi.get(self, "cassandra")

    @property
    @pulumi.getter(name="cassandraVersion")
    def cassandra_version(self) -> Optional[str]:
        return pulumi.get(self, "cassandra_version")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="migrateSstableloader")
    def migrate_sstableloader(self) -> Optional[str]:
        return pulumi.get(self, "migrate_sstableloader")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetCassandraCassandraUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetCassandraCassandraUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetCassandraCassandraUserConfigCassandraResult(dict):
    def __init__(__self__, *,
                 batch_size_fail_threshold_in_kb: Optional[str] = None,
                 batch_size_warn_threshold_in_kb: Optional[str] = None):
        if batch_size_fail_threshold_in_kb is not None:
            pulumi.set(__self__, "batch_size_fail_threshold_in_kb", batch_size_fail_threshold_in_kb)
        if batch_size_warn_threshold_in_kb is not None:
            pulumi.set(__self__, "batch_size_warn_threshold_in_kb", batch_size_warn_threshold_in_kb)

    @property
    @pulumi.getter(name="batchSizeFailThresholdInKb")
    def batch_size_fail_threshold_in_kb(self) -> Optional[str]:
        return pulumi.get(self, "batch_size_fail_threshold_in_kb")

    @property
    @pulumi.getter(name="batchSizeWarnThresholdInKb")
    def batch_size_warn_threshold_in_kb(self) -> Optional[str]:
        return pulumi.get(self, "batch_size_warn_threshold_in_kb")


@pulumi.output_type
class GetCassandraCassandraUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetCassandraCassandraUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetCassandraComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetCassandraServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetCassandraTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClickhouseClickhouseResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClickhouseClickhouseUserConfigResult(dict):
    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 project_to_fork_from: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None):
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")


@pulumi.output_type
class GetClickhouseComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetClickhouseServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetClickhouseTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFlinkComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetFlinkFlinkResult(dict):
    def __init__(__self__, *,
                 host_ports: Sequence[str]):
        pulumi.set(__self__, "host_ports", host_ports)

    @property
    @pulumi.getter(name="hostPorts")
    def host_ports(self) -> Sequence[str]:
        return pulumi.get(self, "host_ports")


@pulumi.output_type
class GetFlinkFlinkUserConfigResult(dict):
    def __init__(__self__, *,
                 execution_checkpointing_interval_ms: Optional[str] = None,
                 execution_checkpointing_timeout_ms: Optional[str] = None,
                 flink_version: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 number_of_task_slots: Optional[str] = None,
                 parallelism_default: Optional[str] = None,
                 privatelink_access: Optional['outputs.GetFlinkFlinkUserConfigPrivatelinkAccessResult'] = None,
                 restart_strategy: Optional[str] = None,
                 restart_strategy_delay_sec: Optional[str] = None,
                 restart_strategy_failure_rate_interval_min: Optional[str] = None,
                 restart_strategy_max_failures: Optional[str] = None):
        if execution_checkpointing_interval_ms is not None:
            pulumi.set(__self__, "execution_checkpointing_interval_ms", execution_checkpointing_interval_ms)
        if execution_checkpointing_timeout_ms is not None:
            pulumi.set(__self__, "execution_checkpointing_timeout_ms", execution_checkpointing_timeout_ms)
        if flink_version is not None:
            pulumi.set(__self__, "flink_version", flink_version)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if number_of_task_slots is not None:
            pulumi.set(__self__, "number_of_task_slots", number_of_task_slots)
        if parallelism_default is not None:
            pulumi.set(__self__, "parallelism_default", parallelism_default)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if restart_strategy is not None:
            pulumi.set(__self__, "restart_strategy", restart_strategy)
        if restart_strategy_delay_sec is not None:
            pulumi.set(__self__, "restart_strategy_delay_sec", restart_strategy_delay_sec)
        if restart_strategy_failure_rate_interval_min is not None:
            pulumi.set(__self__, "restart_strategy_failure_rate_interval_min", restart_strategy_failure_rate_interval_min)
        if restart_strategy_max_failures is not None:
            pulumi.set(__self__, "restart_strategy_max_failures", restart_strategy_max_failures)

    @property
    @pulumi.getter(name="executionCheckpointingIntervalMs")
    def execution_checkpointing_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "execution_checkpointing_interval_ms")

    @property
    @pulumi.getter(name="executionCheckpointingTimeoutMs")
    def execution_checkpointing_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "execution_checkpointing_timeout_ms")

    @property
    @pulumi.getter(name="flinkVersion")
    def flink_version(self) -> Optional[str]:
        return pulumi.get(self, "flink_version")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="numberOfTaskSlots")
    def number_of_task_slots(self) -> Optional[str]:
        return pulumi.get(self, "number_of_task_slots")

    @property
    @pulumi.getter(name="parallelismDefault")
    def parallelism_default(self) -> Optional[str]:
        return pulumi.get(self, "parallelism_default")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetFlinkFlinkUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="restartStrategy")
    def restart_strategy(self) -> Optional[str]:
        return pulumi.get(self, "restart_strategy")

    @property
    @pulumi.getter(name="restartStrategyDelaySec")
    def restart_strategy_delay_sec(self) -> Optional[str]:
        return pulumi.get(self, "restart_strategy_delay_sec")

    @property
    @pulumi.getter(name="restartStrategyFailureRateIntervalMin")
    def restart_strategy_failure_rate_interval_min(self) -> Optional[str]:
        return pulumi.get(self, "restart_strategy_failure_rate_interval_min")

    @property
    @pulumi.getter(name="restartStrategyMaxFailures")
    def restart_strategy_max_failures(self) -> Optional[str]:
        return pulumi.get(self, "restart_strategy_max_failures")


@pulumi.output_type
class GetFlinkFlinkUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 flink: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if flink is not None:
            pulumi.set(__self__, "flink", flink)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def flink(self) -> Optional[str]:
        return pulumi.get(self, "flink")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetFlinkServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetFlinkTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGrafanaComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetGrafanaGrafanaResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetGrafanaGrafanaUserConfigResult(dict):
    def __init__(__self__, *,
                 alerting_enabled: Optional[str] = None,
                 alerting_error_or_timeout: Optional[str] = None,
                 alerting_max_annotations_to_keep: Optional[str] = None,
                 alerting_nodata_or_nullvalues: Optional[str] = None,
                 allow_embedding: Optional[str] = None,
                 auth_azuread: Optional['outputs.GetGrafanaGrafanaUserConfigAuthAzureadResult'] = None,
                 auth_basic_enabled: Optional[str] = None,
                 auth_generic_oauth: Optional['outputs.GetGrafanaGrafanaUserConfigAuthGenericOauthResult'] = None,
                 auth_github: Optional['outputs.GetGrafanaGrafanaUserConfigAuthGithubResult'] = None,
                 auth_gitlab: Optional['outputs.GetGrafanaGrafanaUserConfigAuthGitlabResult'] = None,
                 auth_google: Optional['outputs.GetGrafanaGrafanaUserConfigAuthGoogleResult'] = None,
                 cookie_samesite: Optional[str] = None,
                 custom_domain: Optional[str] = None,
                 dashboards_min_refresh_interval: Optional[str] = None,
                 dashboards_versions_to_keep: Optional[str] = None,
                 dataproxy_send_user_header: Optional[str] = None,
                 dataproxy_timeout: Optional[str] = None,
                 date_formats: Optional['outputs.GetGrafanaGrafanaUserConfigDateFormatsResult'] = None,
                 disable_gravatar: Optional[str] = None,
                 editors_can_admin: Optional[str] = None,
                 external_image_storage: Optional['outputs.GetGrafanaGrafanaUserConfigExternalImageStorageResult'] = None,
                 google_analytics_ua_id: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 metrics_enabled: Optional[str] = None,
                 private_access: Optional['outputs.GetGrafanaGrafanaUserConfigPrivateAccessResult'] = None,
                 privatelink_access: Optional['outputs.GetGrafanaGrafanaUserConfigPrivatelinkAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetGrafanaGrafanaUserConfigPublicAccessResult'] = None,
                 recovery_basebackup_name: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 smtp_server: Optional['outputs.GetGrafanaGrafanaUserConfigSmtpServerResult'] = None,
                 static_ips: Optional[str] = None,
                 user_auto_assign_org: Optional[str] = None,
                 user_auto_assign_org_role: Optional[str] = None,
                 viewers_can_edit: Optional[str] = None):
        if alerting_enabled is not None:
            pulumi.set(__self__, "alerting_enabled", alerting_enabled)
        if alerting_error_or_timeout is not None:
            pulumi.set(__self__, "alerting_error_or_timeout", alerting_error_or_timeout)
        if alerting_max_annotations_to_keep is not None:
            pulumi.set(__self__, "alerting_max_annotations_to_keep", alerting_max_annotations_to_keep)
        if alerting_nodata_or_nullvalues is not None:
            pulumi.set(__self__, "alerting_nodata_or_nullvalues", alerting_nodata_or_nullvalues)
        if allow_embedding is not None:
            pulumi.set(__self__, "allow_embedding", allow_embedding)
        if auth_azuread is not None:
            pulumi.set(__self__, "auth_azuread", auth_azuread)
        if auth_basic_enabled is not None:
            pulumi.set(__self__, "auth_basic_enabled", auth_basic_enabled)
        if auth_generic_oauth is not None:
            pulumi.set(__self__, "auth_generic_oauth", auth_generic_oauth)
        if auth_github is not None:
            pulumi.set(__self__, "auth_github", auth_github)
        if auth_gitlab is not None:
            pulumi.set(__self__, "auth_gitlab", auth_gitlab)
        if auth_google is not None:
            pulumi.set(__self__, "auth_google", auth_google)
        if cookie_samesite is not None:
            pulumi.set(__self__, "cookie_samesite", cookie_samesite)
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if dashboards_min_refresh_interval is not None:
            pulumi.set(__self__, "dashboards_min_refresh_interval", dashboards_min_refresh_interval)
        if dashboards_versions_to_keep is not None:
            pulumi.set(__self__, "dashboards_versions_to_keep", dashboards_versions_to_keep)
        if dataproxy_send_user_header is not None:
            pulumi.set(__self__, "dataproxy_send_user_header", dataproxy_send_user_header)
        if dataproxy_timeout is not None:
            pulumi.set(__self__, "dataproxy_timeout", dataproxy_timeout)
        if date_formats is not None:
            pulumi.set(__self__, "date_formats", date_formats)
        if disable_gravatar is not None:
            pulumi.set(__self__, "disable_gravatar", disable_gravatar)
        if editors_can_admin is not None:
            pulumi.set(__self__, "editors_can_admin", editors_can_admin)
        if external_image_storage is not None:
            pulumi.set(__self__, "external_image_storage", external_image_storage)
        if google_analytics_ua_id is not None:
            pulumi.set(__self__, "google_analytics_ua_id", google_analytics_ua_id)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if metrics_enabled is not None:
            pulumi.set(__self__, "metrics_enabled", metrics_enabled)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_basebackup_name is not None:
            pulumi.set(__self__, "recovery_basebackup_name", recovery_basebackup_name)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if smtp_server is not None:
            pulumi.set(__self__, "smtp_server", smtp_server)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)
        if user_auto_assign_org is not None:
            pulumi.set(__self__, "user_auto_assign_org", user_auto_assign_org)
        if user_auto_assign_org_role is not None:
            pulumi.set(__self__, "user_auto_assign_org_role", user_auto_assign_org_role)
        if viewers_can_edit is not None:
            pulumi.set(__self__, "viewers_can_edit", viewers_can_edit)

    @property
    @pulumi.getter(name="alertingEnabled")
    def alerting_enabled(self) -> Optional[str]:
        return pulumi.get(self, "alerting_enabled")

    @property
    @pulumi.getter(name="alertingErrorOrTimeout")
    def alerting_error_or_timeout(self) -> Optional[str]:
        return pulumi.get(self, "alerting_error_or_timeout")

    @property
    @pulumi.getter(name="alertingMaxAnnotationsToKeep")
    def alerting_max_annotations_to_keep(self) -> Optional[str]:
        return pulumi.get(self, "alerting_max_annotations_to_keep")

    @property
    @pulumi.getter(name="alertingNodataOrNullvalues")
    def alerting_nodata_or_nullvalues(self) -> Optional[str]:
        return pulumi.get(self, "alerting_nodata_or_nullvalues")

    @property
    @pulumi.getter(name="allowEmbedding")
    def allow_embedding(self) -> Optional[str]:
        return pulumi.get(self, "allow_embedding")

    @property
    @pulumi.getter(name="authAzuread")
    def auth_azuread(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigAuthAzureadResult']:
        return pulumi.get(self, "auth_azuread")

    @property
    @pulumi.getter(name="authBasicEnabled")
    def auth_basic_enabled(self) -> Optional[str]:
        return pulumi.get(self, "auth_basic_enabled")

    @property
    @pulumi.getter(name="authGenericOauth")
    def auth_generic_oauth(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigAuthGenericOauthResult']:
        return pulumi.get(self, "auth_generic_oauth")

    @property
    @pulumi.getter(name="authGithub")
    def auth_github(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigAuthGithubResult']:
        return pulumi.get(self, "auth_github")

    @property
    @pulumi.getter(name="authGitlab")
    def auth_gitlab(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigAuthGitlabResult']:
        return pulumi.get(self, "auth_gitlab")

    @property
    @pulumi.getter(name="authGoogle")
    def auth_google(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigAuthGoogleResult']:
        return pulumi.get(self, "auth_google")

    @property
    @pulumi.getter(name="cookieSamesite")
    def cookie_samesite(self) -> Optional[str]:
        return pulumi.get(self, "cookie_samesite")

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="dashboardsMinRefreshInterval")
    def dashboards_min_refresh_interval(self) -> Optional[str]:
        return pulumi.get(self, "dashboards_min_refresh_interval")

    @property
    @pulumi.getter(name="dashboardsVersionsToKeep")
    def dashboards_versions_to_keep(self) -> Optional[str]:
        return pulumi.get(self, "dashboards_versions_to_keep")

    @property
    @pulumi.getter(name="dataproxySendUserHeader")
    def dataproxy_send_user_header(self) -> Optional[str]:
        return pulumi.get(self, "dataproxy_send_user_header")

    @property
    @pulumi.getter(name="dataproxyTimeout")
    def dataproxy_timeout(self) -> Optional[str]:
        return pulumi.get(self, "dataproxy_timeout")

    @property
    @pulumi.getter(name="dateFormats")
    def date_formats(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigDateFormatsResult']:
        return pulumi.get(self, "date_formats")

    @property
    @pulumi.getter(name="disableGravatar")
    def disable_gravatar(self) -> Optional[str]:
        return pulumi.get(self, "disable_gravatar")

    @property
    @pulumi.getter(name="editorsCanAdmin")
    def editors_can_admin(self) -> Optional[str]:
        return pulumi.get(self, "editors_can_admin")

    @property
    @pulumi.getter(name="externalImageStorage")
    def external_image_storage(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigExternalImageStorageResult']:
        return pulumi.get(self, "external_image_storage")

    @property
    @pulumi.getter(name="googleAnalyticsUaId")
    def google_analytics_ua_id(self) -> Optional[str]:
        return pulumi.get(self, "google_analytics_ua_id")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="metricsEnabled")
    def metrics_enabled(self) -> Optional[str]:
        return pulumi.get(self, "metrics_enabled")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryBasebackupName")
    def recovery_basebackup_name(self) -> Optional[str]:
        return pulumi.get(self, "recovery_basebackup_name")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="smtpServer")
    def smtp_server(self) -> Optional['outputs.GetGrafanaGrafanaUserConfigSmtpServerResult']:
        return pulumi.get(self, "smtp_server")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")

    @property
    @pulumi.getter(name="userAutoAssignOrg")
    def user_auto_assign_org(self) -> Optional[str]:
        return pulumi.get(self, "user_auto_assign_org")

    @property
    @pulumi.getter(name="userAutoAssignOrgRole")
    def user_auto_assign_org_role(self) -> Optional[str]:
        return pulumi.get(self, "user_auto_assign_org_role")

    @property
    @pulumi.getter(name="viewersCanEdit")
    def viewers_can_edit(self) -> Optional[str]:
        return pulumi.get(self, "viewers_can_edit")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigAuthAzureadResult(dict):
    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_domains: Optional[Sequence[str]] = None,
                 allowed_groups: Optional[Sequence[str]] = None,
                 auth_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 token_url: Optional[str] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_domains")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        return pulumi.get(self, "token_url")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigAuthGenericOauthResult(dict):
    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_domains: Optional[Sequence[str]] = None,
                 allowed_organizations: Optional[Sequence[str]] = None,
                 api_url: Optional[str] = None,
                 auth_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 name: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 token_url: Optional[str] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if allowed_organizations is not None:
            pulumi.set(__self__, "allowed_organizations", allowed_organizations)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_domains")

    @property
    @pulumi.getter(name="allowedOrganizations")
    def allowed_organizations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_organizations")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        return pulumi.get(self, "token_url")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigAuthGithubResult(dict):
    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_organizations: Optional[Sequence[str]] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 team_ids: Optional[Sequence[str]] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_organizations is not None:
            pulumi.set(__self__, "allowed_organizations", allowed_organizations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if team_ids is not None:
            pulumi.set(__self__, "team_ids", team_ids)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedOrganizations")
    def allowed_organizations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_organizations")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="teamIds")
    def team_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "team_ids")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigAuthGitlabResult(dict):
    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_groups: Optional[Sequence[str]] = None,
                 api_url: Optional[str] = None,
                 auth_url: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 token_url: Optional[str] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_groups")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[str]:
        return pulumi.get(self, "token_url")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigAuthGoogleResult(dict):
    def __init__(__self__, *,
                 allow_sign_up: Optional[str] = None,
                 allowed_domains: Optional[Sequence[str]] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        if allow_sign_up is not None:
            pulumi.set(__self__, "allow_sign_up", allow_sign_up)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="allowSignUp")
    def allow_sign_up(self) -> Optional[str]:
        return pulumi.get(self, "allow_sign_up")

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_domains")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigDateFormatsResult(dict):
    def __init__(__self__, *,
                 default_timezone: Optional[str] = None,
                 full_date: Optional[str] = None,
                 interval_day: Optional[str] = None,
                 interval_hour: Optional[str] = None,
                 interval_minute: Optional[str] = None,
                 interval_month: Optional[str] = None,
                 interval_second: Optional[str] = None,
                 interval_year: Optional[str] = None):
        if default_timezone is not None:
            pulumi.set(__self__, "default_timezone", default_timezone)
        if full_date is not None:
            pulumi.set(__self__, "full_date", full_date)
        if interval_day is not None:
            pulumi.set(__self__, "interval_day", interval_day)
        if interval_hour is not None:
            pulumi.set(__self__, "interval_hour", interval_hour)
        if interval_minute is not None:
            pulumi.set(__self__, "interval_minute", interval_minute)
        if interval_month is not None:
            pulumi.set(__self__, "interval_month", interval_month)
        if interval_second is not None:
            pulumi.set(__self__, "interval_second", interval_second)
        if interval_year is not None:
            pulumi.set(__self__, "interval_year", interval_year)

    @property
    @pulumi.getter(name="defaultTimezone")
    def default_timezone(self) -> Optional[str]:
        return pulumi.get(self, "default_timezone")

    @property
    @pulumi.getter(name="fullDate")
    def full_date(self) -> Optional[str]:
        return pulumi.get(self, "full_date")

    @property
    @pulumi.getter(name="intervalDay")
    def interval_day(self) -> Optional[str]:
        return pulumi.get(self, "interval_day")

    @property
    @pulumi.getter(name="intervalHour")
    def interval_hour(self) -> Optional[str]:
        return pulumi.get(self, "interval_hour")

    @property
    @pulumi.getter(name="intervalMinute")
    def interval_minute(self) -> Optional[str]:
        return pulumi.get(self, "interval_minute")

    @property
    @pulumi.getter(name="intervalMonth")
    def interval_month(self) -> Optional[str]:
        return pulumi.get(self, "interval_month")

    @property
    @pulumi.getter(name="intervalSecond")
    def interval_second(self) -> Optional[str]:
        return pulumi.get(self, "interval_second")

    @property
    @pulumi.getter(name="intervalYear")
    def interval_year(self) -> Optional[str]:
        return pulumi.get(self, "interval_year")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigExternalImageStorageResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 bucket_url: Optional[str] = None,
                 provider: Optional[str] = None,
                 secret_key: Optional[str] = None):
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bucket_url is not None:
            pulumi.set(__self__, "bucket_url", bucket_url)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bucketUrl")
    def bucket_url(self) -> Optional[str]:
        return pulumi.get(self, "bucket_url")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 grafana: Optional[str] = None):
        if grafana is not None:
            pulumi.set(__self__, "grafana", grafana)

    @property
    @pulumi.getter
    def grafana(self) -> Optional[str]:
        return pulumi.get(self, "grafana")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 grafana: Optional[str] = None):
        if grafana is not None:
            pulumi.set(__self__, "grafana", grafana)

    @property
    @pulumi.getter
    def grafana(self) -> Optional[str]:
        return pulumi.get(self, "grafana")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 grafana: Optional[str] = None):
        if grafana is not None:
            pulumi.set(__self__, "grafana", grafana)

    @property
    @pulumi.getter
    def grafana(self) -> Optional[str]:
        return pulumi.get(self, "grafana")


@pulumi.output_type
class GetGrafanaGrafanaUserConfigSmtpServerResult(dict):
    def __init__(__self__, *,
                 from_address: Optional[str] = None,
                 from_name: Optional[str] = None,
                 host: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 skip_verify: Optional[str] = None,
                 starttls_policy: Optional[str] = None,
                 username: Optional[str] = None):
        if from_address is not None:
            pulumi.set(__self__, "from_address", from_address)
        if from_name is not None:
            pulumi.set(__self__, "from_name", from_name)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if skip_verify is not None:
            pulumi.set(__self__, "skip_verify", skip_verify)
        if starttls_policy is not None:
            pulumi.set(__self__, "starttls_policy", starttls_policy)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="fromAddress")
    def from_address(self) -> Optional[str]:
        return pulumi.get(self, "from_address")

    @property
    @pulumi.getter(name="fromName")
    def from_name(self) -> Optional[str]:
        return pulumi.get(self, "from_name")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="skipVerify")
    def skip_verify(self) -> Optional[str]:
        return pulumi.get(self, "skip_verify")

    @property
    @pulumi.getter(name="starttlsPolicy")
    def starttls_policy(self) -> Optional[str]:
        return pulumi.get(self, "starttls_policy")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetGrafanaServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetGrafanaTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetInfluxDbComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetInfluxDbInfluxdbResult(dict):
    def __init__(__self__, *,
                 database_name: str):
        pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetInfluxDbInfluxdbUserConfigResult(dict):
    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 influxdb: Optional['outputs.GetInfluxDbInfluxdbUserConfigInfluxdbResult'] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 private_access: Optional['outputs.GetInfluxDbInfluxdbUserConfigPrivateAccessResult'] = None,
                 privatelink_access: Optional['outputs.GetInfluxDbInfluxdbUserConfigPrivatelinkAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetInfluxDbInfluxdbUserConfigPublicAccessResult'] = None,
                 recovery_basebackup_name: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if influxdb is not None:
            pulumi.set(__self__, "influxdb", influxdb)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_basebackup_name is not None:
            pulumi.set(__self__, "recovery_basebackup_name", recovery_basebackup_name)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter
    def influxdb(self) -> Optional['outputs.GetInfluxDbInfluxdbUserConfigInfluxdbResult']:
        return pulumi.get(self, "influxdb")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetInfluxDbInfluxdbUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetInfluxDbInfluxdbUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetInfluxDbInfluxdbUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryBasebackupName")
    def recovery_basebackup_name(self) -> Optional[str]:
        return pulumi.get(self, "recovery_basebackup_name")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetInfluxDbInfluxdbUserConfigInfluxdbResult(dict):
    def __init__(__self__, *,
                 log_queries_after: Optional[str] = None,
                 max_connection_limit: Optional[str] = None,
                 max_row_limit: Optional[str] = None,
                 max_select_buckets: Optional[str] = None,
                 max_select_point: Optional[str] = None,
                 query_timeout: Optional[str] = None):
        if log_queries_after is not None:
            pulumi.set(__self__, "log_queries_after", log_queries_after)
        if max_connection_limit is not None:
            pulumi.set(__self__, "max_connection_limit", max_connection_limit)
        if max_row_limit is not None:
            pulumi.set(__self__, "max_row_limit", max_row_limit)
        if max_select_buckets is not None:
            pulumi.set(__self__, "max_select_buckets", max_select_buckets)
        if max_select_point is not None:
            pulumi.set(__self__, "max_select_point", max_select_point)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)

    @property
    @pulumi.getter(name="logQueriesAfter")
    def log_queries_after(self) -> Optional[str]:
        return pulumi.get(self, "log_queries_after")

    @property
    @pulumi.getter(name="maxConnectionLimit")
    def max_connection_limit(self) -> Optional[str]:
        return pulumi.get(self, "max_connection_limit")

    @property
    @pulumi.getter(name="maxRowLimit")
    def max_row_limit(self) -> Optional[str]:
        return pulumi.get(self, "max_row_limit")

    @property
    @pulumi.getter(name="maxSelectBuckets")
    def max_select_buckets(self) -> Optional[str]:
        return pulumi.get(self, "max_select_buckets")

    @property
    @pulumi.getter(name="maxSelectPoint")
    def max_select_point(self) -> Optional[str]:
        return pulumi.get(self, "max_select_point")

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[str]:
        return pulumi.get(self, "query_timeout")


@pulumi.output_type
class GetInfluxDbInfluxdbUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 influxdb: Optional[str] = None):
        if influxdb is not None:
            pulumi.set(__self__, "influxdb", influxdb)

    @property
    @pulumi.getter
    def influxdb(self) -> Optional[str]:
        return pulumi.get(self, "influxdb")


@pulumi.output_type
class GetInfluxDbInfluxdbUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 influxdb: Optional[str] = None):
        if influxdb is not None:
            pulumi.set(__self__, "influxdb", influxdb)

    @property
    @pulumi.getter
    def influxdb(self) -> Optional[str]:
        return pulumi.get(self, "influxdb")


@pulumi.output_type
class GetInfluxDbInfluxdbUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 influxdb: Optional[str] = None):
        if influxdb is not None:
            pulumi.set(__self__, "influxdb", influxdb)

    @property
    @pulumi.getter
    def influxdb(self) -> Optional[str]:
        return pulumi.get(self, "influxdb")


@pulumi.output_type
class GetInfluxDbServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetInfluxDbTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetKafkaComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetKafkaConnectComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetKafkaConnectKafkaConnectResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetKafkaConnectKafkaConnectUserConfigResult(dict):
    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka_connect: Optional['outputs.GetKafkaConnectKafkaConnectUserConfigKafkaConnectResult'] = None,
                 private_access: Optional['outputs.GetKafkaConnectKafkaConnectUserConfigPrivateAccessResult'] = None,
                 privatelink_access: Optional['outputs.GetKafkaConnectKafkaConnectUserConfigPrivatelinkAccessResult'] = None,
                 public_access: Optional['outputs.GetKafkaConnectKafkaConnectUserConfigPublicAccessResult'] = None,
                 static_ips: Optional[str] = None):
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional['outputs.GetKafkaConnectKafkaConnectUserConfigKafkaConnectResult']:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetKafkaConnectKafkaConnectUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetKafkaConnectKafkaConnectUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetKafkaConnectKafkaConnectUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetKafkaConnectKafkaConnectUserConfigKafkaConnectResult(dict):
    def __init__(__self__, *,
                 connector_client_config_override_policy: Optional[str] = None,
                 consumer_auto_offset_reset: Optional[str] = None,
                 consumer_fetch_max_bytes: Optional[str] = None,
                 consumer_isolation_level: Optional[str] = None,
                 consumer_max_partition_fetch_bytes: Optional[str] = None,
                 consumer_max_poll_interval_ms: Optional[str] = None,
                 consumer_max_poll_records: Optional[str] = None,
                 offset_flush_interval_ms: Optional[str] = None,
                 offset_flush_timeout_ms: Optional[str] = None,
                 producer_compression_type: Optional[str] = None,
                 producer_max_request_size: Optional[str] = None,
                 session_timeout_ms: Optional[str] = None):
        if connector_client_config_override_policy is not None:
            pulumi.set(__self__, "connector_client_config_override_policy", connector_client_config_override_policy)
        if consumer_auto_offset_reset is not None:
            pulumi.set(__self__, "consumer_auto_offset_reset", consumer_auto_offset_reset)
        if consumer_fetch_max_bytes is not None:
            pulumi.set(__self__, "consumer_fetch_max_bytes", consumer_fetch_max_bytes)
        if consumer_isolation_level is not None:
            pulumi.set(__self__, "consumer_isolation_level", consumer_isolation_level)
        if consumer_max_partition_fetch_bytes is not None:
            pulumi.set(__self__, "consumer_max_partition_fetch_bytes", consumer_max_partition_fetch_bytes)
        if consumer_max_poll_interval_ms is not None:
            pulumi.set(__self__, "consumer_max_poll_interval_ms", consumer_max_poll_interval_ms)
        if consumer_max_poll_records is not None:
            pulumi.set(__self__, "consumer_max_poll_records", consumer_max_poll_records)
        if offset_flush_interval_ms is not None:
            pulumi.set(__self__, "offset_flush_interval_ms", offset_flush_interval_ms)
        if offset_flush_timeout_ms is not None:
            pulumi.set(__self__, "offset_flush_timeout_ms", offset_flush_timeout_ms)
        if producer_compression_type is not None:
            pulumi.set(__self__, "producer_compression_type", producer_compression_type)
        if producer_max_request_size is not None:
            pulumi.set(__self__, "producer_max_request_size", producer_max_request_size)
        if session_timeout_ms is not None:
            pulumi.set(__self__, "session_timeout_ms", session_timeout_ms)

    @property
    @pulumi.getter(name="connectorClientConfigOverridePolicy")
    def connector_client_config_override_policy(self) -> Optional[str]:
        return pulumi.get(self, "connector_client_config_override_policy")

    @property
    @pulumi.getter(name="consumerAutoOffsetReset")
    def consumer_auto_offset_reset(self) -> Optional[str]:
        return pulumi.get(self, "consumer_auto_offset_reset")

    @property
    @pulumi.getter(name="consumerFetchMaxBytes")
    def consumer_fetch_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_fetch_max_bytes")

    @property
    @pulumi.getter(name="consumerIsolationLevel")
    def consumer_isolation_level(self) -> Optional[str]:
        return pulumi.get(self, "consumer_isolation_level")

    @property
    @pulumi.getter(name="consumerMaxPartitionFetchBytes")
    def consumer_max_partition_fetch_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_partition_fetch_bytes")

    @property
    @pulumi.getter(name="consumerMaxPollIntervalMs")
    def consumer_max_poll_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_poll_interval_ms")

    @property
    @pulumi.getter(name="consumerMaxPollRecords")
    def consumer_max_poll_records(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_poll_records")

    @property
    @pulumi.getter(name="offsetFlushIntervalMs")
    def offset_flush_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "offset_flush_interval_ms")

    @property
    @pulumi.getter(name="offsetFlushTimeoutMs")
    def offset_flush_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "offset_flush_timeout_ms")

    @property
    @pulumi.getter(name="producerCompressionType")
    def producer_compression_type(self) -> Optional[str]:
        return pulumi.get(self, "producer_compression_type")

    @property
    @pulumi.getter(name="producerMaxRequestSize")
    def producer_max_request_size(self) -> Optional[str]:
        return pulumi.get(self, "producer_max_request_size")

    @property
    @pulumi.getter(name="sessionTimeoutMs")
    def session_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "session_timeout_ms")


@pulumi.output_type
class GetKafkaConnectKafkaConnectUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 kafka_connect: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetKafkaConnectKafkaConnectUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 jolokia: Optional[str] = None,
                 kafka_connect: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if jolokia is not None:
            pulumi.set(__self__, "jolokia", jolokia)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def jolokia(self) -> Optional[str]:
        return pulumi.get(self, "jolokia")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetKafkaConnectKafkaConnectUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 kafka_connect: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetKafkaConnectServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetKafkaConnectTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetKafkaConnectorTaskResult(dict):
    def __init__(__self__, *,
                 connector: str,
                 task: int):
        pulumi.set(__self__, "connector", connector)
        pulumi.set(__self__, "task", task)

    @property
    @pulumi.getter
    def connector(self) -> str:
        return pulumi.get(self, "connector")

    @property
    @pulumi.getter
    def task(self) -> int:
        return pulumi.get(self, "task")


@pulumi.output_type
class GetKafkaKafkaResult(dict):
    def __init__(__self__, *,
                 access_cert: str,
                 access_key: str,
                 connect_uri: str,
                 rest_uri: str,
                 schema_registry_uri: str):
        pulumi.set(__self__, "access_cert", access_cert)
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "connect_uri", connect_uri)
        pulumi.set(__self__, "rest_uri", rest_uri)
        pulumi.set(__self__, "schema_registry_uri", schema_registry_uri)

    @property
    @pulumi.getter(name="accessCert")
    def access_cert(self) -> str:
        return pulumi.get(self, "access_cert")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="connectUri")
    def connect_uri(self) -> str:
        return pulumi.get(self, "connect_uri")

    @property
    @pulumi.getter(name="restUri")
    def rest_uri(self) -> str:
        return pulumi.get(self, "rest_uri")

    @property
    @pulumi.getter(name="schemaRegistryUri")
    def schema_registry_uri(self) -> str:
        return pulumi.get(self, "schema_registry_uri")


@pulumi.output_type
class GetKafkaKafkaUserConfigResult(dict):
    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka: Optional['outputs.GetKafkaKafkaUserConfigKafkaResult'] = None,
                 kafka_authentication_methods: Optional['outputs.GetKafkaKafkaUserConfigKafkaAuthenticationMethodsResult'] = None,
                 kafka_connect: Optional[str] = None,
                 kafka_connect_config: Optional['outputs.GetKafkaKafkaUserConfigKafkaConnectConfigResult'] = None,
                 kafka_rest: Optional[str] = None,
                 kafka_rest_config: Optional['outputs.GetKafkaKafkaUserConfigKafkaRestConfigResult'] = None,
                 kafka_version: Optional[str] = None,
                 private_access: Optional['outputs.GetKafkaKafkaUserConfigPrivateAccessResult'] = None,
                 privatelink_access: Optional['outputs.GetKafkaKafkaUserConfigPrivatelinkAccessResult'] = None,
                 public_access: Optional['outputs.GetKafkaKafkaUserConfigPublicAccessResult'] = None,
                 schema_registry: Optional[str] = None,
                 schema_registry_config: Optional['outputs.GetKafkaKafkaUserConfigSchemaRegistryConfigResult'] = None,
                 static_ips: Optional[str] = None):
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kafka_authentication_methods is not None:
            pulumi.set(__self__, "kafka_authentication_methods", kafka_authentication_methods)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if kafka_connect_config is not None:
            pulumi.set(__self__, "kafka_connect_config", kafka_connect_config)
        if kafka_rest is not None:
            pulumi.set(__self__, "kafka_rest", kafka_rest)
        if kafka_rest_config is not None:
            pulumi.set(__self__, "kafka_rest_config", kafka_rest_config)
        if kafka_version is not None:
            pulumi.set(__self__, "kafka_version", kafka_version)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)
        if schema_registry_config is not None:
            pulumi.set(__self__, "schema_registry_config", schema_registry_config)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def kafka(self) -> Optional['outputs.GetKafkaKafkaUserConfigKafkaResult']:
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethods")
    def kafka_authentication_methods(self) -> Optional['outputs.GetKafkaKafkaUserConfigKafkaAuthenticationMethodsResult']:
        return pulumi.get(self, "kafka_authentication_methods")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter(name="kafkaConnectConfig")
    def kafka_connect_config(self) -> Optional['outputs.GetKafkaKafkaUserConfigKafkaConnectConfigResult']:
        return pulumi.get(self, "kafka_connect_config")

    @property
    @pulumi.getter(name="kafkaRest")
    def kafka_rest(self) -> Optional[str]:
        return pulumi.get(self, "kafka_rest")

    @property
    @pulumi.getter(name="kafkaRestConfig")
    def kafka_rest_config(self) -> Optional['outputs.GetKafkaKafkaUserConfigKafkaRestConfigResult']:
        return pulumi.get(self, "kafka_rest_config")

    @property
    @pulumi.getter(name="kafkaVersion")
    def kafka_version(self) -> Optional[str]:
        return pulumi.get(self, "kafka_version")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetKafkaKafkaUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetKafkaKafkaUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetKafkaKafkaUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[str]:
        return pulumi.get(self, "schema_registry")

    @property
    @pulumi.getter(name="schemaRegistryConfig")
    def schema_registry_config(self) -> Optional['outputs.GetKafkaKafkaUserConfigSchemaRegistryConfigResult']:
        return pulumi.get(self, "schema_registry_config")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetKafkaKafkaUserConfigKafkaResult(dict):
    def __init__(__self__, *,
                 auto_create_topics_enable: Optional[str] = None,
                 compression_type: Optional[str] = None,
                 connections_max_idle_ms: Optional[str] = None,
                 default_replication_factor: Optional[str] = None,
                 group_initial_rebalance_delay_ms: Optional[str] = None,
                 group_max_session_timeout_ms: Optional[str] = None,
                 group_min_session_timeout_ms: Optional[str] = None,
                 log_cleaner_delete_retention_ms: Optional[str] = None,
                 log_cleaner_max_compaction_lag_ms: Optional[str] = None,
                 log_cleaner_min_cleanable_ratio: Optional[str] = None,
                 log_cleaner_min_compaction_lag_ms: Optional[str] = None,
                 log_cleanup_policy: Optional[str] = None,
                 log_flush_interval_messages: Optional[str] = None,
                 log_flush_interval_ms: Optional[str] = None,
                 log_index_interval_bytes: Optional[str] = None,
                 log_index_size_max_bytes: Optional[str] = None,
                 log_message_downconversion_enable: Optional[str] = None,
                 log_message_timestamp_difference_max_ms: Optional[str] = None,
                 log_message_timestamp_type: Optional[str] = None,
                 log_preallocate: Optional[str] = None,
                 log_retention_bytes: Optional[str] = None,
                 log_retention_hours: Optional[str] = None,
                 log_retention_ms: Optional[str] = None,
                 log_roll_jitter_ms: Optional[str] = None,
                 log_roll_ms: Optional[str] = None,
                 log_segment_bytes: Optional[str] = None,
                 log_segment_delete_delay_ms: Optional[str] = None,
                 max_connections_per_ip: Optional[str] = None,
                 max_incremental_fetch_session_cache_slots: Optional[str] = None,
                 message_max_bytes: Optional[str] = None,
                 min_insync_replicas: Optional[str] = None,
                 num_partitions: Optional[str] = None,
                 offsets_retention_minutes: Optional[str] = None,
                 producer_purgatory_purge_interval_requests: Optional[str] = None,
                 replica_fetch_max_bytes: Optional[str] = None,
                 replica_fetch_response_max_bytes: Optional[str] = None,
                 socket_request_max_bytes: Optional[str] = None,
                 transaction_remove_expired_transaction_cleanup_interval_ms: Optional[str] = None,
                 transaction_state_log_segment_bytes: Optional[str] = None):
        if auto_create_topics_enable is not None:
            pulumi.set(__self__, "auto_create_topics_enable", auto_create_topics_enable)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if connections_max_idle_ms is not None:
            pulumi.set(__self__, "connections_max_idle_ms", connections_max_idle_ms)
        if default_replication_factor is not None:
            pulumi.set(__self__, "default_replication_factor", default_replication_factor)
        if group_initial_rebalance_delay_ms is not None:
            pulumi.set(__self__, "group_initial_rebalance_delay_ms", group_initial_rebalance_delay_ms)
        if group_max_session_timeout_ms is not None:
            pulumi.set(__self__, "group_max_session_timeout_ms", group_max_session_timeout_ms)
        if group_min_session_timeout_ms is not None:
            pulumi.set(__self__, "group_min_session_timeout_ms", group_min_session_timeout_ms)
        if log_cleaner_delete_retention_ms is not None:
            pulumi.set(__self__, "log_cleaner_delete_retention_ms", log_cleaner_delete_retention_ms)
        if log_cleaner_max_compaction_lag_ms is not None:
            pulumi.set(__self__, "log_cleaner_max_compaction_lag_ms", log_cleaner_max_compaction_lag_ms)
        if log_cleaner_min_cleanable_ratio is not None:
            pulumi.set(__self__, "log_cleaner_min_cleanable_ratio", log_cleaner_min_cleanable_ratio)
        if log_cleaner_min_compaction_lag_ms is not None:
            pulumi.set(__self__, "log_cleaner_min_compaction_lag_ms", log_cleaner_min_compaction_lag_ms)
        if log_cleanup_policy is not None:
            pulumi.set(__self__, "log_cleanup_policy", log_cleanup_policy)
        if log_flush_interval_messages is not None:
            pulumi.set(__self__, "log_flush_interval_messages", log_flush_interval_messages)
        if log_flush_interval_ms is not None:
            pulumi.set(__self__, "log_flush_interval_ms", log_flush_interval_ms)
        if log_index_interval_bytes is not None:
            pulumi.set(__self__, "log_index_interval_bytes", log_index_interval_bytes)
        if log_index_size_max_bytes is not None:
            pulumi.set(__self__, "log_index_size_max_bytes", log_index_size_max_bytes)
        if log_message_downconversion_enable is not None:
            pulumi.set(__self__, "log_message_downconversion_enable", log_message_downconversion_enable)
        if log_message_timestamp_difference_max_ms is not None:
            pulumi.set(__self__, "log_message_timestamp_difference_max_ms", log_message_timestamp_difference_max_ms)
        if log_message_timestamp_type is not None:
            pulumi.set(__self__, "log_message_timestamp_type", log_message_timestamp_type)
        if log_preallocate is not None:
            pulumi.set(__self__, "log_preallocate", log_preallocate)
        if log_retention_bytes is not None:
            pulumi.set(__self__, "log_retention_bytes", log_retention_bytes)
        if log_retention_hours is not None:
            pulumi.set(__self__, "log_retention_hours", log_retention_hours)
        if log_retention_ms is not None:
            pulumi.set(__self__, "log_retention_ms", log_retention_ms)
        if log_roll_jitter_ms is not None:
            pulumi.set(__self__, "log_roll_jitter_ms", log_roll_jitter_ms)
        if log_roll_ms is not None:
            pulumi.set(__self__, "log_roll_ms", log_roll_ms)
        if log_segment_bytes is not None:
            pulumi.set(__self__, "log_segment_bytes", log_segment_bytes)
        if log_segment_delete_delay_ms is not None:
            pulumi.set(__self__, "log_segment_delete_delay_ms", log_segment_delete_delay_ms)
        if max_connections_per_ip is not None:
            pulumi.set(__self__, "max_connections_per_ip", max_connections_per_ip)
        if max_incremental_fetch_session_cache_slots is not None:
            pulumi.set(__self__, "max_incremental_fetch_session_cache_slots", max_incremental_fetch_session_cache_slots)
        if message_max_bytes is not None:
            pulumi.set(__self__, "message_max_bytes", message_max_bytes)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if num_partitions is not None:
            pulumi.set(__self__, "num_partitions", num_partitions)
        if offsets_retention_minutes is not None:
            pulumi.set(__self__, "offsets_retention_minutes", offsets_retention_minutes)
        if producer_purgatory_purge_interval_requests is not None:
            pulumi.set(__self__, "producer_purgatory_purge_interval_requests", producer_purgatory_purge_interval_requests)
        if replica_fetch_max_bytes is not None:
            pulumi.set(__self__, "replica_fetch_max_bytes", replica_fetch_max_bytes)
        if replica_fetch_response_max_bytes is not None:
            pulumi.set(__self__, "replica_fetch_response_max_bytes", replica_fetch_response_max_bytes)
        if socket_request_max_bytes is not None:
            pulumi.set(__self__, "socket_request_max_bytes", socket_request_max_bytes)
        if transaction_remove_expired_transaction_cleanup_interval_ms is not None:
            pulumi.set(__self__, "transaction_remove_expired_transaction_cleanup_interval_ms", transaction_remove_expired_transaction_cleanup_interval_ms)
        if transaction_state_log_segment_bytes is not None:
            pulumi.set(__self__, "transaction_state_log_segment_bytes", transaction_state_log_segment_bytes)

    @property
    @pulumi.getter(name="autoCreateTopicsEnable")
    def auto_create_topics_enable(self) -> Optional[str]:
        return pulumi.get(self, "auto_create_topics_enable")

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        return pulumi.get(self, "compression_type")

    @property
    @pulumi.getter(name="connectionsMaxIdleMs")
    def connections_max_idle_ms(self) -> Optional[str]:
        return pulumi.get(self, "connections_max_idle_ms")

    @property
    @pulumi.getter(name="defaultReplicationFactor")
    def default_replication_factor(self) -> Optional[str]:
        return pulumi.get(self, "default_replication_factor")

    @property
    @pulumi.getter(name="groupInitialRebalanceDelayMs")
    def group_initial_rebalance_delay_ms(self) -> Optional[str]:
        return pulumi.get(self, "group_initial_rebalance_delay_ms")

    @property
    @pulumi.getter(name="groupMaxSessionTimeoutMs")
    def group_max_session_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "group_max_session_timeout_ms")

    @property
    @pulumi.getter(name="groupMinSessionTimeoutMs")
    def group_min_session_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "group_min_session_timeout_ms")

    @property
    @pulumi.getter(name="logCleanerDeleteRetentionMs")
    def log_cleaner_delete_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_cleaner_delete_retention_ms")

    @property
    @pulumi.getter(name="logCleanerMaxCompactionLagMs")
    def log_cleaner_max_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_cleaner_max_compaction_lag_ms")

    @property
    @pulumi.getter(name="logCleanerMinCleanableRatio")
    def log_cleaner_min_cleanable_ratio(self) -> Optional[str]:
        return pulumi.get(self, "log_cleaner_min_cleanable_ratio")

    @property
    @pulumi.getter(name="logCleanerMinCompactionLagMs")
    def log_cleaner_min_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_cleaner_min_compaction_lag_ms")

    @property
    @pulumi.getter(name="logCleanupPolicy")
    def log_cleanup_policy(self) -> Optional[str]:
        return pulumi.get(self, "log_cleanup_policy")

    @property
    @pulumi.getter(name="logFlushIntervalMessages")
    def log_flush_interval_messages(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_interval_messages")

    @property
    @pulumi.getter(name="logFlushIntervalMs")
    def log_flush_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_interval_ms")

    @property
    @pulumi.getter(name="logIndexIntervalBytes")
    def log_index_interval_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_index_interval_bytes")

    @property
    @pulumi.getter(name="logIndexSizeMaxBytes")
    def log_index_size_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_index_size_max_bytes")

    @property
    @pulumi.getter(name="logMessageDownconversionEnable")
    def log_message_downconversion_enable(self) -> Optional[str]:
        return pulumi.get(self, "log_message_downconversion_enable")

    @property
    @pulumi.getter(name="logMessageTimestampDifferenceMaxMs")
    def log_message_timestamp_difference_max_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_message_timestamp_difference_max_ms")

    @property
    @pulumi.getter(name="logMessageTimestampType")
    def log_message_timestamp_type(self) -> Optional[str]:
        return pulumi.get(self, "log_message_timestamp_type")

    @property
    @pulumi.getter(name="logPreallocate")
    def log_preallocate(self) -> Optional[str]:
        return pulumi.get(self, "log_preallocate")

    @property
    @pulumi.getter(name="logRetentionBytes")
    def log_retention_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_bytes")

    @property
    @pulumi.getter(name="logRetentionHours")
    def log_retention_hours(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_hours")

    @property
    @pulumi.getter(name="logRetentionMs")
    def log_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_ms")

    @property
    @pulumi.getter(name="logRollJitterMs")
    def log_roll_jitter_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_roll_jitter_ms")

    @property
    @pulumi.getter(name="logRollMs")
    def log_roll_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_roll_ms")

    @property
    @pulumi.getter(name="logSegmentBytes")
    def log_segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_segment_bytes")

    @property
    @pulumi.getter(name="logSegmentDeleteDelayMs")
    def log_segment_delete_delay_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_segment_delete_delay_ms")

    @property
    @pulumi.getter(name="maxConnectionsPerIp")
    def max_connections_per_ip(self) -> Optional[str]:
        return pulumi.get(self, "max_connections_per_ip")

    @property
    @pulumi.getter(name="maxIncrementalFetchSessionCacheSlots")
    def max_incremental_fetch_session_cache_slots(self) -> Optional[str]:
        return pulumi.get(self, "max_incremental_fetch_session_cache_slots")

    @property
    @pulumi.getter(name="messageMaxBytes")
    def message_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "message_max_bytes")

    @property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[str]:
        return pulumi.get(self, "min_insync_replicas")

    @property
    @pulumi.getter(name="numPartitions")
    def num_partitions(self) -> Optional[str]:
        return pulumi.get(self, "num_partitions")

    @property
    @pulumi.getter(name="offsetsRetentionMinutes")
    def offsets_retention_minutes(self) -> Optional[str]:
        return pulumi.get(self, "offsets_retention_minutes")

    @property
    @pulumi.getter(name="producerPurgatoryPurgeIntervalRequests")
    def producer_purgatory_purge_interval_requests(self) -> Optional[str]:
        return pulumi.get(self, "producer_purgatory_purge_interval_requests")

    @property
    @pulumi.getter(name="replicaFetchMaxBytes")
    def replica_fetch_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "replica_fetch_max_bytes")

    @property
    @pulumi.getter(name="replicaFetchResponseMaxBytes")
    def replica_fetch_response_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "replica_fetch_response_max_bytes")

    @property
    @pulumi.getter(name="socketRequestMaxBytes")
    def socket_request_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "socket_request_max_bytes")

    @property
    @pulumi.getter(name="transactionRemoveExpiredTransactionCleanupIntervalMs")
    def transaction_remove_expired_transaction_cleanup_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "transaction_remove_expired_transaction_cleanup_interval_ms")

    @property
    @pulumi.getter(name="transactionStateLogSegmentBytes")
    def transaction_state_log_segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "transaction_state_log_segment_bytes")


@pulumi.output_type
class GetKafkaKafkaUserConfigKafkaAuthenticationMethodsResult(dict):
    def __init__(__self__, *,
                 certificate: Optional[str] = None,
                 sasl: Optional[str] = None):
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if sasl is not None:
            pulumi.set(__self__, "sasl", sasl)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def sasl(self) -> Optional[str]:
        return pulumi.get(self, "sasl")


@pulumi.output_type
class GetKafkaKafkaUserConfigKafkaConnectConfigResult(dict):
    def __init__(__self__, *,
                 connector_client_config_override_policy: Optional[str] = None,
                 consumer_auto_offset_reset: Optional[str] = None,
                 consumer_fetch_max_bytes: Optional[str] = None,
                 consumer_isolation_level: Optional[str] = None,
                 consumer_max_partition_fetch_bytes: Optional[str] = None,
                 consumer_max_poll_interval_ms: Optional[str] = None,
                 consumer_max_poll_records: Optional[str] = None,
                 offset_flush_interval_ms: Optional[str] = None,
                 offset_flush_timeout_ms: Optional[str] = None,
                 producer_compression_type: Optional[str] = None,
                 producer_max_request_size: Optional[str] = None,
                 session_timeout_ms: Optional[str] = None):
        if connector_client_config_override_policy is not None:
            pulumi.set(__self__, "connector_client_config_override_policy", connector_client_config_override_policy)
        if consumer_auto_offset_reset is not None:
            pulumi.set(__self__, "consumer_auto_offset_reset", consumer_auto_offset_reset)
        if consumer_fetch_max_bytes is not None:
            pulumi.set(__self__, "consumer_fetch_max_bytes", consumer_fetch_max_bytes)
        if consumer_isolation_level is not None:
            pulumi.set(__self__, "consumer_isolation_level", consumer_isolation_level)
        if consumer_max_partition_fetch_bytes is not None:
            pulumi.set(__self__, "consumer_max_partition_fetch_bytes", consumer_max_partition_fetch_bytes)
        if consumer_max_poll_interval_ms is not None:
            pulumi.set(__self__, "consumer_max_poll_interval_ms", consumer_max_poll_interval_ms)
        if consumer_max_poll_records is not None:
            pulumi.set(__self__, "consumer_max_poll_records", consumer_max_poll_records)
        if offset_flush_interval_ms is not None:
            pulumi.set(__self__, "offset_flush_interval_ms", offset_flush_interval_ms)
        if offset_flush_timeout_ms is not None:
            pulumi.set(__self__, "offset_flush_timeout_ms", offset_flush_timeout_ms)
        if producer_compression_type is not None:
            pulumi.set(__self__, "producer_compression_type", producer_compression_type)
        if producer_max_request_size is not None:
            pulumi.set(__self__, "producer_max_request_size", producer_max_request_size)
        if session_timeout_ms is not None:
            pulumi.set(__self__, "session_timeout_ms", session_timeout_ms)

    @property
    @pulumi.getter(name="connectorClientConfigOverridePolicy")
    def connector_client_config_override_policy(self) -> Optional[str]:
        return pulumi.get(self, "connector_client_config_override_policy")

    @property
    @pulumi.getter(name="consumerAutoOffsetReset")
    def consumer_auto_offset_reset(self) -> Optional[str]:
        return pulumi.get(self, "consumer_auto_offset_reset")

    @property
    @pulumi.getter(name="consumerFetchMaxBytes")
    def consumer_fetch_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_fetch_max_bytes")

    @property
    @pulumi.getter(name="consumerIsolationLevel")
    def consumer_isolation_level(self) -> Optional[str]:
        return pulumi.get(self, "consumer_isolation_level")

    @property
    @pulumi.getter(name="consumerMaxPartitionFetchBytes")
    def consumer_max_partition_fetch_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_partition_fetch_bytes")

    @property
    @pulumi.getter(name="consumerMaxPollIntervalMs")
    def consumer_max_poll_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_poll_interval_ms")

    @property
    @pulumi.getter(name="consumerMaxPollRecords")
    def consumer_max_poll_records(self) -> Optional[str]:
        return pulumi.get(self, "consumer_max_poll_records")

    @property
    @pulumi.getter(name="offsetFlushIntervalMs")
    def offset_flush_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "offset_flush_interval_ms")

    @property
    @pulumi.getter(name="offsetFlushTimeoutMs")
    def offset_flush_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "offset_flush_timeout_ms")

    @property
    @pulumi.getter(name="producerCompressionType")
    def producer_compression_type(self) -> Optional[str]:
        return pulumi.get(self, "producer_compression_type")

    @property
    @pulumi.getter(name="producerMaxRequestSize")
    def producer_max_request_size(self) -> Optional[str]:
        return pulumi.get(self, "producer_max_request_size")

    @property
    @pulumi.getter(name="sessionTimeoutMs")
    def session_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "session_timeout_ms")


@pulumi.output_type
class GetKafkaKafkaUserConfigKafkaRestConfigResult(dict):
    def __init__(__self__, *,
                 consumer_enable_auto_commit: Optional[str] = None,
                 consumer_request_max_bytes: Optional[str] = None,
                 consumer_request_timeout_ms: Optional[str] = None,
                 producer_acks: Optional[str] = None,
                 producer_linger_ms: Optional[str] = None,
                 simpleconsumer_pool_size_max: Optional[str] = None):
        if consumer_enable_auto_commit is not None:
            pulumi.set(__self__, "consumer_enable_auto_commit", consumer_enable_auto_commit)
        if consumer_request_max_bytes is not None:
            pulumi.set(__self__, "consumer_request_max_bytes", consumer_request_max_bytes)
        if consumer_request_timeout_ms is not None:
            pulumi.set(__self__, "consumer_request_timeout_ms", consumer_request_timeout_ms)
        if producer_acks is not None:
            pulumi.set(__self__, "producer_acks", producer_acks)
        if producer_linger_ms is not None:
            pulumi.set(__self__, "producer_linger_ms", producer_linger_ms)
        if simpleconsumer_pool_size_max is not None:
            pulumi.set(__self__, "simpleconsumer_pool_size_max", simpleconsumer_pool_size_max)

    @property
    @pulumi.getter(name="consumerEnableAutoCommit")
    def consumer_enable_auto_commit(self) -> Optional[str]:
        return pulumi.get(self, "consumer_enable_auto_commit")

    @property
    @pulumi.getter(name="consumerRequestMaxBytes")
    def consumer_request_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_request_max_bytes")

    @property
    @pulumi.getter(name="consumerRequestTimeoutMs")
    def consumer_request_timeout_ms(self) -> Optional[str]:
        return pulumi.get(self, "consumer_request_timeout_ms")

    @property
    @pulumi.getter(name="producerAcks")
    def producer_acks(self) -> Optional[str]:
        return pulumi.get(self, "producer_acks")

    @property
    @pulumi.getter(name="producerLingerMs")
    def producer_linger_ms(self) -> Optional[str]:
        return pulumi.get(self, "producer_linger_ms")

    @property
    @pulumi.getter(name="simpleconsumerPoolSizeMax")
    def simpleconsumer_pool_size_max(self) -> Optional[str]:
        return pulumi.get(self, "simpleconsumer_pool_size_max")


@pulumi.output_type
class GetKafkaKafkaUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetKafkaKafkaUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 jolokia: Optional[str] = None,
                 kafka: Optional[str] = None,
                 kafka_connect: Optional[str] = None,
                 kafka_rest: Optional[str] = None,
                 prometheus: Optional[str] = None,
                 schema_registry: Optional[str] = None):
        if jolokia is not None:
            pulumi.set(__self__, "jolokia", jolokia)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if kafka_rest is not None:
            pulumi.set(__self__, "kafka_rest", kafka_rest)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)

    @property
    @pulumi.getter
    def jolokia(self) -> Optional[str]:
        return pulumi.get(self, "jolokia")

    @property
    @pulumi.getter
    def kafka(self) -> Optional[str]:
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter(name="kafkaRest")
    def kafka_rest(self) -> Optional[str]:
        return pulumi.get(self, "kafka_rest")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[str]:
        return pulumi.get(self, "schema_registry")


@pulumi.output_type
class GetKafkaKafkaUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 kafka: Optional[str] = None,
                 kafka_connect: Optional[str] = None,
                 kafka_rest: Optional[str] = None,
                 prometheus: Optional[str] = None,
                 schema_registry: Optional[str] = None):
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)
        if kafka_rest is not None:
            pulumi.set(__self__, "kafka_rest", kafka_rest)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)

    @property
    @pulumi.getter
    def kafka(self) -> Optional[str]:
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional[str]:
        return pulumi.get(self, "kafka_connect")

    @property
    @pulumi.getter(name="kafkaRest")
    def kafka_rest(self) -> Optional[str]:
        return pulumi.get(self, "kafka_rest")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[str]:
        return pulumi.get(self, "schema_registry")


@pulumi.output_type
class GetKafkaKafkaUserConfigSchemaRegistryConfigResult(dict):
    def __init__(__self__, *,
                 leader_eligibility: Optional[str] = None,
                 topic_name: Optional[str] = None):
        if leader_eligibility is not None:
            pulumi.set(__self__, "leader_eligibility", leader_eligibility)
        if topic_name is not None:
            pulumi.set(__self__, "topic_name", topic_name)

    @property
    @pulumi.getter(name="leaderEligibility")
    def leader_eligibility(self) -> Optional[str]:
        return pulumi.get(self, "leader_eligibility")

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> Optional[str]:
        return pulumi.get(self, "topic_name")


@pulumi.output_type
class GetKafkaMirrorMakerComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetKafkaMirrorMakerKafkaMirrormakerResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetKafkaMirrorMakerKafkaMirrormakerUserConfigResult(dict):
    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka_mirrormaker: Optional['outputs.GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormakerResult'] = None,
                 static_ips: Optional[str] = None):
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka_mirrormaker is not None:
            pulumi.set(__self__, "kafka_mirrormaker", kafka_mirrormaker)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="kafkaMirrormaker")
    def kafka_mirrormaker(self) -> Optional['outputs.GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormakerResult']:
        return pulumi.get(self, "kafka_mirrormaker")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetKafkaMirrorMakerKafkaMirrormakerUserConfigKafkaMirrormakerResult(dict):
    def __init__(__self__, *,
                 emit_checkpoints_enabled: Optional[str] = None,
                 emit_checkpoints_interval_seconds: Optional[str] = None,
                 refresh_groups_enabled: Optional[str] = None,
                 refresh_groups_interval_seconds: Optional[str] = None,
                 refresh_topics_enabled: Optional[str] = None,
                 refresh_topics_interval_seconds: Optional[str] = None,
                 sync_group_offsets_enabled: Optional[str] = None,
                 sync_group_offsets_interval_seconds: Optional[str] = None,
                 sync_topic_configs_enabled: Optional[str] = None,
                 tasks_max_per_cpu: Optional[str] = None):
        if emit_checkpoints_enabled is not None:
            pulumi.set(__self__, "emit_checkpoints_enabled", emit_checkpoints_enabled)
        if emit_checkpoints_interval_seconds is not None:
            pulumi.set(__self__, "emit_checkpoints_interval_seconds", emit_checkpoints_interval_seconds)
        if refresh_groups_enabled is not None:
            pulumi.set(__self__, "refresh_groups_enabled", refresh_groups_enabled)
        if refresh_groups_interval_seconds is not None:
            pulumi.set(__self__, "refresh_groups_interval_seconds", refresh_groups_interval_seconds)
        if refresh_topics_enabled is not None:
            pulumi.set(__self__, "refresh_topics_enabled", refresh_topics_enabled)
        if refresh_topics_interval_seconds is not None:
            pulumi.set(__self__, "refresh_topics_interval_seconds", refresh_topics_interval_seconds)
        if sync_group_offsets_enabled is not None:
            pulumi.set(__self__, "sync_group_offsets_enabled", sync_group_offsets_enabled)
        if sync_group_offsets_interval_seconds is not None:
            pulumi.set(__self__, "sync_group_offsets_interval_seconds", sync_group_offsets_interval_seconds)
        if sync_topic_configs_enabled is not None:
            pulumi.set(__self__, "sync_topic_configs_enabled", sync_topic_configs_enabled)
        if tasks_max_per_cpu is not None:
            pulumi.set(__self__, "tasks_max_per_cpu", tasks_max_per_cpu)

    @property
    @pulumi.getter(name="emitCheckpointsEnabled")
    def emit_checkpoints_enabled(self) -> Optional[str]:
        return pulumi.get(self, "emit_checkpoints_enabled")

    @property
    @pulumi.getter(name="emitCheckpointsIntervalSeconds")
    def emit_checkpoints_interval_seconds(self) -> Optional[str]:
        return pulumi.get(self, "emit_checkpoints_interval_seconds")

    @property
    @pulumi.getter(name="refreshGroupsEnabled")
    def refresh_groups_enabled(self) -> Optional[str]:
        return pulumi.get(self, "refresh_groups_enabled")

    @property
    @pulumi.getter(name="refreshGroupsIntervalSeconds")
    def refresh_groups_interval_seconds(self) -> Optional[str]:
        return pulumi.get(self, "refresh_groups_interval_seconds")

    @property
    @pulumi.getter(name="refreshTopicsEnabled")
    def refresh_topics_enabled(self) -> Optional[str]:
        return pulumi.get(self, "refresh_topics_enabled")

    @property
    @pulumi.getter(name="refreshTopicsIntervalSeconds")
    def refresh_topics_interval_seconds(self) -> Optional[str]:
        return pulumi.get(self, "refresh_topics_interval_seconds")

    @property
    @pulumi.getter(name="syncGroupOffsetsEnabled")
    def sync_group_offsets_enabled(self) -> Optional[str]:
        return pulumi.get(self, "sync_group_offsets_enabled")

    @property
    @pulumi.getter(name="syncGroupOffsetsIntervalSeconds")
    def sync_group_offsets_interval_seconds(self) -> Optional[str]:
        return pulumi.get(self, "sync_group_offsets_interval_seconds")

    @property
    @pulumi.getter(name="syncTopicConfigsEnabled")
    def sync_topic_configs_enabled(self) -> Optional[str]:
        return pulumi.get(self, "sync_topic_configs_enabled")

    @property
    @pulumi.getter(name="tasksMaxPerCpu")
    def tasks_max_per_cpu(self) -> Optional[str]:
        return pulumi.get(self, "tasks_max_per_cpu")


@pulumi.output_type
class GetKafkaMirrorMakerServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetKafkaMirrorMakerTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetKafkaServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetKafkaTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetKafkaTopicConfigResult(dict):
    def __init__(__self__, *,
                 cleanup_policy: Optional[str] = None,
                 compression_type: Optional[str] = None,
                 delete_retention_ms: Optional[str] = None,
                 file_delete_delay_ms: Optional[str] = None,
                 flush_messages: Optional[str] = None,
                 flush_ms: Optional[str] = None,
                 index_interval_bytes: Optional[str] = None,
                 max_compaction_lag_ms: Optional[str] = None,
                 max_message_bytes: Optional[str] = None,
                 message_downconversion_enable: Optional[str] = None,
                 message_format_version: Optional[str] = None,
                 message_timestamp_difference_max_ms: Optional[str] = None,
                 message_timestamp_type: Optional[str] = None,
                 min_cleanable_dirty_ratio: Optional[str] = None,
                 min_compaction_lag_ms: Optional[str] = None,
                 min_insync_replicas: Optional[str] = None,
                 preallocate: Optional[str] = None,
                 retention_bytes: Optional[str] = None,
                 retention_ms: Optional[str] = None,
                 segment_bytes: Optional[str] = None,
                 segment_index_bytes: Optional[str] = None,
                 segment_jitter_ms: Optional[str] = None,
                 segment_ms: Optional[str] = None,
                 unclean_leader_election_enable: Optional[str] = None):
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if delete_retention_ms is not None:
            pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        if file_delete_delay_ms is not None:
            pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        if flush_messages is not None:
            pulumi.set(__self__, "flush_messages", flush_messages)
        if flush_ms is not None:
            pulumi.set(__self__, "flush_ms", flush_ms)
        if index_interval_bytes is not None:
            pulumi.set(__self__, "index_interval_bytes", index_interval_bytes)
        if max_compaction_lag_ms is not None:
            pulumi.set(__self__, "max_compaction_lag_ms", max_compaction_lag_ms)
        if max_message_bytes is not None:
            pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        if message_downconversion_enable is not None:
            pulumi.set(__self__, "message_downconversion_enable", message_downconversion_enable)
        if message_format_version is not None:
            pulumi.set(__self__, "message_format_version", message_format_version)
        if message_timestamp_difference_max_ms is not None:
            pulumi.set(__self__, "message_timestamp_difference_max_ms", message_timestamp_difference_max_ms)
        if message_timestamp_type is not None:
            pulumi.set(__self__, "message_timestamp_type", message_timestamp_type)
        if min_cleanable_dirty_ratio is not None:
            pulumi.set(__self__, "min_cleanable_dirty_ratio", min_cleanable_dirty_ratio)
        if min_compaction_lag_ms is not None:
            pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if preallocate is not None:
            pulumi.set(__self__, "preallocate", preallocate)
        if retention_bytes is not None:
            pulumi.set(__self__, "retention_bytes", retention_bytes)
        if retention_ms is not None:
            pulumi.set(__self__, "retention_ms", retention_ms)
        if segment_bytes is not None:
            pulumi.set(__self__, "segment_bytes", segment_bytes)
        if segment_index_bytes is not None:
            pulumi.set(__self__, "segment_index_bytes", segment_index_bytes)
        if segment_jitter_ms is not None:
            pulumi.set(__self__, "segment_jitter_ms", segment_jitter_ms)
        if segment_ms is not None:
            pulumi.set(__self__, "segment_ms", segment_ms)
        if unclean_leader_election_enable is not None:
            pulumi.set(__self__, "unclean_leader_election_enable", unclean_leader_election_enable)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[str]:
        return pulumi.get(self, "cleanup_policy")

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        return pulumi.get(self, "compression_type")

    @property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "delete_retention_ms")

    @property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> Optional[str]:
        return pulumi.get(self, "file_delete_delay_ms")

    @property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> Optional[str]:
        return pulumi.get(self, "flush_messages")

    @property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> Optional[str]:
        return pulumi.get(self, "flush_ms")

    @property
    @pulumi.getter(name="indexIntervalBytes")
    def index_interval_bytes(self) -> Optional[str]:
        return pulumi.get(self, "index_interval_bytes")

    @property
    @pulumi.getter(name="maxCompactionLagMs")
    def max_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "max_compaction_lag_ms")

    @property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> Optional[str]:
        return pulumi.get(self, "max_message_bytes")

    @property
    @pulumi.getter(name="messageDownconversionEnable")
    def message_downconversion_enable(self) -> Optional[str]:
        return pulumi.get(self, "message_downconversion_enable")

    @property
    @pulumi.getter(name="messageFormatVersion")
    def message_format_version(self) -> Optional[str]:
        return pulumi.get(self, "message_format_version")

    @property
    @pulumi.getter(name="messageTimestampDifferenceMaxMs")
    def message_timestamp_difference_max_ms(self) -> Optional[str]:
        return pulumi.get(self, "message_timestamp_difference_max_ms")

    @property
    @pulumi.getter(name="messageTimestampType")
    def message_timestamp_type(self) -> Optional[str]:
        return pulumi.get(self, "message_timestamp_type")

    @property
    @pulumi.getter(name="minCleanableDirtyRatio")
    def min_cleanable_dirty_ratio(self) -> Optional[str]:
        return pulumi.get(self, "min_cleanable_dirty_ratio")

    @property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "min_compaction_lag_ms")

    @property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[str]:
        return pulumi.get(self, "min_insync_replicas")

    @property
    @pulumi.getter
    def preallocate(self) -> Optional[str]:
        return pulumi.get(self, "preallocate")

    @property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> Optional[str]:
        return pulumi.get(self, "retention_bytes")

    @property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "retention_ms")

    @property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "segment_bytes")

    @property
    @pulumi.getter(name="segmentIndexBytes")
    def segment_index_bytes(self) -> Optional[str]:
        return pulumi.get(self, "segment_index_bytes")

    @property
    @pulumi.getter(name="segmentJitterMs")
    def segment_jitter_ms(self) -> Optional[str]:
        return pulumi.get(self, "segment_jitter_ms")

    @property
    @pulumi.getter(name="segmentMs")
    def segment_ms(self) -> Optional[str]:
        return pulumi.get(self, "segment_ms")

    @property
    @pulumi.getter(name="uncleanLeaderElectionEnable")
    def unclean_leader_election_enable(self) -> Optional[str]:
        return pulumi.get(self, "unclean_leader_election_enable")


@pulumi.output_type
class GetKafkaTopicTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetM3AggregatorComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetM3AggregatorM3aggregatorResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetM3AggregatorM3aggregatorUserConfigResult(dict):
    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 m3_version: Optional[str] = None,
                 m3aggregator_version: Optional[str] = None,
                 static_ips: Optional[str] = None):
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if m3_version is not None:
            pulumi.set(__self__, "m3_version", m3_version)
        if m3aggregator_version is not None:
            pulumi.set(__self__, "m3aggregator_version", m3aggregator_version)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="m3Version")
    def m3_version(self) -> Optional[str]:
        return pulumi.get(self, "m3_version")

    @property
    @pulumi.getter(name="m3aggregatorVersion")
    def m3aggregator_version(self) -> Optional[str]:
        return pulumi.get(self, "m3aggregator_version")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetM3AggregatorServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetM3AggregatorTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetM3DbComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetM3DbM3dbResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetM3DbM3dbUserConfigResult(dict):
    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 limits: Optional['outputs.GetM3DbM3dbUserConfigLimitsResult'] = None,
                 m3_version: Optional[str] = None,
                 m3coordinator_enable_graphite_carbon_ingest: Optional[str] = None,
                 m3db_version: Optional[str] = None,
                 namespaces: Optional[Sequence['outputs.GetM3DbM3dbUserConfigNamespaceResult']] = None,
                 private_access: Optional['outputs.GetM3DbM3dbUserConfigPrivateAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetM3DbM3dbUserConfigPublicAccessResult'] = None,
                 rules: Optional['outputs.GetM3DbM3dbUserConfigRulesResult'] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if m3_version is not None:
            pulumi.set(__self__, "m3_version", m3_version)
        if m3coordinator_enable_graphite_carbon_ingest is not None:
            pulumi.set(__self__, "m3coordinator_enable_graphite_carbon_ingest", m3coordinator_enable_graphite_carbon_ingest)
        if m3db_version is not None:
            pulumi.set(__self__, "m3db_version", m3db_version)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def limits(self) -> Optional['outputs.GetM3DbM3dbUserConfigLimitsResult']:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter(name="m3Version")
    def m3_version(self) -> Optional[str]:
        return pulumi.get(self, "m3_version")

    @property
    @pulumi.getter(name="m3coordinatorEnableGraphiteCarbonIngest")
    def m3coordinator_enable_graphite_carbon_ingest(self) -> Optional[str]:
        return pulumi.get(self, "m3coordinator_enable_graphite_carbon_ingest")

    @property
    @pulumi.getter(name="m3dbVersion")
    def m3db_version(self) -> Optional[str]:
        return pulumi.get(self, "m3db_version")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence['outputs.GetM3DbM3dbUserConfigNamespaceResult']]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetM3DbM3dbUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetM3DbM3dbUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter
    def rules(self) -> Optional['outputs.GetM3DbM3dbUserConfigRulesResult']:
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetM3DbM3dbUserConfigLimitsResult(dict):
    def __init__(__self__, *,
                 query_require_exhaustive: Optional[str] = None,
                 query_series: Optional[str] = None):
        if query_require_exhaustive is not None:
            pulumi.set(__self__, "query_require_exhaustive", query_require_exhaustive)
        if query_series is not None:
            pulumi.set(__self__, "query_series", query_series)

    @property
    @pulumi.getter(name="queryRequireExhaustive")
    def query_require_exhaustive(self) -> Optional[str]:
        return pulumi.get(self, "query_require_exhaustive")

    @property
    @pulumi.getter(name="querySeries")
    def query_series(self) -> Optional[str]:
        return pulumi.get(self, "query_series")


@pulumi.output_type
class GetM3DbM3dbUserConfigNamespaceResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 options: Optional['outputs.GetM3DbM3dbUserConfigNamespaceOptionsResult'] = None,
                 resolution: Optional[str] = None,
                 type: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def options(self) -> Optional['outputs.GetM3DbM3dbUserConfigNamespaceOptionsResult']:
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def resolution(self) -> Optional[str]:
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetM3DbM3dbUserConfigNamespaceOptionsResult(dict):
    def __init__(__self__, *,
                 retention_options: Optional['outputs.GetM3DbM3dbUserConfigNamespaceOptionsRetentionOptionsResult'] = None,
                 snapshot_enabled: Optional[str] = None,
                 writes_to_commitlog: Optional[str] = None):
        if retention_options is not None:
            pulumi.set(__self__, "retention_options", retention_options)
        if snapshot_enabled is not None:
            pulumi.set(__self__, "snapshot_enabled", snapshot_enabled)
        if writes_to_commitlog is not None:
            pulumi.set(__self__, "writes_to_commitlog", writes_to_commitlog)

    @property
    @pulumi.getter(name="retentionOptions")
    def retention_options(self) -> Optional['outputs.GetM3DbM3dbUserConfigNamespaceOptionsRetentionOptionsResult']:
        return pulumi.get(self, "retention_options")

    @property
    @pulumi.getter(name="snapshotEnabled")
    def snapshot_enabled(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_enabled")

    @property
    @pulumi.getter(name="writesToCommitlog")
    def writes_to_commitlog(self) -> Optional[str]:
        return pulumi.get(self, "writes_to_commitlog")


@pulumi.output_type
class GetM3DbM3dbUserConfigNamespaceOptionsRetentionOptionsResult(dict):
    def __init__(__self__, *,
                 block_data_expiry_duration: Optional[str] = None,
                 blocksize_duration: Optional[str] = None,
                 buffer_future_duration: Optional[str] = None,
                 buffer_past_duration: Optional[str] = None,
                 retention_period_duration: Optional[str] = None):
        if block_data_expiry_duration is not None:
            pulumi.set(__self__, "block_data_expiry_duration", block_data_expiry_duration)
        if blocksize_duration is not None:
            pulumi.set(__self__, "blocksize_duration", blocksize_duration)
        if buffer_future_duration is not None:
            pulumi.set(__self__, "buffer_future_duration", buffer_future_duration)
        if buffer_past_duration is not None:
            pulumi.set(__self__, "buffer_past_duration", buffer_past_duration)
        if retention_period_duration is not None:
            pulumi.set(__self__, "retention_period_duration", retention_period_duration)

    @property
    @pulumi.getter(name="blockDataExpiryDuration")
    def block_data_expiry_duration(self) -> Optional[str]:
        return pulumi.get(self, "block_data_expiry_duration")

    @property
    @pulumi.getter(name="blocksizeDuration")
    def blocksize_duration(self) -> Optional[str]:
        return pulumi.get(self, "blocksize_duration")

    @property
    @pulumi.getter(name="bufferFutureDuration")
    def buffer_future_duration(self) -> Optional[str]:
        return pulumi.get(self, "buffer_future_duration")

    @property
    @pulumi.getter(name="bufferPastDuration")
    def buffer_past_duration(self) -> Optional[str]:
        return pulumi.get(self, "buffer_past_duration")

    @property
    @pulumi.getter(name="retentionPeriodDuration")
    def retention_period_duration(self) -> Optional[str]:
        return pulumi.get(self, "retention_period_duration")


@pulumi.output_type
class GetM3DbM3dbUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 m3coordinator: Optional[str] = None):
        if m3coordinator is not None:
            pulumi.set(__self__, "m3coordinator", m3coordinator)

    @property
    @pulumi.getter
    def m3coordinator(self) -> Optional[str]:
        return pulumi.get(self, "m3coordinator")


@pulumi.output_type
class GetM3DbM3dbUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 m3coordinator: Optional[str] = None):
        if m3coordinator is not None:
            pulumi.set(__self__, "m3coordinator", m3coordinator)

    @property
    @pulumi.getter
    def m3coordinator(self) -> Optional[str]:
        return pulumi.get(self, "m3coordinator")


@pulumi.output_type
class GetM3DbM3dbUserConfigRulesResult(dict):
    def __init__(__self__, *,
                 mappings: Optional[Sequence['outputs.GetM3DbM3dbUserConfigRulesMappingResult']] = None):
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter
    def mappings(self) -> Optional[Sequence['outputs.GetM3DbM3dbUserConfigRulesMappingResult']]:
        return pulumi.get(self, "mappings")


@pulumi.output_type
class GetM3DbM3dbUserConfigRulesMappingResult(dict):
    def __init__(__self__, *,
                 aggregations: Optional[Sequence[str]] = None,
                 drop: Optional[str] = None,
                 filter: Optional[str] = None,
                 name: Optional[str] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence['outputs.GetM3DbM3dbUserConfigRulesMappingTagResult']] = None):
        if aggregations is not None:
            pulumi.set(__self__, "aggregations", aggregations)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def aggregations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "aggregations")

    @property
    @pulumi.getter
    def drop(self) -> Optional[str]:
        return pulumi.get(self, "drop")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.GetM3DbM3dbUserConfigRulesMappingTagResult']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetM3DbM3dbUserConfigRulesMappingTagResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetM3DbServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetM3DbTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetMySqlComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetMySqlMysqlResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMySqlMysqlUserConfigResult(dict):
    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_hour: Optional[str] = None,
                 backup_minute: Optional[str] = None,
                 binlog_retention_period: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 migration: Optional['outputs.GetMySqlMysqlUserConfigMigrationResult'] = None,
                 mysql: Optional['outputs.GetMySqlMysqlUserConfigMysqlResult'] = None,
                 mysql_version: Optional[str] = None,
                 private_access: Optional['outputs.GetMySqlMysqlUserConfigPrivateAccessResult'] = None,
                 privatelink_access: Optional['outputs.GetMySqlMysqlUserConfigPrivatelinkAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetMySqlMysqlUserConfigPublicAccessResult'] = None,
                 recovery_target_time: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if binlog_retention_period is not None:
            pulumi.set(__self__, "binlog_retention_period", binlog_retention_period)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if mysql_version is not None:
            pulumi.set(__self__, "mysql_version", mysql_version)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_target_time is not None:
            pulumi.set(__self__, "recovery_target_time", recovery_target_time)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[str]:
        return pulumi.get(self, "backup_hour")

    @property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[str]:
        return pulumi.get(self, "backup_minute")

    @property
    @pulumi.getter(name="binlogRetentionPeriod")
    def binlog_retention_period(self) -> Optional[str]:
        return pulumi.get(self, "binlog_retention_period")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def migration(self) -> Optional['outputs.GetMySqlMysqlUserConfigMigrationResult']:
        return pulumi.get(self, "migration")

    @property
    @pulumi.getter
    def mysql(self) -> Optional['outputs.GetMySqlMysqlUserConfigMysqlResult']:
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter(name="mysqlVersion")
    def mysql_version(self) -> Optional[str]:
        return pulumi.get(self, "mysql_version")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetMySqlMysqlUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetMySqlMysqlUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetMySqlMysqlUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryTargetTime")
    def recovery_target_time(self) -> Optional[str]:
        return pulumi.get(self, "recovery_target_time")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetMySqlMysqlUserConfigMigrationResult(dict):
    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 ignore_dbs: Optional[str] = None,
                 method: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 ssl: Optional[str] = None,
                 username: Optional[str] = None):
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[str]:
        return pulumi.get(self, "ignore_dbs")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetMySqlMysqlUserConfigMysqlResult(dict):
    def __init__(__self__, *,
                 connect_timeout: Optional[str] = None,
                 default_time_zone: Optional[str] = None,
                 group_concat_max_len: Optional[str] = None,
                 information_schema_stats_expiry: Optional[str] = None,
                 innodb_ft_min_token_size: Optional[str] = None,
                 innodb_ft_server_stopword_table: Optional[str] = None,
                 innodb_lock_wait_timeout: Optional[str] = None,
                 innodb_log_buffer_size: Optional[str] = None,
                 innodb_online_alter_log_max_size: Optional[str] = None,
                 innodb_print_all_deadlocks: Optional[str] = None,
                 innodb_rollback_on_timeout: Optional[str] = None,
                 interactive_timeout: Optional[str] = None,
                 internal_tmp_mem_storage_engine: Optional[str] = None,
                 long_query_time: Optional[str] = None,
                 max_allowed_packet: Optional[str] = None,
                 max_heap_table_size: Optional[str] = None,
                 net_read_timeout: Optional[str] = None,
                 net_write_timeout: Optional[str] = None,
                 slow_query_log: Optional[str] = None,
                 sort_buffer_size: Optional[str] = None,
                 sql_mode: Optional[str] = None,
                 sql_require_primary_key: Optional[str] = None,
                 tmp_table_size: Optional[str] = None,
                 wait_timeout: Optional[str] = None):
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if default_time_zone is not None:
            pulumi.set(__self__, "default_time_zone", default_time_zone)
        if group_concat_max_len is not None:
            pulumi.set(__self__, "group_concat_max_len", group_concat_max_len)
        if information_schema_stats_expiry is not None:
            pulumi.set(__self__, "information_schema_stats_expiry", information_schema_stats_expiry)
        if innodb_ft_min_token_size is not None:
            pulumi.set(__self__, "innodb_ft_min_token_size", innodb_ft_min_token_size)
        if innodb_ft_server_stopword_table is not None:
            pulumi.set(__self__, "innodb_ft_server_stopword_table", innodb_ft_server_stopword_table)
        if innodb_lock_wait_timeout is not None:
            pulumi.set(__self__, "innodb_lock_wait_timeout", innodb_lock_wait_timeout)
        if innodb_log_buffer_size is not None:
            pulumi.set(__self__, "innodb_log_buffer_size", innodb_log_buffer_size)
        if innodb_online_alter_log_max_size is not None:
            pulumi.set(__self__, "innodb_online_alter_log_max_size", innodb_online_alter_log_max_size)
        if innodb_print_all_deadlocks is not None:
            pulumi.set(__self__, "innodb_print_all_deadlocks", innodb_print_all_deadlocks)
        if innodb_rollback_on_timeout is not None:
            pulumi.set(__self__, "innodb_rollback_on_timeout", innodb_rollback_on_timeout)
        if interactive_timeout is not None:
            pulumi.set(__self__, "interactive_timeout", interactive_timeout)
        if internal_tmp_mem_storage_engine is not None:
            pulumi.set(__self__, "internal_tmp_mem_storage_engine", internal_tmp_mem_storage_engine)
        if long_query_time is not None:
            pulumi.set(__self__, "long_query_time", long_query_time)
        if max_allowed_packet is not None:
            pulumi.set(__self__, "max_allowed_packet", max_allowed_packet)
        if max_heap_table_size is not None:
            pulumi.set(__self__, "max_heap_table_size", max_heap_table_size)
        if net_read_timeout is not None:
            pulumi.set(__self__, "net_read_timeout", net_read_timeout)
        if net_write_timeout is not None:
            pulumi.set(__self__, "net_write_timeout", net_write_timeout)
        if slow_query_log is not None:
            pulumi.set(__self__, "slow_query_log", slow_query_log)
        if sort_buffer_size is not None:
            pulumi.set(__self__, "sort_buffer_size", sort_buffer_size)
        if sql_mode is not None:
            pulumi.set(__self__, "sql_mode", sql_mode)
        if sql_require_primary_key is not None:
            pulumi.set(__self__, "sql_require_primary_key", sql_require_primary_key)
        if tmp_table_size is not None:
            pulumi.set(__self__, "tmp_table_size", tmp_table_size)
        if wait_timeout is not None:
            pulumi.set(__self__, "wait_timeout", wait_timeout)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[str]:
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="defaultTimeZone")
    def default_time_zone(self) -> Optional[str]:
        return pulumi.get(self, "default_time_zone")

    @property
    @pulumi.getter(name="groupConcatMaxLen")
    def group_concat_max_len(self) -> Optional[str]:
        return pulumi.get(self, "group_concat_max_len")

    @property
    @pulumi.getter(name="informationSchemaStatsExpiry")
    def information_schema_stats_expiry(self) -> Optional[str]:
        return pulumi.get(self, "information_schema_stats_expiry")

    @property
    @pulumi.getter(name="innodbFtMinTokenSize")
    def innodb_ft_min_token_size(self) -> Optional[str]:
        return pulumi.get(self, "innodb_ft_min_token_size")

    @property
    @pulumi.getter(name="innodbFtServerStopwordTable")
    def innodb_ft_server_stopword_table(self) -> Optional[str]:
        return pulumi.get(self, "innodb_ft_server_stopword_table")

    @property
    @pulumi.getter(name="innodbLockWaitTimeout")
    def innodb_lock_wait_timeout(self) -> Optional[str]:
        return pulumi.get(self, "innodb_lock_wait_timeout")

    @property
    @pulumi.getter(name="innodbLogBufferSize")
    def innodb_log_buffer_size(self) -> Optional[str]:
        return pulumi.get(self, "innodb_log_buffer_size")

    @property
    @pulumi.getter(name="innodbOnlineAlterLogMaxSize")
    def innodb_online_alter_log_max_size(self) -> Optional[str]:
        return pulumi.get(self, "innodb_online_alter_log_max_size")

    @property
    @pulumi.getter(name="innodbPrintAllDeadlocks")
    def innodb_print_all_deadlocks(self) -> Optional[str]:
        return pulumi.get(self, "innodb_print_all_deadlocks")

    @property
    @pulumi.getter(name="innodbRollbackOnTimeout")
    def innodb_rollback_on_timeout(self) -> Optional[str]:
        return pulumi.get(self, "innodb_rollback_on_timeout")

    @property
    @pulumi.getter(name="interactiveTimeout")
    def interactive_timeout(self) -> Optional[str]:
        return pulumi.get(self, "interactive_timeout")

    @property
    @pulumi.getter(name="internalTmpMemStorageEngine")
    def internal_tmp_mem_storage_engine(self) -> Optional[str]:
        return pulumi.get(self, "internal_tmp_mem_storage_engine")

    @property
    @pulumi.getter(name="longQueryTime")
    def long_query_time(self) -> Optional[str]:
        return pulumi.get(self, "long_query_time")

    @property
    @pulumi.getter(name="maxAllowedPacket")
    def max_allowed_packet(self) -> Optional[str]:
        return pulumi.get(self, "max_allowed_packet")

    @property
    @pulumi.getter(name="maxHeapTableSize")
    def max_heap_table_size(self) -> Optional[str]:
        return pulumi.get(self, "max_heap_table_size")

    @property
    @pulumi.getter(name="netReadTimeout")
    def net_read_timeout(self) -> Optional[str]:
        return pulumi.get(self, "net_read_timeout")

    @property
    @pulumi.getter(name="netWriteTimeout")
    def net_write_timeout(self) -> Optional[str]:
        return pulumi.get(self, "net_write_timeout")

    @property
    @pulumi.getter(name="slowQueryLog")
    def slow_query_log(self) -> Optional[str]:
        return pulumi.get(self, "slow_query_log")

    @property
    @pulumi.getter(name="sortBufferSize")
    def sort_buffer_size(self) -> Optional[str]:
        return pulumi.get(self, "sort_buffer_size")

    @property
    @pulumi.getter(name="sqlMode")
    def sql_mode(self) -> Optional[str]:
        return pulumi.get(self, "sql_mode")

    @property
    @pulumi.getter(name="sqlRequirePrimaryKey")
    def sql_require_primary_key(self) -> Optional[str]:
        return pulumi.get(self, "sql_require_primary_key")

    @property
    @pulumi.getter(name="tmpTableSize")
    def tmp_table_size(self) -> Optional[str]:
        return pulumi.get(self, "tmp_table_size")

    @property
    @pulumi.getter(name="waitTimeout")
    def wait_timeout(self) -> Optional[str]:
        return pulumi.get(self, "wait_timeout")


@pulumi.output_type
class GetMySqlMysqlUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 mysql: Optional[str] = None,
                 mysqlx: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if mysqlx is not None:
            pulumi.set(__self__, "mysqlx", mysqlx)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def mysql(self) -> Optional[str]:
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter
    def mysqlx(self) -> Optional[str]:
        return pulumi.get(self, "mysqlx")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetMySqlMysqlUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 mysql: Optional[str] = None,
                 mysqlx: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if mysqlx is not None:
            pulumi.set(__self__, "mysqlx", mysqlx)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def mysql(self) -> Optional[str]:
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter
    def mysqlx(self) -> Optional[str]:
        return pulumi.get(self, "mysqlx")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetMySqlMysqlUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 mysql: Optional[str] = None,
                 mysqlx: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if mysqlx is not None:
            pulumi.set(__self__, "mysqlx", mysqlx)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def mysql(self) -> Optional[str]:
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter
    def mysqlx(self) -> Optional[str]:
        return pulumi.get(self, "mysqlx")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetMySqlServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetMySqlTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetOpenSearchComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetOpenSearchOpensearchResult(dict):
    def __init__(__self__, *,
                 opensearch_dashboards_uri: str):
        pulumi.set(__self__, "opensearch_dashboards_uri", opensearch_dashboards_uri)

    @property
    @pulumi.getter(name="opensearchDashboardsUri")
    def opensearch_dashboards_uri(self) -> str:
        return pulumi.get(self, "opensearch_dashboards_uri")


@pulumi.output_type
class GetOpenSearchOpensearchUserConfigResult(dict):
    def __init__(__self__, *,
                 custom_domain: Optional[str] = None,
                 disable_replication_factor_adjustment: Optional[str] = None,
                 index_patterns: Optional[Sequence['outputs.GetOpenSearchOpensearchUserConfigIndexPatternResult']] = None,
                 index_template: Optional['outputs.GetOpenSearchOpensearchUserConfigIndexTemplateResult'] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 keep_index_refresh_interval: Optional[str] = None,
                 max_index_count: Optional[str] = None,
                 opensearch: Optional['outputs.GetOpenSearchOpensearchUserConfigOpensearchResult'] = None,
                 opensearch_dashboards: Optional['outputs.GetOpenSearchOpensearchUserConfigOpensearchDashboardsResult'] = None,
                 opensearch_version: Optional[str] = None,
                 private_access: Optional['outputs.GetOpenSearchOpensearchUserConfigPrivateAccessResult'] = None,
                 privatelink_access: Optional['outputs.GetOpenSearchOpensearchUserConfigPrivatelinkAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetOpenSearchOpensearchUserConfigPublicAccessResult'] = None,
                 recovery_basebackup_name: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if disable_replication_factor_adjustment is not None:
            pulumi.set(__self__, "disable_replication_factor_adjustment", disable_replication_factor_adjustment)
        if index_patterns is not None:
            pulumi.set(__self__, "index_patterns", index_patterns)
        if index_template is not None:
            pulumi.set(__self__, "index_template", index_template)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if keep_index_refresh_interval is not None:
            pulumi.set(__self__, "keep_index_refresh_interval", keep_index_refresh_interval)
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if opensearch is not None:
            pulumi.set(__self__, "opensearch", opensearch)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if opensearch_version is not None:
            pulumi.set(__self__, "opensearch_version", opensearch_version)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_basebackup_name is not None:
            pulumi.set(__self__, "recovery_basebackup_name", recovery_basebackup_name)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="disableReplicationFactorAdjustment")
    def disable_replication_factor_adjustment(self) -> Optional[str]:
        return pulumi.get(self, "disable_replication_factor_adjustment")

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[Sequence['outputs.GetOpenSearchOpensearchUserConfigIndexPatternResult']]:
        return pulumi.get(self, "index_patterns")

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional['outputs.GetOpenSearchOpensearchUserConfigIndexTemplateResult']:
        return pulumi.get(self, "index_template")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[str]:
        return pulumi.get(self, "keep_index_refresh_interval")

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[str]:
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter
    def opensearch(self) -> Optional['outputs.GetOpenSearchOpensearchUserConfigOpensearchResult']:
        return pulumi.get(self, "opensearch")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional['outputs.GetOpenSearchOpensearchUserConfigOpensearchDashboardsResult']:
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter(name="opensearchVersion")
    def opensearch_version(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_version")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetOpenSearchOpensearchUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetOpenSearchOpensearchUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetOpenSearchOpensearchUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryBasebackupName")
    def recovery_basebackup_name(self) -> Optional[str]:
        return pulumi.get(self, "recovery_basebackup_name")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetOpenSearchOpensearchUserConfigIndexPatternResult(dict):
    def __init__(__self__, *,
                 max_index_count: Optional[str] = None,
                 pattern: Optional[str] = None,
                 sorting_algorithm: Optional[str] = None):
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if sorting_algorithm is not None:
            pulumi.set(__self__, "sorting_algorithm", sorting_algorithm)

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[str]:
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="sortingAlgorithm")
    def sorting_algorithm(self) -> Optional[str]:
        return pulumi.get(self, "sorting_algorithm")


@pulumi.output_type
class GetOpenSearchOpensearchUserConfigIndexTemplateResult(dict):
    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[str] = None,
                 number_of_replicas: Optional[str] = None,
                 number_of_shards: Optional[str] = None):
        if mapping_nested_objects_limit is not None:
            pulumi.set(__self__, "mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[str]:
        return pulumi.get(self, "mapping_nested_objects_limit")

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[str]:
        return pulumi.get(self, "number_of_replicas")

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[str]:
        return pulumi.get(self, "number_of_shards")


@pulumi.output_type
class GetOpenSearchOpensearchUserConfigOpensearchResult(dict):
    def __init__(__self__, *,
                 action_auto_create_index_enabled: Optional[str] = None,
                 action_destructive_requires_name: Optional[str] = None,
                 cluster_max_shards_per_node: Optional[str] = None,
                 cluster_routing_allocation_node_concurrent_recoveries: Optional[str] = None,
                 http_max_content_length: Optional[str] = None,
                 http_max_header_size: Optional[str] = None,
                 http_max_initial_line_length: Optional[str] = None,
                 indices_fielddata_cache_size: Optional[str] = None,
                 indices_memory_index_buffer_size: Optional[str] = None,
                 indices_queries_cache_size: Optional[str] = None,
                 indices_query_bool_max_clause_count: Optional[str] = None,
                 indices_recovery_max_bytes_per_sec: Optional[str] = None,
                 indices_recovery_max_concurrent_file_chunks: Optional[str] = None,
                 override_main_response_version: Optional[str] = None,
                 reindex_remote_whitelists: Optional[Sequence[str]] = None,
                 script_max_compilations_rate: Optional[str] = None,
                 search_max_buckets: Optional[str] = None,
                 thread_pool_analyze_queue_size: Optional[str] = None,
                 thread_pool_analyze_size: Optional[str] = None,
                 thread_pool_force_merge_size: Optional[str] = None,
                 thread_pool_get_queue_size: Optional[str] = None,
                 thread_pool_get_size: Optional[str] = None,
                 thread_pool_search_queue_size: Optional[str] = None,
                 thread_pool_search_size: Optional[str] = None,
                 thread_pool_search_throttled_queue_size: Optional[str] = None,
                 thread_pool_search_throttled_size: Optional[str] = None,
                 thread_pool_write_queue_size: Optional[str] = None,
                 thread_pool_write_size: Optional[str] = None):
        if action_auto_create_index_enabled is not None:
            pulumi.set(__self__, "action_auto_create_index_enabled", action_auto_create_index_enabled)
        if action_destructive_requires_name is not None:
            pulumi.set(__self__, "action_destructive_requires_name", action_destructive_requires_name)
        if cluster_max_shards_per_node is not None:
            pulumi.set(__self__, "cluster_max_shards_per_node", cluster_max_shards_per_node)
        if cluster_routing_allocation_node_concurrent_recoveries is not None:
            pulumi.set(__self__, "cluster_routing_allocation_node_concurrent_recoveries", cluster_routing_allocation_node_concurrent_recoveries)
        if http_max_content_length is not None:
            pulumi.set(__self__, "http_max_content_length", http_max_content_length)
        if http_max_header_size is not None:
            pulumi.set(__self__, "http_max_header_size", http_max_header_size)
        if http_max_initial_line_length is not None:
            pulumi.set(__self__, "http_max_initial_line_length", http_max_initial_line_length)
        if indices_fielddata_cache_size is not None:
            pulumi.set(__self__, "indices_fielddata_cache_size", indices_fielddata_cache_size)
        if indices_memory_index_buffer_size is not None:
            pulumi.set(__self__, "indices_memory_index_buffer_size", indices_memory_index_buffer_size)
        if indices_queries_cache_size is not None:
            pulumi.set(__self__, "indices_queries_cache_size", indices_queries_cache_size)
        if indices_query_bool_max_clause_count is not None:
            pulumi.set(__self__, "indices_query_bool_max_clause_count", indices_query_bool_max_clause_count)
        if indices_recovery_max_bytes_per_sec is not None:
            pulumi.set(__self__, "indices_recovery_max_bytes_per_sec", indices_recovery_max_bytes_per_sec)
        if indices_recovery_max_concurrent_file_chunks is not None:
            pulumi.set(__self__, "indices_recovery_max_concurrent_file_chunks", indices_recovery_max_concurrent_file_chunks)
        if override_main_response_version is not None:
            pulumi.set(__self__, "override_main_response_version", override_main_response_version)
        if reindex_remote_whitelists is not None:
            pulumi.set(__self__, "reindex_remote_whitelists", reindex_remote_whitelists)
        if script_max_compilations_rate is not None:
            pulumi.set(__self__, "script_max_compilations_rate", script_max_compilations_rate)
        if search_max_buckets is not None:
            pulumi.set(__self__, "search_max_buckets", search_max_buckets)
        if thread_pool_analyze_queue_size is not None:
            pulumi.set(__self__, "thread_pool_analyze_queue_size", thread_pool_analyze_queue_size)
        if thread_pool_analyze_size is not None:
            pulumi.set(__self__, "thread_pool_analyze_size", thread_pool_analyze_size)
        if thread_pool_force_merge_size is not None:
            pulumi.set(__self__, "thread_pool_force_merge_size", thread_pool_force_merge_size)
        if thread_pool_get_queue_size is not None:
            pulumi.set(__self__, "thread_pool_get_queue_size", thread_pool_get_queue_size)
        if thread_pool_get_size is not None:
            pulumi.set(__self__, "thread_pool_get_size", thread_pool_get_size)
        if thread_pool_search_queue_size is not None:
            pulumi.set(__self__, "thread_pool_search_queue_size", thread_pool_search_queue_size)
        if thread_pool_search_size is not None:
            pulumi.set(__self__, "thread_pool_search_size", thread_pool_search_size)
        if thread_pool_search_throttled_queue_size is not None:
            pulumi.set(__self__, "thread_pool_search_throttled_queue_size", thread_pool_search_throttled_queue_size)
        if thread_pool_search_throttled_size is not None:
            pulumi.set(__self__, "thread_pool_search_throttled_size", thread_pool_search_throttled_size)
        if thread_pool_write_queue_size is not None:
            pulumi.set(__self__, "thread_pool_write_queue_size", thread_pool_write_queue_size)
        if thread_pool_write_size is not None:
            pulumi.set(__self__, "thread_pool_write_size", thread_pool_write_size)

    @property
    @pulumi.getter(name="actionAutoCreateIndexEnabled")
    def action_auto_create_index_enabled(self) -> Optional[str]:
        return pulumi.get(self, "action_auto_create_index_enabled")

    @property
    @pulumi.getter(name="actionDestructiveRequiresName")
    def action_destructive_requires_name(self) -> Optional[str]:
        return pulumi.get(self, "action_destructive_requires_name")

    @property
    @pulumi.getter(name="clusterMaxShardsPerNode")
    def cluster_max_shards_per_node(self) -> Optional[str]:
        return pulumi.get(self, "cluster_max_shards_per_node")

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeConcurrentRecoveries")
    def cluster_routing_allocation_node_concurrent_recoveries(self) -> Optional[str]:
        return pulumi.get(self, "cluster_routing_allocation_node_concurrent_recoveries")

    @property
    @pulumi.getter(name="httpMaxContentLength")
    def http_max_content_length(self) -> Optional[str]:
        return pulumi.get(self, "http_max_content_length")

    @property
    @pulumi.getter(name="httpMaxHeaderSize")
    def http_max_header_size(self) -> Optional[str]:
        return pulumi.get(self, "http_max_header_size")

    @property
    @pulumi.getter(name="httpMaxInitialLineLength")
    def http_max_initial_line_length(self) -> Optional[str]:
        return pulumi.get(self, "http_max_initial_line_length")

    @property
    @pulumi.getter(name="indicesFielddataCacheSize")
    def indices_fielddata_cache_size(self) -> Optional[str]:
        return pulumi.get(self, "indices_fielddata_cache_size")

    @property
    @pulumi.getter(name="indicesMemoryIndexBufferSize")
    def indices_memory_index_buffer_size(self) -> Optional[str]:
        return pulumi.get(self, "indices_memory_index_buffer_size")

    @property
    @pulumi.getter(name="indicesQueriesCacheSize")
    def indices_queries_cache_size(self) -> Optional[str]:
        return pulumi.get(self, "indices_queries_cache_size")

    @property
    @pulumi.getter(name="indicesQueryBoolMaxClauseCount")
    def indices_query_bool_max_clause_count(self) -> Optional[str]:
        return pulumi.get(self, "indices_query_bool_max_clause_count")

    @property
    @pulumi.getter(name="indicesRecoveryMaxBytesPerSec")
    def indices_recovery_max_bytes_per_sec(self) -> Optional[str]:
        return pulumi.get(self, "indices_recovery_max_bytes_per_sec")

    @property
    @pulumi.getter(name="indicesRecoveryMaxConcurrentFileChunks")
    def indices_recovery_max_concurrent_file_chunks(self) -> Optional[str]:
        return pulumi.get(self, "indices_recovery_max_concurrent_file_chunks")

    @property
    @pulumi.getter(name="overrideMainResponseVersion")
    def override_main_response_version(self) -> Optional[str]:
        return pulumi.get(self, "override_main_response_version")

    @property
    @pulumi.getter(name="reindexRemoteWhitelists")
    def reindex_remote_whitelists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "reindex_remote_whitelists")

    @property
    @pulumi.getter(name="scriptMaxCompilationsRate")
    def script_max_compilations_rate(self) -> Optional[str]:
        return pulumi.get(self, "script_max_compilations_rate")

    @property
    @pulumi.getter(name="searchMaxBuckets")
    def search_max_buckets(self) -> Optional[str]:
        return pulumi.get(self, "search_max_buckets")

    @property
    @pulumi.getter(name="threadPoolAnalyzeQueueSize")
    def thread_pool_analyze_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_analyze_queue_size")

    @property
    @pulumi.getter(name="threadPoolAnalyzeSize")
    def thread_pool_analyze_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_analyze_size")

    @property
    @pulumi.getter(name="threadPoolForceMergeSize")
    def thread_pool_force_merge_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_force_merge_size")

    @property
    @pulumi.getter(name="threadPoolGetQueueSize")
    def thread_pool_get_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_get_queue_size")

    @property
    @pulumi.getter(name="threadPoolGetSize")
    def thread_pool_get_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_get_size")

    @property
    @pulumi.getter(name="threadPoolSearchQueueSize")
    def thread_pool_search_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_search_queue_size")

    @property
    @pulumi.getter(name="threadPoolSearchSize")
    def thread_pool_search_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_search_size")

    @property
    @pulumi.getter(name="threadPoolSearchThrottledQueueSize")
    def thread_pool_search_throttled_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_search_throttled_queue_size")

    @property
    @pulumi.getter(name="threadPoolSearchThrottledSize")
    def thread_pool_search_throttled_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_search_throttled_size")

    @property
    @pulumi.getter(name="threadPoolWriteQueueSize")
    def thread_pool_write_queue_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_write_queue_size")

    @property
    @pulumi.getter(name="threadPoolWriteSize")
    def thread_pool_write_size(self) -> Optional[str]:
        return pulumi.get(self, "thread_pool_write_size")


@pulumi.output_type
class GetOpenSearchOpensearchUserConfigOpensearchDashboardsResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[str] = None,
                 max_old_space_size: Optional[str] = None,
                 opensearch_request_timeout: Optional[str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_old_space_size is not None:
            pulumi.set(__self__, "max_old_space_size", max_old_space_size)
        if opensearch_request_timeout is not None:
            pulumi.set(__self__, "opensearch_request_timeout", opensearch_request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[str]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[str]:
        return pulumi.get(self, "max_old_space_size")

    @property
    @pulumi.getter(name="opensearchRequestTimeout")
    def opensearch_request_timeout(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_request_timeout")


@pulumi.output_type
class GetOpenSearchOpensearchUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 opensearch: Optional[str] = None,
                 opensearch_dashboards: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if opensearch is not None:
            pulumi.set(__self__, "opensearch", opensearch)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def opensearch(self) -> Optional[str]:
        return pulumi.get(self, "opensearch")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetOpenSearchOpensearchUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 opensearch: Optional[str] = None,
                 opensearch_dashboards: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if opensearch is not None:
            pulumi.set(__self__, "opensearch", opensearch)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def opensearch(self) -> Optional[str]:
        return pulumi.get(self, "opensearch")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetOpenSearchOpensearchUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 opensearch: Optional[str] = None,
                 opensearch_dashboards: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if opensearch is not None:
            pulumi.set(__self__, "opensearch", opensearch)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def opensearch(self) -> Optional[str]:
        return pulumi.get(self, "opensearch")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional[str]:
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetOpenSearchServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetOpenSearchTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPgComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetPgPgResult(dict):
    def __init__(__self__, *,
                 dbname: str,
                 host: str,
                 password: str,
                 port: int,
                 replica_uri: str,
                 sslmode: str,
                 uri: str,
                 user: str):
        pulumi.set(__self__, "dbname", dbname)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "replica_uri", replica_uri)
        pulumi.set(__self__, "sslmode", sslmode)
        pulumi.set(__self__, "uri", uri)
        pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def dbname(self) -> str:
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="replicaUri")
    def replica_uri(self) -> str:
        return pulumi.get(self, "replica_uri")

    @property
    @pulumi.getter
    def sslmode(self) -> str:
        return pulumi.get(self, "sslmode")

    @property
    @pulumi.getter
    def uri(self) -> str:
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def user(self) -> str:
        return pulumi.get(self, "user")


@pulumi.output_type
class GetPgPgUserConfigResult(dict):
    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_hour: Optional[str] = None,
                 backup_minute: Optional[str] = None,
                 enable_ipv6: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 migration: Optional['outputs.GetPgPgUserConfigMigrationResult'] = None,
                 pg: Optional['outputs.GetPgPgUserConfigPgResult'] = None,
                 pg_read_replica: Optional[str] = None,
                 pg_service_to_fork_from: Optional[str] = None,
                 pg_version: Optional[str] = None,
                 pgbouncer: Optional['outputs.GetPgPgUserConfigPgbouncerResult'] = None,
                 pglookout: Optional['outputs.GetPgPgUserConfigPglookoutResult'] = None,
                 private_access: Optional['outputs.GetPgPgUserConfigPrivateAccessResult'] = None,
                 privatelink_access: Optional['outputs.GetPgPgUserConfigPrivatelinkAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetPgPgUserConfigPublicAccessResult'] = None,
                 recovery_target_time: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 shared_buffers_percentage: Optional[str] = None,
                 static_ips: Optional[str] = None,
                 synchronous_replication: Optional[str] = None,
                 timescaledb: Optional['outputs.GetPgPgUserConfigTimescaledbResult'] = None,
                 variant: Optional[str] = None,
                 work_mem: Optional[str] = None):
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if enable_ipv6 is not None:
            pulumi.set(__self__, "enable_ipv6", enable_ipv6)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if pg_read_replica is not None:
            pulumi.set(__self__, "pg_read_replica", pg_read_replica)
        if pg_service_to_fork_from is not None:
            pulumi.set(__self__, "pg_service_to_fork_from", pg_service_to_fork_from)
        if pg_version is not None:
            pulumi.set(__self__, "pg_version", pg_version)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if pglookout is not None:
            pulumi.set(__self__, "pglookout", pglookout)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_target_time is not None:
            pulumi.set(__self__, "recovery_target_time", recovery_target_time)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if shared_buffers_percentage is not None:
            pulumi.set(__self__, "shared_buffers_percentage", shared_buffers_percentage)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)
        if synchronous_replication is not None:
            pulumi.set(__self__, "synchronous_replication", synchronous_replication)
        if timescaledb is not None:
            pulumi.set(__self__, "timescaledb", timescaledb)
        if variant is not None:
            pulumi.set(__self__, "variant", variant)
        if work_mem is not None:
            pulumi.set(__self__, "work_mem", work_mem)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[str]:
        return pulumi.get(self, "backup_hour")

    @property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[str]:
        return pulumi.get(self, "backup_minute")

    @property
    @pulumi.getter(name="enableIpv6")
    def enable_ipv6(self) -> Optional[str]:
        return pulumi.get(self, "enable_ipv6")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def migration(self) -> Optional['outputs.GetPgPgUserConfigMigrationResult']:
        return pulumi.get(self, "migration")

    @property
    @pulumi.getter
    def pg(self) -> Optional['outputs.GetPgPgUserConfigPgResult']:
        return pulumi.get(self, "pg")

    @property
    @pulumi.getter(name="pgReadReplica")
    def pg_read_replica(self) -> Optional[str]:
        return pulumi.get(self, "pg_read_replica")

    @property
    @pulumi.getter(name="pgServiceToForkFrom")
    def pg_service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "pg_service_to_fork_from")

    @property
    @pulumi.getter(name="pgVersion")
    def pg_version(self) -> Optional[str]:
        return pulumi.get(self, "pg_version")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional['outputs.GetPgPgUserConfigPgbouncerResult']:
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def pglookout(self) -> Optional['outputs.GetPgPgUserConfigPglookoutResult']:
        return pulumi.get(self, "pglookout")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetPgPgUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetPgPgUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetPgPgUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryTargetTime")
    def recovery_target_time(self) -> Optional[str]:
        return pulumi.get(self, "recovery_target_time")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="sharedBuffersPercentage")
    def shared_buffers_percentage(self) -> Optional[str]:
        return pulumi.get(self, "shared_buffers_percentage")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")

    @property
    @pulumi.getter(name="synchronousReplication")
    def synchronous_replication(self) -> Optional[str]:
        return pulumi.get(self, "synchronous_replication")

    @property
    @pulumi.getter
    def timescaledb(self) -> Optional['outputs.GetPgPgUserConfigTimescaledbResult']:
        return pulumi.get(self, "timescaledb")

    @property
    @pulumi.getter
    def variant(self) -> Optional[str]:
        return pulumi.get(self, "variant")

    @property
    @pulumi.getter(name="workMem")
    def work_mem(self) -> Optional[str]:
        return pulumi.get(self, "work_mem")


@pulumi.output_type
class GetPgPgUserConfigMigrationResult(dict):
    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 ignore_dbs: Optional[str] = None,
                 method: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 ssl: Optional[str] = None,
                 username: Optional[str] = None):
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[str]:
        return pulumi.get(self, "ignore_dbs")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetPgPgUserConfigPgResult(dict):
    def __init__(__self__, *,
                 autovacuum_analyze_scale_factor: Optional[str] = None,
                 autovacuum_analyze_threshold: Optional[str] = None,
                 autovacuum_freeze_max_age: Optional[str] = None,
                 autovacuum_max_workers: Optional[str] = None,
                 autovacuum_naptime: Optional[str] = None,
                 autovacuum_vacuum_cost_delay: Optional[str] = None,
                 autovacuum_vacuum_cost_limit: Optional[str] = None,
                 autovacuum_vacuum_scale_factor: Optional[str] = None,
                 autovacuum_vacuum_threshold: Optional[str] = None,
                 bgwriter_delay: Optional[str] = None,
                 bgwriter_flush_after: Optional[str] = None,
                 bgwriter_lru_maxpages: Optional[str] = None,
                 bgwriter_lru_multiplier: Optional[str] = None,
                 deadlock_timeout: Optional[str] = None,
                 default_toast_compression: Optional[str] = None,
                 idle_in_transaction_session_timeout: Optional[str] = None,
                 jit: Optional[str] = None,
                 log_autovacuum_min_duration: Optional[str] = None,
                 log_error_verbosity: Optional[str] = None,
                 log_line_prefix: Optional[str] = None,
                 log_min_duration_statement: Optional[str] = None,
                 max_files_per_process: Optional[str] = None,
                 max_locks_per_transaction: Optional[str] = None,
                 max_logical_replication_workers: Optional[str] = None,
                 max_parallel_workers: Optional[str] = None,
                 max_parallel_workers_per_gather: Optional[str] = None,
                 max_pred_locks_per_transaction: Optional[str] = None,
                 max_prepared_transactions: Optional[str] = None,
                 max_replication_slots: Optional[str] = None,
                 max_slot_wal_keep_size: Optional[str] = None,
                 max_stack_depth: Optional[str] = None,
                 max_standby_archive_delay: Optional[str] = None,
                 max_standby_streaming_delay: Optional[str] = None,
                 max_wal_senders: Optional[str] = None,
                 max_worker_processes: Optional[str] = None,
                 pg_partman_bgw_dot_interval: Optional[str] = None,
                 pg_partman_bgw_dot_role: Optional[str] = None,
                 pg_stat_statements_dot_track: Optional[str] = None,
                 temp_file_limit: Optional[str] = None,
                 timezone: Optional[str] = None,
                 track_activity_query_size: Optional[str] = None,
                 track_commit_timestamp: Optional[str] = None,
                 track_functions: Optional[str] = None,
                 track_io_timing: Optional[str] = None,
                 wal_sender_timeout: Optional[str] = None,
                 wal_writer_delay: Optional[str] = None):
        if autovacuum_analyze_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_analyze_scale_factor", autovacuum_analyze_scale_factor)
        if autovacuum_analyze_threshold is not None:
            pulumi.set(__self__, "autovacuum_analyze_threshold", autovacuum_analyze_threshold)
        if autovacuum_freeze_max_age is not None:
            pulumi.set(__self__, "autovacuum_freeze_max_age", autovacuum_freeze_max_age)
        if autovacuum_max_workers is not None:
            pulumi.set(__self__, "autovacuum_max_workers", autovacuum_max_workers)
        if autovacuum_naptime is not None:
            pulumi.set(__self__, "autovacuum_naptime", autovacuum_naptime)
        if autovacuum_vacuum_cost_delay is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_delay", autovacuum_vacuum_cost_delay)
        if autovacuum_vacuum_cost_limit is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_limit", autovacuum_vacuum_cost_limit)
        if autovacuum_vacuum_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_vacuum_scale_factor", autovacuum_vacuum_scale_factor)
        if autovacuum_vacuum_threshold is not None:
            pulumi.set(__self__, "autovacuum_vacuum_threshold", autovacuum_vacuum_threshold)
        if bgwriter_delay is not None:
            pulumi.set(__self__, "bgwriter_delay", bgwriter_delay)
        if bgwriter_flush_after is not None:
            pulumi.set(__self__, "bgwriter_flush_after", bgwriter_flush_after)
        if bgwriter_lru_maxpages is not None:
            pulumi.set(__self__, "bgwriter_lru_maxpages", bgwriter_lru_maxpages)
        if bgwriter_lru_multiplier is not None:
            pulumi.set(__self__, "bgwriter_lru_multiplier", bgwriter_lru_multiplier)
        if deadlock_timeout is not None:
            pulumi.set(__self__, "deadlock_timeout", deadlock_timeout)
        if default_toast_compression is not None:
            pulumi.set(__self__, "default_toast_compression", default_toast_compression)
        if idle_in_transaction_session_timeout is not None:
            pulumi.set(__self__, "idle_in_transaction_session_timeout", idle_in_transaction_session_timeout)
        if jit is not None:
            pulumi.set(__self__, "jit", jit)
        if log_autovacuum_min_duration is not None:
            pulumi.set(__self__, "log_autovacuum_min_duration", log_autovacuum_min_duration)
        if log_error_verbosity is not None:
            pulumi.set(__self__, "log_error_verbosity", log_error_verbosity)
        if log_line_prefix is not None:
            pulumi.set(__self__, "log_line_prefix", log_line_prefix)
        if log_min_duration_statement is not None:
            pulumi.set(__self__, "log_min_duration_statement", log_min_duration_statement)
        if max_files_per_process is not None:
            pulumi.set(__self__, "max_files_per_process", max_files_per_process)
        if max_locks_per_transaction is not None:
            pulumi.set(__self__, "max_locks_per_transaction", max_locks_per_transaction)
        if max_logical_replication_workers is not None:
            pulumi.set(__self__, "max_logical_replication_workers", max_logical_replication_workers)
        if max_parallel_workers is not None:
            pulumi.set(__self__, "max_parallel_workers", max_parallel_workers)
        if max_parallel_workers_per_gather is not None:
            pulumi.set(__self__, "max_parallel_workers_per_gather", max_parallel_workers_per_gather)
        if max_pred_locks_per_transaction is not None:
            pulumi.set(__self__, "max_pred_locks_per_transaction", max_pred_locks_per_transaction)
        if max_prepared_transactions is not None:
            pulumi.set(__self__, "max_prepared_transactions", max_prepared_transactions)
        if max_replication_slots is not None:
            pulumi.set(__self__, "max_replication_slots", max_replication_slots)
        if max_slot_wal_keep_size is not None:
            pulumi.set(__self__, "max_slot_wal_keep_size", max_slot_wal_keep_size)
        if max_stack_depth is not None:
            pulumi.set(__self__, "max_stack_depth", max_stack_depth)
        if max_standby_archive_delay is not None:
            pulumi.set(__self__, "max_standby_archive_delay", max_standby_archive_delay)
        if max_standby_streaming_delay is not None:
            pulumi.set(__self__, "max_standby_streaming_delay", max_standby_streaming_delay)
        if max_wal_senders is not None:
            pulumi.set(__self__, "max_wal_senders", max_wal_senders)
        if max_worker_processes is not None:
            pulumi.set(__self__, "max_worker_processes", max_worker_processes)
        if pg_partman_bgw_dot_interval is not None:
            pulumi.set(__self__, "pg_partman_bgw_dot_interval", pg_partman_bgw_dot_interval)
        if pg_partman_bgw_dot_role is not None:
            pulumi.set(__self__, "pg_partman_bgw_dot_role", pg_partman_bgw_dot_role)
        if pg_stat_statements_dot_track is not None:
            pulumi.set(__self__, "pg_stat_statements_dot_track", pg_stat_statements_dot_track)
        if temp_file_limit is not None:
            pulumi.set(__self__, "temp_file_limit", temp_file_limit)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if track_activity_query_size is not None:
            pulumi.set(__self__, "track_activity_query_size", track_activity_query_size)
        if track_commit_timestamp is not None:
            pulumi.set(__self__, "track_commit_timestamp", track_commit_timestamp)
        if track_functions is not None:
            pulumi.set(__self__, "track_functions", track_functions)
        if track_io_timing is not None:
            pulumi.set(__self__, "track_io_timing", track_io_timing)
        if wal_sender_timeout is not None:
            pulumi.set(__self__, "wal_sender_timeout", wal_sender_timeout)
        if wal_writer_delay is not None:
            pulumi.set(__self__, "wal_writer_delay", wal_writer_delay)

    @property
    @pulumi.getter(name="autovacuumAnalyzeScaleFactor")
    def autovacuum_analyze_scale_factor(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_analyze_scale_factor")

    @property
    @pulumi.getter(name="autovacuumAnalyzeThreshold")
    def autovacuum_analyze_threshold(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_analyze_threshold")

    @property
    @pulumi.getter(name="autovacuumFreezeMaxAge")
    def autovacuum_freeze_max_age(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_freeze_max_age")

    @property
    @pulumi.getter(name="autovacuumMaxWorkers")
    def autovacuum_max_workers(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_max_workers")

    @property
    @pulumi.getter(name="autovacuumNaptime")
    def autovacuum_naptime(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_naptime")

    @property
    @pulumi.getter(name="autovacuumVacuumCostDelay")
    def autovacuum_vacuum_cost_delay(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_vacuum_cost_delay")

    @property
    @pulumi.getter(name="autovacuumVacuumCostLimit")
    def autovacuum_vacuum_cost_limit(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_vacuum_cost_limit")

    @property
    @pulumi.getter(name="autovacuumVacuumScaleFactor")
    def autovacuum_vacuum_scale_factor(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_vacuum_scale_factor")

    @property
    @pulumi.getter(name="autovacuumVacuumThreshold")
    def autovacuum_vacuum_threshold(self) -> Optional[str]:
        return pulumi.get(self, "autovacuum_vacuum_threshold")

    @property
    @pulumi.getter(name="bgwriterDelay")
    def bgwriter_delay(self) -> Optional[str]:
        return pulumi.get(self, "bgwriter_delay")

    @property
    @pulumi.getter(name="bgwriterFlushAfter")
    def bgwriter_flush_after(self) -> Optional[str]:
        return pulumi.get(self, "bgwriter_flush_after")

    @property
    @pulumi.getter(name="bgwriterLruMaxpages")
    def bgwriter_lru_maxpages(self) -> Optional[str]:
        return pulumi.get(self, "bgwriter_lru_maxpages")

    @property
    @pulumi.getter(name="bgwriterLruMultiplier")
    def bgwriter_lru_multiplier(self) -> Optional[str]:
        return pulumi.get(self, "bgwriter_lru_multiplier")

    @property
    @pulumi.getter(name="deadlockTimeout")
    def deadlock_timeout(self) -> Optional[str]:
        return pulumi.get(self, "deadlock_timeout")

    @property
    @pulumi.getter(name="defaultToastCompression")
    def default_toast_compression(self) -> Optional[str]:
        return pulumi.get(self, "default_toast_compression")

    @property
    @pulumi.getter(name="idleInTransactionSessionTimeout")
    def idle_in_transaction_session_timeout(self) -> Optional[str]:
        return pulumi.get(self, "idle_in_transaction_session_timeout")

    @property
    @pulumi.getter
    def jit(self) -> Optional[str]:
        return pulumi.get(self, "jit")

    @property
    @pulumi.getter(name="logAutovacuumMinDuration")
    def log_autovacuum_min_duration(self) -> Optional[str]:
        return pulumi.get(self, "log_autovacuum_min_duration")

    @property
    @pulumi.getter(name="logErrorVerbosity")
    def log_error_verbosity(self) -> Optional[str]:
        return pulumi.get(self, "log_error_verbosity")

    @property
    @pulumi.getter(name="logLinePrefix")
    def log_line_prefix(self) -> Optional[str]:
        return pulumi.get(self, "log_line_prefix")

    @property
    @pulumi.getter(name="logMinDurationStatement")
    def log_min_duration_statement(self) -> Optional[str]:
        return pulumi.get(self, "log_min_duration_statement")

    @property
    @pulumi.getter(name="maxFilesPerProcess")
    def max_files_per_process(self) -> Optional[str]:
        return pulumi.get(self, "max_files_per_process")

    @property
    @pulumi.getter(name="maxLocksPerTransaction")
    def max_locks_per_transaction(self) -> Optional[str]:
        return pulumi.get(self, "max_locks_per_transaction")

    @property
    @pulumi.getter(name="maxLogicalReplicationWorkers")
    def max_logical_replication_workers(self) -> Optional[str]:
        return pulumi.get(self, "max_logical_replication_workers")

    @property
    @pulumi.getter(name="maxParallelWorkers")
    def max_parallel_workers(self) -> Optional[str]:
        return pulumi.get(self, "max_parallel_workers")

    @property
    @pulumi.getter(name="maxParallelWorkersPerGather")
    def max_parallel_workers_per_gather(self) -> Optional[str]:
        return pulumi.get(self, "max_parallel_workers_per_gather")

    @property
    @pulumi.getter(name="maxPredLocksPerTransaction")
    def max_pred_locks_per_transaction(self) -> Optional[str]:
        return pulumi.get(self, "max_pred_locks_per_transaction")

    @property
    @pulumi.getter(name="maxPreparedTransactions")
    def max_prepared_transactions(self) -> Optional[str]:
        return pulumi.get(self, "max_prepared_transactions")

    @property
    @pulumi.getter(name="maxReplicationSlots")
    def max_replication_slots(self) -> Optional[str]:
        return pulumi.get(self, "max_replication_slots")

    @property
    @pulumi.getter(name="maxSlotWalKeepSize")
    def max_slot_wal_keep_size(self) -> Optional[str]:
        return pulumi.get(self, "max_slot_wal_keep_size")

    @property
    @pulumi.getter(name="maxStackDepth")
    def max_stack_depth(self) -> Optional[str]:
        return pulumi.get(self, "max_stack_depth")

    @property
    @pulumi.getter(name="maxStandbyArchiveDelay")
    def max_standby_archive_delay(self) -> Optional[str]:
        return pulumi.get(self, "max_standby_archive_delay")

    @property
    @pulumi.getter(name="maxStandbyStreamingDelay")
    def max_standby_streaming_delay(self) -> Optional[str]:
        return pulumi.get(self, "max_standby_streaming_delay")

    @property
    @pulumi.getter(name="maxWalSenders")
    def max_wal_senders(self) -> Optional[str]:
        return pulumi.get(self, "max_wal_senders")

    @property
    @pulumi.getter(name="maxWorkerProcesses")
    def max_worker_processes(self) -> Optional[str]:
        return pulumi.get(self, "max_worker_processes")

    @property
    @pulumi.getter(name="pgPartmanBgwDotInterval")
    def pg_partman_bgw_dot_interval(self) -> Optional[str]:
        return pulumi.get(self, "pg_partman_bgw_dot_interval")

    @property
    @pulumi.getter(name="pgPartmanBgwDotRole")
    def pg_partman_bgw_dot_role(self) -> Optional[str]:
        return pulumi.get(self, "pg_partman_bgw_dot_role")

    @property
    @pulumi.getter(name="pgStatStatementsDotTrack")
    def pg_stat_statements_dot_track(self) -> Optional[str]:
        return pulumi.get(self, "pg_stat_statements_dot_track")

    @property
    @pulumi.getter(name="tempFileLimit")
    def temp_file_limit(self) -> Optional[str]:
        return pulumi.get(self, "temp_file_limit")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter(name="trackActivityQuerySize")
    def track_activity_query_size(self) -> Optional[str]:
        return pulumi.get(self, "track_activity_query_size")

    @property
    @pulumi.getter(name="trackCommitTimestamp")
    def track_commit_timestamp(self) -> Optional[str]:
        return pulumi.get(self, "track_commit_timestamp")

    @property
    @pulumi.getter(name="trackFunctions")
    def track_functions(self) -> Optional[str]:
        return pulumi.get(self, "track_functions")

    @property
    @pulumi.getter(name="trackIoTiming")
    def track_io_timing(self) -> Optional[str]:
        return pulumi.get(self, "track_io_timing")

    @property
    @pulumi.getter(name="walSenderTimeout")
    def wal_sender_timeout(self) -> Optional[str]:
        return pulumi.get(self, "wal_sender_timeout")

    @property
    @pulumi.getter(name="walWriterDelay")
    def wal_writer_delay(self) -> Optional[str]:
        return pulumi.get(self, "wal_writer_delay")


@pulumi.output_type
class GetPgPgUserConfigPgbouncerResult(dict):
    def __init__(__self__, *,
                 autodb_idle_timeout: Optional[str] = None,
                 autodb_max_db_connections: Optional[str] = None,
                 autodb_pool_mode: Optional[str] = None,
                 autodb_pool_size: Optional[str] = None,
                 ignore_startup_parameters: Optional[Sequence[str]] = None,
                 min_pool_size: Optional[str] = None,
                 server_idle_timeout: Optional[str] = None,
                 server_lifetime: Optional[str] = None,
                 server_reset_query_always: Optional[str] = None):
        if autodb_idle_timeout is not None:
            pulumi.set(__self__, "autodb_idle_timeout", autodb_idle_timeout)
        if autodb_max_db_connections is not None:
            pulumi.set(__self__, "autodb_max_db_connections", autodb_max_db_connections)
        if autodb_pool_mode is not None:
            pulumi.set(__self__, "autodb_pool_mode", autodb_pool_mode)
        if autodb_pool_size is not None:
            pulumi.set(__self__, "autodb_pool_size", autodb_pool_size)
        if ignore_startup_parameters is not None:
            pulumi.set(__self__, "ignore_startup_parameters", ignore_startup_parameters)
        if min_pool_size is not None:
            pulumi.set(__self__, "min_pool_size", min_pool_size)
        if server_idle_timeout is not None:
            pulumi.set(__self__, "server_idle_timeout", server_idle_timeout)
        if server_lifetime is not None:
            pulumi.set(__self__, "server_lifetime", server_lifetime)
        if server_reset_query_always is not None:
            pulumi.set(__self__, "server_reset_query_always", server_reset_query_always)

    @property
    @pulumi.getter(name="autodbIdleTimeout")
    def autodb_idle_timeout(self) -> Optional[str]:
        return pulumi.get(self, "autodb_idle_timeout")

    @property
    @pulumi.getter(name="autodbMaxDbConnections")
    def autodb_max_db_connections(self) -> Optional[str]:
        return pulumi.get(self, "autodb_max_db_connections")

    @property
    @pulumi.getter(name="autodbPoolMode")
    def autodb_pool_mode(self) -> Optional[str]:
        return pulumi.get(self, "autodb_pool_mode")

    @property
    @pulumi.getter(name="autodbPoolSize")
    def autodb_pool_size(self) -> Optional[str]:
        return pulumi.get(self, "autodb_pool_size")

    @property
    @pulumi.getter(name="ignoreStartupParameters")
    def ignore_startup_parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ignore_startup_parameters")

    @property
    @pulumi.getter(name="minPoolSize")
    def min_pool_size(self) -> Optional[str]:
        return pulumi.get(self, "min_pool_size")

    @property
    @pulumi.getter(name="serverIdleTimeout")
    def server_idle_timeout(self) -> Optional[str]:
        return pulumi.get(self, "server_idle_timeout")

    @property
    @pulumi.getter(name="serverLifetime")
    def server_lifetime(self) -> Optional[str]:
        return pulumi.get(self, "server_lifetime")

    @property
    @pulumi.getter(name="serverResetQueryAlways")
    def server_reset_query_always(self) -> Optional[str]:
        return pulumi.get(self, "server_reset_query_always")


@pulumi.output_type
class GetPgPgUserConfigPglookoutResult(dict):
    def __init__(__self__, *,
                 max_failover_replication_time_lag: Optional[str] = None):
        if max_failover_replication_time_lag is not None:
            pulumi.set(__self__, "max_failover_replication_time_lag", max_failover_replication_time_lag)

    @property
    @pulumi.getter(name="maxFailoverReplicationTimeLag")
    def max_failover_replication_time_lag(self) -> Optional[str]:
        return pulumi.get(self, "max_failover_replication_time_lag")


@pulumi.output_type
class GetPgPgUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 pg: Optional[str] = None,
                 pgbouncer: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def pg(self) -> Optional[str]:
        return pulumi.get(self, "pg")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional[str]:
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetPgPgUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 pg: Optional[str] = None,
                 pgbouncer: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def pg(self) -> Optional[str]:
        return pulumi.get(self, "pg")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional[str]:
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetPgPgUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 pg: Optional[str] = None,
                 pgbouncer: Optional[str] = None,
                 prometheus: Optional[str] = None):
        if pg is not None:
            pulumi.set(__self__, "pg", pg)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def pg(self) -> Optional[str]:
        return pulumi.get(self, "pg")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional[str]:
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")


@pulumi.output_type
class GetPgPgUserConfigTimescaledbResult(dict):
    def __init__(__self__, *,
                 max_background_workers: Optional[str] = None):
        if max_background_workers is not None:
            pulumi.set(__self__, "max_background_workers", max_background_workers)

    @property
    @pulumi.getter(name="maxBackgroundWorkers")
    def max_background_workers(self) -> Optional[str]:
        return pulumi.get(self, "max_background_workers")


@pulumi.output_type
class GetPgServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetPgTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetProjectTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRedisComponentResult(dict):
    def __init__(__self__, *,
                 component: str,
                 host: str,
                 kafka_authentication_method: str,
                 port: int,
                 route: str,
                 ssl: bool,
                 usage: str):
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "kafka_authentication_method", kafka_authentication_method)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> str:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="kafkaAuthenticationMethod")
    def kafka_authentication_method(self) -> str:
        return pulumi.get(self, "kafka_authentication_method")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def usage(self) -> str:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetRedisRediResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetRedisRedisUserConfigResult(dict):
    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 migration: Optional['outputs.GetRedisRedisUserConfigMigrationResult'] = None,
                 private_access: Optional['outputs.GetRedisRedisUserConfigPrivateAccessResult'] = None,
                 privatelink_access: Optional['outputs.GetRedisRedisUserConfigPrivatelinkAccessResult'] = None,
                 project_to_fork_from: Optional[str] = None,
                 public_access: Optional['outputs.GetRedisRedisUserConfigPublicAccessResult'] = None,
                 recovery_basebackup_name: Optional[str] = None,
                 redis_acl_channels_default: Optional[str] = None,
                 redis_io_threads: Optional[str] = None,
                 redis_lfu_decay_time: Optional[str] = None,
                 redis_lfu_log_factor: Optional[str] = None,
                 redis_maxmemory_policy: Optional[str] = None,
                 redis_notify_keyspace_events: Optional[str] = None,
                 redis_number_of_databases: Optional[str] = None,
                 redis_persistence: Optional[str] = None,
                 redis_pubsub_client_output_buffer_limit: Optional[str] = None,
                 redis_ssl: Optional[str] = None,
                 redis_timeout: Optional[str] = None,
                 service_to_fork_from: Optional[str] = None,
                 static_ips: Optional[str] = None):
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if privatelink_access is not None:
            pulumi.set(__self__, "privatelink_access", privatelink_access)
        if project_to_fork_from is not None:
            pulumi.set(__self__, "project_to_fork_from", project_to_fork_from)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if recovery_basebackup_name is not None:
            pulumi.set(__self__, "recovery_basebackup_name", recovery_basebackup_name)
        if redis_acl_channels_default is not None:
            pulumi.set(__self__, "redis_acl_channels_default", redis_acl_channels_default)
        if redis_io_threads is not None:
            pulumi.set(__self__, "redis_io_threads", redis_io_threads)
        if redis_lfu_decay_time is not None:
            pulumi.set(__self__, "redis_lfu_decay_time", redis_lfu_decay_time)
        if redis_lfu_log_factor is not None:
            pulumi.set(__self__, "redis_lfu_log_factor", redis_lfu_log_factor)
        if redis_maxmemory_policy is not None:
            pulumi.set(__self__, "redis_maxmemory_policy", redis_maxmemory_policy)
        if redis_notify_keyspace_events is not None:
            pulumi.set(__self__, "redis_notify_keyspace_events", redis_notify_keyspace_events)
        if redis_number_of_databases is not None:
            pulumi.set(__self__, "redis_number_of_databases", redis_number_of_databases)
        if redis_persistence is not None:
            pulumi.set(__self__, "redis_persistence", redis_persistence)
        if redis_pubsub_client_output_buffer_limit is not None:
            pulumi.set(__self__, "redis_pubsub_client_output_buffer_limit", redis_pubsub_client_output_buffer_limit)
        if redis_ssl is not None:
            pulumi.set(__self__, "redis_ssl", redis_ssl)
        if redis_timeout is not None:
            pulumi.set(__self__, "redis_timeout", redis_timeout)
        if service_to_fork_from is not None:
            pulumi.set(__self__, "service_to_fork_from", service_to_fork_from)
        if static_ips is not None:
            pulumi.set(__self__, "static_ips", static_ips)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def migration(self) -> Optional['outputs.GetRedisRedisUserConfigMigrationResult']:
        return pulumi.get(self, "migration")

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional['outputs.GetRedisRedisUserConfigPrivateAccessResult']:
        return pulumi.get(self, "private_access")

    @property
    @pulumi.getter(name="privatelinkAccess")
    def privatelink_access(self) -> Optional['outputs.GetRedisRedisUserConfigPrivatelinkAccessResult']:
        return pulumi.get(self, "privatelink_access")

    @property
    @pulumi.getter(name="projectToForkFrom")
    def project_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "project_to_fork_from")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional['outputs.GetRedisRedisUserConfigPublicAccessResult']:
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="recoveryBasebackupName")
    def recovery_basebackup_name(self) -> Optional[str]:
        return pulumi.get(self, "recovery_basebackup_name")

    @property
    @pulumi.getter(name="redisAclChannelsDefault")
    def redis_acl_channels_default(self) -> Optional[str]:
        return pulumi.get(self, "redis_acl_channels_default")

    @property
    @pulumi.getter(name="redisIoThreads")
    def redis_io_threads(self) -> Optional[str]:
        return pulumi.get(self, "redis_io_threads")

    @property
    @pulumi.getter(name="redisLfuDecayTime")
    def redis_lfu_decay_time(self) -> Optional[str]:
        return pulumi.get(self, "redis_lfu_decay_time")

    @property
    @pulumi.getter(name="redisLfuLogFactor")
    def redis_lfu_log_factor(self) -> Optional[str]:
        return pulumi.get(self, "redis_lfu_log_factor")

    @property
    @pulumi.getter(name="redisMaxmemoryPolicy")
    def redis_maxmemory_policy(self) -> Optional[str]:
        return pulumi.get(self, "redis_maxmemory_policy")

    @property
    @pulumi.getter(name="redisNotifyKeyspaceEvents")
    def redis_notify_keyspace_events(self) -> Optional[str]:
        return pulumi.get(self, "redis_notify_keyspace_events")

    @property
    @pulumi.getter(name="redisNumberOfDatabases")
    def redis_number_of_databases(self) -> Optional[str]:
        return pulumi.get(self, "redis_number_of_databases")

    @property
    @pulumi.getter(name="redisPersistence")
    def redis_persistence(self) -> Optional[str]:
        return pulumi.get(self, "redis_persistence")

    @property
    @pulumi.getter(name="redisPubsubClientOutputBufferLimit")
    def redis_pubsub_client_output_buffer_limit(self) -> Optional[str]:
        return pulumi.get(self, "redis_pubsub_client_output_buffer_limit")

    @property
    @pulumi.getter(name="redisSsl")
    def redis_ssl(self) -> Optional[str]:
        return pulumi.get(self, "redis_ssl")

    @property
    @pulumi.getter(name="redisTimeout")
    def redis_timeout(self) -> Optional[str]:
        return pulumi.get(self, "redis_timeout")

    @property
    @pulumi.getter(name="serviceToForkFrom")
    def service_to_fork_from(self) -> Optional[str]:
        return pulumi.get(self, "service_to_fork_from")

    @property
    @pulumi.getter(name="staticIps")
    def static_ips(self) -> Optional[str]:
        return pulumi.get(self, "static_ips")


@pulumi.output_type
class GetRedisRedisUserConfigMigrationResult(dict):
    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 ignore_dbs: Optional[str] = None,
                 method: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 ssl: Optional[str] = None,
                 username: Optional[str] = None):
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[str]:
        return pulumi.get(self, "ignore_dbs")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetRedisRedisUserConfigPrivateAccessResult(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None,
                 redis: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter
    def redis(self) -> Optional[str]:
        return pulumi.get(self, "redis")


@pulumi.output_type
class GetRedisRedisUserConfigPrivatelinkAccessResult(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None,
                 redis: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter
    def redis(self) -> Optional[str]:
        return pulumi.get(self, "redis")


@pulumi.output_type
class GetRedisRedisUserConfigPublicAccessResult(dict):
    def __init__(__self__, *,
                 prometheus: Optional[str] = None,
                 redis: Optional[str] = None):
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[str]:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter
    def redis(self) -> Optional[str]:
        return pulumi.get(self, "redis")


@pulumi.output_type
class GetRedisServiceIntegrationResult(dict):
    def __init__(__self__, *,
                 integration_type: str,
                 source_service_name: str):
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "source_service_name", source_service_name)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="sourceServiceName")
    def source_service_name(self) -> str:
        return pulumi.get(self, "source_service_name")


@pulumi.output_type
class GetRedisTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServiceIntegrationEndpointDatadogUserConfigResult(dict):
    def __init__(__self__, *,
                 datadog_api_key: Optional[str] = None,
                 datadog_tags: Optional[Sequence['outputs.GetServiceIntegrationEndpointDatadogUserConfigDatadogTagResult']] = None,
                 disable_consumer_stats: Optional[str] = None,
                 kafka_consumer_check_instances: Optional[str] = None,
                 kafka_consumer_stats_timeout: Optional[str] = None,
                 max_partition_contexts: Optional[str] = None,
                 site: Optional[str] = None):
        if datadog_api_key is not None:
            pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        if datadog_tags is not None:
            pulumi.set(__self__, "datadog_tags", datadog_tags)
        if disable_consumer_stats is not None:
            pulumi.set(__self__, "disable_consumer_stats", disable_consumer_stats)
        if kafka_consumer_check_instances is not None:
            pulumi.set(__self__, "kafka_consumer_check_instances", kafka_consumer_check_instances)
        if kafka_consumer_stats_timeout is not None:
            pulumi.set(__self__, "kafka_consumer_stats_timeout", kafka_consumer_stats_timeout)
        if max_partition_contexts is not None:
            pulumi.set(__self__, "max_partition_contexts", max_partition_contexts)
        if site is not None:
            pulumi.set(__self__, "site", site)

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> Optional[str]:
        return pulumi.get(self, "datadog_api_key")

    @property
    @pulumi.getter(name="datadogTags")
    def datadog_tags(self) -> Optional[Sequence['outputs.GetServiceIntegrationEndpointDatadogUserConfigDatadogTagResult']]:
        return pulumi.get(self, "datadog_tags")

    @property
    @pulumi.getter(name="disableConsumerStats")
    def disable_consumer_stats(self) -> Optional[str]:
        return pulumi.get(self, "disable_consumer_stats")

    @property
    @pulumi.getter(name="kafkaConsumerCheckInstances")
    def kafka_consumer_check_instances(self) -> Optional[str]:
        return pulumi.get(self, "kafka_consumer_check_instances")

    @property
    @pulumi.getter(name="kafkaConsumerStatsTimeout")
    def kafka_consumer_stats_timeout(self) -> Optional[str]:
        return pulumi.get(self, "kafka_consumer_stats_timeout")

    @property
    @pulumi.getter(name="maxPartitionContexts")
    def max_partition_contexts(self) -> Optional[str]:
        return pulumi.get(self, "max_partition_contexts")

    @property
    @pulumi.getter
    def site(self) -> Optional[str]:
        return pulumi.get(self, "site")


@pulumi.output_type
class GetServiceIntegrationEndpointDatadogUserConfigDatadogTagResult(dict):
    def __init__(__self__, *,
                 comment: Optional[str] = None,
                 tag: Optional[str] = None):
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")


@pulumi.output_type
class GetServiceIntegrationEndpointExternalAwsCloudwatchLogsUserConfigResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 log_group_name: Optional[str] = None,
                 region: Optional[str] = None,
                 secret_key: Optional[str] = None):
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[str]:
        return pulumi.get(self, "log_group_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class GetServiceIntegrationEndpointExternalAwsCloudwatchMetricsUserConfigResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 namespace: Optional[str] = None,
                 region: Optional[str] = None,
                 secret_key: Optional[str] = None):
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class GetServiceIntegrationEndpointExternalElasticsearchLogsUserConfigResult(dict):
    def __init__(__self__, *,
                 ca: Optional[str] = None,
                 index_days_max: Optional[str] = None,
                 index_prefix: Optional[str] = None,
                 timeout: Optional[str] = None,
                 url: Optional[str] = None):
        if ca is not None:
            pulumi.set(__self__, "ca", ca)
        if index_days_max is not None:
            pulumi.set(__self__, "index_days_max", index_days_max)
        if index_prefix is not None:
            pulumi.set(__self__, "index_prefix", index_prefix)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def ca(self) -> Optional[str]:
        return pulumi.get(self, "ca")

    @property
    @pulumi.getter(name="indexDaysMax")
    def index_days_max(self) -> Optional[str]:
        return pulumi.get(self, "index_days_max")

    @property
    @pulumi.getter(name="indexPrefix")
    def index_prefix(self) -> Optional[str]:
        return pulumi.get(self, "index_prefix")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class GetServiceIntegrationEndpointExternalGoogleCloudLoggingUserConfigResult(dict):
    def __init__(__self__, *,
                 log_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 service_account_credentials: Optional[str] = None):
        if log_id is not None:
            pulumi.set(__self__, "log_id", log_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if service_account_credentials is not None:
            pulumi.set(__self__, "service_account_credentials", service_account_credentials)

    @property
    @pulumi.getter(name="logId")
    def log_id(self) -> Optional[str]:
        return pulumi.get(self, "log_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="serviceAccountCredentials")
    def service_account_credentials(self) -> Optional[str]:
        return pulumi.get(self, "service_account_credentials")


@pulumi.output_type
class GetServiceIntegrationEndpointExternalKafkaUserConfigResult(dict):
    def __init__(__self__, *,
                 bootstrap_servers: Optional[str] = None,
                 sasl_mechanism: Optional[str] = None,
                 sasl_plain_password: Optional[str] = None,
                 sasl_plain_username: Optional[str] = None,
                 security_protocol: Optional[str] = None,
                 ssl_ca_cert: Optional[str] = None,
                 ssl_client_cert: Optional[str] = None,
                 ssl_client_key: Optional[str] = None,
                 ssl_endpoint_identification_algorithm: Optional[str] = None):
        if bootstrap_servers is not None:
            pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_plain_password is not None:
            pulumi.set(__self__, "sasl_plain_password", sasl_plain_password)
        if sasl_plain_username is not None:
            pulumi.set(__self__, "sasl_plain_username", sasl_plain_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)
        if ssl_ca_cert is not None:
            pulumi.set(__self__, "ssl_ca_cert", ssl_ca_cert)
        if ssl_client_cert is not None:
            pulumi.set(__self__, "ssl_client_cert", ssl_client_cert)
        if ssl_client_key is not None:
            pulumi.set(__self__, "ssl_client_key", ssl_client_key)
        if ssl_endpoint_identification_algorithm is not None:
            pulumi.set(__self__, "ssl_endpoint_identification_algorithm", ssl_endpoint_identification_algorithm)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> Optional[str]:
        return pulumi.get(self, "bootstrap_servers")

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[str]:
        return pulumi.get(self, "sasl_mechanism")

    @property
    @pulumi.getter(name="saslPlainPassword")
    def sasl_plain_password(self) -> Optional[str]:
        return pulumi.get(self, "sasl_plain_password")

    @property
    @pulumi.getter(name="saslPlainUsername")
    def sasl_plain_username(self) -> Optional[str]:
        return pulumi.get(self, "sasl_plain_username")

    @property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[str]:
        return pulumi.get(self, "security_protocol")

    @property
    @pulumi.getter(name="sslCaCert")
    def ssl_ca_cert(self) -> Optional[str]:
        return pulumi.get(self, "ssl_ca_cert")

    @property
    @pulumi.getter(name="sslClientCert")
    def ssl_client_cert(self) -> Optional[str]:
        return pulumi.get(self, "ssl_client_cert")

    @property
    @pulumi.getter(name="sslClientKey")
    def ssl_client_key(self) -> Optional[str]:
        return pulumi.get(self, "ssl_client_key")

    @property
    @pulumi.getter(name="sslEndpointIdentificationAlgorithm")
    def ssl_endpoint_identification_algorithm(self) -> Optional[str]:
        return pulumi.get(self, "ssl_endpoint_identification_algorithm")


@pulumi.output_type
class GetServiceIntegrationEndpointExternalSchemaRegistryUserConfigResult(dict):
    def __init__(__self__, *,
                 authentication: Optional[str] = None,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_username: Optional[str] = None,
                 url: Optional[str] = None):
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_username is not None:
            pulumi.set(__self__, "basic_auth_username", basic_auth_username)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[str]:
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUsername")
    def basic_auth_username(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_username")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class GetServiceIntegrationEndpointJolokiaUserConfigResult(dict):
    def __init__(__self__, *,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_username: Optional[str] = None):
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_username is not None:
            pulumi.set(__self__, "basic_auth_username", basic_auth_username)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUsername")
    def basic_auth_username(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_username")


@pulumi.output_type
class GetServiceIntegrationEndpointPrometheusUserConfigResult(dict):
    def __init__(__self__, *,
                 basic_auth_password: Optional[str] = None,
                 basic_auth_username: Optional[str] = None):
        if basic_auth_password is not None:
            pulumi.set(__self__, "basic_auth_password", basic_auth_password)
        if basic_auth_username is not None:
            pulumi.set(__self__, "basic_auth_username", basic_auth_username)

    @property
    @pulumi.getter(name="basicAuthPassword")
    def basic_auth_password(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_password")

    @property
    @pulumi.getter(name="basicAuthUsername")
    def basic_auth_username(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_username")


@pulumi.output_type
class GetServiceIntegrationEndpointRsyslogUserConfigResult(dict):
    def __init__(__self__, *,
                 ca: Optional[str] = None,
                 cert: Optional[str] = None,
                 format: Optional[str] = None,
                 key: Optional[str] = None,
                 logline: Optional[str] = None,
                 port: Optional[str] = None,
                 sd: Optional[str] = None,
                 server: Optional[str] = None,
                 tls: Optional[str] = None):
        if ca is not None:
            pulumi.set(__self__, "ca", ca)
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if logline is not None:
            pulumi.set(__self__, "logline", logline)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if sd is not None:
            pulumi.set(__self__, "sd", sd)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def ca(self) -> Optional[str]:
        return pulumi.get(self, "ca")

    @property
    @pulumi.getter
    def cert(self) -> Optional[str]:
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def logline(self) -> Optional[str]:
        return pulumi.get(self, "logline")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def sd(self) -> Optional[str]:
        return pulumi.get(self, "sd")

    @property
    @pulumi.getter
    def server(self) -> Optional[str]:
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def tls(self) -> Optional[str]:
        return pulumi.get(self, "tls")


@pulumi.output_type
class GetServiceIntegrationEndpointSignalfxUserConfigResult(dict):
    def __init__(__self__, *,
                 enabled_metrics: Optional[Sequence[str]] = None,
                 signalfx_api_key: Optional[str] = None,
                 signalfx_realm: Optional[str] = None):
        if enabled_metrics is not None:
            pulumi.set(__self__, "enabled_metrics", enabled_metrics)
        if signalfx_api_key is not None:
            pulumi.set(__self__, "signalfx_api_key", signalfx_api_key)
        if signalfx_realm is not None:
            pulumi.set(__self__, "signalfx_realm", signalfx_realm)

    @property
    @pulumi.getter(name="enabledMetrics")
    def enabled_metrics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "enabled_metrics")

    @property
    @pulumi.getter(name="signalfxApiKey")
    def signalfx_api_key(self) -> Optional[str]:
        return pulumi.get(self, "signalfx_api_key")

    @property
    @pulumi.getter(name="signalfxRealm")
    def signalfx_realm(self) -> Optional[str]:
        return pulumi.get(self, "signalfx_realm")


@pulumi.output_type
class GetServiceIntegrationKafkaConnectUserConfigResult(dict):
    def __init__(__self__, *,
                 kafka_connect: Optional['outputs.GetServiceIntegrationKafkaConnectUserConfigKafkaConnectResult'] = None):
        if kafka_connect is not None:
            pulumi.set(__self__, "kafka_connect", kafka_connect)

    @property
    @pulumi.getter(name="kafkaConnect")
    def kafka_connect(self) -> Optional['outputs.GetServiceIntegrationKafkaConnectUserConfigKafkaConnectResult']:
        return pulumi.get(self, "kafka_connect")


@pulumi.output_type
class GetServiceIntegrationKafkaConnectUserConfigKafkaConnectResult(dict):
    def __init__(__self__, *,
                 config_storage_topic: Optional[str] = None,
                 group_id: Optional[str] = None,
                 offset_storage_topic: Optional[str] = None,
                 status_storage_topic: Optional[str] = None):
        if config_storage_topic is not None:
            pulumi.set(__self__, "config_storage_topic", config_storage_topic)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if offset_storage_topic is not None:
            pulumi.set(__self__, "offset_storage_topic", offset_storage_topic)
        if status_storage_topic is not None:
            pulumi.set(__self__, "status_storage_topic", status_storage_topic)

    @property
    @pulumi.getter(name="configStorageTopic")
    def config_storage_topic(self) -> Optional[str]:
        return pulumi.get(self, "config_storage_topic")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="offsetStorageTopic")
    def offset_storage_topic(self) -> Optional[str]:
        return pulumi.get(self, "offset_storage_topic")

    @property
    @pulumi.getter(name="statusStorageTopic")
    def status_storage_topic(self) -> Optional[str]:
        return pulumi.get(self, "status_storage_topic")


@pulumi.output_type
class GetServiceIntegrationKafkaLogsUserConfigResult(dict):
    def __init__(__self__, *,
                 kafka_topic: Optional[str] = None):
        if kafka_topic is not None:
            pulumi.set(__self__, "kafka_topic", kafka_topic)

    @property
    @pulumi.getter(name="kafkaTopic")
    def kafka_topic(self) -> Optional[str]:
        return pulumi.get(self, "kafka_topic")


@pulumi.output_type
class GetServiceIntegrationKafkaMirrormakerUserConfigResult(dict):
    def __init__(__self__, *,
                 cluster_alias: Optional[str] = None,
                 kafka_mirrormaker: Optional['outputs.GetServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormakerResult'] = None):
        if cluster_alias is not None:
            pulumi.set(__self__, "cluster_alias", cluster_alias)
        if kafka_mirrormaker is not None:
            pulumi.set(__self__, "kafka_mirrormaker", kafka_mirrormaker)

    @property
    @pulumi.getter(name="clusterAlias")
    def cluster_alias(self) -> Optional[str]:
        return pulumi.get(self, "cluster_alias")

    @property
    @pulumi.getter(name="kafkaMirrormaker")
    def kafka_mirrormaker(self) -> Optional['outputs.GetServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormakerResult']:
        return pulumi.get(self, "kafka_mirrormaker")


@pulumi.output_type
class GetServiceIntegrationKafkaMirrormakerUserConfigKafkaMirrormakerResult(dict):
    def __init__(__self__, *,
                 consumer_fetch_min_bytes: Optional[str] = None,
                 producer_batch_size: Optional[str] = None,
                 producer_buffer_memory: Optional[str] = None,
                 producer_linger_ms: Optional[str] = None,
                 producer_max_request_size: Optional[str] = None):
        if consumer_fetch_min_bytes is not None:
            pulumi.set(__self__, "consumer_fetch_min_bytes", consumer_fetch_min_bytes)
        if producer_batch_size is not None:
            pulumi.set(__self__, "producer_batch_size", producer_batch_size)
        if producer_buffer_memory is not None:
            pulumi.set(__self__, "producer_buffer_memory", producer_buffer_memory)
        if producer_linger_ms is not None:
            pulumi.set(__self__, "producer_linger_ms", producer_linger_ms)
        if producer_max_request_size is not None:
            pulumi.set(__self__, "producer_max_request_size", producer_max_request_size)

    @property
    @pulumi.getter(name="consumerFetchMinBytes")
    def consumer_fetch_min_bytes(self) -> Optional[str]:
        return pulumi.get(self, "consumer_fetch_min_bytes")

    @property
    @pulumi.getter(name="producerBatchSize")
    def producer_batch_size(self) -> Optional[str]:
        return pulumi.get(self, "producer_batch_size")

    @property
    @pulumi.getter(name="producerBufferMemory")
    def producer_buffer_memory(self) -> Optional[str]:
        return pulumi.get(self, "producer_buffer_memory")

    @property
    @pulumi.getter(name="producerLingerMs")
    def producer_linger_ms(self) -> Optional[str]:
        return pulumi.get(self, "producer_linger_ms")

    @property
    @pulumi.getter(name="producerMaxRequestSize")
    def producer_max_request_size(self) -> Optional[str]:
        return pulumi.get(self, "producer_max_request_size")


@pulumi.output_type
class GetServiceIntegrationLogsUserConfigResult(dict):
    def __init__(__self__, *,
                 elasticsearch_index_days_max: Optional[str] = None,
                 elasticsearch_index_prefix: Optional[str] = None):
        if elasticsearch_index_days_max is not None:
            pulumi.set(__self__, "elasticsearch_index_days_max", elasticsearch_index_days_max)
        if elasticsearch_index_prefix is not None:
            pulumi.set(__self__, "elasticsearch_index_prefix", elasticsearch_index_prefix)

    @property
    @pulumi.getter(name="elasticsearchIndexDaysMax")
    def elasticsearch_index_days_max(self) -> Optional[str]:
        return pulumi.get(self, "elasticsearch_index_days_max")

    @property
    @pulumi.getter(name="elasticsearchIndexPrefix")
    def elasticsearch_index_prefix(self) -> Optional[str]:
        return pulumi.get(self, "elasticsearch_index_prefix")


@pulumi.output_type
class GetServiceIntegrationMetricsUserConfigResult(dict):
    def __init__(__self__, *,
                 database: Optional[str] = None,
                 retention_days: Optional[str] = None,
                 ro_username: Optional[str] = None,
                 source_mysql: Optional['outputs.GetServiceIntegrationMetricsUserConfigSourceMysqlResult'] = None,
                 username: Optional[str] = None):
        if database is not None:
            pulumi.set(__self__, "database", database)
        if retention_days is not None:
            pulumi.set(__self__, "retention_days", retention_days)
        if ro_username is not None:
            pulumi.set(__self__, "ro_username", ro_username)
        if source_mysql is not None:
            pulumi.set(__self__, "source_mysql", source_mysql)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> Optional[str]:
        return pulumi.get(self, "retention_days")

    @property
    @pulumi.getter(name="roUsername")
    def ro_username(self) -> Optional[str]:
        return pulumi.get(self, "ro_username")

    @property
    @pulumi.getter(name="sourceMysql")
    def source_mysql(self) -> Optional['outputs.GetServiceIntegrationMetricsUserConfigSourceMysqlResult']:
        return pulumi.get(self, "source_mysql")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetServiceIntegrationMetricsUserConfigSourceMysqlResult(dict):
    def __init__(__self__, *,
                 telegraf: Optional['outputs.GetServiceIntegrationMetricsUserConfigSourceMysqlTelegrafResult'] = None):
        if telegraf is not None:
            pulumi.set(__self__, "telegraf", telegraf)

    @property
    @pulumi.getter
    def telegraf(self) -> Optional['outputs.GetServiceIntegrationMetricsUserConfigSourceMysqlTelegrafResult']:
        return pulumi.get(self, "telegraf")


@pulumi.output_type
class GetServiceIntegrationMetricsUserConfigSourceMysqlTelegrafResult(dict):
    def __init__(__self__, *,
                 gather_event_waits: Optional[str] = None,
                 gather_file_events_stats: Optional[str] = None,
                 gather_index_io_waits: Optional[str] = None,
                 gather_info_schema_auto_inc: Optional[str] = None,
                 gather_innodb_metrics: Optional[str] = None,
                 gather_perf_events_statements: Optional[str] = None,
                 gather_process_list: Optional[str] = None,
                 gather_slave_status: Optional[str] = None,
                 gather_table_io_waits: Optional[str] = None,
                 gather_table_lock_waits: Optional[str] = None,
                 gather_table_schema: Optional[str] = None,
                 perf_events_statements_digest_text_limit: Optional[str] = None,
                 perf_events_statements_limit: Optional[str] = None,
                 perf_events_statements_time_limit: Optional[str] = None):
        if gather_event_waits is not None:
            pulumi.set(__self__, "gather_event_waits", gather_event_waits)
        if gather_file_events_stats is not None:
            pulumi.set(__self__, "gather_file_events_stats", gather_file_events_stats)
        if gather_index_io_waits is not None:
            pulumi.set(__self__, "gather_index_io_waits", gather_index_io_waits)
        if gather_info_schema_auto_inc is not None:
            pulumi.set(__self__, "gather_info_schema_auto_inc", gather_info_schema_auto_inc)
        if gather_innodb_metrics is not None:
            pulumi.set(__self__, "gather_innodb_metrics", gather_innodb_metrics)
        if gather_perf_events_statements is not None:
            pulumi.set(__self__, "gather_perf_events_statements", gather_perf_events_statements)
        if gather_process_list is not None:
            pulumi.set(__self__, "gather_process_list", gather_process_list)
        if gather_slave_status is not None:
            pulumi.set(__self__, "gather_slave_status", gather_slave_status)
        if gather_table_io_waits is not None:
            pulumi.set(__self__, "gather_table_io_waits", gather_table_io_waits)
        if gather_table_lock_waits is not None:
            pulumi.set(__self__, "gather_table_lock_waits", gather_table_lock_waits)
        if gather_table_schema is not None:
            pulumi.set(__self__, "gather_table_schema", gather_table_schema)
        if perf_events_statements_digest_text_limit is not None:
            pulumi.set(__self__, "perf_events_statements_digest_text_limit", perf_events_statements_digest_text_limit)
        if perf_events_statements_limit is not None:
            pulumi.set(__self__, "perf_events_statements_limit", perf_events_statements_limit)
        if perf_events_statements_time_limit is not None:
            pulumi.set(__self__, "perf_events_statements_time_limit", perf_events_statements_time_limit)

    @property
    @pulumi.getter(name="gatherEventWaits")
    def gather_event_waits(self) -> Optional[str]:
        return pulumi.get(self, "gather_event_waits")

    @property
    @pulumi.getter(name="gatherFileEventsStats")
    def gather_file_events_stats(self) -> Optional[str]:
        return pulumi.get(self, "gather_file_events_stats")

    @property
    @pulumi.getter(name="gatherIndexIoWaits")
    def gather_index_io_waits(self) -> Optional[str]:
        return pulumi.get(self, "gather_index_io_waits")

    @property
    @pulumi.getter(name="gatherInfoSchemaAutoInc")
    def gather_info_schema_auto_inc(self) -> Optional[str]:
        return pulumi.get(self, "gather_info_schema_auto_inc")

    @property
    @pulumi.getter(name="gatherInnodbMetrics")
    def gather_innodb_metrics(self) -> Optional[str]:
        return pulumi.get(self, "gather_innodb_metrics")

    @property
    @pulumi.getter(name="gatherPerfEventsStatements")
    def gather_perf_events_statements(self) -> Optional[str]:
        return pulumi.get(self, "gather_perf_events_statements")

    @property
    @pulumi.getter(name="gatherProcessList")
    def gather_process_list(self) -> Optional[str]:
        return pulumi.get(self, "gather_process_list")

    @property
    @pulumi.getter(name="gatherSlaveStatus")
    def gather_slave_status(self) -> Optional[str]:
        return pulumi.get(self, "gather_slave_status")

    @property
    @pulumi.getter(name="gatherTableIoWaits")
    def gather_table_io_waits(self) -> Optional[str]:
        return pulumi.get(self, "gather_table_io_waits")

    @property
    @pulumi.getter(name="gatherTableLockWaits")
    def gather_table_lock_waits(self) -> Optional[str]:
        return pulumi.get(self, "gather_table_lock_waits")

    @property
    @pulumi.getter(name="gatherTableSchema")
    def gather_table_schema(self) -> Optional[str]:
        return pulumi.get(self, "gather_table_schema")

    @property
    @pulumi.getter(name="perfEventsStatementsDigestTextLimit")
    def perf_events_statements_digest_text_limit(self) -> Optional[str]:
        return pulumi.get(self, "perf_events_statements_digest_text_limit")

    @property
    @pulumi.getter(name="perfEventsStatementsLimit")
    def perf_events_statements_limit(self) -> Optional[str]:
        return pulumi.get(self, "perf_events_statements_limit")

    @property
    @pulumi.getter(name="perfEventsStatementsTimeLimit")
    def perf_events_statements_time_limit(self) -> Optional[str]:
        return pulumi.get(self, "perf_events_statements_time_limit")


@pulumi.output_type
class GetServiceIntegrationMirrormakerUserConfigResult(dict):
    def __init__(__self__, *,
                 mirrormaker_whitelist: Optional[str] = None):
        if mirrormaker_whitelist is not None:
            pulumi.set(__self__, "mirrormaker_whitelist", mirrormaker_whitelist)

    @property
    @pulumi.getter(name="mirrormakerWhitelist")
    def mirrormaker_whitelist(self) -> Optional[str]:
        return pulumi.get(self, "mirrormaker_whitelist")


