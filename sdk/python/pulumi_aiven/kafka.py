# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Union
from . import _utilities, _tables


class Kafka(pulumi.CustomResource):
    cloud_name: pulumi.Output[str]
    """
    Cloud the service runs in
    """
    components: pulumi.Output[list]
    """
    Service component information objects

      * `component` (`str`)
      * `host` (`str`)
      * `kafkaAuthenticationMethod` (`str`)
      * `port` (`float`)
      * `route` (`str`)
      * `ssl` (`bool`)
      * `usage` (`str`)
    """
    default_acl: pulumi.Output[bool]
    """
    Create default wildcard Kafka ACL
    """
    kafka: pulumi.Output[dict]
    """
    Kafka server provided values

      * `access_cert` (`str`)
      * `access_key` (`str`)
      * `connectUri` (`str`)
      * `restUri` (`str`)
      * `schemaRegistryUri` (`str`)
    """
    kafka_user_config: pulumi.Output[dict]
    """
    Kafka user configurable settings

      * `customDomain` (`str`)
      * `ipFilters` (`list`)
      * `kafka` (`dict`)
        * `autoCreateTopicsEnable` (`str`)
        * `compressionType` (`str`)
        * `connectionsMaxIdleMs` (`str`)
        * `defaultReplicationFactor` (`str`)
        * `groupMaxSessionTimeoutMs` (`str`)
        * `groupMinSessionTimeoutMs` (`str`)
        * `logCleanerMaxCompactionLagMs` (`str`)
        * `logCleanerMinCleanableRatio` (`str`)
        * `logCleanerMinCompactionLagMs` (`str`)
        * `logCleanupPolicy` (`str`)
        * `logMessageTimestampDifferenceMaxMs` (`str`)
        * `logMessageTimestampType` (`str`)
        * `logRetentionBytes` (`str`)
        * `logRetentionHours` (`str`)
        * `logSegmentBytes` (`str`)
        * `maxConnectionsPerIp` (`str`)
        * `maxIncrementalFetchSessionCacheSlots` (`str`)
        * `messageMaxBytes` (`str`)
        * `numPartitions` (`str`)
        * `offsetsRetentionMinutes` (`str`)
        * `producerPurgatoryPurgeIntervalRequests` (`str`)
        * `replicaFetchMaxBytes` (`str`)
        * `replicaFetchResponseMaxBytes` (`str`)
        * `socketRequestMaxBytes` (`str`)

      * `kafkaAuthenticationMethods` (`dict`)
        * `certificate` (`str`)
        * `sasl` (`str`)

      * `kafka_connect` (`str`)
      * `kafkaConnectConfig` (`dict`)
        * `connectorClientConfigOverridePolicy` (`str`)
        * `consumerAutoOffsetReset` (`str`)
        * `consumerIsolationLevel` (`str`)
        * `consumerMaxPollIntervalMs` (`str`)
        * `consumerMaxPollRecords` (`str`)
        * `offsetFlushIntervalMs` (`str`)
        * `offsetFlushTimeoutMs` (`str`)
        * `sessionTimeoutMs` (`str`)

      * `kafkaRest` (`str`)
      * `kafkaRestConfig` (`dict`)
        * `consumerEnableAutoCommit` (`str`)
        * `consumerRequestMaxBytes` (`str`)
        * `consumerRequestTimeoutMs` (`str`)
        * `producerAcks` (`str`)
        * `producerLingerMs` (`str`)
        * `simpleconsumerPoolSizeMax` (`str`)

      * `kafkaVersion` (`str`)
      * `privateAccess` (`dict`)
        * `prometheus` (`str`)

      * `publicAccess` (`dict`)
        * `kafka` (`str`)
        * `kafka_connect` (`str`)
        * `kafkaRest` (`str`)
        * `prometheus` (`str`)
        * `schemaRegistry` (`str`)

      * `schemaRegistry` (`str`)
    """
    maintenance_window_dow: pulumi.Output[str]
    """
    Day of week when maintenance operations should be performed. One monday, tuesday, wednesday, etc.
    """
    maintenance_window_time: pulumi.Output[str]
    """
    Time of day when maintenance operations should be performed. UTC time in HH:mm:ss format.
    """
    plan: pulumi.Output[str]
    """
    Subscription plan
    """
    project: pulumi.Output[str]
    """
    Target project
    """
    project_vpc_id: pulumi.Output[str]
    """
    Identifier of the VPC the service should be in, if any
    """
    service_host: pulumi.Output[str]
    """
    Service hostname
    """
    service_integrations: pulumi.Output[list]
    """
    Service integrations to specify when creating a service. Not applied after initial service creation

      * `integration_type` (`str`)
      * `source_service_name` (`str`)
    """
    service_name: pulumi.Output[str]
    """
    Service name
    """
    service_password: pulumi.Output[str]
    """
    Password used for connecting to the service, if applicable
    """
    service_port: pulumi.Output[float]
    """
    Service port
    """
    service_type: pulumi.Output[str]
    """
    Aiven internal service type code
    """
    service_uri: pulumi.Output[str]
    """
    URI for connecting to the service. Service specific info is under "kafka", "pg", etc.
    """
    service_username: pulumi.Output[str]
    """
    Username used for connecting to the service, if applicable
    """
    state: pulumi.Output[str]
    """
    Service state
    """
    termination_protection: pulumi.Output[bool]
    """
    Prevent service from being deleted. It is recommended to have this enabled for all services.
    """
    def __init__(__self__, resource_name, opts=None, cloud_name=None, default_acl=None, kafka=None, kafka_user_config=None, maintenance_window_dow=None, maintenance_window_time=None, plan=None, project=None, project_vpc_id=None, service_integrations=None, service_name=None, termination_protection=None, __props__=None, __name__=None, __opts__=None):
        """
        Create a Kafka resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] cloud_name: Cloud the service runs in
        :param pulumi.Input[bool] default_acl: Create default wildcard Kafka ACL
        :param pulumi.Input[dict] kafka: Kafka server provided values
        :param pulumi.Input[dict] kafka_user_config: Kafka user configurable settings
        :param pulumi.Input[str] maintenance_window_dow: Day of week when maintenance operations should be performed. One monday, tuesday, wednesday, etc.
        :param pulumi.Input[str] maintenance_window_time: Time of day when maintenance operations should be performed. UTC time in HH:mm:ss format.
        :param pulumi.Input[str] plan: Subscription plan
        :param pulumi.Input[str] project: Target project
        :param pulumi.Input[str] project_vpc_id: Identifier of the VPC the service should be in, if any
        :param pulumi.Input[list] service_integrations: Service integrations to specify when creating a service. Not applied after initial service creation
        :param pulumi.Input[str] service_name: Service name
        :param pulumi.Input[bool] termination_protection: Prevent service from being deleted. It is recommended to have this enabled for all services.

        The **kafka** object supports the following:

          * `access_cert` (`pulumi.Input[str]`)
          * `access_key` (`pulumi.Input[str]`)
          * `connectUri` (`pulumi.Input[str]`)
          * `restUri` (`pulumi.Input[str]`)
          * `schemaRegistryUri` (`pulumi.Input[str]`)

        The **kafka_user_config** object supports the following:

          * `customDomain` (`pulumi.Input[str]`)
          * `ipFilters` (`pulumi.Input[list]`)
          * `kafka` (`pulumi.Input[dict]`)
            * `autoCreateTopicsEnable` (`pulumi.Input[str]`)
            * `compressionType` (`pulumi.Input[str]`)
            * `connectionsMaxIdleMs` (`pulumi.Input[str]`)
            * `defaultReplicationFactor` (`pulumi.Input[str]`)
            * `groupMaxSessionTimeoutMs` (`pulumi.Input[str]`)
            * `groupMinSessionTimeoutMs` (`pulumi.Input[str]`)
            * `logCleanerMaxCompactionLagMs` (`pulumi.Input[str]`)
            * `logCleanerMinCleanableRatio` (`pulumi.Input[str]`)
            * `logCleanerMinCompactionLagMs` (`pulumi.Input[str]`)
            * `logCleanupPolicy` (`pulumi.Input[str]`)
            * `logMessageTimestampDifferenceMaxMs` (`pulumi.Input[str]`)
            * `logMessageTimestampType` (`pulumi.Input[str]`)
            * `logRetentionBytes` (`pulumi.Input[str]`)
            * `logRetentionHours` (`pulumi.Input[str]`)
            * `logSegmentBytes` (`pulumi.Input[str]`)
            * `maxConnectionsPerIp` (`pulumi.Input[str]`)
            * `maxIncrementalFetchSessionCacheSlots` (`pulumi.Input[str]`)
            * `messageMaxBytes` (`pulumi.Input[str]`)
            * `numPartitions` (`pulumi.Input[str]`)
            * `offsetsRetentionMinutes` (`pulumi.Input[str]`)
            * `producerPurgatoryPurgeIntervalRequests` (`pulumi.Input[str]`)
            * `replicaFetchMaxBytes` (`pulumi.Input[str]`)
            * `replicaFetchResponseMaxBytes` (`pulumi.Input[str]`)
            * `socketRequestMaxBytes` (`pulumi.Input[str]`)

          * `kafkaAuthenticationMethods` (`pulumi.Input[dict]`)
            * `certificate` (`pulumi.Input[str]`)
            * `sasl` (`pulumi.Input[str]`)

          * `kafka_connect` (`pulumi.Input[str]`)
          * `kafkaConnectConfig` (`pulumi.Input[dict]`)
            * `connectorClientConfigOverridePolicy` (`pulumi.Input[str]`)
            * `consumerAutoOffsetReset` (`pulumi.Input[str]`)
            * `consumerIsolationLevel` (`pulumi.Input[str]`)
            * `consumerMaxPollIntervalMs` (`pulumi.Input[str]`)
            * `consumerMaxPollRecords` (`pulumi.Input[str]`)
            * `offsetFlushIntervalMs` (`pulumi.Input[str]`)
            * `offsetFlushTimeoutMs` (`pulumi.Input[str]`)
            * `sessionTimeoutMs` (`pulumi.Input[str]`)

          * `kafkaRest` (`pulumi.Input[str]`)
          * `kafkaRestConfig` (`pulumi.Input[dict]`)
            * `consumerEnableAutoCommit` (`pulumi.Input[str]`)
            * `consumerRequestMaxBytes` (`pulumi.Input[str]`)
            * `consumerRequestTimeoutMs` (`pulumi.Input[str]`)
            * `producerAcks` (`pulumi.Input[str]`)
            * `producerLingerMs` (`pulumi.Input[str]`)
            * `simpleconsumerPoolSizeMax` (`pulumi.Input[str]`)

          * `kafkaVersion` (`pulumi.Input[str]`)
          * `privateAccess` (`pulumi.Input[dict]`)
            * `prometheus` (`pulumi.Input[str]`)

          * `publicAccess` (`pulumi.Input[dict]`)
            * `kafka` (`pulumi.Input[str]`)
            * `kafka_connect` (`pulumi.Input[str]`)
            * `kafkaRest` (`pulumi.Input[str]`)
            * `prometheus` (`pulumi.Input[str]`)
            * `schemaRegistry` (`pulumi.Input[str]`)

          * `schemaRegistry` (`pulumi.Input[str]`)

        The **service_integrations** object supports the following:

          * `integration_type` (`pulumi.Input[str]`)
          * `source_service_name` (`pulumi.Input[str]`)
        """
        if __name__ is not None:
            warnings.warn("explicit use of __name__ is deprecated", DeprecationWarning)
            resource_name = __name__
        if __opts__ is not None:
            warnings.warn("explicit use of __opts__ is deprecated, use 'opts' instead", DeprecationWarning)
            opts = __opts__
        if opts is None:
            opts = pulumi.ResourceOptions()
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.version is None:
            opts.version = _utilities.get_version()
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = dict()

            __props__['cloud_name'] = cloud_name
            __props__['default_acl'] = default_acl
            __props__['kafka'] = kafka
            __props__['kafka_user_config'] = kafka_user_config
            __props__['maintenance_window_dow'] = maintenance_window_dow
            __props__['maintenance_window_time'] = maintenance_window_time
            __props__['plan'] = plan
            if project is None:
                raise TypeError("Missing required property 'project'")
            __props__['project'] = project
            __props__['project_vpc_id'] = project_vpc_id
            __props__['service_integrations'] = service_integrations
            if service_name is None:
                raise TypeError("Missing required property 'service_name'")
            __props__['service_name'] = service_name
            __props__['termination_protection'] = termination_protection
            __props__['components'] = None
            __props__['service_host'] = None
            __props__['service_password'] = None
            __props__['service_port'] = None
            __props__['service_type'] = None
            __props__['service_uri'] = None
            __props__['service_username'] = None
            __props__['state'] = None
        super(Kafka, __self__).__init__(
            'aiven:index/kafka:Kafka',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name, id, opts=None, cloud_name=None, components=None, default_acl=None, kafka=None, kafka_user_config=None, maintenance_window_dow=None, maintenance_window_time=None, plan=None, project=None, project_vpc_id=None, service_host=None, service_integrations=None, service_name=None, service_password=None, service_port=None, service_type=None, service_uri=None, service_username=None, state=None, termination_protection=None):
        """
        Get an existing Kafka resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param str id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] cloud_name: Cloud the service runs in
        :param pulumi.Input[list] components: Service component information objects
        :param pulumi.Input[bool] default_acl: Create default wildcard Kafka ACL
        :param pulumi.Input[dict] kafka: Kafka server provided values
        :param pulumi.Input[dict] kafka_user_config: Kafka user configurable settings
        :param pulumi.Input[str] maintenance_window_dow: Day of week when maintenance operations should be performed. One monday, tuesday, wednesday, etc.
        :param pulumi.Input[str] maintenance_window_time: Time of day when maintenance operations should be performed. UTC time in HH:mm:ss format.
        :param pulumi.Input[str] plan: Subscription plan
        :param pulumi.Input[str] project: Target project
        :param pulumi.Input[str] project_vpc_id: Identifier of the VPC the service should be in, if any
        :param pulumi.Input[str] service_host: Service hostname
        :param pulumi.Input[list] service_integrations: Service integrations to specify when creating a service. Not applied after initial service creation
        :param pulumi.Input[str] service_name: Service name
        :param pulumi.Input[str] service_password: Password used for connecting to the service, if applicable
        :param pulumi.Input[float] service_port: Service port
        :param pulumi.Input[str] service_type: Aiven internal service type code
        :param pulumi.Input[str] service_uri: URI for connecting to the service. Service specific info is under "kafka", "pg", etc.
        :param pulumi.Input[str] service_username: Username used for connecting to the service, if applicable
        :param pulumi.Input[str] state: Service state
        :param pulumi.Input[bool] termination_protection: Prevent service from being deleted. It is recommended to have this enabled for all services.

        The **components** object supports the following:

          * `component` (`pulumi.Input[str]`)
          * `host` (`pulumi.Input[str]`)
          * `kafkaAuthenticationMethod` (`pulumi.Input[str]`)
          * `port` (`pulumi.Input[float]`)
          * `route` (`pulumi.Input[str]`)
          * `ssl` (`pulumi.Input[bool]`)
          * `usage` (`pulumi.Input[str]`)

        The **kafka** object supports the following:

          * `access_cert` (`pulumi.Input[str]`)
          * `access_key` (`pulumi.Input[str]`)
          * `connectUri` (`pulumi.Input[str]`)
          * `restUri` (`pulumi.Input[str]`)
          * `schemaRegistryUri` (`pulumi.Input[str]`)

        The **kafka_user_config** object supports the following:

          * `customDomain` (`pulumi.Input[str]`)
          * `ipFilters` (`pulumi.Input[list]`)
          * `kafka` (`pulumi.Input[dict]`)
            * `autoCreateTopicsEnable` (`pulumi.Input[str]`)
            * `compressionType` (`pulumi.Input[str]`)
            * `connectionsMaxIdleMs` (`pulumi.Input[str]`)
            * `defaultReplicationFactor` (`pulumi.Input[str]`)
            * `groupMaxSessionTimeoutMs` (`pulumi.Input[str]`)
            * `groupMinSessionTimeoutMs` (`pulumi.Input[str]`)
            * `logCleanerMaxCompactionLagMs` (`pulumi.Input[str]`)
            * `logCleanerMinCleanableRatio` (`pulumi.Input[str]`)
            * `logCleanerMinCompactionLagMs` (`pulumi.Input[str]`)
            * `logCleanupPolicy` (`pulumi.Input[str]`)
            * `logMessageTimestampDifferenceMaxMs` (`pulumi.Input[str]`)
            * `logMessageTimestampType` (`pulumi.Input[str]`)
            * `logRetentionBytes` (`pulumi.Input[str]`)
            * `logRetentionHours` (`pulumi.Input[str]`)
            * `logSegmentBytes` (`pulumi.Input[str]`)
            * `maxConnectionsPerIp` (`pulumi.Input[str]`)
            * `maxIncrementalFetchSessionCacheSlots` (`pulumi.Input[str]`)
            * `messageMaxBytes` (`pulumi.Input[str]`)
            * `numPartitions` (`pulumi.Input[str]`)
            * `offsetsRetentionMinutes` (`pulumi.Input[str]`)
            * `producerPurgatoryPurgeIntervalRequests` (`pulumi.Input[str]`)
            * `replicaFetchMaxBytes` (`pulumi.Input[str]`)
            * `replicaFetchResponseMaxBytes` (`pulumi.Input[str]`)
            * `socketRequestMaxBytes` (`pulumi.Input[str]`)

          * `kafkaAuthenticationMethods` (`pulumi.Input[dict]`)
            * `certificate` (`pulumi.Input[str]`)
            * `sasl` (`pulumi.Input[str]`)

          * `kafka_connect` (`pulumi.Input[str]`)
          * `kafkaConnectConfig` (`pulumi.Input[dict]`)
            * `connectorClientConfigOverridePolicy` (`pulumi.Input[str]`)
            * `consumerAutoOffsetReset` (`pulumi.Input[str]`)
            * `consumerIsolationLevel` (`pulumi.Input[str]`)
            * `consumerMaxPollIntervalMs` (`pulumi.Input[str]`)
            * `consumerMaxPollRecords` (`pulumi.Input[str]`)
            * `offsetFlushIntervalMs` (`pulumi.Input[str]`)
            * `offsetFlushTimeoutMs` (`pulumi.Input[str]`)
            * `sessionTimeoutMs` (`pulumi.Input[str]`)

          * `kafkaRest` (`pulumi.Input[str]`)
          * `kafkaRestConfig` (`pulumi.Input[dict]`)
            * `consumerEnableAutoCommit` (`pulumi.Input[str]`)
            * `consumerRequestMaxBytes` (`pulumi.Input[str]`)
            * `consumerRequestTimeoutMs` (`pulumi.Input[str]`)
            * `producerAcks` (`pulumi.Input[str]`)
            * `producerLingerMs` (`pulumi.Input[str]`)
            * `simpleconsumerPoolSizeMax` (`pulumi.Input[str]`)

          * `kafkaVersion` (`pulumi.Input[str]`)
          * `privateAccess` (`pulumi.Input[dict]`)
            * `prometheus` (`pulumi.Input[str]`)

          * `publicAccess` (`pulumi.Input[dict]`)
            * `kafka` (`pulumi.Input[str]`)
            * `kafka_connect` (`pulumi.Input[str]`)
            * `kafkaRest` (`pulumi.Input[str]`)
            * `prometheus` (`pulumi.Input[str]`)
            * `schemaRegistry` (`pulumi.Input[str]`)

          * `schemaRegistry` (`pulumi.Input[str]`)

        The **service_integrations** object supports the following:

          * `integration_type` (`pulumi.Input[str]`)
          * `source_service_name` (`pulumi.Input[str]`)
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = dict()

        __props__["cloud_name"] = cloud_name
        __props__["components"] = components
        __props__["default_acl"] = default_acl
        __props__["kafka"] = kafka
        __props__["kafka_user_config"] = kafka_user_config
        __props__["maintenance_window_dow"] = maintenance_window_dow
        __props__["maintenance_window_time"] = maintenance_window_time
        __props__["plan"] = plan
        __props__["project"] = project
        __props__["project_vpc_id"] = project_vpc_id
        __props__["service_host"] = service_host
        __props__["service_integrations"] = service_integrations
        __props__["service_name"] = service_name
        __props__["service_password"] = service_password
        __props__["service_port"] = service_port
        __props__["service_type"] = service_type
        __props__["service_uri"] = service_uri
        __props__["service_username"] = service_username
        __props__["state"] = state
        __props__["termination_protection"] = termination_protection
        return Kafka(resource_name, opts=opts, __props__=__props__)

    def translate_output_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop

    def translate_input_property(self, prop):
        return _tables.SNAKE_TO_CAMEL_CASE_TABLE.get(prop) or prop
